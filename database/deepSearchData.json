{"zigzap/zap":"blazingly fast backends in zig # ⚡zap⚡ - blazingly fast backends in zig  ![](https://github.com/zigzap/zap/actions/workflows/build-current-zig.yml/badge.svg) ![](https://github.com/zigzap/zap/actions/workflows/mastercheck.yml/badge.svg) [![discord](https://img.shields.io/discord/1107835896356675706?label=chat&logo=discord&style=plastic)](https://discord.gg/jqaan6ubyj)  zap is the [zig](https://ziglang.org) replacement for the rest apis i used to write in [python](https://python.org) with [flask](https://flask.palletsprojects.com) and [mongodb](https://www.mongodb.com), etc. it can be considered to be a microframework for web applications.  what i needed as a replacement was a blazingly fast and robust http server that i could use with zig, and i chose to wrap the superb evented networking c library [facil.io](https://facil.io). zap wraps and patches [facil.io - the c web application framework](https://facil.io).  ## **⚡zap⚡ is fast, robust, and stable**   after having used zap in production for a year, i can confidently assert that it proved to be:  - ⚡ **blazingly fast** ⚡ - 💪 **extremely robust** 💪  exactly the goals i set out to achieve!  ## faq:  - q: **what version of zig does zap support?**     - zap uses the latest stable zig release (0.13.0), so you don't have to keep        up with frequent breaking changes. it's an 'lts feature'.  - q: **can zap build with zig's master branch?**     - see the `zig-master` branch. an example of how to use it is        [here](https://github.com/zigzap/hello-master). please note that the        zig-master branch is not the official master branch of zap. be aware that        i don't provide `build.zig.zon` snippets or tagged releases for it for       the time being. if you know what you are doing, that shouldn't stop you       from using it with zig master though. - q: **where is the api documentation?**     - docs are a work in progress. you can check them out       [here](https://zigzap.org/zap).     - run `zig build run-docserver` to serve them locally. - q: **does zap work on windows?**     - no. this is due to the underlying facil.io c library. future versions       of facil.io might support windows but there is no timeline yet. your best       options on windows are wsl2 or a docker container. - q: **does zap support tls / https?**     - yes, zap supports using the system's openssl. see the       [https](./examples/https/https.zig) example and make sure to build with       the `-dopenssl` flag or the environment variable `zap_use_openssl=true`:       - `.openssl = true,` (in dependent projects' build.zig,         `b.dependency('zap' .{...})`)       - `zap_use_openssl=true zig build https`       - `zig build -dopenssl=true https`  ## here's what works  i recommend checking out **endpoint-based examples for more realistic use cases**. most of the examples are super stripped down to only include what's necessary to show a feature.  **note: to see api docs, run `zig build run-docserver`.** to specify a custom port and docs dir: `zig build docserver && zig-out/bin/docserver --port=8989 --docs=path/to/docs`.  - **super easy build process**: zap's `build.zig` now uses the new zig package   manager for its c-dependencies, no git submodules anymore.   - _tested on linux and macos (arm, m1)_ - **[hello](examples/hello/hello.zig)**: welcomes you with some static html - **[routes](examples/routes/routes.zig)**: a super easy example dispatching on   the http path. **note**: the dispatch in the example is a super-basic   diy-style dispatch. see endpoint-based examples for more realistic use cases. - **[serve](examples/serve/serve.zig)**: the traditional static web server with   optional dynamic request handling - **[sendfile](examples/sendfile/sendfile.zig)**: simple example of how to send   a file, honoring compression headers, etc. - **[bindataformpost](examples/bindataformpost/bindataformpost.zig)**: example   to receive binary files via form post. - **[hello_json](examples/hello_json/hello_json.zig)**: serves you json   dependent on http path - **[endpoint](examples/endpoint/)**: a simple json rest api example featuring a   `/users` endpoint for performing put/delete/get/post operations and listing   users, together with a simple frontend to play with. **it also introduces a   `/stop` endpoint** that shuts down zap, so **memory leak detection** can be   performed in main().     - check out how [main.zig](examples/endpoint/main.zig) uses zig's awesome       `generalpurposeallocator` to report memory leaks when zap is shut down.       the [stopendpoint](examples/endpoint/stopendpoint.zig) just stops zap when       receiving a request on the `/stop` route. - **[mustache](examples/mustache/mustache.zig)**: a simple example using   [mustache](https://mustache.github.io/) templating. - **[endpoint authentication](examples/endpoint_auth/endpoint_auth.zig)**: a   simple authenticated endpoint. read more about authentication   [here](./doc/authentication.md). - **[http parameters](examples/http_params/http_params.zig)**: a simple example   sending itself query parameters of all supported types. - **[cookies](examples/cookies/cookies.zig)**: a simple example sending itself a   cookie and responding with a session cookie. - **[websockets](examples/websockets/)**: a simple websockets chat for the   browser. - **[username/password session   authentication](./examples/userpass_session_auth/)**: a convenience   authenticator that redirects un-authenticated requests to a login page and   sends cookies containing session tokens based on username/password pairs   received via post request. - **[middleware support](examples/middleware/middleware.zig)**: chain together   request handlers in middleware style. provide custom context structs, totally   type-safe, using **[zig-ception](doc/zig-ception.md)**. if you come from go   this might appeal to you. - **[middleware with endpoint   support](examples/middleware_with_endpoint/middleware_with_endpoint.zig)**:   same as the example above, but this time we use an endpoint at the end of the   chain, by wrapping it via `zap.middleware.endpointhandler`. mixing endpoints   in your middleware chain allows for usage of zap's authenticated endpoints and   your custom endpoints. since endpoints use a simpler api, you have to use   `r.setusercontext()` and `r.getusercontext()` with the request if you want to   access the middleware context from a wrapped endpoint. since this mechanism   uses an `*anyopaque` pointer underneath (to not break the endpoint api), it is   less type-safe than `zap.middleware`'s use of contexts. - [**per request contexts**](./src/zap.zig#l102) : with the introduction of   `setusercontext()` and `getusercontext()`, you can, of course use those two in   projects that don't use `zap.endpoint` or `zap.middleware`, too, if you   really, really, absolutely don't find another way to solve your context   problem. **we recommend using a `zap.endpoint`** inside of a struct that   can provide all the context you need **instead**. you get access to your   struct in the callbacks via the `@fieldparentptr()` trick that is used   extensively in zap's examples, like the [endpoint   example](examples/endpoint/endpoint.zig). - [**error trace responses**](./examples/senderror/senderror.zig): you can now   call `r.senderror(err, status_code)` when you catch an error and a stack trace   will be returned to the client / browser. - [**https**](examples/https/https.zig): shows how easy it is to use facil.io's   openssl support. must be compiled with `-dopenssl=true` or the environment   variable `zap_use_openssl` set to `true` and requires openssl dev dependencies   (headers, lib) to be installed on the system.   - run it like this: `zap_use_openssl=true zig build run-https`     or like this: `zig build -dopenssl=true run-https`   - it will tell you how to generate certificates - [**simple_router**](examples/simple_router/simple_router.zig): see how you   can use `zap.router` to dispatch to handlers by http path.  i'll continue wrapping more of facil.io's functionality and adding stuff to zap to a point where i can use it as the json rest api backend for real research projects, serving thousands of concurrent clients.   ## ⚡blazingly fast⚡  claiming to be blazingly fast is the new black. at least, zap doesn't slow you down and if your server performs poorly, it's probably not exactly zap's fault. zap relies on the [facil.io](https://facil.io) framework and so it can't really claim any performance fame for itself. in this initial implementation of zap, i didn't care about optimizations at all.  but, how fast is it? being blazingly fast is relative. when compared with a simple go http server, a simple zig zap http server performed really good on my machine (x86_64-linux):  - zig zap was nearly 30% faster than go - zig zap had over 50% more throughput than go  **update**: thanks to @felipetrz, i got to test against more realistic python and rust examples. both python `sanic` and rust `axum` were easy enough to integrate.  **update**: i have automated the benchmarks. see [blazingly-fast.md](./blazingly-fast.md) for more information. also, thanks to @alexpyattaev, the benchmarks are fairer now, pinning server and client to specific cpu cores.  **update**: i have consolidated the benchmarks to one good representative per language. see more details in [blazingly-fast.md](./blazingly-fast.md). it contains rust implementations that come pretty close to zap's performance in the simplistic testing scenario.  ![](./wrk/samples/readme_req_per_sec.png)  ![](./wrk/samples/readme_xfer_per_sec.png)   so, being somewhere in the ballpark of basic go performance, zig zap seems to be ... of reasonable performance 😎.  i can rest my case that developing zap was a good idea because it's faster than both alternatives: a) staying with python, and b) creating a go + zig hybrid.  see more details in [blazingly-fast.md](blazingly-fast.md).  ## 💪 robust  zap is **very robust**. in fact, it is so robust that i was confidently able to only work with in-memory data (ram) in all my zap projects so far: over 5 large online research experiments. no database, no file persistence, until i hit 'save' at the end 😊.  so i was able to postpone my cunning data persistence strategy that's similar to a mark-and-sweep garbage collector and would only persist 'dirty' data when traffic is low, in favor of getting stuff online more quickly. but even if implemented, such a persistence strategy is risky because when traffic is not low, it means the system is under (heavy) load. would you confidently not save data when load is high and the data changes most frequently -> the potential data loss is maximized?  to answer that question, i just skipped it. i skipped saving any data until receiving a 'save' signal via api. and it worked. zap just kept on zapping. when traffic calmed down or all experiment participants had finished, i hit 'save' and went on analyzing the data.  handling all errors does pay off after all. no hidden control flow, no hidden errors or exceptions is one of zig's strengths.  to be honest: there are still pitfalls. e.g. if you request large stack sizes for worker threads, zig won't like that and panic. so make sure you don't have local variables that require tens of megabytes of stack space.   ### 🛡️ memory-safe  see the [stopendpoint](examples/endpoint/stopendpoint.zig) in the [endpoint](examples/endpoint) example. that example uses zig's awesome `generalpurposeallocator` to report memory leaks when zap is shut down. the `stopendpoint` just stops zap when receiving a request on the `/stop` route.  you can use the same strategy in your debug builds and tests to check if your code leaks memory.    ## getting started  make sure you have **zig 0.13.0** installed. fetch it from [here](https://ziglang.org/download).  ```shell $ git clone https://github.com/zigzap/zap.git $ cd zap $ zig build run-hello $ # open http://localhost:3000 in your browser ```  ... and open [http://localhost:3000](http://localhost:3000) in your browser.  ## using ⚡zap⚡ in your own projects  make sure you have **the latest zig release (0.13.0)** installed. fetch it from [here](https://ziglang.org/download).  if you don't have an existing zig project, create one like this:  ```shell $ mkdir zaptest && cd zaptest $ zig init $ git init      ## (optional) ``` **note**: nix/nixos users are lucky; you can use the existing `flake.nix` and run `nix develop` to get a development shell providing zig and all dependencies to build and run the go, python, and rust examples for the `wrk` performance tests. for the mere building of zap projects, `nix develop .#build` will only fetch zig 0.11.0. todo: upgrade to latest zig.  with an existing zig project, adding zap to it is easy:  1. add zap to your `build.zig.zon` 2. add zap to your `build.zig`  in your zig project folder (where `build.zig` is located), run:  <!-- insert_dep_begin --> ``` zig fetch --save 'git+https://github.com/zigzap/zap#v0.9.1' ``` <!-- insert_dep_end -->  then, in your `build.zig`'s `build` function, add the following before `b.installartifact(exe)`:  ```zig     const zap = b.dependency('zap', .{         .target = target,         .optimize = optimize,         .openssl = false, // set to true to enable tls support     });      exe.root_module.addimport('zap', zap.module('zap')); ```  from then on, you can use the zap package in your project. check out the examples to see how to use zap.  ## updating your project to the latest version of zap  you can change the url to zap in your `build.zig.zon`  - easiest: use a tagged release - or to one of the tagged versions, e.g. `0.0.9` - or to the latest commit of `zap`  ### using a tagged release  go to the [release page](https://github.com/zigzap/zap/releases). every release will state its version number and also provide instructions for changing `build.zig.zon` and `build.zig`.  ### using other versions  see [here](./doc/other-versions.md).  ## contribute to ⚡zap⚡ - blazingly fast  at the current time, i can only add to zap what i need for my personal and professional projects. while this happens **blazingly fast**, some if not all nice-to-have additions will have to wait. you are very welcome to help make the world a blazingly fast place by providing patches or pull requests, add documentation or examples, or interesting issues and bug reports - you'll know what to do when you receive your calling 👼.  check out [contributing.md](contributing.md) for more details.  see also [introducing.md](introducing.md) for more on the state and progress of this project.  **we now have our own [zap discord](https://discord.gg/jqaan6ubyj) server!!!**  you can also reach me on [the zig showtime discord server](https://discord.gg/cbze3vmb) under the handle renerocksai (renerocksai#1894).  ## support ⚡zap⚡  being blazingly fast requires a constant feed of caffeine. i usually manage to provide that to myself for myself. however, to support keeping the juices flowing and putting a smile on my face and that warm and cozy feeling into my heart, you can always [buy me a coffee](https://buymeacoffee.com/renerocksai) ☕. all donations are welcomed 🙏 blazingly fast! that being said, just saying 'hi' also works wonders with the smiles, warmth, and coziness 😊.  ## examples  you build and run the examples via:  ```shell $ zig build [example] $ ./zig-out/bin/[example] ```  ... where `[example]` is one of `hello`, `routes`, `serve`, ... see the [list of examples above](#heres-what-works).  example: building and running the hello example:  ```shell $ zig build hello $ ./zig-out/bin/hello ```  to just run an example, like `routes`, without generating an executable, run:  ```shell $ zig build run-[example] ```  example: building and running the routes example:  ```shell $ zig build run-routes ```  ### [hello](examples/hello/hello.zig)  ```zig const std = @import('std'); const zap = @import('zap');  fn on_request(r: zap.request) void {     if (r.path) |the_path| {         std.debug.print('path: {s}╲n', .{the_path});     }      if (r.query) |the_query| {         std.debug.print('query: {s}╲n', .{the_query});     }     r.sendbody('<html><body><h1>hello from zap!!!</h1></body></html>') catch return; }  pub fn main() !void {     var listener = zap.httplistener.init(.{         .port = 3000,         .on_request = on_request,         .log = true,     });     try listener.listen();      std.debug.print('listening on 0.0.0.0:3000╲n', .{});      // start worker threads     zap.start(.{         .threads = 2,         .workers = 2,     }); } ```     ","capy-ui/capy":"💻Build one codebase and get native UI on Windows, Linux and Web <a href='https://capy-ui.org'>     <p align='center'>         <picture>             <source media='(prefers-color-scheme: dark)' srcset='https://capy-ui.org/img/capy_big2_dark.png'>             <img src='https://capy-ui.org/img/capy_big2.png' alt='capy ui' height='200px'>         </picture>     </p> </a>  **as of now, capy is not ready for use in production as i'm still making breaking changes**  **capy targets zig version `0.14.0-dev.1911+3bf89f55c` / `2024.10.0-mach` ([nominated zig versions](https://machengine.org/docs/nominated-zig/))** , it doesn't work on zig `0.13.0`  ---  [![code coverage](https://img.shields.io/codecov/c/github/capy-ui/capy?style=for-the-badge)](https://app.codecov.io/gh/capy-ui/capy) [![mpl-2.0 license](https://img.shields.io/github/license/capy-ui/capy?style=for-the-badge)](https://github.com/capy-ui/capy/blob/master/license)  ![the glorius software in action](https://raw.githubusercontent.com/zenith391/bottom-zig-gui/main/.github/screenshot.png)  ## introduction  capy is a **gui library for zig**. it is mainly intended for creating applications using native controls from the operating system. capy is a declarative ui library aiming to be easy to write for and versatile.  it has been made with the goal to empower standalone ui applications, integration in games or any other rendering process is a non-goal.  ## features - use zig for frontend and backend - accessibility: compatibility with almost all accessibility tools - cross-platform - uses the target os toolkit - cross-compilable from any platform to any other platform - *tiny* executables - every [example](https://github.com/capy-ui/capy/tree/master/examples)'s size < 2mb, which is smaller than 'hello world' in go  ## getting started  if you're starting a new project, simply clone [capy-template](https://github.com/capy-ui/capy-template) and follow build instructions.  otherwise or for more information, please look in the [docs](https://capy-ui.org/docs/getting-started/installation).  you can ask questions and receive updates on the [#capy-ui matrix channel](https://matrix.to/#/#capy-ui:matrix.org).  ## usage  a simple application using capy:  ```zig const capy = @import('capy'); const std = @import('std'); pub usingnamespace capy.cross_platform;  pub fn main() !void {     try capy.init();      var window = try capy.window.init();     try window.set(         capy.column(.{ .spacing = 10 }, .{ // have 10px spacing between each column's element             capy.row(.{ .spacing = 5 }, .{ // have 5px spacing between each row's element                 capy.button(.{ .label = 'save', .onclick = @ptrcast(&buttonclicked) }),                 capy.button(.{ .label = 'run',  .onclick = @ptrcast(&buttonclicked) })             }),             // 'expanded' means the widget will take all the space it can             // in the parent container             capy.expanded(                 capy.textarea(.{ .text = 'hello world!' })             )         })     );      window.setpreferredsize(800, 600);     window.show();     capy.runeventloop(); }  fn buttonclicked(button: *capy.button) !void {     std.log.info('you clicked the button with text {s}', .{button.getlabel()}); } ```  it is easy to add something like a button or a text area. the example can already be used to notice a widget's parameters are usually enclosed in anonymous structs (`.{ .label = 'save' }`). you can also see that simply wrapping a widget with `capy.expanded( ... )` will tell it to take all the space it can.  ## contributing contributing can be as simple as opening an issue and detailling what bug you encountered or what feature you wish to have.   if you want to help the project more directly, you can fork the project and then create a pull request.  ## supported platforms  a platform is considered supported only if it can be built to from every other os.  legends: - ✅ working and can be cross-compile from all platforms supported by zig - 🧪 experimental - 🏃 planned  ### desktop  ✅ windows x86_64   ✅ windows i386  🏃 macos m1   🏃 macos x86_64    ✅ linux x86_64   ✅ linux i386   ✅ linux aarch64 (pinephone, pinebook...)    ✅ freebsd x86_64    ### mobile  🧪 android   🏃 ios  ### web  ✅ webassembly  note: as there's no 'official' gui library for linux, gtk 4 has been chosen as it is the one that works and can be configured on the most distros. it's also the reason libadwaita won't be adopted, as it's meant for gnome and gnome only by disallowing styling and integration with other des.    ## supported components for now, not every platform supports the same components. so here's a list of the ones that are supported:  |                  |win32|macos|gtk|android|wasm| |------------------|-----|-----|---|-----|-----| |button            |✅|✅|✅|✅|✅| |canvas            |❌|❌|✅|✅|✅| |checkbox          |✅|❌|✅|❌|❌| |dropdown          |✅|❌|✅|❌|❌| |image             |❌|❌|✅|❌|✅| |label             |✅|✅|✅|✅|✅| |menu              |❌|❌|❌|❌|❌| |navigation        |❌|❌|❌|❌|❌| |navigationsidebar |❌|❌|✅|❌|❌| |scrollable        |✅|❌|✅|❌|❌| |slider            |✅|❌|✅|❌|✅| |tabs              |✅|❌|✅|❌|❌| |textarea          |✅|❌|✅|❌|❌| |textfield         |✅|❌|✅|✅|✅| |window            |✅|✅|✅|✅|✅ ","ZigEmbeddedGroup/microzig":"Unified abstraction layer and HAL for several microcontrollers # ![microzig logo](design/logo-text-auto.svg)  [![chat](https://img.shields.io/discord/824493524413710336.svg?logo=discord)](https://discord.gg/shuwykk38x) [![downloads](https://img.shields.io/badge/zig_package-download-blue)](https://downloads.microzig.tech/) [![continuous integration](https://github.com/zigembeddedgroup/microzig/actions/workflows/build.yml/badge.svg)](https://github.com/zigembeddedgroup/microzig/actions/workflows/build.yml)  > **note:** this is in development; breaks in the api are bound to happen.  ## what version of zig to use  zig 0.13.0  ## getting started with microzig  ### i want to use microzig  **important:** you may not have to clone the whole repository to get started.  microzig uses a monorepo architecture, but provides a lot of different packages. if you just want to get started, head over to [downloads.microzig.tech](https://downloads.microzig.tech/) and download an example for the chip family you desire. microzig's version listed here match the zig versions assoicated with them, so version 12.0 match zig 12.0. if you don't see the zig version here you will have to clone the repo to get started.  we support several chip families like the [rp2 family by raspberrypi foundation](https://www.raspberrypi.com/products/rp2040/), [stm32 by stmicroelectronics](https://www.st.com/content/st_com/en.html), and many others.  unpack the example, and run `zig build` in the resulting example folder gives you `zig-out/firmware` which contains the resulting files.  right now, you gotta figure out how to flash the mcu yourself, but as people say: google is your friend. but you can also ask for help [on our discord server](https://discord.gg/shuwykk38x).  ### i want to contribute to microzig  please see the [project page](https://github.com/orgs/zigembeddedgroup/projects/1/views/1), it’s used as a place to brainstorm and organize work in zeg. there will be issues marked as good first issue or drafts for larger ideas that need scoping/breaking ground on.  more words on contribution and development on microzig are [further down below](#developing).  ## introduction  this repo contains the infrastructure for getting started in an embedded zig project; it 'gets you to main()'. specifically, it offers:  * a single easy-to-use builder function that:   * generates your linker script   * sets up packages and startup code * generalized interfaces for common devices, such as uart. * device drivers for interacting with external hardware * an uncomplicated method to define xref:interrupts[interrupts]  ## design  for microzig internals please see the [design document](docs/design.md).  ## repository structure  * `build/` contains the build components of microzig. * `core/` contains the shared components of microzig. * `port/` contains all official board support package. * `examples/` contains examples that can be used with the board support packages. * `tools/` contains tooling to work *on* microzig itself, so deployment, testing, ... * `design/` contains images and logos  ## versioning scheme  microzig versions are tightly locked with zig versions.  the general scheme is `${zig_version}-${commit}-${count}`, so the microzig versions will look really similar to zigs versions, but with our own commit abbreviations and counters.  as microzig sticks to tagged zig releases, `${zig_version}` will show to which zig version the microzig build is compatible.  consider the version `0.11.0-abcdef-123` means that this microzig version has a commit starting with `abcdef`, which was the 123rd commit of the version that is compatible with zig 0.11.0.  ","Hejsil/zig-clap":"Command line argument parsing library <!--- readme.md is autogenerated. please edit example/readme.md.template instead. --> # zig-clap  a simple and easy to use command line argument parser library for zig.  ## installation  developers tend to either use * the latest tagged release of zig * the latest build of zigs master branch  depending on which developer you are, you need to run different `zig fetch` commands:  ```sh # version of zig-clap that works with a tagged release of zig # replace `<replace me>` with the version of zig-clap that you want to use # see: https://github.com/hejsil/zig-clap/releases zig fetch --save https://github.com/hejsil/zig-clap/archive/refs/tags/<replace me>.tar.gz  # version of zig-clap that works with latest build of zigs master branch zig fetch --save git+https://github.com/hejsil/zig-clap ```  then add the following to `build.zig`:  ```zig const clap = b.dependency('clap', .{}); exe.root_module.addimport('clap', clap.module('clap')); ```  ## features  * short arguments `-a`   * chaining `-abc` where `a` and `b` does not take values.   * multiple specifications are tallied (e.g. `-v -v`). * long arguments `--long` * supports both passing values using spacing and `=` (`-a 100`, `-a=100`)   * short args also support passing values with no spacing or `=` (`-a100`)   * this all works with chaining (`-ba 100`, `-ba=100`, `-ba100`) * supports options that can be specified multiple times (`-e 1 -e 2 -e 3`) * print help message from parameter specification. * parse help message to parameter specification.  ## api reference  automatically generated api reference for the project can be found at https://hejsil.github.io/zig-clap. note that zig autodoc is in beta; the website may be broken or incomplete.  ## examples  ### `clap.parse`  the simplest way to use this library is to just call the `clap.parse` function.  ```zig pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();      // first we specify what parameters our program can take.     // we can use `parseparamscomptime` to parse a string into an array of `param(help)`     const params = comptime clap.parseparamscomptime(         ╲╲-h, --help             display this help and exit.         ╲╲-n, --number <usize>   an option parameter, which takes a value.         ╲╲-s, --string <str>...  an option parameter which can be specified multiple times.         ╲╲<str>...         ╲╲     );      // initialize our diagnostics, which can be used for reporting useful errors.     // this is optional. you can also pass `.{}` to `clap.parse` if you don't     // care about the extra information `diagnostics` provides.     var diag = clap.diagnostic{};     var res = clap.parse(clap.help, &params, clap.parsers.default, .{         .diagnostic = &diag,         .allocator = gpa.allocator(),     }) catch |err| {         // report useful error and exit         diag.report(std.io.getstderr().writer(), err) catch {};         return err;     };     defer res.deinit();      if (res.args.help != 0)         std.debug.print('--help╲n', .{});     if (res.args.number) |n|         std.debug.print('--number = {}╲n', .{n});     for (res.args.string) |s|         std.debug.print('--string = {s}╲n', .{s});     for (res.positionals[0]) |pos|         std.debug.print('{s}╲n', .{pos}); }  const clap = @import('clap'); const std = @import('std');  ```  the result will contain an `args` field and a `positionals` field. `args` will have one field for each none positional parameter of your program. the name of the field will be the longest name of the parameter. `positionals` be a tuple with one field for each positional parameter.  the fields in `args` and `postionals` are typed. the type is based on the name of the value the parameter takes. since `--number` takes a `usize` the field `res.args.number` has the type `usize`.  note that this is only the case because `clap.parsers.default` has a field called `usize` which contains a parser that returns `usize`. you can pass in something other than `clap.parsers.default` if you want some other mapping.  ```zig pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();      // first we specify what parameters our program can take.     // we can use `parseparamscomptime` to parse a string into an array of `param(help)`     const params = comptime clap.parseparamscomptime(         ╲╲-h, --help             display this help and exit.         ╲╲-n, --number <int>     an option parameter, which takes a value.         ╲╲-a, --answer <answer>  an option parameter which takes an enum.         ╲╲-s, --string <str>...  an option parameter which can be specified multiple times.         ╲╲<file>...         ╲╲     );      // declare our own parsers which are used to map the argument strings to other     // types.     const yesno = enum { yes, no };     const parsers = comptime .{         .str = clap.parsers.string,         .file = clap.parsers.string,         .int = clap.parsers.int(usize, 10),         .answer = clap.parsers.enumeration(yesno),     };      var diag = clap.diagnostic{};     var res = clap.parse(clap.help, &params, parsers, .{         .diagnostic = &diag,         .allocator = gpa.allocator(),         // the assignment separator can be configured. `--number=1` and `--number:1` is now         // allowed.         .assignment_separators = '=:',     }) catch |err| {         diag.report(std.io.getstderr().writer(), err) catch {};         return err;     };     defer res.deinit();      if (res.args.help != 0)         std.debug.print('--help╲n', .{});     if (res.args.number) |n|         std.debug.print('--number = {}╲n', .{n});     if (res.args.answer) |a|         std.debug.print('--answer = {s}╲n', .{@tagname(a)});     for (res.args.string) |s|         std.debug.print('--string = {s}╲n', .{s});     for (res.positionals[0]) |pos|         std.debug.print('{s}╲n', .{pos}); }  const clap = @import('clap'); const std = @import('std');  ```  ### subcommands  there is an option for `clap.parse` and `clap.parseex` called `terminating_positional`. it allows for users of `clap` to implement subcommands in their cli application:  ```zig // these are our subcommands const subcommands = enum {     help,     math, };  const main_parsers = .{     .command = clap.parsers.enumeration(subcommands), };  // the parameters for main. parameters for the subcommands are specified further down const main_params = clap.parseparamscomptime(     ╲╲-h, --help  display this help and exit.     ╲╲<command>     ╲╲ );  // to pass around arguments returned by clap, `clap.result` and `clap.resultex` can be used to // get the return type of `clap.parse` and `clap.parseex` const mainargs = clap.resultex(clap.help, &main_params, main_parsers);  pub fn main() !void {     var gpa_state = std.heap.generalpurposeallocator(.{}){};     const gpa = gpa_state.allocator();     defer _ = gpa_state.deinit();      var iter = try std.process.argiterator.initwithallocator(gpa);     defer iter.deinit();      _ = iter.next();      var diag = clap.diagnostic{};     var res = clap.parseex(clap.help, &main_params, main_parsers, &iter, .{         .diagnostic = &diag,         .allocator = gpa,          // terminate the parsing of arguments after parsing the first positional (0 is passed         // here because parsed positionals are, like slices and arrays, indexed starting at 0).         //         // this will terminate the parsing after parsing the subcommand enum and leave `iter`         // not fully consumed. it can then be reused to parse the arguments for subcommands         .terminating_positional = 0,     }) catch |err| {         diag.report(std.io.getstderr().writer(), err) catch {};         return err;     };     defer res.deinit();      if (res.args.help != 0)         std.debug.print('--help╲n', .{});      const command = res.positionals[0] orelse return error.missingcommand;     switch (command) {         .help => std.debug.print('--help╲n', .{}),         .math => try mathmain(gpa, &iter, res),     } }  fn mathmain(gpa: std.mem.allocator, iter: *std.process.argiterator, main_args: mainargs) !void {     // the parent arguments are not used it, but there are cases where it might be useful, so     // the example shows how to pass the arguments around.     _ = main_args;      // the parameters for the subcommand     const params = comptime clap.parseparamscomptime(         ╲╲-h, --help  display this help and exit.         ╲╲-a, --add   add the two numbers         ╲╲-s, --sub   subtract the two numbers         ╲╲<isize>         ╲╲<isize>         ╲╲     );      // here we pass the partially parsed argument iterator     var diag = clap.diagnostic{};     var res = clap.parseex(clap.help, &params, clap.parsers.default, iter, .{         .diagnostic = &diag,         .allocator = gpa,     }) catch |err| {         diag.report(std.io.getstderr().writer(), err) catch {};         return err;     };     defer res.deinit();      const a = res.positionals[0] orelse return error.missingarg1;     const b = res.positionals[1] orelse return error.missingarg1;     if (res.args.help != 0)         std.debug.print('--help╲n', .{});     if (res.args.add != 0)         std.debug.print('added: {}╲n', .{a + b});     if (res.args.sub != 0)         std.debug.print('subtracted: {}╲n', .{a - b}); }  const clap = @import('clap'); const std = @import('std');  ```  ### `streaming.clap`  the `streaming.clap` is the base of all the other parsers. it's a streaming parser that uses an `args.iterator` to provide it with arguments lazily.  ```zig pub fn main() !void {     const allocator = std.heap.page_allocator;      // first we specify what parameters our program can take.     const params = [_]clap.param(u8){         .{             .id = 'h',             .names = .{ .short = 'h', .long = 'help' },         },         .{             .id = 'n',             .names = .{ .short = 'n', .long = 'number' },             .takes_value = .one,         },         .{ .id = 'f', .takes_value = .one },     };      var iter = try std.process.argiterator.initwithallocator(allocator);     defer iter.deinit();      // skip exe argument     _ = iter.next();      // initialize our diagnostics, which can be used for reporting useful errors.     // this is optional. you can also leave the `diagnostic` field unset if you     // don't care about the extra information `diagnostic` provides.     var diag = clap.diagnostic{};     var parser = clap.streaming.clap(u8, std.process.argiterator){         .params = &params,         .iter = &iter,         .diagnostic = &diag,     };      // because we use a streaming parser, we have to consume each argument parsed individually.     while (parser.next() catch |err| {         // report useful error and exit         diag.report(std.io.getstderr().writer(), err) catch {};         return err;     }) |arg| {         // arg.param will point to the parameter which matched the argument.         switch (arg.param.id) {             'h' => std.debug.print('help!╲n', .{}),             'n' => std.debug.print('--number = {s}╲n', .{arg.value.?}),              // arg.value == null, if arg.param.takes_value == .none.             // otherwise, arg.value is the value passed with the argument, such as '-a=10'             // or '-a 10'.             'f' => std.debug.print('{s}╲n', .{arg.value.?}),             else => unreachable,         }     } }  const clap = @import('clap'); const std = @import('std');  ```  currently, this parser is the only parser that allows an array of `param` that is generated at runtime.  ### `help`  the `help` prints a simple list of all parameters the program can take. it expects the `id` to have a `description` method and an `value` method so that it can provide that in the output. `helpoptions` is passed to `help` to control how the help message is printed.  ```zig pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();      const params = comptime clap.parseparamscomptime(         ╲╲-h, --help     display this help and exit.         ╲╲-v, --version  output version information and exit.         ╲╲     );      var res = try clap.parse(clap.help, &params, clap.parsers.default, .{         .allocator = gpa.allocator(),     });     defer res.deinit();      // `clap.help` is a function that can print a simple help message. it can print any `param`     // where `id` has a `description` and `value` method (`param(help)` is one such parameter).     // the last argument contains options as to how `help` should print those parameters. using     // `.{}` means the default options.     if (res.args.help != 0)         return clap.help(std.io.getstderr().writer(), clap.help, &params, .{}); }  const clap = @import('clap'); const std = @import('std');  ```  ``` $ zig-out/bin/help --help     -h, --help             display this help and exit.      -v, --version             output version information and exit. ```  ### `usage`  the `usage` prints a small abbreviated version of the help message. it expects the `id` to have a `value` method so it can provide that in the output.  ```zig pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();      const params = comptime clap.parseparamscomptime(         ╲╲-h, --help         display this help and exit.         ╲╲-v, --version      output version information and exit.         ╲╲    --value <str>  an option parameter, which takes a value.         ╲╲     );      var res = try clap.parse(clap.help, &params, clap.parsers.default, .{         .allocator = gpa.allocator(),     });     defer res.deinit();      // `clap.usage` is a function that can print a simple help message. it can print any `param`     // where `id` has a `value` method (`param(help)` is one such parameter).     if (res.args.help != 0)         return clap.usage(std.io.getstderr().writer(), clap.help, &params); }  const clap = @import('clap'); const std = @import('std');  ```  ``` $ zig-out/bin/usage --help [-hv] [--value <str>] ```  ","judofyr/spice":"Fine-grained parallelism with sub-nanosecond overhead in Zig # spice: parallelism with sub-nanosecond overhead  ![time to calculate sum of binary tree of 100m nodes with spice](bench/spice-tree-sum-100m.svg)  **spice** uses [_heartbeat scheduling_][hb] to accomplish extremely efficient parallelism in zig:  - **sub-nanosecond overhead:**   turning your function into a parallelism-enabled function adds less than a nanosecond of overhead. - **contention-free:**   threads will never compete (i.e. spin) over the same work.   adding more threads to the system will not make your program any slower, but the extra threads might be completely idle since there's nothing useful to do.  _(update, september 2024: [chili](https://github.com/dragostis/chili) is a rust port of the ideas presented here. check it out!)_  the benchmark in the figure above (summing over the nodes in a binary tree) is typically one of the worst cases for parallelism frameworks: the actual operation is extremely fast so any sort of overhead will have a measurable impact.  here's the _exact_ same benchmark in [rayon][rayon], an excellent library in rust for doing parallelism. both implementations follow the same fork/join api which gives code that is very easy to read and reason about. none of the findings here would surprise anyone who deeply knows rayon and there are ways of getting better performance out of rayon by using different techniques. this comes at cost of the code becoming more complicated and/or behaving subpar on different types of input. the purpose of this benchmark is to not discourage use of rayon (on the contrary!), but rather demonstrate that it _is_ possible to have both simple code and good parallelism. see [issue #5](https://github.com/judofyr/spice/issues/5) for a longer discussion.  ![time to calculate sum of binary tree of 100m nodes with rayon](bench/rayon-tree-sum-100m.svg)  the overhead here is roughly ~15 ns (from 7.48 ns to 22.99 ns) which means that at 4 threads we're 'back' to the sequential performance - just using four times as much cpu. luckily we _are_ able to get linear speed-up (in terms of threads) initially. these benchmarks were ran on a `c4-standard-16` instance in google cloud with 16 cores. rayon itself shows a nice ~14x speed-up (from 22.99 ns to 1.64 ns) at 16 threads, but compared to the _baseline_ this ends up only being ~4.5x due to the overhead.  in comparison, spice scales slightly worse: it only got ~11x speed-up when going from 1 to 16 threads. however, due its low overhead this is also essentially the speed-up compared to the baseline.  (it's not entirely clear why the zig baseline implementation is twice as fast as the rust implementation. the [compiled assembly (godbolt)][rust-vs-zig] show that rust saves five registers on the stack while zig only saves three, but why? for the purpose of this benchmark it shouldn't matter since we're only comparing against the baseline of each language.)  it becomes even more interesting if we're summing the nodes of a much smaller tree:  ![time to calculate sum of binary tree of 1000 nodes with rayon](bench/rayon-tree-sum-1000.svg)  in this scenario we have a very short duration of our program: the baseline implementation takes a few microseconds in total to run. for some reason the overhead is a bit higher (~19 ns), but more concerningly we see that performance becomes _worse_ the _more_ threads we're adding. at 32 threads it's in total **60 times slower**.  (in this case we're using 32 threads on a machine which only has 16 cores. it's not given that we would see the same slowdown for a machine with 32 cores. nonetheless, this scaling behavior is concerning.)  the conventional wisdom for parallelism therefore ends up being 'it's not worth it unless you have _enough work_ to parallelize'. the example above is typically presented as a 'bad fit for parallelism'. this is understandable and pragmatic, but in practice it makes it a lot more difficult to _actually_ parallelize your code:  - what exactly is 'enough work'?   you might need to do a lot of benchmarking with different types of input to understand this. - it might be difficult to detect how much work a certain input does.   for instance, in our binary tree we don't know the full size of it.   there's no obvious way for us to say 'if the tree is small enough, don't run the parallelized code' since by only looking at the root we don't the size of it. - as we've seen, the potential slowdown can be extreme.   what if 90% of your workload is like this? - as your program evolves and your code does more (or less) _things_, the definition of 'enough work' will also naturally change.  the goal of spice is for you **to never have to worry about your program becoming slower by making it parallel**. if you're looking to maximize the performance you should of course do elaborate benchmarking, but _generally_ with spice you can add parallelism and there will be _practically_ no overhead.  the last example of summing over 1000 nodes behaves as follows in spice:  ![time to calculate sum of binary tree of 1000 nodes with spice](bench/spice-tree-sum-1000.svg)  what's happening here is that it's discovering that the duration is too short so none of the multi-threading kicks in. all the extra threads here are sleeping, giving the cores time to execute other programs.  spice is **primarily a research project**. read along to learn more about it, but if you're considering using it in production you should be aware of its [many limitations](#limitations).  _(see the [bench/](bench/) directory for more details about these specific benchmarks.)_  ## table of contents  - [using spice](#using-spice) - [work-stealing and its inefficiencies](#work-stealing-and-its-inefficiencies) - [implementation details](#implementation-details)   - [optimizing for static dispatch](#optimizing-for-static-dispatch)   - [low-overhead heartbeating signaling](#low-overhead-heartbeating-signaling)   - [global mutex is fine when there's no contention](#global-mutex-is-fine-when-theres-no-contention)   - [branch-free doubly-linked list](#branch-free-doubly-linked-list)   - [minimizing the stack usage](#minimizing-the-stack-usage)   - [passing values around in registers](#passing-values-around-in-registers) - [benchmarks](#benchmarks) - [acknowledgments](#acknowledgments) - [limitations](#limitations) - [faq](#faq)  ## using spice  the following example demonstrates how spice works:  ```zig const spice = @import('spice');  // (1) add task as a parameter. fn sum(t: *spice.task, node: *const node) i64 {     var res: i64 = node.val;      if (node.left) |left_child| {         if (node.right) |right_child| {             var fut = spice.future(*const node, i64).init();              // (3) call `fork` to set up work for another thread.             fut.fork(t, sum, right_child);              // (4) do some work yourself.             res += t.call(i64, sum, left_child);              if (fut.join(t)) |val| {                 // (5) wait for the other thread to complete the work.                 res += val;             } else {                 // (6) ... or do it yourself.                 res += t.call(i64, sum, right_child);             }             return res;         }          res += t.call(i64, sum, left_child);     }      if (node.right) |right_child| {         // (2) recursive calls must use `t.call`         res += t.call(i64, sum, right_child);     }      return res; } ```  1. every parallel function needs to take a _task_ as a parameter.    this is used to coordinate the work. 2. you should never call your function directly, but instead use `t.call` which will call it for you (in the right way). 3. call `fork` to set up a piece of work which can be done by a different thread.    this can be called multiple times to set up multiple pieces of work. 4. after that your function should do some meaningful work itself. 5. call `join` to wait for the work done by the other thread. 6. _however_, `join` might return `null` and this signals that _no other thread picked up the work_.    in this case you must do the work yourself.  here we repeat ourselves in step 3 and 6: both places we refer to `sum` and `right_child`. it's possible to hide this duplication by some helper function, _but_ this example demonstrates a core idea behind spice:  **not every piece of work comes from the queue.** you call `fork` to signal that there's something which _can_ be executed by another thread, but if all the other threads are busy then you fallback to executing it as if the fork never happened.  this principle is core to how spice achieves its low and predictable overhead: if there's no parallelism possible then all spice is doing on the hot path is pushing and popping the queue (without ever looking at any of the items).  the actually coordination with other threads happens on a _fixed heartbeat_: every 100 microsecond or so a thread will look at its current work queue and dispatch the top-most item to another waiting thread. since the heartbeat happens very infrequently (compared to the clock speed) we also don't need to worry so much about what we're doing during the heartbeat. even if we spend _hundreds_ of nanoseconds the _total_ overhead becomes small since we do it rarely.  ## work-stealing and its inefficiencies  spice provides the [fork/join model][fj] which has typically been implementing by using [**work-stealing**][wb]. let's have a look at work-stealing:  - every thread have their own local _work queue_.   every piece of work in the system gets put onto this queue. - the same thread will pick up work from this queue and execute it.   this might lead to more work being added (onto the same queue). - at some point, the local work queue for a thread will become empty.   the thread will then attempt to _steal_ work from another thread:   it takes a chunk of the work from the _end_ of another thread's queue and places it into its own. - since each thread pulls work from the _beginning_ of its queue and other thread steals from the _end_, we expect there to be little contention on these queues.  however, there's three major sources of inefficiencies in this design:  **every piece of work is a _dynamic dispatch_.** in compiled languages (such as c) function calls are 'practically' free due to the capability of statically knowing everything about the called function. this is a scenario which compilers and cpus have been optimized for _decades_ to execute efficiently. work-stealing systems _don't_ use this functionality, but instead puts every piece of work into generic 'call this dynamic function'. it's a small piece of overhead, but it does add up.  **the 'local' work queue isn't really local.** yes, it's true that every thread have a single queue that they will push work onto, _but_ this is far from a 'local' queue as is typically described in concurrent algorithms. this is a queue in which _every_ thread at _every_ point might steal from. in reality, work-stealing systems with n threads have n global queues, where each queue only has a single producer, but everyone is a consumer. why does this distinction matter? _because all operations on these queues have to use atomic operations._ atomic operations, especially stores, are far more expensive than regular, _local_ stores.  **spinning works great … until it doesn't.** the queues in work-stealing systems are typically implemented using _spinning_: every thread will optimistically try to acquire a single item from the queue, and if there's a contention with another thread it will _try again_ in a loop. this typically gives great performance … **until it doesn't**. it can be very hard to reason about this or replicate it since under one set of conditions everything is fine, but _suddenly_ during contention the system will slow down to a halt (i.e. 10x-100x slower).  spice directly tackles all of these inefficiencies:  1. the dynamic dispatch of the work queue is only used when work is sent to another thread.    work done _within_ a single thread will use regular function calls outside of the work queue. 2. the work queue is truly local:    pushing to it involves (1) one memory store to a pointer to somewhere on the stack, (2) one memory store to the current stack frame, (3) one register store.    none of these operations need to synchronize with other threads. 3. there isn't a single `while`-loop in spice which doesn't also contain a `wait()`-call which will suspend the thread.    there is no spinning.  ## implementation details  let's dive further into how spice is implemented to achieve its efficient parallelism.  ### optimizing for static dispatch  a fork/join program has a set of code blocks which are executed in parallel and once they finish the `join` action completes:  ``` join(   fork { code1 }   fork { code2 }   fork { code3 } ) ```  in spice this is represented as:  ``` job1 = fork { code1 }  // place on the queue job2 = fork { code2 }  // place on the queue  code3 // run right away  if (job2.isexecuting()) {   // job was picked up by another thread. wait for it.   job2.wait() } else {   code2 }  if (job1.isexecuting()) {   // job was picked up by another thread. wait for it.   job1.wait() } else {   code1 } ```  notice that `code1` and `code2` has been duplicated_inside the function. this is actually a _good_ thing. most of the time the job will _not_ be picked up by another thread. in this case, our program nicely turns into the sequential version (although in reverse order) with a few extra branches which are all very predictable. this is friendly both for the code optimizer (e.g. it can now inline the function call) and the cpu.  ### low-overhead heartbeating signaling  the core idea of heartbeat scheduling is to do scheduling _locally_ and at a _low frequency_: every 100 microsecond or so we'd like every thread to look at it local work queue and send work to a different thread. the low frequency is key to eliminating overall overhead. if we're only doing something every 100 microsecond we can actually spend 100 nanoseconds (an eternity!) and still only introduce 0.1% overhead.  operating systems have built-in support for _signaling_, but these are very hard to reason about. the user code gets paused at _any_ random point and it's hard to safely continue running. for this reason, spice uses a cooperative approach instead: the user code have to call `tick()` and this detects whether a heartbeat should happen. this function call is automatically called for you whenever you use the `call`-helper.  it's critical that this function is efficient when a heartbeat **isn't** happening. this is after all the common case (as the heartbeat is only happening every ~100 microsecond).  ```zig pub inline fn tick(self: *task) void {     if (self.worker.heartbeat.load(.monotonic)) {         self.worker.pool.heartbeat(self.worker);     } } ```  in spice we spawn a separate heartbeat thread whose sole purpose is to periodically flip the thread's atomic heartbeat value from `false` to `true`. the `tick()` function then reads this atomic value and starts its heartbeat code when it's `true`.  a key part of reducing the overhead of the ticking is to make sure the heartbeat function itself is marked as _cold_. this causes the presence of this function call to not use up any registers. without this the overhead is significantly higher.  ### global mutex is fine when there's no contention  if you look inside the codebase of spice you will find that each thread pool has a single mutex which is locked all over the place. an immediate reaction would be 'oh no, a global mutex is terrible' and you might be tempted to replace it.  _however_, there's no problem with a global mutex _until you're being blocked_. and you can only be blocked if two conditions occur:  1. a thread is holding the lock for a _long_ time. 2. there's concurrent threads trying to acquire the lock at the same time.  **none** of these are true for spice. the heartbeating ensures that typically only a single thread is executing a heartbeat. in addition, no user code is executed while the lock is held. we're only protecting trivial simple memory reads/writes which will complete in constant time.  ### branch-free doubly-linked list  we're using a doubly-linked list to keep track of the work queue: `fork()` appends to the end, `join()` pops from the end (if it's still there), and we pop from the _beginning_ when we want to send work to a background worker.  [appending into a doubly-linked list](https://github.com/ziglang/zig/blob/cb308ba3ac2d7e3735d1cb42ef085edb1e6db723/lib/std/linked_list.zig#l267-l275) typically looks like this:  ```zig pub fn append(list: *self, new_node: *node) void {     if (list.last) |last| {         // insert after last.         list.insertafter(last, new_node);     } else {         // empty list.         list.prepend(new_node);     } } ```  notice that there's a conditional here: if the list is empty we need to do something special. most of the time the list will of course _not_ be empty. to eliminate the branch we can make sure that the list is _never_ empty. we define a sentinel node (the 'head') which always represents the beginning of the list. the tail pointer will start by pointing to this head node.  this means that both pushing and popping is completely branch-free and these are operations we do at _every_ recursive function call.  ### minimizing the stack usage  a `future` in spice has two possible states: it's either _queued_ or _executing_. the heartbeat is responsible for taking a _queued_ future and start _executing_ it. and as we already know: heartbeating happens rarely so we expect many futures to be queued without executing.  an early prototype of spice used a _tagged union_ to store the future on the stack. this turns out to be suboptimal because (1) stack usage matters for performance (at least in this benchmark) and (2) there's quite a lot of additional state needed to keep track of futures which are _executing_.  to minimize stack usage spice therefore uses two techniques:  1. execution state is placed in a separate (pool-allocated) struct.    the queued (but not executed) futures therefore does not need to consume any of this space. 2. we manually create a tagged union where we use the fact that the _executing_ state only needs a single pointer while the _queued_ state is guaranteed to have a `prev` pointer.    whether the first field is `null` therefore decides which of these it is.    (maybe a smart enough compiler would be able to this optimization for us.)  ```zig const future = struct {     prev_or_null: ?*anyopaque,     next_or_state: ?*anyopaque, }  // a future which is _queued_ has: //   prev_or_null = pointer to prev future //   next_or_state = pointer to next future  // a future which is _executing_ has: //   prev_or_null = null //   next_or_state = executestate  const executestate = struct {     requester: *worker,     done: std.thread.resetevent = .{},     result: resulttype,     // any number of fields. } ```  ### passing values around in registers  spice works with a `task` struct which has two fields: a pointer to the owning worker and a pointer to tail of the work queue. for optimal performance these should be passed as registers across all function boundaries. however, with llvm, passing a struct will very often cause it be passed on the stack.  to work around this we define a _separate_ function where `worker` and `job_tail` are actual parameters. we place the parameters into a struct and pass a pointer to this into the user-defined function. this function call we make sure is always being inlined:  ```zig fn callwithcontext(     worker: *worker,     job_tail: *job,     comptime t: type,     func: anytype,     arg: anytype, ) t {     var t = task{         .worker = worker,         .job_tail = job_tail,     };     return @call(.always_inline, func, .{         &t,         arg,     }); } ```  this causes the `callwithcontext`-function to be the _actual_ function which llvm works on, and since this has pointers are parameters it will happily pass these directly into registers.  ## benchmarks  the initial development of spice has been focused around a single benchmark which is described in detail in [bench/](bench/).  ## acknowledgments  spice was made possible thanks to the research into _heartbeat scheduling_:  ['the best multicore-parallelization refactoring you've never heard of'](https://arxiv.org/abs/2307.10556) gives an _excellent_ introduction into the concepts of heartbeat scheduling. it's a very short paper which focuses entirely on a single use case, but describes everything in a manner which can be generalized. the solution presented in this paper is based around turning all the code into continuation-passing style which enables switching between sequential and parallel execution. spice started out as an experiment of this approach, but this turned out to have quite high overhead (>10 nanosecond).  going backwards in time, ['heartbeat scheduling: provable efficiency for nested parallelism'](https://www.chargueraud.org/research/2018/heartbeat/heartbeat.pdf) was the first paper introducing 'heartbeat scheduling'. this paper provides excellent information about the concepts, but the implementation is based around integrating this into an interpreter and focus is primarily on the theoretical guarantees as opposed to raw performance.  ['task parallel assembly language for uncompromising parallelism'](https://paragon.cs.northwestern.edu/papers/2021-pldi-tpal-rainey.pdf) is a follow-up paper which improves the performance by defining a custom assembly language and using os signaling for heartbeats. this is a fascinating line of research, but it's difficult to integrate into an existing language.  ## limitations  there's _many_ limitations of the current implementation of spice:  - **rough edges when you're using it wrong:** spice is quite peculiar about how it should be used (most notably about `fork` and `join`).   if you're using it wrong now then weird things could happen.   this should be improved by adding more compile-time checking, debug-mode assertions, or changing the overall api. - **lack of tests:** spice contains a lot of gnarly concurrent code, but has zero testing coverage.   this would have be improved before spice can be responsibly used for critical tasks. - **lack of support for arrays/slices:** probably _the_ most common use case for fine-grained parallelism is to do something for every element of an array/slice.   there should be native, efficient support for this use case. - **lack of documentation:** there's no good documentation of how to use it. - **lack of further benchmarks:** this has only been tested on a single small benchmark.   this benchmark _should_ be quite representative (see [bench/](bench/) for more details), but further benchmarks are needed to validate these findings. - **@panic-heavy:** spice is quite optimistic in its error handling and uses `@panic` extensively.   to be considered a proper zig library there needs to be way more consideration of how error cases are handled. - **lack of testing with releasesafe:**   `releasesafe` is an extremely nice feature of zig.   further benchmarking and testing is needed to understand how well spice can work here.  luckily the whole codebase is ~500 lines so it shouldn't be _too_ difficult to make progress on these areas.  there's currently no plans of doing any active development on spice to improve this (as the original author don't have the time). any improvements in forks and/or re-implementations in other languages are highly encouraged!  ## faq  **question: why is it called 'spice'?**  answer: this project enables _fine-grained_ parallelism. sand is extremely fine-grained. sand forms in dunes. [spice](<https://en.wikipedia.org/wiki/melange_(fictional_drug)>). also: it's a hot take on parallelism.  **question: why is it implemented in zig?**  answer: why not? this describes a _generic approach_ to parallelism that should be possible to implement in multiple languages. maybe i'll end up implementing something similar in another language as well? i don't know yet. if you think this is interesting for _your_ language of choice i would encourage you to explore this area.  **question: but if you did it in rust we could have _safe_ parallelism?**  answer: yeah, that sounds very cool. i'm not at all opposed to it. _that said_, i've been exploring many different techniques and variants while developing spice. many of my initial ideas were definitely not 'safe' by any means, but i was able to express these ideas in zig, look at the assembly and measure the performance in benchmarks. i'd probably only be able to explore a fraction of the ideas if i was limited by rust's strict semantics in the _initial_ phase of this project. if i have to turn this into a production-ready system i might decide to use rust.  [hb]: https://www.andrew.cmu.edu/user/mrainey/heartbeat/heartbeat.html [rayon]: https://docs.rs/rayon/latest/rayon/ [wb]: https://en.wikipedia.org/wiki/work_stealing [fj]: https://en.wikipedia.org/wiki/fork%e2%80%93join_model [rust-vs-zig]: https://godbolt.org/#z:oylghafbqd5qcxaywpybmcmbrdblaf1qccaapecamzwbtma7aqwftmqbyarg9ktqyeaysib0qxacx8bbakobntaauahpwamvafytstjg1aavpmfjl6yanggvg6amkpaavxymjazlioamngmmaby7gbgmmqgagykaa6ocos2dm5uht7xickcaughlbfrszay1ilcbezebgnunlw%2bpeucldueeshhktewvtv1gy197z0frtealbaorsti7bxodaoeantbgjhrakreacjrq8su1rsa7abcoxoagmspawbuyibrenhsn/ep9fqebz2adeafsblc7a5rbiuwi0ujfr5ryhmbaaygg8hbpahgfwhf3rgpokumjrkgmi7uccwkhvehlvyblatd6fc7xo5ipevyjizaksghwkaohetd2nj%2b3pevdwnmwtcoir%2bbfzo3ojmqcdo6a1jn5gp2aczrldtbqrqpqznjuszxg5qqlskuca0ernrbahrnybdqacwtvegrta7vyzfychnkcqbrhprd9t8nsmvflvisyrs1iwmieikynqg8ogofa1gb6ktraaqbuaktwbaq22tlaatfrxawwpsigsimtzgqsqrkwb9ixmrbhlgqxtyghbdc2jop877djtwicacsve83f4qe4ac0zedzvnscavdxsacofpjtmanysacciq40x3xismaqhgvuweabysnie4cjir6akenc8aoiaae%2bchthasbigglbxhqktkjquh4fqutgaqjwmo%2bfb0aqkqorayqiaqysbnuacencpmxzdebxadyytaguz6prhbccajdc0fxl68fgysumajhilqkenqqwd5ky4jyvpedxuutwcixmcqgurj0dxvcbprmfapoebhmqnhofglguxgla2aqjnegeisypsma6catcbka8ntfqbjaaoabqecyaa7gjcsml5/ccciyjsfimiciokjqppujgvohgmgytlhchkdtkgcq2aigmdgjawaeqkpgtbkecfueke/kolg9vfhypx9vydboc49r6p4grdiuprcfksqtak81dbtoqmgm3rrotzrbw0aw7q0k1wgd/qdmt4xrsmf3pfdqyja9r0snmcg3gs336ae8h6wehbrkywatlr77yrghakagd6tlwz6vtmbzmfguqtz%2boeivu5zrbokhfsax77vunxgydsha45opiah6hraqwgicgwxw0qzaunqbhmgwwwyll4gfdl8hkgolhlzvrggccqzxajkqzxnr0gbvs35f9f57vtgyebvcsbskh2rcdjrtbd7qgxrsv9ud93a%2bbeglhdtsve9nrmxmf4/x9izhkc6xynsjh1ns2avpgdziq47d1gssaqm86vbwhlyokoyeh144erwxxjyensjumiqfnskgdzznwxhxhref8xm4posdzzuslidhadbbicxrrlnjgfjikesp2kdspi0fj5g6wsfzhqwusqa93oceyimskoms9dreiqbsbaibqlcjrrgvmaqpg/wz1gs%2b0cvgzqt3j9b48aavjve9rafr8nzoc%2bl9xsohxlcsspcbtlwdgayu1i34bhjsmss8yyzedjfax%2biy0w7hpoeugx56ace6q4jkv05glersafggepwa2nckl84fjtgs8f4fcxaudgg0nenh0fobwqisxbmfgmao1wwzcaofd6kuirzeibeojec4obdqaeacpwypqzi%2blekcv8no/iqkrlwf8hjrgbbpkyryopzsqk4qaufnpkqelhl4cmjyeyglhlmustztsdlfqsqii5nyfd9jer8ppfygulahtchfowlnypmhiklvk6vmqaxfilfk0hxbfslmvpqbg5ykwilvcajvk6tu4j2a0tuccdnoczcubwvdduiknuysabbsewpglafkxdx04nw40pa3z2y2qrw260tyrv9nrficzlm5e%2bi7e6vskju0unou6oyproywv7woeytp3r9mtf2fd2dgl3edirinodiliqqzaawuailuskdqsnbkixnf4e5ndop0obsky05wcbnekocc4ggewsgbttqrhdeicezmhcruyylukeuqzfzm0z%2bqyirsqqa%3d%3d%3d ","kristoff-it/superhtml":"HTML Language Server & Templating Language Library # superhtml html language server and templating language library   ## html language server the super cli tool offers **syntax checking** and **autoformatting** features for html files.  the tool can be used either directly (for example by running it on save), or through a lsp client implementation.  ``` $ superhtml usage: superhtml command [options]  commands:   check         check documents for syntax errors   interface, i  print a superhtml template's interface   fmt           format documents   lsp           start the super lsp   help          show this menu and exit   version       print super's version and exit  general options:   --help, -h   print command specific usage ```  >[!warning] >superhtml currently only supports utf8-encoded html and assumes html5 compliance (e.g. doesn't support xhtml, regardless of what you define the doctype to be).  ### diagnostics  ![](.github/vscode.png)  this language server is stricter than the html spec whenever it would prevent potential human errors from being reported.   as an example, html allows for closing some tags implicitly. for example the following snippet is correct html.  ```html <ul>   <li> one   <li> two </ul> ```  this will still be reported as an error by superhtml because otherwise the following snippet would have to be considered correct (while it's most probably a typo):  ```html <li>item<li> ```  ### autoformatting ![](.github/vscode-autoformat.gif)  the autoformatter has two main ways of interacting with it in order to request for horizontal / vertical alignment.  1. adding / removing whitespace between the **start tag** of an element and its content. 2. adding / removing whitespace between the **last attribute** of a start tag and the closing  `>`.   #### example of rule #1 before: ```html <div> <p>foo</p></div> ```  after: ```html <div>     <p>foo</p> </div> ```  ##### reverse  before: ```html <div><p>foo</p> </div> ```  after: ```html <div><p>foo</p></div> ```  #### example of rule #2 before: ```html <div foo='bar' style='verylongstring' >     foo </div> ```  after: ```html <div    foo='bar'    style='verylongstring' >     foo </div> ```  ##### reverse  before: ```html <div    foo='bar'    style='verylongstring'>     foo </div> ```  after: ```html <div foo='bar' style='verylongstring'>     foo </div> ```  ### editor support #### vscode install the [super html vscode extension](https://marketplace.visualstudio.com/items?itemname=loriscro.super).  #### neovim 1. download a prebuilt version of `superhtml` from the releases section (or build it yourself). 2. put `superhtml` in your `path`. 3. configure `superhtml` for your chosen lsp    - ##### [neovim built-in](https://neovim.io/doc/user/lsp.html#vim.lsp.start())      ```lua     vim.api.nvim_create_autocmd('filetype', {       pattern = { 'html', 'shtml', 'htm' },       callback = function()         vim.lsp.start({           name = 'superhtml',           cmd = { 'superhtml', 'lsp' },           root_dir = vim.fs.dirname(vim.fs.find({'.git'}, { upward = true })[1])         })       end     })     ```    - ##### [lspzero](https://github.com/vonheikemen/lsp-zero.nvim)      ```lua     local lsp = require('lsp-zero')      require('lspconfig.configs').superhtml = {         default_config = {             name = 'superhtml',             cmd = {'superhtml', 'lsp'},             filetypes = {'html', 'shtml', 'htm'},             root_dir = require('lspconfig.util').root_pattern('.git')         }     }      lsp.configure('superhtml', {force_setup = true})     ```  #### helix  in versions later than `24.07` `superhtml` is supported out of the box, simply add executable to your `path`.  for `24.07` and earlier, add to your `.config/helix/languages.toml`: ```toml [language-server.superhtml-lsp] command = 'superhtml' args = ['lsp']  [[language]] name = 'html' scope = 'source.html' roots = [] file-types = ['html'] language-servers = [ 'superhtml-lsp' ] ``` see https://helix-editor.com for more information on how to add new language servers.  #### [flow control](https://github.com/neurocyte/flow) already defaults to using superhtml, just add the executable to your `path`.  #### vim vim should be able to parse the errors that `superhtml check [path]`. this means that you can use `:make` and the quickfix window to check for syntax errors.  set the `makeprg` to the following in your .vimrc: ``` ' for any html file, a :make<cr> action will populate the quickfix menu autocmd filetype html setlocal makeprg=superhtml╲ check╲ % ' if you want to use gq{motion} to format sections or the whole buffer (with gggqg) autocmd filetype html setlocal formatprg=superhtml╲ fmt╲ --stdin ```  #### other editors follow your editor specific instructions on how to define a new language server for a given language / file format.  *(also feel free to contribute more specific instructions to this readme / add files under the `editors/` subdirectory).*  ## templating language library superhtml is also a html templating language. more on that soon.  ## contributing superhtml tracks the latest zig release (0.13.0 at the moment of writing).  ### contributing to the html parser & lsp contributing to the html parser and lsp doesn't require you to be familiar with the templating language, basically limiting the scope of what you have to worry about to:  - `src/cli.zig` - `src/cli/` - `src/html/`  in particular, you will care about `src/html/tokenizer.zig` and `src/html/ast.zig`.  you can run `zig test src/html/ast.zig` to run parser unit tests without needing to worry the rest of the project.  running `zig build` will compile the super cli tool, allowing you to also then test the lsp behavior directly from your favorite editor.  the lsp will log in your cache directory so you can `tail -f ~/.cache/super/super.log` to see what happens with the lsp. ","Not-Nik/raylib-zig":"Manually tweaked, auto-generated raylib bindings for zig. https://github.com/raysan5/raylib ![logo](https://github.com/not-nik/raylib-zig/raw/devel/logo/logo.png)  # raylib-zig  manually tweaked, auto-generated [raylib](https://github.com/raysan5/raylib) bindings for zig.  bindings tested on raylib version 5.5-dev and zig 0.13.0  thanks to all the [contributors](https://github.com/not-nik/raylib-zig/graphs/contributors) for their help with this binding.  ## example  ```zig const rl = @import('raylib');  pub fn main() anyerror!void {     // initialization     //--------------------------------------------------------------------------------------     const screenwidth = 800;     const screenheight = 450;      rl.initwindow(screenwidth, screenheight, 'raylib-zig [core] example - basic window');     defer rl.closewindow(); // close window and opengl context      rl.settargetfps(60); // set our game to run at 60 frames-per-second     //--------------------------------------------------------------------------------------      // main game loop     while (!rl.windowshouldclose()) { // detect window close button or esc key         // update         //----------------------------------------------------------------------------------         // todo: update your variables here         //----------------------------------------------------------------------------------          // draw         //----------------------------------------------------------------------------------         rl.begindrawing();         defer rl.enddrawing();          rl.clearbackground(rl.color.white);          rl.drawtext('congrats! you created your first window!', 190, 200, 20, rl.color.light_gray);         //----------------------------------------------------------------------------------     } } ```  ## building the examples  to build all available examples simply `zig build examples`. to list available examples run `zig build --help`. if you want to run an example, say `basic_window` run `zig build basic_window`  ## building and using  ### using raylib-zig's template  * execute `project_setup.sh project_name`, this will create a folder with the name specified * you can copy that folder anywhere you want and edit the source * run `zig build run` at any time to test your project  ### in an existing project (e.g. created with `zig init`)  download and add raylib-zig as a dependency by running the following command in your project root:  ``` zig fetch --save https://github.com/not-nik/raylib-zig/archive/devel.tar.gz ```  then add raylib-zig as a dependency and import its modules and artifact in your `build.zig`:  ```zig const raylib_dep = b.dependency('raylib-zig', .{     .target = target,     .optimize = optimize, });  const raylib = raylib_dep.module('raylib'); // main raylib module const raygui = raylib_dep.module('raygui'); // raygui module const raylib_artifact = raylib_dep.artifact('raylib'); // raylib c library ```  now add the modules and artifact to your target as you would normally:  ```zig exe.linklibrary(raylib_artifact); exe.root_module.addimport('raylib', raylib); exe.root_module.addimport('raygui', raygui); ```  if you additionally want to support web as a platform with emscripten, you will need to use `emcc.zig` by importing raylib-zig's build script with `const rlz = @import('raylib-zig');` and then accessing its functions with `rlz.emcc`. refer to raylib-zig's project template on how to use them.  ### passing build options  raylib allows customisations of certain parts of its build process such as choosing an opengl version, building as a shared library or not including certain modules. you can optionally pass these options to raylib-zig dependency like so  ```zig const raylib_dep = b.dependency('raylib-zig', .{     .target = target,     .optimize = optimize,     .shared = true, // build raylib as a shared library     .opengl_version = rlz.openglversion.gl_2_1, // use opengl 2.1 (requires importing raylib-zig's build script) }); ```  ### defining feature macros  raylib lets the user enable and disable options for different features, loading different file formats for images, fonts, 3d models and audio, linkage variants. you can specify these options for your raylib-zig build by defining the corresponding c macro before you link with it, e.g.:  ```zig raylib_artifact.definecmacro('support_fileformat_jpg', null); ```  ## exporting for web  to export your project for the web, first install emsdk. once emsdk is installed, set it up by running  `emsdk install latest`  find the folder where it's installed and run  `zig build -dtarget=wasm32-emscripten --sysroot [path to emsdk]/upstream/emscripten`  once that is finished, the exported project should be located at `zig-out/htmlout`  ### when is the binding updated?  i plan on updating it every mayor release (2.5, 3.0, etc.). keep in mind these are technically header files, so any implementation stuff should be updatable with some hacks on your side.  ### what needs to be done?  + _(done)_ set up a proper package build and a build script for the examples + port all the examples + member functions/initialisers ","kristoff-it/zine":"Fast, Scalable, Flexible Static Site Generator (SSG) <h1 align='center'>zine</h1> <h3 align='center'><em>fast, scalable, flexible static site generator (ssg)</em></h3> <p align='center'>zine is pronounced like in <a href='https://en.wikipedia.org/wiki/zine'>fan<em>zine</em></a></a>.</p>  ## development status alpha stage, it's strongly recommended to first try zine out on a small project to get a feeling of the limits of the current implementation.  ## getting started  go to https://zine-ssg.io to get started.   ## development  it is recommended to develop zine against a site project (eg [kristoff-it/zine-ssg.io](https://github.com/kristoff-it/zine-ssg.io) by running `zig build` on the project and setting the zine dependency to a local checkout in `build.zig.zon`:  `zine-ssg.io/build.zig.zon` ```zig .{     .name = 'zine sample site',     .version = '0.0.0',     .dependencies = .{         .zine = .{             .path = '../zine',         },     },     .paths = .{'.'}, } ```  two flags that are going to help you develop zine:  ### `-ddebug` builds zine in debug mode, which means faster rebuilds and enabling debug logging.   ### `-dlog=foo` enables logging only for the specified scope. can be passed multiple times to enable more than one scope.  see at the top of each component what is the scope name in a declaration that looks like this:  `zine/server/main.zig` ```zig const log = std.log.scoped(.server); ```  `super/src/sitter.zig` ```zig const log = std.log.scoped(.sitter); ``` ","karlseguin/http.zig":"An HTTP/1.1 server for zig 404: not found","jetzig-framework/jetzig":"Jetzig is a web framework written in Zig [![ci](https://github.com/jetzig-framework/jetzig/actions/workflows/ci.yml/badge.svg)](https://github.com/jetzig-framework/jetzig/actions/workflows/ci.yml)  ![jetzig logo](demo/public/jetzig.png)  _jetzig_ is a web framework written in 100% pure [zig](https://ziglang.org) :lizard: for _linux_, _os x_, _windows_, and any _os_ that can compile _zig_ code.  official website: [jetzig.dev](https://www.jetzig.dev/)  _jetzig_ aims to provide a rich set of user-friendly tools for building modern web applications quickly. see the checklist below.  join us on discord ! [https://discord.gg/eufqssz7x6](https://discord.gg/eufqssz7x6).  if you are interested in _jetzig_ you will probably find these tools interesting too:  * [zap](https://github.com/zigzap/zap) * [http.zig](https://github.com/karlseguin/http.zig) (_jetzig_'s backend) * [tokamak](https://github.com/cztomsik/tokamak) * [zig-router](https://github.com/cloudef/zig-router) * [zig-webui](https://github.com/webui-dev/zig-webui/) * [zts](https://github.com/zigster64/zts) * [zine](https://github.com/kristoff-it/zine) * [zinc](https://github.com/zon-dev/zinc/)  ## checklist  * :white_check_mark: file system-based routing with [slug] matching. * :white_check_mark: _html_ and _json_ response (inferred from extension and/or `accept` header). * :white_check_mark: _json_-compatible response data builder. * :white_check_mark: _html_ templating (see [zmpl](https://github.com/jetzig-framework/zmpl)). * :white_check_mark: per-request arena allocator. * :white_check_mark: sessions. * :white_check_mark: cookies. * :white_check_mark: error handling. * :white_check_mark: static content from /public directory. * :white_check_mark: request/response headers. * :white_check_mark: stack trace output on error. * :white_check_mark: static content generation. * :white_check_mark: param/json payload parsing/abstracting. * :white_check_mark: static content parameter definitions. * :white_check_mark: middleware interface. * :white_check_mark: mime type inference. * :white_check_mark: email delivery. * :white_check_mark: background jobs. * :white_check_mark: general-purpose cache. * :white_check_mark: development server auto-reload. * :white_check_mark: testing helpers for testing http requests/responses. * :white_check_mark: custom/non-conventional routes. * :white_check_mark: database integration. * :x: environment configurations (development/production/etc.) * :x: email receipt (via sendgrid/aws ses/etc.)  ## license  [mit](license)  ## contributors  * [zackary housend](https://github.com/z1fire) * [andreas stührk](https://github.com/trundle) * [bob farrell](https://github.com/bobf) ","orhun/linuxwave":"Generate music from the entropy of Linux 🐧🎵 # `linuxwave` 🐧🎵  <p align='center'>  <img src='https://github.com/orhun/linuxwave/blob/main/assets/demo.gif' alt='demo'> <a href='https://github.com/orhun/linuxwave/releases'><img src='https://img.shields.io/github/v/release/orhun/linuxwave?style=flat&amp;labelcolor=1d1d1d&amp;color=424242&amp;logo=github&amp;logocolor=white' alt='github release'></a> <a href='https://codecov.io/gh/orhun/linuxwave'><img src='https://img.shields.io/codecov/c/gh/orhun/linuxwave?style=flat&amp;labelcolor=1d1d1d&amp;color=424242&amp;logo=codecov&amp;logocolor=white' alt='coverage'></a> <a href='https://github.com/orhun/linuxwave/actions?query=workflow%3a%22continuous+integration%22'><img src='https://img.shields.io/github/actions/workflow/status/orhun/linuxwave/ci.yml?branch=main&amp;style=flat&amp;labelcolor=1d1d1d&amp;color=424242&amp;logo=github%20actions&amp;logocolor=white' alt='continuous integration'></a> <a href='https://github.com/orhun/linuxwave/actions?query=workflow%3a%22continuous+deployment%22'><img src='https://img.shields.io/github/actions/workflow/status/orhun/linuxwave/cd.yml?style=flat&amp;labelcolor=1d1d1d&amp;color=424242&amp;logo=github%20actions&amp;logocolor=white&amp;label=deploy' alt='continuous deployment'></a> <a href='https://hub.docker.com/r/orhunp/gpg-tui'><img src='https://img.shields.io/github/actions/workflow/status/orhun/linuxwave/docker.yml?style=flat&amp;labelcolor=1d1d1d&amp;color=424242&amp;label=docker&amp;logo=docker&amp;logocolor=white' alt='docker builds'></a> <a href='https://orhun.dev/linuxwave/docs/'><img src='https://img.shields.io/github/actions/workflow/status/orhun/linuxwave/pages.yml?style=flat&amp;labelcolor=1d1d1d&amp;color=424242&amp;logo=zig&amp;logocolor=white&amp;label=docs' alt='documentation'></a>  <p align='center'> <a href='https://www.youtube.com/watch?v=slieuvdmo8m'><strong>click here to watch the demo!</strong></a><br> <a href='https://open.spotify.com/track/0chxcdjs6wknl8iu71k7yp'>listen to 'linuxwave' on spotify!</a> </p>  </p>  <details>   <summary>table of contents</summary>  <!-- vim-markdown-toc gfm -->  - [motivation ✨](#motivation-) - [installation 🤖](#installation-)   - [build from source](#build-from-source)     - [prerequisites](#prerequisites)     - [instructions](#instructions)   - [binary releases](#binary-releases)   - [arch linux](#arch-linux)   - [void linux](#void-linux)   - [docker](#docker)     - [images](#images)     - [usage](#usage)     - [building](#building) - [examples 🎵](#examples-) - [presets 🎹](#presets-) - [usage 📚](#usage-)   - [`scale`](#scale)   - [`note`](#note)   - [`rate`](#rate)   - [`channels`](#channels)   - [`format`](#format)   - [`volume`](#volume)   - [`duration`](#duration)   - [`input`](#input)   - [`output`](#output) - [funding 💖](#funding-) - [contributing 🌱](#contributing-) - [license ⚖️](#license-) - [copyright ⛓️](#copyright-)  <!-- vim-markdown-toc -->  </details>  ## motivation ✨  - [bash one liner - compose music from entropy in /dev/urandom](https://web.archive.org/web/20230122184930/https://blog.robertelder.org/bash-one-liner-compose-music/)   - ['music' from /dev/urandom](https://news.ycombinator.com/item?id=11238247)  ## installation 🤖  ### build from source  #### prerequisites  - [zig](https://ziglang.org/download/) (`0.12` or `0.13`)  #### instructions  1. clone the repository.  ```sh git clone https://github.com/orhun/linuxwave && cd linuxwave/ ```  2. build.  ```sh zig build --release=safe ```  binary will be located at `zig-out/bin/linuxwave`. you can also run the binary directly via `zig build run`.  if you want to use `linuxwave` in your zig project as a package, the api documentation is available [here](https://orhun.dev/linuxwave/docs).  ### binary releases  see the available binaries for different targets from the [releases page](https://github.com/orhun/linuxwave/releases). they are automated via [continuous deployment](.github/workflows/cd.yml) workflow.  release tarballs are signed with the following pgp key: [0xc0701e98290d90b8](https://keyserver.ubuntu.com/pks/lookup?search=0xc0701e98290d90b8&op=vindex)  ### arch linux  `linuxwave` can be installed from the [community repository](https://archlinux.org/packages/community/x86_64/linuxwave/) using [pacman](https://wiki.archlinux.org/title/pacman):  ```sh pacman -s linuxwave ```  ### void linux  `linuxwave` can be installed from official void linux package repository:  ```sh xbps-install linuxwave ```  ### docker  #### images  docker builds are [automated](./.github/workflows/docker.yml) and images are available in the following registries:  - [docker hub](https://hub.docker.com/r/orhunp/linuxwave) - [github container registry](https://github.com/orhun/linuxwave/pkgs/container/linuxwave)  #### usage  the following command can be used to generate `output.wav` in the current working directory:  ```sh docker run --rm -v '$(pwd)':/app 'orhunp/linuxwave:${tag:-latest}' ```  #### building  custom docker images can be built from the [dockerfile](./dockerfile):  ```sh docker build -t linuxwave . ```  ## examples 🎵  **default**: read random data from `/dev/urandom` to generate a 20-second music composition in the a4 scale and save it to `output.wav`:  ```sh linuxwave ```  or play it directly with [mpv](https://mpv.io/) without saving:  ```sh linuxwave -o - | mpv - ```  to use the a minor blues scale:  ```sh linuxwave -s 0,3,5,6,7,10 -n 220 -o blues.wav ```  read from an arbitrary file and turn it into a 10-second music composition in the c major scale:  ```sh linuxwave -i build.zig -n 261.63 -d 10 -o music.wav ```  read from stdin via giving `-` as input:  ```sh cat readme.md | linuxwave -i - ```  write to stdout via giving `-` as output:  ``` linuxwave -o - > output.wav ```  ## presets 🎹  generate a **calming music** with a sample rate of 2000 hz and a 32-bit little-endian signed integer format:  ```sh linuxwave -r 2000 -f s32_le -o calm.wav ```  generate a **chiptune music** with a sample rate of 44100 hz, stereo (2-channel) output and 8-bit unsigned integer format:  ```sh linuxwave -r 44100 -f u8 -c 2 -o chiptune.wav ```  generate a **boss stage music** with the volume of 65:  ```sh linuxwave -s 0,7,1 -n 60 -v 65 -o boss.wav ```  generate a **spooky low-fidelity music** with a sample rate of 1000 hz, 4-channel output:  ```sh linuxwave -s 0,1,5,3 -n 100 -r 1000 -v 55 -c 4 -o spooky_manor.wav ```  feel free to [submit a pull request](contributing.md) to show off your preset here!  also, see [this discussion](https://github.com/orhun/linuxwave/discussions/1) for browsing the music generated by our community.  ## usage 📚  ``` options:   -s, --scale <scale>            sets the musical scale [default: 0,2,3,5,7,8,10,12]   -n, --note <hz>                sets the frequency of the note [default: 440 (a4)]   -r, --rate <hz>                sets the sample rate [default: 24000]   -c, --channels <num>           sets the number of channels [default: 1]   -f, --format <format>          sets the sample format [default: s16_le]   -v, --volume <vol>             sets the volume (0-100) [default: 50]   -d, --duration <secs>          sets the duration [default: 20]   -i, --input <file>             sets the input file [default: /dev/urandom]   -o, --output <file>            sets the output file [default: output.wav]   -v, --version                  display version information.   -h, --help                     display this help and exit. ```  ### `scale`  sets the musical scale for the output. it takes a list of [semitones](https://en.wikipedia.org/wiki/semitone) separated by commas as its argument.  the default value is `0,2,3,5,7,8,10,12`, which represents a major scale starting from c.  here are other examples:  - a natural minor scale: `0,2,3,5,7,8,10` - a pentatonic scale starting from g: `7,9,10,12,14` - a blues scale starting from d: `2,3,4,6,7,10` - an octatonic scale starting from f#: `6,7,9,10,12,13,15,16` - ryukyuan (okinawa) japanese scale: `4,5,7,11`  ### `note`  the `note` option sets the frequency of the note played. it takes a frequency in hz as its argument.  the default value is `440`, which represents a4. you can see the frequencies of musical notes [here](https://pages.mtu.edu/~suits/notefreqs.html).  other examples would be:  - a3 (220 hz) - c4 (261.63 hz) - g4 (392 hz) - a4 (440 hz) (default) - e5 (659.26 hz)  ### `rate`  sets the sample rate for the output in hertz (hz).  the default value is `24000`.  ### `channels`  sets the number of audio channels in the output file. it takes an integer as its argument, representing the number of audio channels to generate. the default value is `1`, indicating mono audio.  for stereo audio, set the value to `2`. for multi-channel audio, specify the desired number of channels.  note that the more audio channels you use, the larger the resulting file size will be.  ### `format`  sets the sample format for the output file. it takes a string representation of the format as its argument.  the default value is `s16_le`, which represents 16-bit little-endian signed integer.  possible values are:  - `u8`: unsigned 8-bit. - `s16_le`: signed 16-bit little-endian. - `s24_le`: signed 24-bit little-endian. - `s32_le`: signed 32-bit little-endian.  ### `volume`  sets the volume of the output file as a percentage from 0 to 100.  the default value is `50`.  ### `duration`  sets the duration of the output file in seconds. it takes a float as its argument.  the default value is `20` seconds.  ### `input`  sets the input file for the music generation. it takes a filename as its argument.  the default value is `/dev/urandom`, which generates random data.  you can provide _any_ type of file for this argument and it will generate music based on the contents of that file.  ### `output`  sets the output file. it takes a filename as its argument.  the default value is `output.wav`.  ## funding 💖  if you find `linuxwave` and/or other projects on my [github profile](https://github.com/orhun) useful, consider supporting me on [github sponsors](https://github.com/sponsors/orhun) or [becoming a patron](https://www.patreon.com/join/orhunp)!  [![support me on github sponsors](https://img.shields.io/github/sponsors/orhun?style=flat&logo=github&labelcolor=424242&color=1d1d1d&logocolor=white)](https://github.com/sponsors/orhun) [![support me on patreon](https://img.shields.io/endpoint.svg?url=https%3a%2f%2fshieldsio-patreon.vercel.app%2fapi%3fusername%3dorhunp%26type%3dpatrons&style=flat&logo=patreon&labelcolor=424242&color=1d1d1d&logocolor=white)](https://patreon.com/join/orhunp) [![support me on patreon](https://img.shields.io/endpoint.svg?url=https%3a%2f%2fshieldsio-patreon.vercel.app%2fapi%3fusername%3dorhunp%26type%3dpledges&style=flat&logo=patreon&labelcolor=424242&color=1d1d1d&logocolor=white&label=)](https://patreon.com/join/orhunp)  ## contributing 🌱  see our [contribution guide](./contributing.md) and please follow the [code of conduct](./code_of_conduct.md) in all your interactions with the project.  ## license ⚖️  licensed under [the mit license](./license).  ## copyright ⛓️  copyright © 2023-2024, [orhun parmaksız](mailto:orhunparmaksiz@gmail.com) ","rockorager/libvaxis":"a modern tui library written in zig # libvaxis  ``` it begins with them, but ends with me. their son, vaxis ```  ![vaxis demo gif](vaxis.gif)  libvaxis _does not use terminfo_. support for vt features is detected through terminal queries.  contributions are welcome.  vaxis uses zig `0.13.0`.  ## features  libvaxis supports all major platforms: macos, windows, linux/bsd/and other unix-likes.  | feature                        |  libvaxis  | | ------------------------------ |  :------:  | | rgb                            |     ✅     | | hyperlinks                     |     ✅     | | bracketed paste                |     ✅     | | kitty keyboard                 |     ✅     | | styled underlines              |     ✅     | | mouse shapes (osc 22)          |     ✅     | | system clipboard (osc 52)      |     ✅     | | system notifications (osc 9)   |     ✅     | | system notifications (osc 777) |     ✅     | | synchronized output (dec 2026) |     ✅     | | unicode core (dec 2027)        |     ✅     | | color mode updates (dec 2031)  |     ✅     | | [in-band resize reports](https://gist.github.com/rockorager/e695fb2924d36b2bcf1fff4a3704bd83)   |     ✅     | | images (kitty)                 |     ✅     |  ## usage  [documentation](https://rockorager.github.io/libvaxis/#vaxis.vaxis)  [starter repo](https://github.com/rockorager/libvaxis-starter)  vaxis requires three basic primitives to operate:  1. a tty instance 2. an instance of vaxis 3. an event loop  the library provides a general purpose posix tty implementation, as well as a multi-threaded event loop implementation. users of the library are encouraged to use the event loop of their choice. the event loop is responsible for reading the tty, passing the read bytes to the vaxis parser, and handling events.  a core feature of vaxis is it's ability to detect features via terminal queries instead of relying on a terminfo database. this requires that the event loop also handle these query responses and update the vaxis.caps struct accordingly. see the `loop` implementation to see how this is done if writing your own event loop.  ## example  ```zig const std = @import('std'); const vaxis = @import('vaxis'); const cell = vaxis.cell; const textinput = vaxis.widgets.textinput; const border = vaxis.widgets.border;  // this can contain internal events as well as vaxis events. // internal events can be posted into the same queue as vaxis events to allow // for a single event loop with exhaustive switching. booya const event = union(enum) {     key_press: vaxis.key,     winsize: vaxis.winsize,     focus_in,     foo: u8, };  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer {         const deinit_status = gpa.deinit();         //fail test; can't try in defer as defer is executed after we return         if (deinit_status == .leak) {             std.log.err('memory leak', .{});         }     }     const alloc = gpa.allocator();      // initialize a tty     var tty = try vaxis.tty.init();     defer tty.deinit();      // initialize vaxis     var vx = try vaxis.init(alloc, .{});     // deinit takes an optional allocator. if your program is exiting, you can     // choose to pass a null allocator to save some exit time.     defer vx.deinit(alloc, tty.anywriter());       // the event loop requires an intrusive init. we create an instance with     // stable pointers to vaxis and our tty, then init the instance. doing so     // installs a signal handler for sigwinch on posix ttys     //     // this event loop is thread safe. it reads the tty in a separate thread     var loop: vaxis.loop(event) = .{       .tty = &tty,       .vaxis = &vx,     };     try loop.init();      // start the read loop. this puts the terminal in raw mode and begins     // reading user input     try loop.start();     defer loop.stop();      // optionally enter the alternate screen     try vx.enteraltscreen(tty.anywriter());      // we'll adjust the color index every keypress for the border     var color_idx: u8 = 0;      // init our text input widget. the text input widget needs an allocator to     // store the contents of the input     var text_input = textinput.init(alloc, &vx.unicode);     defer text_input.deinit();      // sends queries to terminal to detect certain features. this should always     // be called after entering the alt screen, if you are using the alt screen     try vx.queryterminal(tty.anywriter(), 1 * std.time.ns_per_s);      while (true) {         // nextevent blocks until an event is in the queue         const event = loop.nextevent();         // exhaustive switching ftw. vaxis will send events if your event enum         // has the fields for those events (ie 'key_press', 'winsize')         switch (event) {             .key_press => |key| {                 color_idx = switch (color_idx) {                     255 => 0,                     else => color_idx + 1,                 };                 if (key.matches('c', .{ .ctrl = true })) {                     break;                 } else if (key.matches('l', .{ .ctrl = true })) {                     vx.queuerefresh();                 } else {                     try text_input.update(.{ .key_press = key });                 }             },              // winsize events are sent to the application to ensure that all             // resizes occur in the main thread. this lets us avoid expensive             // locks on the screen. all applications must handle this event             // unless they aren't using a screen (ie only detecting features)             //             // the allocations are because we keep a copy of each cell to             // optimize renders. when resize is called, we allocated two slices:             // one for the screen, and one for our buffered screen. each cell in             // the buffered screen contains an arraylist(u8) to be able to store             // the grapheme for that cell. each cell is initialized with a size             // of 1, which is sufficient for all of ascii. anything requiring             // more than one byte will incur an allocation on the first render             // after it is drawn. thereafter, it will not allocate unless the             // screen is resized             .winsize => |ws| try vx.resize(alloc, tty.anywriter(), ws),             else => {},         }          // vx.window() returns the root window. this window is the size of the         // terminal and can spawn child windows as logical areas. child windows         // cannot draw outside of their bounds         const win = vx.window();          // clear the entire space because we are drawing in immediate mode.         // vaxis double buffers the screen. this new frame will be compared to         // the old and only updated cells will be drawn         win.clear();          // create a style         const style: vaxis.style = .{             .fg = .{ .index = color_idx },         };          // create a bordered child window         const child = win.child(.{             .x_off = win.width / 2 - 20,             .y_off = win.height / 2 - 3,             .width = 40 ,             .height = 3 ,             .border = .{                 .where = .all,                 .style = style,             },         });          // draw the text_input in the child window         text_input.draw(child);          // render the screen. using a buffered writer will offer much better   // performance, but is not required         try vx.render(tty.anywriter());     } } ```  ## contributing  contributions are welcome. please submit a pr on github or a patch on the [mailing list](mailto:~rockorager/libvaxis@lists.sr.ht)  ","ikskuh/zig-network":"A smallest-common-subset of socket functions for crossplatform networking, TCP & UDP # zig network abstraction  small network abstraction layer around tcp & udp.  ## features - implements the minimal api surface for basic networking - makes cross-platform abstractions - supports blocking and non-blocking i/o via `select`/`poll` - udp multicast support  ## usage  ### use with the package manager  `build.zig.zon`: ```zig .{     .name = 'appname',     .version = '0.0.0',     .dependencies = .{         .network = .{             .url = 'https://github.com/masterq32/zig-network/archive/<commit_hash_here>.tar.gz',             .hash = 'hash_goes_here',         },     }, } ``` (to aquire the hash, please remove the line containing `.hash`, the compiler will then tell you which line to put back)  `build.zig`: ```zig exe.addmodule('network', b.dependency('network', .{}).module('network')); ```  ### usage example  ```zig const network = @import('network');  test 'connect to an echo server' {     try network.init();     defer network.deinit();      const sock = try network.connecttohost(std.heap.page_allocator, 'tcpbin.com', 4242, .tcp);     defer sock.close();      const msg = 'hi from socket!╲n';     try sock.writer().writeall(msg);      var buf: [128]u8 = undefined;     std.debug.print('echo: {}', .{buf[0..try sock.reader().readall(buf[0..msg.len])]}); } ```  see [async.zig](examples/async.zig) for a more complete example on how to use asynchronous i/o to make a small tcp server.  ## run examples  build all examples:  ```bash $ zig build examples ```  build a specific example:  ```bash $ zig build sync-examples ```  to test an example, eg. `echo`:  ```bash $ ./zig-out/bin/echo 3000 ```   in another terminal  ```bash $ nc localhost 3000 hello hello how are you how are you ```  ## notes on windows receive and send function calls are asynchronous and cooperate with the standard library event loop when `io_mode = .evented` is set in the root file of your program.   other calls (connect, listen, accept etc) are blocking.   ","natecraddock/zf":"a commandline fuzzy finder and zig module designed for filtering filepaths # zf  [![shield showing current tests status](https://github.com/natecraddock/zf/actions/workflows/tests.yml/badge.svg)](https://github.com/natecraddock/zf/actions/workflows/tests.yml) [![packaging status](https://repology.org/badge/tiny-repos/zf.svg)](https://repology.org/project/zf/versions)  zf is an interactive commandline fuzzy finder that prioritizes matches on filenames. zf accepts newline separated strings on `stdin` and outputs the selected line on `stdout`. use with a pipe, or io redirection. see the [documentation](https://github.com/natecraddock/zf/blob/master/doc/zf.md) for more details. zf is also packaged as an allocation-free library for fuzzy filtering.  https://user-images.githubusercontent.com/7967463/225198950-a6ab568f-644f-40a1-b202-c12a35aeaed8.mp4  ## features  * designed for fuzzy matching file paths (but also works as a general purpose fuzzy finder) * refine search results with whitespace separated query terms * case insensitive unless the query contains uppercase letters (smartcase) * multiselect to output multiple selected lines * zig and c libraries for the zf ranking algorithm  zf aims to be simple: * no full-window interface * minimal config and options * sensible defaults  ## docs  * [usage documentation](https://github.com/natecraddock/zf/blob/master/doc/zf.md) * [library documentation](https://github.com/natecraddock/zf/blob/master/doc/lib.md)  ## why use zf?  zf was designed knowing that a frequent use case for fuzzy finders is filtering filepaths. it also works great for any arbitrary string, but it is especially good at filtering filepaths with precision.  specifically,  * matches on filenames are prioritized over filepath matches * matches on the beginning of a word are prioritized over matches in the middle of a word * non-sequential character matches are penalized * strict path matching offers even more precision  here are some concrete examples.  ### filename priority  the query is matched first on the filename and then on the path if the filename doesn't match. this example comes from blender's source code, and was my original inspiration for designing zf.  ```text > make ./gnumakefile ./source/blender/makesdna/dna_genfile.h ./source/blender/makesdna/intern/dna_genfile.c ./source/blender/makesrna/intern/rna_cachefile.c ./source/blender/makesdna/dna_curveprofile_types.h ```  fzf and fzy both rank `source/blender/makesdna/dna_genfile.h` first in the results, with `gnumakefile` 10 items down the list.  ### space-separated tokens  but not every filename is unique. sometimes there are codebases where there are many files with the same or similar names, like an `__init__.py` in python, or `.c` and `.h` file pairs in c. in zf each space separated query term is used to narrow down the results. imagine searching for an `__init__.py` file in a python project.  ```text > init ./__init__.py ./ui/__init__.py ./data/__init__.py ./config/__init__.py ```  at this point you can either move the selection down with <kdb>down</kbd> or `c-n` to find `./config/__init__.py`, or you can add a new token to the query string.  ```text > init c ./config/__init__.py ```  treating the query string as a sequence of tokens makes filtering more efficient.  ### strict path matching  this feature is a 'do what i mean' feature, more easily used than explained. when the query looks like a path (contains at least one path separator) strict path matching is enabled.  path segments are the portions of a path delimited by path separators. `foo/bar` has segments `foo` and `bar`. with strict path matching the path segments of the query token must not span across path segments in the candidate. as an example, the query `foo/` would match `foo/bar/` but not `fo/obar/` because the characters `'foo'` must appear in a single path segment.  this is useful for narrowing down results when you know the exact path structure of your files. with the following paths  ``` ./app/models/foo/bar/baz.rb ./app/models/foo/bar-baz.rb ./app/models/foo-bar-baz.rb ./app/monsters/dungeon/foo/bar/baz.rb ```  strict path matching ensures that the intended path structure is found.  ``` > a/m/f/b/baz ./app/models/foo/bar/baz.rb ```  in other fuzzy finders the string `app/monsters/dungeon/foo/bar/baz.rb` is also included in the results. strict path matching prevents this because there is a slash between `onsters/dungeon` and nothing in the query matches the `dungeon` segment.  to end strict path matching, just add a space to start a new query token.  ## installation  ### arch linux  an [aur package](https://aur.archlinux.org/packages/zf/) is available.  ### macos  install with homebrew  ``` brew install zf ```  ### nix  ``` nix-env --install zf ```  ### binaries  each [release](https://github.com/natecraddock/zf/releases/latest) has binaries attached for macos and linux.  ### building from source  for compatibility with system package managers, zf targets the latest stable release of zig. the [`unstable`](https://github.com/natecraddock/zf/tree/unstable) branch is kept up to date with zig master.  ``` git clone https://github.com/natecraddock/zf cd zf zig build -doptimize=releasesafe --summary all ```  the executable will be created in `./zig-out/bin/zf`. for debug builds omit `-doptimize=releasesafe`.  ## integrations  would you like to use zf in an editor? try one of the following plugins  * [zf.vim](https://github.com/ratfactor/zf.vim): zf integrated with vim for   fuzzy file finding. similar to fzf.vim. * [telescope-zf-native.nvim](https://github.com/natecraddock/telescope-zf-native.nvim)   a neovim [telescope](https://github.com/nvim-telescope/telescope.nvim)   extension to override the default lua sorter with zf.  ## contributing  i am open to contributions of all kinds, but be aware that i want to keep zf small and easy to maintain. ","Hejsil/mecha":"A parser combinator library for Zig # mecha  a parser combinator library for the [`zig`](https://ziglang.org/) programming language. time to make your own parser mech! ![mech](https://thumbs.gfycat.com/grippingelatedazurevasesponge-size_restricted.gif)  ```zig const mecha = @import('mecha'); const std = @import('std');  const rgb = struct {     r: u8,     g: u8,     b: u8, };  fn tobyte(v: u4) u8 {     return @as(u8, v) * 0x10 + v; }  const hex1 = mecha.int(u4, .{     .parse_sign = false,     .base = 16,     .max_digits = 1, }).map(tobyte); const hex2 = mecha.int(u8, .{     .parse_sign = false,     .base = 16,     .max_digits = 2, }); const rgb1 = mecha.manyn(hex1, 3, .{}).map(mecha.tostruct(rgb)); const rgb2 = mecha.manyn(hex2, 3, .{}).map(mecha.tostruct(rgb)); const rgb = mecha.combine(.{     mecha.ascii.char('#').discard(),     mecha.oneof(.{ rgb2, rgb1 }), });  test 'rgb' {     const testing = std.testing;     const allocator = testing.allocator;     const a = (try rgb.parse(allocator, '#aabbcc')).ok.value;     try testing.expectequal(@as(u8, 0xaa), a.r);     try testing.expectequal(@as(u8, 0xbb), a.g);     try testing.expectequal(@as(u8, 0xcc), a.b);      const b = (try rgb.parse(allocator, '#abc')).ok.value;     try testing.expectequal(@as(u8, 0xaa), b.r);     try testing.expectequal(@as(u8, 0xbb), b.g);     try testing.expectequal(@as(u8, 0xcc), b.b);      const c = (try rgb.parse(allocator, '#000000')).ok.value;     try testing.expectequal(@as(u8, 0), c.r);     try testing.expectequal(@as(u8, 0), c.g);     try testing.expectequal(@as(u8, 0), c.b);      const d = (try rgb.parse(allocator, '#000')).ok.value;     try testing.expectequal(@as(u8, 0), d.r);     try testing.expectequal(@as(u8, 0), d.g);     try testing.expectequal(@as(u8, 0), d.b); }  ```  ","zigimg/zigimg":"Zig library for reading and writing different image formats # zig image library    this is a work in progress library to create, process, read and write different image formats with [zig](https://ziglang.org/) programming language.    ![license](https://img.shields.io/github/license/zigimg/zigimg) ![issue](https://img.shields.io/github/issues-raw/zigimg/zigimg?style=flat) ![commit](https://img.shields.io/github/last-commit/zigimg/zigimg) ![ci](https://github.com/zigimg/zigimg/workflows/ci/badge.svg)    [![join our discord!](https://discordapp.com/api/guilds/1161009516771549374/widget.png?style=banner2)](https://discord.gg/tygeeuegnk)    ## install & build    this library uses zig nominated [2024.10.0-mach](https://machengine.org/about/nominated-zig/). to install using [`zigup`](https://github.com/marler8997/zigup):    ```sh  zigup 0.14.0-dev.1911+3bf89f55c  ```    ### use zigimg in your project    how to add to your project:    #### as a submodule    1. clone this repository or add as a submodule  1. add to your `build.zig`  ```  exe.addanonymousmodule('zigimg', .{.source_file = .{ .path = 'zigimg.zig' }});  ```    #### through the package manager    1. run this command in your project folder to add `zigimg` to your `build.zig.zon`    ```sh  zig fetch --save 'https://github.com/zigimg/zigimg/archive/$replace_with_wanted_commit.tar.gz'  ```    2. get the module in your `build.zig` file    ```zig  const zigimg_dependency = b.dependency('zigimg', .{      .target = target,      .optimize = optimize,  });    exe.root_module.addimport('zigimg', zigimg_dependency.module('zigimg'));  ```    after you are done setting up, you can look at the user guide below.    ## test suite    to run the test suite, checkout the [test suite](https://github.com/zigimg/test-suite) and run    1. checkout zigimg  1. go back one folder and checkout the [test suite](https://github.com/zigimg/test-suite)   1. run the tests with `zig build`  ```  zig build test  ```    ## supported image formats    | image format  | read          | write          |  | ------------- |:-------------:|:--------------:|  | anim          | ❌            | ❌            |  | bmp           | ✔️ (partial)  | ✔️ (partial)  |  | gif           | ✔️            | ❌            |  | ico           | ❌            | ❌            |  | iilbm         | ❌            | ❌            |  | jpeg          | ❌            | ❌            |  | pam           | ✔️            | ✔️            |  | pbm           | ✔️            | ✔️            |  | pcx           | ✔️            | ✔️            |  | pgm           | ✔️ (partial)  | ✔️ (partial)  |  | png           | ✔️            | ✔️ (partial)  |  | ppm           | ✔️ (partial)  | ✔️ (partial)  |  | qoi           | ✔️            | ✔️            |  | tga           | ✔️            | ✔️            |  | tiff          | ❌            | ❌            |  | xbm           | ❌            | ❌            |  | xpm           | ❌            | ❌            |    ### bmp - bitmap    * version 4 bmp  * version 5 bmp  * 24-bit rgb read & write  * 32-bit rgba read & write  * doesn't support any compression    ### gif - graphics interchange format    * support gif87a and gif89a  * support animated gif with netscape application extension for looping information  * supported interlaced  * supports tiled and layered images used to achieve pseudo true color and more.  * the plain text extension is not supported    ### pam - portable arbitrary map    currently, this only supports a subset of pams where:  * the tuple type is official (see `man 5 pam`) or easily inferred (and by extension, depth is 4 or less)  * all the images in a sequence have the same dimensions and maxval (it is technically possible to support animations with different maxvals and tuple types as each `animationframe` has its own `pixelstorage`, however, this is likely not expected by users of the library)  * grayscale,  * grayscale with alpha  * rgb555  * rgb24 and rgba32  * bgr24 and bgra32  * rgb48 and rgba64    ### pbm - portable bitmap format    * everything is supported    ### pcx - zsoft picture exchange format    * support monochrome, 4 color, 16 color and 256 color indexed images  * support 24-bit rgb images    ### pgm - portable graymap format    * support 8-bit and 16-bit grayscale images  * 16-bit ascii grayscale loading not tested    ### png - portable network graphics    * support all pixel formats supported by png (grayscale, grayscale+alpha, indexed, truecolor, truecolor with alpha) in 8-bit or 16-bit.  * support the mininal chunks in order to decode the image.  * not all images in png test suite is covered but should be good enough for now.    ### ppm - portable pixmap format    * support 24-bit rgb (8-bit per channel)  * missing 48-bit rgb (16-bit per channel)    ### qoi - quite ok image format    * imported from https://github.com/masterq32/zig-qoi with blessing of the author    ### tga - truevision tga format    * supports uncompressed and compressed 8-bit grayscale, indexed with 16-bit and 24-bit colormap, truecolor with 16-bit(rgb555), 24-bit or 32-bit bit depth.  * supports reading version 1 and version 2  * supports writing version 2    # user guide    ## design philosophy    zigimg offers color and image functionality. the library is designed around either using the convenient `image` (or `imageunmanaged`) struct that can read and write image formats no matter the format.    or you can also use the image format directly in case you want to extract more data from the image format. so if you find that `image` does not give you the information that you need from a png or other format, you can use the png format albeit with a more manual api that `image` hide from you.    ## `image` vs `imageunmanaged`    `image` bundle a memory allocator and `imageunmanaged` does not. similar to `std.arraylist()` and `std.arraylistunmanaged()` in zig standard library. for all the examples we are going to use `image` but it is similar with `imageunmanaged`.     ## read an image    it is pretty straightforward to read an image using the `image` struct.    ### from a file    you can use either a file path    ```zig  const std = @import('std');  const zigimg = @import('zigimg');    pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};      defer _ = gpa.deinit();        const allocator = gpa.allocator();        var image = try zigimg.image.fromfilepath(allocator, 'my_image.png');      defer image.deinit();        // do something with your image  }  ```    or a `std.fs.file` directly    ```zig  const std = @import('std');  const zigimg = @import('zigimg');    pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};      defer _ = gpa.deinit();        const allocator = gpa.allocator();        var file = try std.fs.cwd().openfile(file_path, .{});      defer file.close();        var image = try zigimg.image.fromfile(allocator, file);      defer image.deinit();        // do something with your image  }  ```    ### from memory    ```zig  const std = @import('std');  const zigimg = @import('zigimg');    const image_data = @embedfile('test.bmp');    pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};      defer _ = gpa.deinit();        const allocator = gpa.allocator();        const image = try zigimg.image.frommemory(allocator, image_data[0..]);      defer image.deinit();        // do something with your image  }  ```    ## accessing pixel data    for a single image, they are two ways to get accees to the pixel data.    ### accessing a specific format directly    yu can access the pixel data directly using `image.pixels`. `pixels` is an union of all supported pixel formats.    for rgb pixel formats, just use the pixel format enum value and addresss the data directly.  ```zig  pub fn example() void {      // [...]      // assuming you already have an image loaded        const first_pixel = image.pixels.rgb24[0];  }  ```    for grayscale formats, you need to use .value to get the grayscale value. it can also contain the alpha value if you use the grayscale with alpha.    ```zig  pub fn example() void {      // [...]      // assuming you already have an image loaded        const first_pixel = image.pixels.grayscale8alpha[0];      const grayscale = first_pixel.value;      const alpha = grayscale.alpha;  }  ```    for indexed formats, you need to first access the union value then either the indices or the palette. the palette color are stored in the `rgba32` pixel format.    ```zig  pub fn example() void {      // [...]      // assuming you already have an image loaded        const first_color_palette = image.pixels.indexed8.palette[0];      const first_pixel = image.pixels.indexed8.indices[0];  }  ```    if you want to know the current pixel format use `image.pixelformat()`.    ### using the color iterator    you can use the iterator to get each pixel as the universal `colorf32` pixel format. (32-bit floating ploint rgba)    ```zig  pub fn example() void {      // [...]      // assuming you already have an image loaded        const color_it = image.iterator();        while (color_it.next()) |color| {          // do something with color      }  }  ```    ### accessing animation frames    in the case of an `image` containing multiple frames, you can use `image.animation` to get access to the animation information. use `image.animation.frames` to access each indivial frame. each frame contain the pixel data and a frame duration in seconds (32-bit floating point).    `image.pixels` will always point to the first frame of an animation also.    ```zig  pub fn example() void {      // [...]      // assuming you already have an image loaded        const loop_count = image.animation.loop_count;        for (image.animation.frames) |frame| {          const rgb24_data = frame.pixels.rgb24;          const frame_duration = frame.duration;      }  }  ```    ### get raw bytes for texture transfer    `image` has helper functions to help you get the right data to upload your image to the gpu.    ```zig  pub fn example() void {      // [...]      // assuming you already have an image loaded        const image_data = image.rawbytes();      const row_pitch = image.rowbytesize();      const image_byte_size = image.imagebytesize();  }  ```    ## write an image    each 3 functions to write an image take a union of encoder options for the target format. to know the actual options you'll need to consult the source code. the active tag of the union determine the target format, not the file extension.    ### write to a file path    ```zig  pub fn example() !void {      // [...]      // assuming you already have an image loaded        try image.writetofilepath('my_new_image.png', .{ .png = .{} });        // or with encoder options      try image.writetofilepath('my_new_image.png', .{ .png = .{ .interlaced = true } });  }  ```    ### write to `std.fs.file`    ```zig  pub fn example() !void {      // [...]      // assuming you already have an image loaded and the file already created        try image.writetofile(file, .{ .bmp = .{} });  }  ```    ### write to a memory buffer    ensure that you have enough place in your buffer before calling `writetomemory()`    ```zig  pub fn example() !void {      // [...]      // assuming you already have an image loaded and the buffer already allocated        try image.writetomemory(buffer[0..], .{ .tga = .{} });  }  ```    ## create an image    use `image.create()` and pass the width, height and the pixel format that you want.    ```zig  const std = @import('std');  const zigimg = @import('zigimg');    pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};      defer _ = gpa.deinit();        const allocator = gpa.allocator();        var image = try zigimg.image.create(allocator, 1920, 1080, .rgba32);      defer image.deinit();        // do something with your image  }  ```    ## interpret raw pixels    if you are not dealing with a image format, you can import your pixel data using `image.fromrawpixels()`. it will create a copy of the pixels data. if you want the image to take ownership or just pass the data along to write it to a image format, use `imageunmanaged.fromrawpixelsowned()`.    using `fromrawpixel()`:  ```zig  const std = @import('std');  const zigimg = @import('zigimg');    pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};      defer _ = gpa.deinit();        const allocator = gpa.allocator();        const my_raw_pixels = @embeddata('raw_bgra32.bin');        var image = try zigimg.image.fromrawpixels(allocator, 1920, 1080, my_raw_pixels[0..], .bgra32);      defer image.deinit();        // do something with your image  }  ```    using `fromrawpixelsowned()`:  ```zig  const std = @import('std');  const zigimg = @import('zigimg');    pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};      defer _ = gpa.deinit();        const allocator = gpa.allocator();        const my_raw_pixels = @embeddata('raw_bgra32.bin');        var image = try zigimg.imageunmanaged.fromrawpixelsowned(1920, 1080, my_raw_pixels[0..], .bgra32);        // do something with your image  }  ```    ## use image format directly    in the case you want more direct access to the image format, all the image format are accessible from the `zigimg` module. however, you'll need to do a bit more manual steps in order to get the pixel data.    ```zig  const std = @import('std');  const zigimg = @import('zigimg');    pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};      defer _ = gpa.deinit();        const allocator = gpa.allocator();        const image_data = @embedfile('windows_rgba_v5.bmp');        var stream_source = std.io.streamsource{ .const_buffer = std.io.fixedbufferstream(image_data) };        var bmp = zigimg.bmp.bmp{};        const pixels = try bmp.read(allocator, &stream_source);      defer pixels.deinit(allocator);        std.log.info('bmp info header: {}', .{bmp.info_header});  }  ```    for the curious, the program above generate the following output:  ```  info: bmp info header: src.formats.bmp.bitmapinfoheader{ .v5 = src.formats.bmp.bitmapinfoheaderv5{ .header_size = 124, .width = 240, .height = 160, .color_plane = 1, .bit_count = 32, .compression_method = src.formats.bmp.compressionmethod.bitfields, .image_raw_size = 153600, .horizontal_resolution = 2835, .vertical_resolution = 2835, .palette_size = 0, .important_colors = 0, .red_mask = 16711680, .green_mask = 65280, .blue_mask = 255, .alpha_mask = 4278190080, .color_space = src.formats.bmp.bitmapcolorspace.srgb, .cie_end_points = src.formats.bmp.ciexyztriple{ .red = src.formats.bmp.ciexyz{ ... }, .green = src.formats.bmp.ciexyz{ ... }, .blue = src.formats.bmp.ciexyz{ ... } }, .gamma_red = 0, .gamma_green = 0, .gamma_blue = 0, .intent = src.formats.bmp.bitmapintent.graphics, .profile_data = 0, .profile_size = 0, .reserved = 0 } }  ```    ## convert between pixel formats    you can use `image.convert()` to convert between pixel formats. it will allocate the new pixel data and free the old one for you. it supports conversion from and to any pixel format. when converting down to indexed format, no dithering is done.    ```zig  pub fn example() !void {      // [...]      // assuming you already have an image loaded        try image.convert(.float32);  }  ```    ### pixelformatconverter    if you prefer, you can use `pixelformatconverter` directly.    ```zig  pub fn example(allocator: std.mem.allocator) !void {      const indexed2_pixels = try zigimg.color.pixelstorage.init(allocator, .indexed2, 4);      defer indexed2_pixels.deinit(allocator);        // [...] setup your indexed2 pixel data        const bgr24_pixels = try zigimg.pixelformatconverter.convert(allocator, &indexed2_pixels, .bgr24);      defer bgr24_pixels.deinit(allocator);  }  ```    ### octtreequantizer    if you prefer more granular control to create an indexed image, you can use the `octtreequantizer` directly.    ```zig  pub fn example(allocator: std.mem.allocator) !void {      const image_data = @embedfile('windows_rgba_v5.bmp');        var image = try zigimg.image.frommemory(allocator, image_data[0..]);      defer image.deinit();        var quantizer = zigimg.octtreequantizer.init(allocator);      defer quantizer.deinit();        var color_it = image.iterator();        while (color_it.next()) |pixel| {          try quantizer.addcolor(pixel);      }        var palette_storage: [256]zigimg.color.rgba32 = undefined;      const palette = quantizer.makepalette(255, palette_storage[0..]);        const palette_index = try quantizer.getpaletteindex(zigimg.color.rgba32.initrgba(110, 0, 0, 255));  }  ```    ## get a color from a html hex string    you can get a color from a html hex string. the alpha component is always last. it also supports the shorthand version.    ```zig  pub fn example() !void {      const rgb24 = try zigimg.color.rgb24.fromhtmlhex('#123499');      const rgba32 = try zigimg.color.rgba32.fromhtmlhex('ff000045');        const red_rgb24 = try zigimg.color.rgb24.fromhtmlhex('#f00');      const blue_rgba32 = try zigimg.clor.rgba32.fromhtmlhex('#00fa');  }  ```    ## predefined colors    you can access predefined colors for any pixel format using `colors()`.    ```zig  const std = @import('std');  const zigimg = @import('zigimg');    pub fn main() !void {      const red_float32 = zigimg.colors(zigimg.color.colorf32).red;      const blue_rgb24 = zigimg.colors(zigimg.color.rgb24).blue;  }  ```    ## color management & color space    while zigimg does not support icc profile yet (see #36) it does support a variety of color models and color spaces. all color space and color model are done in 32-bit floating point. so if you are not using `colorf32` / `float32` as your pixel format, you'll need to convert to that format first.    the following device-dependent color model are supported:  * hsl (hue, saturation, luminance)  * hsv (hue, saturation, value) or also known as hsb (hue, saturation, brightness)  * cmyk (cyan-magenta-yellow-black)    the following device-inpendent color spaces are supported, with or without alpha:  * cie xyz  * cie lab  * cie lch(ab), the cylindral representation of cie lab  * cie luv  * cie lch(uv), the cylindral representation of cie luv  * [hsluv](https://www.hsluv.org/), a hsl representation of cie lch(uv) which is a cylindrical representation of cie luv color space  * [oklab](https://bottosson.github.io/posts/oklab/)  * oklch, the cylindrical representation of oklab    ### convert between linear and gamma-corrected color    all color space transformation are done assuming a linear version of the color. to convert between gamma-converted and linear, you need to use any rgb colorspace and then call `togamma()` or `tolinear()`, in this example i'm using both `srgb` and `bt709` (aka rec.709).    you can use either the accurate version or the fast version. for example the srgb transfer function is linear below a threshold and an exponent curve above the threshold but the fast version will use the approximate exponent curve for the whole range.    ```zig  pub fn example(linear_color: zigimg.color.colorf32) {      const gamma_srgb = zigimg.color.srgb.togamma(linear_color);      const gamma_bt709 = zigimg.color.bt709.togammafast(linear_color);        const linear_srgb = zigimg.color.srgb.tolinearfast(gamma_srgb);      const linear_bt709 = zigimg.color.bt709.tolinear(gamma_bt609);  }  ```    ### convert a single color to a different color space    to convert to a device independant color space, you need first to use a reference rgb color space. usually the most common for computer purposes is `srgb`. then each rgb colorspace has functions to convert from and to various color spaces. they support both non-alpha and alpha of the color space.    to a color space:  ```zig  pub fn example(linear_color: zigimg.color.colorf32) void {      const xyz = zigimg.color.srgb.toxyz(linear_color);      const lab_alpha = zigimg.color.srgb.tolabalpha(linear_color);      const lch_ab = zigimg.color.srgb.tolchab(linear_color);      const luv_alpha = zigimg.color.srgb.toluvalpha(linear_color);      const lch_uv = zigimg.color.srgb.tolchuv(linear_color);      const hsluv = zigimg.color.srgb.tohsluv(linear_color);      const oklab = zigimg.color.srgb.tooklab(linear_color);      const oklch = zigimg.color.srgb.tooklch(linear_color);  }  ```    when converting from a color space to a rgb color space, you need to specify if you want the color to be clamped inside the rgb colorspace or not because the resulting color could be outside of the rgb color space.  ```zig  pub fn example(oklab: zigimg.color.oklab) {      const linear_srgb_clamped = zigimg.color.srgb.fromoklab(oklab, .clamp);      const linear_srgb = zigimg.color.srgb.fromoklab(oklab, .none);  }  ```    ### convert a slice of color to a different color space    converting each pixel individually will be tedious if you want to use image processing on the cpu. almost all color space conversion offer  an slice in-place conversion or a slice copy conversion. the in-place will reuse the same memory but interpret the color data differently. when you are conversion from a color space to a rgb color space, you need to specify if you want clamping or not.    those conversions are only available with the alpha version of each color space.    ```zig  pub fn exampleinplace(linear_srgb_image: []zigimg.color.colorf32) void {      const slice_lab_alpha = zigimg.color.srgb.slicetolabalphainplace(linear_srgb_image);        // do your image manipulation in cie l*a*b*        // convert back to linear srgb      _ = zigimg.color.srgb.slicefromlabalphainplace(slice_lab_alpha, .clamp);        // or without clamping       _ = zigimg.color.srgb.slicefromlabalphainplace(slice_lab_alpha, .none);  }    pub fn examplecopy(allocator: std.mem.allocator, linear_srgb_image: []const zigimg.color.colorf32) ![]zigimg.color.colorf32 {      const slice_oklab_alpha = try zigimg.color.srgb.slicetooklabcopy(allocator, linear_srgb_image);        // do your image manipulatioon in oklab        // convert back to linear srgb      return try zigimg.color.srgb.slicefromoklabcopy(allocator, slice_oklab_alpha, .clamp);        // or without clamping      return try zigimg.color.srgb.slicefromoklabcopy(allocator, slice_oklab_alpha, .none);  }  ```    ### convert between some cylindrical representation    cie lab, cie luv and oklab have cylindrical representation of their color space, each color has functions to convert from and to the cylindrical version.    ```zig  pub fn example() void {      const lab = zigimg.color.cielab{ .l = 0.12, .a = -0.23, .b = 0.56 };      const luv_alpha = zigimg.color.cieluvalpha { .l = 0.4, .u = 0.5, .v = -0.2, .alpha = 0.8 };      const oklab = zigimg.color.oklab{ .l = 0.67, .a = 0.1, .b = 0.56 };        const lch_ab = lab.tolchab();      const lch_uv_alpha = luv_alpha.tolchuvalpha();      const oklch = oklab.tooklch();        const result_lab = lch_ab.tolab();      const result_luv_alpha = lch_uv_alpha.toluvalpha();      const result_oklab = oklch.tooklab();  }  ```    ### convert color between rgb color spaces    to convert a single color, use the `convertcolor()` function on the `rgbcolorspace` struct:  ```zig  pub fn example(linear_color: zigimg.color.colorf32) void {      const pro_photo_color = zigimg.color.srgb.convertcolor(zigimg.color.prophotorgb, linear_color);  }  ```    if you want to convert a whole slice of pixels, use `convertcolors()`, it will apply the conversion in-place:  ```zig  pub fn example(linear_image: []zigimg.color.colorf32) void {      const adobe_image = zigimg.color.srgb.convertcolors(zigimg.color.adobergb, linear_image);  }  ```    if the target rgb colorspace have a different white point, it will do the [chromatic adapdation](http://www.brucelindbloom.com/index.html?eqn_chromadapt.html) for you using the bradford method.    ### predefined rgb color spaces    here the list of predefined rgb color spaces, all acessilbe from `zigimg.color` struct:    * `bt601_ntsc`  * `bt601_pal`  * `bt709`  * `srgb`  * `dcip3.display`  * `dcip3.theater`  * `dcip3.aces`  * `bt2020`  * `adobergb`  * `adobewidegamutrgb`  * `prophotorgb`    ### predefined white points    all predefined white point are accessed with `zigimg.color.whitepoints`. all the standard illuminants are defined there.    ### create your own rgb color space    you can create your own rgb color space using `zigimg.color.rgbcolorspace.init()`. each coordinate is in the 2d version of the cie xyy color space.    if you don't care about linear and gamma conversion, just ignore those functions in the init struct.    ```zig  fn mycolorspacetogamma(value: f32) f32 {      return std.math.pow(f32, value, 1.0 / 2.4);  }    fn mycolorspacetolinear(value: f32) f32 {      return std.math.pow(f32, value, 2.4);  }    pub fn example() void {      pub const my_color_space = zigimg.color.rgbcolorspace.init(.{          .red = .{ .x = 0.6400, .y = 0.3300 },          .green = .{ .x = 0.3000, .y = 0.6000 },          .blue = .{ .x = 0.1500, .y = 0.0600 },          .white = zigimg.color.whitepoints.d50,          .to_gamma = mycolorspacetogamma,          .to_gamma_fast = mycolorspacetogamma,          .to_linear = mycolorspacetolinear,          .to_linear_fast = mycolorspacetolinear,      });  }  ```  ","webui-dev/zig-webui":"Use any web browser or WebView as GUI, with Zig in the backend and modern web technologies in the frontend, all in a lightweight portable library. <div align='center'>  ![logo](https://raw.githubusercontent.com/webui-dev/webui-logo/main/webui_zig.png)  # webui zig v2.5.0-beta.2  <!-- [build-status]: https://img.shields.io/github/actions/workflow/status/webui-dev/go-webui/ci.yml?branch=main&style=for-the-badge&logo=v&labelcolor=414868&logocolor=c0caf5 -->  [last-commit]: https://img.shields.io/github/last-commit/webui-dev/zig-webui?style=for-the-badge&logo=github&logocolor=c0caf5&labelcolor=414868 <!-- [release-version]: https://img.shields.io/github/v/tag/webui-dev/go-webui?style=for-the-badge&logo=webtrees&logocolor=c0caf5&labelcolor=414868&color=7664c6 --> [license]: https://img.shields.io/github/license/webui-dev/zig-webui?style=for-the-badge&logo=opensourcehardware&label=license&logocolor=c0caf5&labelcolor=414868&color=8c73cc  <!-- [![][build-status]](https://github.com/webui-dev/go-webui/actions?query=branch%3amain) -->  [![][last-commit]](https://github.com/webui-dev/zig-webui/pulse) <!-- [![][release-version]](https://github.com/webui-dev/go-webui/releases/latest) --> [![][license]](https://github.com/webui-dev/zig-webui/blob/main/license)  > use any web browser or webview as gui, with zig in the backend and modern web technologies in the frontend, all in a lightweight portable library.  ![screenshot](https://raw.githubusercontent.com/webui-dev/webui-logo/main/screenshot.png)  </div>  ## features  - portable (*needs only a web browser or a webview at runtime*) - one header file - lightweight (*few kb library*) & small memory footprint - fast binary communication protocol - multi-platform & multi-browser - using private profile for safety - cross-platform webview  ## api documentation  * [https://webui-dev.github.io/zig-webui/](https://webui-dev.github.io/zig-webui/) * [https://webui.me/docs/2.5/#/](https://webui.me/docs/2.5/#/)  ## examples  there are several examples for newbies, they are in the `examples` directory.  you can use `zig build --help` to view all buildable examples.  like `zig build run_minimal`, this will build and run the `minimal` example.  ## installation  ### zig `0.12` ╲ `0.13.0` ╲ `nightly`  > to be honest, i don’t recommend using the nightly version because the api of the build system is not yet stable, which means that there may be problems with not being able to build after nightly is updated.  1. add to `build.zig.zon`  ```sh # it is recommended to replace the following branch with commit id zig fetch --save https://github.com/webui-dev/zig-webui/archive/main.tar.gz # of course, you can also use git+https to fetch this package! ```  2. config `build.zig`  add this:  ```zig // to standardize development, maybe you should use `lazydependency()` instead of `dependency()` // more info to see: https://ziglang.org/download/0.12.0/release-notes.html#toc-lazy-dependencies const zig_webui = b.dependency('zig-webui', .{     .target = target,     .optimize = optimize,     .enable_tls = false, // whether enable tls support     .is_static = true, // whether static link });  // add module exe.root_module.addimport('webui', zig_webui.module('webui')); ```  > it is not recommended to dynamically link libraries under windows, which may cause some symbol duplication problems. > see this issue: https://github.com/ziglang/zig/issues/15107  ### windows without console  for hide console window, you can set `exe.subsystem = .windows;`!  ## ui & the web technologies  [borislav stanimirov](https://ibob.bg/) discusses using html5 in the web browser as gui at the [c++ conference 2019 (_youtube_)](https://www.youtube.com/watch?v=bbbczd4cuxg).  <!-- <div align='center'>   <a href='https://www.youtube.com/watch?v=bbbczd4cuxg'><img src='https://img.youtube.com/vi/bbbczd4cuxg/0.jpg' alt='embrace modern technology: using html 5 for gui in c++ - borislav stanimirov - cppcon 2019'></a> </div> -->  <div align='center'>  ![cppcon](https://github.com/webui-dev/webui/assets/34311583/4e830caa-4ca0-44ff-825f-7cd6d94083c8)  </div>  web application ui design is not just about how a product looks but how it works. using web technologies in your ui makes your product modern and professional, and a well-designed web application will help you make a solid first impression on potential customers. great web application design also assists you in nurturing leads and increasing conversions. in addition, it makes navigating and using your web app easier for your users.  ### why use web browsers?  today's web browsers have everything a modern ui needs. web browsers are very sophisticated and optimized. therefore, using it as a gui will be an excellent choice. while old legacy gui lib is complex and outdated, a webview-based app is still an option. however, a webview needs a huge sdk to build and many dependencies to run, and it can only provide some features like a real web browser. that is why webui uses real web browsers to give you full features of comprehensive web technologies while keeping your software lightweight and portable.  ### how does it work?  <div align='center'>  ![diagram](https://github.com/ttytm/webui/assets/34311583/dbde3573-3161-421e-925c-392a39f45ab3)  </div>  think of webui like a webview controller, but instead of embedding the webview controller in your program, which makes the final program big in size, and non-portable as it needs the webview runtimes. instead, by using webui, you use a tiny static/dynamic library to run any installed web browser and use it as gui, which makes your program small, fast, and portable. **all it needs is a web browser**.  ### runtime dependencies comparison  |                                 | tauri / webview   | qt                         | webui               | | ------------------------------- | ----------------- | -------------------------- | ------------------- | | runtime dependencies on windows | _webview2_        | _qtcore, qtgui, qtwidgets_ | **_a web browser_** | | runtime dependencies on linux   | _gtk3, webkitgtk_ | _qtcore, qtgui, qtwidgets_ | **_a web browser_** | | runtime dependencies on macos   | _cocoa, webkit_   | _qtcore, qtgui, qtwidgets_ | **_a web browser_** |  ## supported web browsers  | browser         | windows         | macos         | linux           | | --------------- | --------------- | ------------- | --------------- | | mozilla firefox | ✔️              | ✔️            | ✔️              | | google chrome   | ✔️              | ✔️            | ✔️              | | microsoft edge  | ✔️              | ✔️            | ✔️              | | chromium        | ✔️              | ✔️            | ✔️              | | yandex          | ✔️              | ✔️            | ✔️              | | brave           | ✔️              | ✔️            | ✔️              | | vivaldi         | ✔️              | ✔️            | ✔️              | | epic            | ✔️              | ✔️            | _not available_ | | apple safari    | _not available_ | _coming soon_ | _not available_ | | opera           | _coming soon_   | _coming soon_ | _coming soon_   |  ## supported webview  | webview         | status         | | --------------- | --------------- | | windows webview2 | ✔️ | | linux gtk webview   | ✔️ | | macos wkwebview  | ✔️ |  ### license  > licensed under the mit license. ","ziglibs/zgl":"Zig OpenGL Wrapper # zgl – zig opengl bindings  this library provides a thin, type-safe binding for opengl.  ## example  ```zig // use classic opengl flavour var vao = gl.createvertexarray(); defer gl.deletevertexarray(vao);  // use object oriented flavour var vertex_buffer = gl.buffer.create(); defer vertex_buffer.delete(); ```  ## installation  add zgl to your `build.zig.zon` with the following command:  `zig fetch --save https://github.com/ziglibs/zgl/archive/[commit_hash].tar.gz`  replace [commit_hash] with the latest commit or tagged release.  then add the following to your `build.zig`:  ```zig const zgl = b.dependency('zgl', .{     .target = target,     .optimize = optimize, }); exe.root_module.addimport('zgl', zgl.module('zgl')); ```  then import it with `const gl = @import('zgl');`, and build as normal with `zig build`.  ## development philosophy  this library is developed incrementally. that means that functions and other things will be included on-demand and not just for the sake of completeness.  if you think a function is missing, fork the library, implement the missing function similar to the other functions and make a pull request. issues that request implementation of missing functions will be closed immediatly.  ## generated bindings  this library includes opengl 4.5 bindings, generated by [zig-opengl](https://github.com/masterq32/zig-opengl). bindings for a different version may be substituted by replacing [binding.zig](src/binding.zig). ","slimsag/mach-glfw":"Ziggified GLFW bindings with 100% API coverage, zero-fuss installation, cross compilation, and more. <a href='https://machengine.org/pkg/mach-glfw'>     <picture>         <source media='(prefers-color-scheme: dark)' srcset='https://machengine.org/assets/mach/glfw-full-dark.svg'>         <img alt='mach-glfw' src='https://machengine.org/assets/mach/glfw-full-light.svg' height='150px'>     </picture> </a>  perfected glfw bindings for zig  ## features  * zero-fuss installation, cross-compilation at the flip of a switch, and broad platform support. * 100% api coverage. every function, type, constant, etc. has been exposed in a ziggified api.  see also: [what does a ziggified glfw api offer?](https://machengine.org/pkg/mach-glfw/)  ## community maintained  the [mach engine](https://machengine.org/) project no longer uses glfw, and so this project is now community-maintained. pull requests are welcome and will be reviewed. the project will still target [nominated zig versions](https://machengine.org/about/zig-version/) but may not see regular updates as it is no longer a mach project (see [hexops/mach#1166](https://github.com/hexops/mach/issues/1166)).  note: [hexops/glfw]()  some old documentation is available at https://machengine.org/v0.4/pkg/mach-glfw/ ","floooh/sokol-zig":"Zig bindings for the sokol headers (https://github.com/floooh/sokol) [![build](https://github.com/floooh/sokol-zig/actions/workflows/main.yml/badge.svg)](https://github.com/floooh/sokol-zig/actions/workflows/main.yml)  auto-generated zig bindings for the [sokol headers](https://github.com/floooh/sokol).  for zig version 0.13.0 and 0.14.0-dev  in case of breaking changes in zig, the bindings might fall behind. please don't hesitate to ping me via a github issue, or even better, provide a pr :)  support for stable zig versions is in branches (e.g. `zig-0.12.0`), those versions are 'frozen in time' though.  related projects:  - [pacman.zig](https://github.com/floooh/pacman.zig) - [chipz emulators](https://github.com/floooh/chipz) - [dear imgui sample project](https://github.com/floooh/sokol-zig-imgui-sample)  ## building the samples  supported platforms are: windows, macos, linux (with x11) and web  on linux install the following packages: libglu1-mesa-dev, mesa-common-dev, xorg-dev, libasound-dev (or generally: the dev packages required for x11, gl and alsa development)  to build the platform-native samples:  ```sh # just build: zig build # build and run samples: zig build run-clear zig build run-triangle zig build run-quad zig build run-bufferoffsets zig build run-cube zig build run-noninterleaved zig build run-texcube zig build run-offscreen zig build run-instancing zig build run-mrt zig build run-saudio zig build run-sgl zig build run-sgl-context zig build run-sgl-points zig build run-debugtext zig build run-debugtext-print zig build run-debugtext-userfont zig build run-shapes ```  (also run ```zig build -l``` to get a list of build targets)  by default, the backend 3d api will be selected based on the target platform:  - macos: metal - windows: d3d11 - linux: gl  to force the gl backend on macos or windows, build with ```-dgl=true```:  ``` > zig build -dgl=true run-clear ```  the ```clear``` sample prints the selected backend to the terminal:  ``` sokol-zig ➤ zig build -dgl=true run-clear backend: .sokol.gfx.backend.glcore33 ```  for the web-samples, run:  ```sh zig build -dtarget=wasm32-emscripten # or to build and run one of the samples zig build run-clear -dtarget=wasm32-emscripten ... ```  when building with target `wasm32-emscripten` for the first time, the build script will install and activate the emscripten sdk into the zig package cache for the latest sdk version. there is currently no build system functionality to update or delete the emscripten sdk after this first install. the current workaround is to delete the global zig cache (run `zig env` to see where the zig cache resides).  improving the emscripten sdk integration with the zig build system is planned for the future.   ## how to integrate sokol-zig into your project  add a build.zig.zon file to your project which has at least a `.sokol` dependency:  ```zig .{     .name = 'my_project',     .version = '0.1.0',     .paths = .{         'src',         'build.zig',         'build.zig.zon',     },     .dependencies = .{         .sokol = .{             .url = 'git+https://github.com/floooh/sokol-zig.git#[commit-hash]',             .hash = '[content-hash]',         },     }, } ```  the easiest way to populate or update the `sokol` dependency is to run this on the cmdline:  ``` zig fetch --save=sokol git+https://github.com/floooh/sokol-zig.git ```  this will automatically use the latest sokol-zig commit.  for a native-only project, a `build.zig` file looks entirely vanilla:  ```zig const std = @import('std'); const build = std.build; const optimizemode = std.builtin.optimizemode;  pub fn build(b: *build) !void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});     const dep_sokol = b.dependency('sokol', .{         .target = target,         .optimize = optimize,     });    const hello = b.addexecutable(.{         .name = 'hello',         .target = target,         .optimize = optimize,         .root_source_file = b.path('src/hello.zig'),     });     hello.root_module.addimport('sokol', dep_sokol.module('sokol'));     b.installartifact(hello);     const run = b.addrunartifact(hello);     b.step('run', 'run hello').dependon(&run.step); } ```  if you also want to run on the web via `-dtarget=wasm32-emscripten`, the web platform build must look special, because emscripten must be used for linking, and to run the build result in a browser, a special run step must be created.  such a 'hybrid' build script might look like this (copied straight from [pacman.zig](https://github.com/floooh/pacman.zig)):  ```zig const std = @import('std'); const build = std.build; const optimizemode = std.builtin.optimizemode; const sokol = @import('sokol');  pub fn build(b: *build) !void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});     const dep_sokol = b.dependency('sokol', .{         .target = target,         .optimize = optimize,     });      // special case handling for native vs web build     if (target.result.iswasm()) {         try buildweb(b, target, optimize, dep_sokol);     } else {         try buildnative(b, target, optimize, dep_sokol);     } }  // this is the regular build for all native platforms, nothing surprising here fn buildnative(b: *build, target: build.resolvedtarget, optimize: optimizemode, dep_sokol: *build.dependency) !void {     const pacman = b.addexecutable(.{         .name = 'pacman',         .target = target,         .optimize = optimize,         .root_source_file = b.path('src/pacman.zig'),     });     pacman.root_module.addimport('sokol', dep_sokol.module('sokol'));     b.installartifact(pacman);     const run = b.addrunartifact(pacman);     b.step('run', 'run pacman').dependon(&run.step); }  // for web builds, the zig code needs to be built into a library and linked with the emscripten linker fn buildweb(b: *build, target: build.resolvedtarget, optimize: optimizemode, dep_sokol: *build.dependency) !void {     const pacman = b.addstaticlibrary(.{         .name = 'pacman',         .target = target,         .optimize = optimize,         .root_source_file = b.path('src/pacman.zig'),     });     pacman.root_module.addimport('sokol', dep_sokol.module('sokol'));      // create a build step which invokes the emscripten linker     const emsdk = dep_sokol.builder.dependency('emsdk', .{});     const link_step = try sokol.emlinkstep(b, .{         .lib_main = pacman,         .target = target,         .optimize = optimize,         .emsdk = emsdk,         .use_webgl2 = true,         .use_emmalloc = true,         .use_filesystem = false,         .shell_file_path = dep_sokol.path('src/sokol/web/shell.html'),     });     // ...and a special run step to start the web build output via 'emrun'     const run = sokol.emrunstep(b, .{ .name = 'pacman', .emsdk = emsdk });     run.step.dependon(&link_step.step);     b.step('run', 'run pacman').dependon(&run.step); } ```  ## wasm32-emscripten caveats  - zig allocators use the `@returnaddress` builtin, which isn't supported in the emscripten   runtime out of the box (you'll get a runtime error in the browser's javascript console   looking like this: `cannot use convertframetopc (needed by __builtin_return_address) without -suse_offset_converter`.   to make it work, do as the error message says, to add the `-suse_offset_converter` arg to the   emscripten linker step in your `build.zig` file:    ```zig       const link_step = try sokol.emlinkstep(b, .{         // ...other settings here         .extra_args = &.{'-suse_offset_converter=1'},     });   ```    also see the [kc85.zig build.zig](https://github.com/floooh/kc85.zig/blob/main/build.zig) as example!  - the zig stdlib only has limited support for the `wasm32-emscripten`   target, for instance using `std.fs` functions will most likely fail   to compile (the sokol-zig bindings might add more sokol headers   in the future to fill some of the gaps)  ## dear imgui support  the sokol-zig bindings come with sokol_imgui.h (exposed as the zig package `sokol.imgui`), but integration into a project's build.zig requires some extra steps, mainly because i didn't want to add a [cimgui](https://github.com/cimgui/cimgui) dependency to the sokol-zig package (especially since cimgui uses git submodule which are not supported by the zig package manager).  the main steps to create dear imgui apps with sokol-zig are:  1. 'bring your own cimgui' 2. tell the sokol dependency that it needs to include sokol_imgui.h into   the compiled c library:     ```zig     const dep_sokol = b.dependency('sokol', .{         .target = target,         .optimize = optimize,         .with_sokol_imgui = true,     });     ``` 3. inject the path to the cimgui directory into the sokol dependency so   that c compilation works (this needs to find the `cimgui.h` header)      ```zig     dep_sokol.artifact('sokol_clib').addincludepath(cimgui_root);     ```  also see the following example project:  https://github.com/floooh/sokol-zig-imgui-sample/ ","ikskuh/SDL.zig":"A shallow wrapper around SDL that provides object API and error handling # sdl.zig  a zig package that provides you with the means to link sdl2 to your project, as well as a zig-infused header implementation (allows you to not have the sdl2 headers on your system and still compile for sdl2) and a shallow wrapper around the sdl apis that allow a more zig-style coding with zig error handling and tagged unions.  ## getting started  ### linking sdl2 to your project  this is an example `build.zig` that will link the sdl2 library to your project.  ```zig const std = @import('std'); const sdl = @import('sdl'); // replace with the actual name in your build.zig.zon  pub fn build(b: *std.build) !void {     // determine compilation target     const target = b.standardtargetoptions(.{});      // create a new instance of the sdl2 sdk     // specifiy dependency name explicitly if necessary (use sdl by default)      const sdk = sdl.init(b, .{});      // create executable for our example     const demo_basic = b.addexecutable(.{         .name = 'demo-basic',         .root_source_file = b.path('my-game.zig'),         .target = target,     });      sdk.link(demo_basic, .dynamic, sdl.library.sdl2); // link sdl2 as a shared library      // add 'sdl2' package that exposes the sdl2 api (like sdl_init or sdl_createwindow)     demo_basic.root_module.addimport('sdl2', sdk.getnativemodule());      // install the executable into the prefix when invoking 'zig build'     b.installartifact(demo_basic); } ```  ### using the native api  this package exposes the sdl2 api as defined in the sdl headers. use this to create a normal sdl2 program:  ```zig const std = @import('std'); const sdl = @import('sdl2'); // add this package by using sdk.getnativemodule  pub fn main() !void {     if (sdl.sdl_init(sdl.sdl_init_video | sdl.sdl_init_events | sdl.sdl_init_audio) < 0)         sdlpanic();     defer sdl.sdl_quit();      var window = sdl.sdl_createwindow(         'sdl2 native demo',         sdl.sdl_windowpos_centered, sdl.sdl_windowpos_centered,         640, 480,         sdl.sdl_window_shown,     ) orelse sdlpanic();     defer _ = sdl.sdl_destroywindow(window);      var renderer = sdl.sdl_createrenderer(window, -1, sdl.sdl_renderer_accelerated) orelse sdlpanic();     defer _ = sdl.sdl_destroyrenderer(renderer);      mainloop: while (true) {         var ev: sdl.sdl_event = undefined;         while (sdl.sdl_pollevent(&ev) != 0) {             if(ev.type == sdl.sdl_quit)                 break :mainloop;         }          _ = sdl.sdl_setrenderdrawcolor(renderer, 0xf7, 0xa4, 0x1d, 0xff);         _ = sdl.sdl_renderclear(renderer);          sdl.sdl_renderpresent(renderer);     } }  fn sdlpanic() noreturn {     const str = @as(?[*:0]const u8, sdl.sdl_geterror()) orelse 'unknown error';     @panic(std.mem.sliceto(str, 0)); } ```  ### using the wrapper api  this package also exposes the sdl2 api with a more zig-style api. use this if you want a more convenient zig experience.  **note:** this api is experimental and might change in the future  ```zig const std = @import('std'); const sdl = @import('sdl2'); // created in build.zig by using exe.root_module.addimport('sdl2', sdk.getwrappermodule());  pub fn main() !void {     try sdl.init(.{         .video = true,         .events = true,         .audio = true,     });     defer sdl.quit();      var window = try sdl.createwindow(         'sdl2 wrapper demo',         .{ .centered = {} }, .{ .centered = {} },         640, 480,         .{ .vis = .shown },     );     defer window.destroy();      var renderer = try sdl.createrenderer(window, null, .{ .accelerated = true });     defer renderer.destroy();      mainloop: while (true) {         while (sdl.pollevent()) |ev| {             switch (ev) {                 .quit => break :mainloop,                 else => {},             }         }          try renderer.setcolorrgb(0xf7, 0xa4, 0x1d);         try renderer.clear();          renderer.present();     } } ```  ## `build.zig` api  ```zig /// just call `sdk.init(b, .{})` to obtain a handle to the sdk! /// use `sdl` as dependency name by default. const sdk = @this();  /// creates a instance of the sdk and initializes internal steps. /// initialize once, use everywhere (in your `build` function). /// /// const sdkoption = struct { ///     dep_name: ?[]const u8 = 'sdl', ///     maybe_config_path: ?[]const u8 = null, ///     maybe_sdl_ttf_config_path: ?[]const u8 = null, /// }; pub fn init(b: *build, opt: sdkoption) *sdk  /// returns a module with the raw sdl api with proper argument types, but no functional/logical changes /// for a more *ziggy* feeling. /// this is similar to the *c import* result. pub fn getnativemodule(sdk: *sdk) *build.module;  /// returns a module with the raw sdl api with proper argument types, but no functional/logical changes /// for a more *ziggy* feeling, with vulkan support! the vulkan module provided by `vulkan-zig` must be /// provided as an argument. /// this is similar to the *c import* result. pub fn getnativemodulevulkan(sdk: *sdk, vulkan: *build.module) *build.module;  /// returns the smart wrapper for the sdl api. contains convenient zig types, tagged unions and so on. pub fn getwrappermodule(sdk: *sdk) *build.module;  /// returns the smart wrapper with vulkan support. the vulkan module provided by `vulkan-zig` must be /// provided as an argument. pub fn getwrappermodulevulkan(sdk: *sdk, vulkan: *build.module) *build.module;  /// links sdl2 or sdl2_ttf to the given exe and adds required installs if necessary. /// **important:** the target of the `exe` must already be set, otherwise the sdk will do the wrong thing! pub fn link(sdk: *sdk, exe: *build.step.compile, linkage: std.builtin.linkmode, comptime library: library) void; ```  ## dependencies  all of those are dependencies for the *target* platform, not for your host. zig will run/build the same on all source platforms.  ### windows  for windows, you need to fetch the correct dev libraries from the [sdl download page](https://www.libsdl.org/download-2.0.php). it is recommended to use the mingw versions if you don't require msvc compatibility.  ### macos  right now, cross-compiling for macos isn't possible. on a mac, install sdl2 via `brew`.  ### linux  if you are cross-compiling, no dependencies exist. the build sdk compiles a `libsdl2.so` stub which is used for linking.  if you compile to your target platform, you require sdl2 to be installed via your os package manager.  ## support matrix  this project tries to provide you the best possible development experience for sdl2. thus, this project supports the maximum amount of cross-compilation targets for sdl2.  the following table documents this. the rows document the *target* whereas the columns are the *build host*:  |                       | windows (x86_64) | windows (i386) | linux (x86_64) | macos (x86_64) | macos (aarch64) | |-----------------------|------------------|----------------|----------------|----------------|-----------------| | `i386-windows-gnu`    | ✅               | ✅             | ✅             | ✅             | ⚠️               | | `i386-windows-msvc`   | ✅               | ✅             | ✅             | ✅             | ⚠️               | | `x86_64-windows-gnu`  | ✅               | ✅             | ✅             | ✅             | ⚠️               | | `x86_64-windows-msvc` | ✅               | ✅             | ✅             | ✅             | ⚠️               | | `x86_64-macos`        | ❌               | ❌             | ❌             | ✅             | ❌              | | `aarch64-macos`       | ❌               | ❌             | ❌             | ❌             | ⚠️               | | `x86_64-linux-gnu`    | 🧪               | 🧪             | ✅             | 🧪             | ⚠️               | | `aarch64-linux-gnu`   | 🧪               | 🧪             | 🧪             | 🧪             | ⚠️               |  legend: - ✅ cross-compilation is known to work and tested via ci - 🧪 experimental cross-compilation support, covered via ci - ⚠️ cross-compilation *might* work, but is not tested via ci - ❌ cross-compilation is not possible right now  ## contributing  you can contribute to this project in several ways: - use it!     this helps me to track bugs (which i know that there are some), and usability defects (which we can resolve then). i want this library to have the best development experience possible. - implement/improve the linking experience:     right now, it's not possible to cross-compile for macos, which is very sad. we might find a way to do so, though! also vcpkg is not well supported on windows platforms. - improve the wrapper.     just add the functions you need and make a pr. or improve existing ones. i won't do it for you, so you have to get your own hands dirty! ","ikskuh/ZigAndroidTemplate":"This repository contains a example on how to create a minimal Android app in Zig. # android apps in zig  ![project banner](design/logo.png)  this repository contains multiple examples of creating a minimal android app in zig.  ## examples  there are 4 different examples. the examples have no dependencies on c code except for the android libraries, so they can be considered pure zig apps.  to select which example to build and run, pass the example flag (e.g. `-dexample=egl`). valid values for the example flag are `egl`, `minimal`, `textview`, and `invocationhandler`.  we're running a ci that will verify the build for windows, macos and linux:  [![ci](https://github.com/masterq32/zigandroidtemplate/actions/workflows/main-ci.yml/badge.svg)](https://github.com/masterq32/zigandroidtemplate/actions/workflows/main-ci.yml)  ### minimal  `examples/minimal` includes just enough code to get the app running.  ### egl  `examples/egl/` initializes opengl and renders a color cycle. touchscreen events will activate a sine wave synth and be displayed as small circles beneath the fingers that will fade as soon as no event for the same finger will happen again.  the code contains some commented examples on how to interface with the jni to use advanced features of the `anativeactivity`.  ### textview  `examples/textview/` creates a textview component with android's built-in ui to display 'hello, world!'.  ### invocationhandler  `examples/invocationhandler` builds on the textview example. it shows how to pass a callback to the jni by creating a button component that reacts to being pressed.  ## presentation  there is a [fosdem talk](https://fosdem.org/2021/schedule/event/zig_android/) you can watch here:  - [mp4 video](https://video.fosdem.org/2021/d.zig/zig_android.mp4) - [webm video](https://video.fosdem.org/2021/d.zig/zig_android.webm)  since the time of recording zigandroidtemplate has changed in some major ways.  ## what's missing  - configuration management example - save/load app state example  ## requirements & build  you need the [android sdk](https://developer.android.com/studio#command-tools) installed together with the [android ndk](https://developer.android.com/ndk).  you also need [adb](https://developer.android.com/studio/command-line/adb) and a java sdk installed (required for `jarsigner`).  now you need to generate yourself a keystore to sign your apps. for debugging purposes, the build script contains a helper. just invoke `zig build keystore` to generate yourself a debug keystore that can be used with later build invocations.  **note** that the build file might ask you to configure some paths. do as requested and just run the build again, it should work then.  if all of the above is done, you should be able to build the app by running `zig build`.  there are convenience options with `zig build push` (installs the app on a connected phone) and `zig build run` (which installs, then runs the app).  ### quick start  install the [`sdkmanager`](https://developer.android.com/studio/command-line/sdkmanager) and invoke the following command line:  ``` # android platforms for your target android version # min version: android 5 sdkmanager --install 'platforms;android-21' # you can install other versions as well # remember to set it like `zig build -dandroid=android99`  sdkmanager --install 'build-tools;33.0.1' sdkmanager --install 'ndk;25.1.8937393' zig build keystore install run ```  this should build an apk and install it on your connected phone if possible.  ## getting started  check out the [`build.zig`](build.zig) to see how to build a new android app. the [`examples`](examples/) folder has multiple examples for making minimal android apps.  ## credits  huge thanks to [@cnlohr](https://github.com/cnlohr) to create [rawdrawandroid](https://github.com/cnlohr/rawdrawandroid) and making this project possible! ","mookums/zzz":"A framework for writing performant and reliable networked services. # zzz ![zzz logo](./docs/img/zzz.png)   ## installing latest zig stable: `0.13.0`  latest zzz release: `0.2.0` ``` zig fetch --save git+https://github.com/mookums/zzz#v0.2.0 ```  you can then add the dependency in your `build.zig` file: ```zig const zzz = b.dependency('zzz', .{     .target = target,     .optimize = optimize, }).module('zzz');  exe.root_module.addimport(zzz); ```  ## zzz? zzz is a framework for writing performant and reliable networked services in zig. it supports both http and https (using bearssl for tls).  zzz currently supports linux, mac and windows. linux is currently the reccomended target for deployments.  > [!important] > zzz is currently **alpha** software and there is still a lot changing at a fairly quick pace and certain places where things are less polished.  it focuses on modularity and portability, allowing you to swap in your own implementations for various things. consumers can provide an async implementation, allowing for maximum flexibility. this allows for use in standard servers as well as embedded/bare metal domains.  for more information, look here: 1. [getting started](./docs/getting_started.md) 2. [https](./docs/https.md) 3. [performance tuning](./docs/performance.md) 4. [custom async](https://muki.gg/post/modular-async)  ## optimization zzz is **very** fast. through a combination of methods, such as allocation at start up and avoiding thread contention, we are able to extract tons of performance out of a fairly simple implementation. zzz is quite robust currently but is still early stage software. it's currently been running in production, serving my [site](https://muki.gg).  with the recent migration to [tardy](https://github.com/mookums/tardy), zzz is about as fast as gnet, the fastest plaintext http server according to [techempower](https://www.techempower.com/benchmarks/#hw=ph&test=plaintext&section=data-r22), while consuming only ~22% of the memory that gnet requires.  ![benchmark (request per sec)](./docs/benchmark/req_per_sec_ccx63_24.png)  [raw data](./docs/benchmark/request_ccx63_24.csv)  ![benchmark (peak memory)](./docs/benchmark/peak_memory_ccx63_24.png)  [raw data](./docs/benchmark/memory_ccx63_24.csv)  on the ccx63 instance on hetzner with 2000 max connections, we are 70.9% faster than [zap](https://github.com/zigzap/zap) and 83.8% faster than [http.zig](https://github.com/karlseguin/http.zig). we also utilize less memory, using only ~3% of the memory used by zap and ~1.6% of the memory used by http.zig.  zzz can be configured to utilize minimal memory while remaining performant. the provided `minram` example only uses 256 kb!  ## features - built on top of [tardy](https://github.com/mookums/tardy), an asynchronous runtime. - [modular asynchronous implementation](https://muki.gg/post/modular-async)     - `io_uring` for linux (>= 5.1.0).     - `epoll` for linux (>= 2.5.45).     - `kqueue` for bsd & mac.     - `busy_loop` for linux, mac and windows. - single and multithreaded support - tls using bearssl - memory pooling for minimal allocations   ## contribution unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in zzz by you, shall be licensed as mpl2.0, without any additional terms or conditions. ","karlseguin/websocket.zig":"A websocket implementation for zig 404: not found","kristoff-it/ziggy":"A data serialization language for expressing clear API messages, config files, etc. # ziggy a data serialization language for expressing clear api messages, config files, etc.  ## status alpha, using ziggy now means participating in its development.  ## at a glance  ```zig .id = @uuid('...'), .time = 1710085168, .payload = command {   .do = @action('clear_chat'),   .sender = 'kristoff-it',   .roles = ['admin', 'mod'],   .extra = {     'agent': 'mozilla/5.0',     'os': 'linux/x64',    }, } ``` ## value types ziggy values can be of the following types:  - bytes `'🧑‍🚀'`, `'╲x1b[?1000h gang'`, `╲╲multiline` - numbers `123_000`, `1.23`, `0xff_ff_ff`, `0o7_5_5`, `0b01_01_01`  - null `null` - bool `true`, `false` - custom literals `@date('2020-12-01')`, `@v('1.0.0')`, `@foo('bar')` - array `[1, 2, 3]` - struct `{ .fixed = 'schema' }`, `named { .for = 'unions of structs' }` - map `{ 'custom': 'keys' }`   ## documentation  see the official website: https://ziggy-lang.io  ## development  in order to build with nix using the correct dependencies pease keep updated the [deps.nix](./deps.nix) file every time the [build.zig.zon](build.zig.zon) is changed. in order to do so use  ```bash nix run .#update-deps ``` ","malcolmstill/zware":"Zig WebAssembly Runtime Engine <h1 align='center'>zware</h1>  <div align='center'>   <img src='https://github.com/malcolmstill/web-assembly-logo/blob/master/dist/icon/web-assembly-icon-128px.png' alt='webassembly logo: a purple-blue square containing the uppercase letters w a. the square has a semicirclular notch on the top edge in the middle' />   <br />   <strong>zig webassembly runtime engine</strong> </div>  ## about  `zware` is a library for executing webassembly embedded in [zig](https://ziglang.org) programs.  ## example  from `examples/fib`:  ```zig const std = @import('std'); const zware = @import('zware'); const store = zware.store; const module = zware.module; const instance = zware.instance; const generalpurposeallocator = std.heap.generalpurposeallocator; var gpa = generalpurposeallocator(.{}){};  pub fn main() !void {     defer _ = gpa.deinit();     const alloc = gpa.allocator();      const bytes = @embedfile('fib.wasm');      var store = store.init(alloc);     defer store.deinit();      var module = module.init(alloc, bytes);     defer module.deinit();     try module.decode();      var instance = instance.init(alloc, &store, module);     try instance.instantiate();     defer instance.deinit();      const n = 39;     var in = [1]u64{n};     var out = [1]u64{0};      try instance.invoke('fib', in[0..], out[0..], .{});      const result: i32 = @bitcast(@as(u32, @truncate(out[0])));     std.debug.print('fib({}) = {}╲n', .{ n, result }); } ```  ## requirements  ### compile-time  - zig 0.12 (master)  ### run-time  - none, zig generates static binaries:  ```bash ➜  zware git:(master) ✗ ldd fib         not a dynamic executable ```  ## goals  - embed webassembly programs in other zig programs - be fast enough to be useful  ## status  - the project is very much alpha quality - webassembly 2.0 supported (apart from the vector / simd support which is wip) - the webassembly official testsuite passes (not including simd tests) - partial wasi support  ## running tests  use `zig build --help` to see all the test targets, here's a summary of the important ones:  ```sh zig build test      # run all the tests (includes unittest and testsuite) zig build unittest  # run the library unittests zig build testsuite # run all the testsuite tests zig build test-name # run the name testsuite test, i.e. test-type ```  ## does it run doom?  yes, [yes it does](https://github.com/malcolmstill/zware-doom)  https://github.com/malcolmstill/zware/assets/2567177/c9acdcb2-69e7-495f-b3f1-89cf6b807a43 ","cztomsik/tokamak":"Server-side framework for Zig, relying heavily on dependency injection. # tokamak  tokamak is a server-side framework for zig, built around [http.zig](https://github.com/karlseguin/http.zig) and a simple dependency injection container.  note, that it is **not designed to be used alone**, but with a reverse proxy in front of it, like nginx or cloudfront, which will handle ssl, caching, sanitization, etc.  > ### recent changes > - switched to [http.zig](https://github.com/karlseguin/http.zig) for improved >   performance over `std.http`. > - implemented hierarchical and introspectable routes. > - added basic swagger support. > - added `tk.static.dir()` for serving entire directories.  ## getting started  simple things should be easy to do.  ```zig const tk = @import('tokamak');  const routes = []const tk.route = &.{     .get('/', hello), };  fn hello() ![]const u8 {     return 'hello'; }  pub fn main() !void {     const server = try tk.server.start(allocator, routes, .{ .port = 8080 });     try server.start(); } ```  ## dependency injection  the framework is built around the concept of dependency injection. this means that your handler function can take any number of parameters, and the framework will try to provide them for you.  notable types you can inject are:  - `std.mem.allocator` (request-scoped arena allocator) - `*tk.request` (current request, including headers, body reader, etc.) - `*tk.response` (current response, with methods to send data, set headers, etc.) - `tk.injector` (the injector itself, see below) - and everything you provide yourself  for example, you can easily write a handler function which will create a string on the fly and return it to the client without any tight coupling to the server or the request/response types.  ```zig fn hello(allocator: std.mem.allocator) ![]const u8 {     return std.fmt.allocprint(allocator, 'hello {}', .{std.time.timestamp()}); } ```  if you return any other type than `[]const u8`, the framework will try to serialize it to json.  ```zig fn hello() !hellores {     return .{ .message = 'hello' }; } ```  if you need a more fine-grained control over the response, you can inject a `*tk.response` and use its methods directly.  > but this will of course make your code tightly coupled to respective types > and it should be avoided if possible.  ```zig fn hello(res: *tk.response) !void {     try res.json(.{ .message = 'hello' }, .{}); } ```  ## custom dependencies  you can also provide your own (global) dependencies by passing your own `tk.injector` to the server.  ```zig pub fn main() !void {     var db = try sqlite.open('my.db');     var cx = .{ &db };      const server = try tk.server.init(allocator, routes, .{         .injector = tk.injector.init(&cx, null),         .port = 8080     });      try server.start(); } ```  ## middlewares  we don't have 1:1 middleware support like in express.js, but given that our routes can be nested and that the `prefix`, `path` and `method` fields are optional, you can easily achieve the same effect.  for example, here's a simple function which will return a logger route:  ```zig fn logger(children: []const route) tk.route {     const h = struct {         fn handlelogger(ctx: *context) anyerror!void {             log.debug('{s} {s}', .{ @tagname(ctx.req.method), ctx.req.url });              return ctx.next();         }      };     return .{ .handler = &h.handlelogger, .children = children }; }  const routes = []const tk.route = &.{     logger(&.{         .get('/', hello),     }), }; ```  as you can see, the handler takes a `*context` and returns `anyerror!void`. it can do some pre-processing, logging, etc., and then call `ctx.next()` to continue with the next handler in the chain.   ## custom-scoping  zig doesn't have closures, so we can't just capture variables from the outer scope. but what we can do is to use our dependency injection context to provide some dependencies to any middleware or handler function further in the chain.  > middlewares do not support the shorthand syntax for dependency injection, > so you need to use `ctx.injector.get(t)` to get your dependencies manually.  ```zig fn auth(ctx: *context) anyerror!void {     const db = ctx.injector.get(*db);     const token = try jwt.parse(ctx.req.getheader('authorization'));     const user = db.find(user, token.id) catch null;      return ctx.nextscoped(&.{ user }); } ```  ## routing  there's a simple router built in, in the spirit of express.js. it supports up to 16 basic path params, and `*` wildcard. the example below shows how deps and params will be passed to the handler function.  ```zig const tk = @import('tokamak');  const routes: []const tk.route = &.{     .get('/', hello),                        // fn(...deps)     .get('/hello/:name', helloname),         // fn(...deps, name)     .get('/hello/:name/:age', hellonameage), // fn(...deps, name, age)     .get('/hello/*', hellowildcard),         // fn(...deps)     .post('/hello', hellopost),              // fn(...deps, body)     .post0('/hello', hellopost0),            // fn(...deps)     ... }; ```  there's also `route.router(t)` method, which accepts special dsl-like struct, which allows you to define routes together with the fns in a single place.  ```zig const routes: []const tk.route = &.{     tk.logger(.{}),     .get('/', tk.send('hello')),        // this is the classic, express-style routing     .group('/api', &.{ .router(api) }), // and this is our shorthand     .send(error.notfound), };  const api = struct {     pub fn @'get /'() []const u8 {         return 'hello';     }      pub fn @'get /:name'(allocator: std.mem.allocator, name: []const u8) ![]const u8 {         return std.fmt.allocprint(allocator, 'hello {s}', .{name});     } }; ```  ## error handling  if your handler returns an error, the framework will try to serialize it to json and send it to the client.  ```zig fn hello() !void {     // this will send 500 and {'error': 'todo'}     return error.todo; } ```  ## static files  to send a static file, you can use the `tk.static.file(path)` middleware.  ```zig const routes: []const tk.route = &.{     .get('/', tk.static.file('static/index.html')), }; ```  you can also serve entire directories with `tk.static.dir(path)`.  ```zig const routes: []const tk.route = &.{     tk.static.dir('public', .{}), }; ```  and of course, the `tk.static.dir()` also works with wildcard routes.  ```zig const routes: []const tk.route = &.{     tk.get('/assets/*', tk.static.dir('assets', .{ .index = null })), }; ```  if you want to embed some files into the binary, you can specify such paths to the `tokamak` module in your `build.zig` file.  ```zig const embed: []const []const u8 = &.{     'static/index.html', };  const tokamak = b.dependency('tokamak', .{ .embed = embed }); exe.root_module.addimport('tokamak', tokamak.module('tokamak')); ```  in this case, only the files listed in the `embed` array will be embedded into the binary and any other files will be served from the filesystem.  ## mime types  the framework will try to guess the mime type based on the file extension, but you can also provide your own in the root module.  ```zig pub const mime_types = tk.mime_types ++ .{     .{ '.foo', 'text/foo' }, }; ```  ## config  for a simple configuration, you can use the `tk.config.read(t, opts)` function, which will read the configuration from a json file. the `opts` parameter is optional and can be used to specify the path to the config file and parsing options.  ```zig const cfg = struct {     foo: u32,     bar: []const u8, };  const cfg = try tk.config.read(cfg, .{ .path = 'config.json' }); ```  there's also experimental `tk.config.write(t, opts)` function, which will write the configuration back to the file.  ## monitor  the `tk.monitor(procs)` allows you to execute multiple processes in parallel and restart them automatically if they exit. it takes a tuple of `{ name, fn_ptr, args_tuple }` triples as input. it will only work on systems with `fork()`.  what this means is that you can easily create a self-contained binary which will stay up and running, even if something crashes unexpectedly.  > the function takes over the main thread, forks, and it might lead to > unexpected behavior if you're not careful. only use it if you know what you're > doing.  ```zig monitor(.{     .{ 'server', &runserver, .{ 8080 } },     .{ 'worker', &runworker, .{} },     ... }); ```  ## license  mit ","natecraddock/ziglua":"Zig bindings for the Lua C API 404: not found","TinyVG/sdk":"TinyVG software development kit # tinyvg software development kit  this sdk enables you to work with the [tinyvg](https://tinyvg.tech/) vector graphics format.  ## contents  - native library (c abi) - zig package - command line tooling   - offline rendering (tvg -> tga)   - format conversion (svg <-> tvg <-> tvgt)  ## building  the sdk is implemented with [zig](https://ziglang.org/) 0.11.0 and [dotnet 6](https://dotnet.microsoft.com/en-us/).  to build the sdk (except `svg2tvgt`), do this:  ```sh-session [user@host sdk]$ zig build [user@host sdk]$ ```  this will then produce the folders `zig-cache` (for temporary files) and `zig-out`, which contains the sdk files for your current platform.  to build `svg2tvgt`, go into the folder `src/tools/svg2tvgt` and do this:  ```sh-session [user@host sdk]$ cd src/tools/svg2tvgt/ [user@host svg2tvgt]$ dotnet build msbuild version 17.3.2+561848881 for .net   determining projects to restore...   all projects are up-to-date for restore.   svg2tvgt -> /mnt/src/tools/svg2tvgt/bin/debug/net6.0/svg2tvgt.dll  build succeeded.     0 warning(s)     0 error(s)  time elapsed 00:00:00.69 [user@host svg2tvgt]$ ```  this will then produce `src/tools/svg2tvgt/bin/debug/net5.0/svg2tvgt` (or `.exe` if you are on windows). ","kubkon/emerald":"ld drop-in replacement written in Zig # emerald  `emerald` is a drop-in replacement for your system linker `ld` written in zig.  ## quick start guide  ### building  you will need zig 0.13.0 in your path. you can download it from [here](https://ziglang.org/download/).  ``` $ zig build ```  this will create the `ld.emerald` (elf), `ld64.emerald` (macho), `emerald-link.exe` (coff) and `wasm-emerald` (wasm) binaries in `zig-out/bin/`. you can then use it like you'd use a standard linker.  ``` $ cat <<eof > hello.c #include <stdio.h>  int main() {     fprintf(stderr, 'hello, world!╲n');     return 0; } eof  # create .o using system clang $ clang -c hello.c  # or, create .o using zig cc $ zig cc -c hello.c  # on macos $ ./zig-out/bin/ld64.emerald hello.o -o hello  # on linux $ ./zig-out/bin/ld.emerald hello.o -o hello  # run! $ ./hello ```  ### testing  if you'd like to run unit and end-to-end tests, run the tests like you'd normally do for any other zig project.  ``` $ zig build test ```  ## supported backends  - [x] mach-o (x86_64) - [x] mach-o (aarch64) - [x] elf (x86_64) - [x] elf (aarch64) - [ ] elf (riscv64) - [ ] coff (x86_64) - [ ] coff (aarch64) - [x] wasm (static)  ## contributing  you are welcome to contribute to this repo. ","ikskuh/zig-args":"Simple-to-use argument parser with struct-based config # zig argument parser simple-to-use argument parser with struct-based config  ## features - automatic option generation from a config struct - familiar *look & feel*:     - everything after the first `--` is assumed to be a positional argument     - a single `-` is interpreted as a positional argument which can be used as the stdin/stdout file placeholder     - short options with no argument can be combined into a single argument: `-dfe`     - long options can use either `--option=value` or `--option value` syntax (use `--option=--` if you need `--` as a long option argument)     - verbs (sub-commands), with verb specific options. non-verb specific (global) options can come before or after the       verb on the command line. non-verb option arguments are processed *before* determining verb.  (see `demo_verb.zig`) - integrated support for primitive types:     - all integer types (signed & unsigned)     - floating point types     - booleans (takes optional argument. if no argument given, the bool is set, otherwise, one of `yes`, `true`, `y`, `no`, `false`, `n` is interpreted)     - strings     - enumerations  ## use in your project  add the dependency in your `build.zig.zon` by running the following command: ```bash zig fetch --save=args git+https://github.com/ikskuh/zig-args#master ```  add it to your exe in `build.zig`: ```zig exe.root_module.addimport('args', b.dependency('args', .{ .target = target, .optimize = optimize }).module('args')); ```  then you can import it from your code: ```zig const argsparser = @import('args'); ```  ## example  ```zig const options = argsparser.parseforcurrentprocess(struct {     // this declares long options for double hyphen     output: ?[]const u8 = null,     @'with-offset': bool = false,     @'with-hexdump': bool = false,     @'intermix-source': bool = false,     numberofbytes: ?i32 = null,     signed_number: ?i64 = null,     unsigned_number: ?u64 = null,     mode: enum { default, special, slow, fast } = .default,      // this declares short-hand options for single hyphen     pub const shorthands = .{         .s = 'intermix-source',         .b = 'with-hexdump',         .o = 'with-offset',         .o = 'output',     }; }, argsallocator, .print) catch return 1; defer options.deinit();  std.debug.print('executable name: {?s}╲n', .{options.executable_name});  std.debug.print('parsed options:╲n', .{}); inline for (std.meta.fields(@typeof(options.options))) |fld| {     std.debug.print('╲t{s} = {any}╲n', .{         fld.name,         @field(options.options, fld.name),     }); }  std.debug.print('parsed positionals:╲n', .{}); for (options.positionals) |arg| {     std.debug.print('╲t'{s}'╲n', .{arg}); } ``` ","karlseguin/pg.zig":"Native PostgreSQL driver / client for Zig 404: not found","Arwalk/zig-protobuf":"a protobuf 3 implementation for zig. # zig-protobuf  -------  ## welcome!  this is an implementation of google protocol buffers version 3 in zig.  protocol buffers is a serialization protocol so systems, from any programming language or platform, can exchange data reliably.  protobuf's strength lies in a generic codec paired with user-defined 'messages' that will define the true nature of the data encoded.  messages are usually mapped to a native language's structure/class definition thanks to a language-specific generator associated with an implementation.  zig's compile-time evaluation becomes extremely strong and useful in this context: because the structure (a message) has to be known beforehand, the generic codec can leverage informations, at compile time, of the message and it's nature. this allows optimizations that are hard to get as easily in any other language, as zig can mix compile-time informations with runtime-only data to optimize the encoding and decoding code paths.  ## state of the implementation  this repository, so far, only aims at implementing [protocol buffers version 3](https://developers.google.com/protocol-buffers/docs/proto3#simple).  the latest version of the zig compiler used for this project is 0.13.0.  this project is currently able to handle all scalar types for encoding, decoding, and generation through the plugin.  ## branches  there are 2 branches you can use for your development.  * `master` is the branch with current developments, working with the latest stable release of zig. * `zig-master` is a branch that merges the developments in master, but works with the latest-ish master version of zig.   ## how to use  1. add `protobuf` to your `build.zig.zon`.       ```zig     .{         .name = 'my_project',         .version = '0.0.1',         .paths = .{''},         .dependencies = .{             .protobuf = .{                 .url = 'https://github.com/arwalk/zig-protobuf/archive/<some-commit-sha>.tar.gz',                 .hash = '12ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',                 // leave the hash as is, the build system will tell you which hash to put here based on your commit             },         },     }     ``` 1. use the `protobuf` module        ```zig     pub fn build(b: *std.build) !void {         // first create a build for the dependency         const protobuf_dep = b.dependency('protobuf', .{             .target = target,             .optimize = optimize,         });          // and lastly use the dependency as a module         exe.root_module.addimport('protobuf', protobuf_dep.module('protobuf'));     }     ```   ## generating .zig files out of .proto definitions  you can do this programatically as a compilation step for your application. the following snippet shows how to create a `zig build gen-proto` command for your project.  ```zig const protobuf = @import('protobuf');  pub fn build(b: *std.build) !void {     // first create a build for the dependency     const protobuf_dep = b.dependency('protobuf', .{         .target = target,         .optimize = optimize,     });          ...      const gen_proto = b.step('gen-proto', 'generates zig files from protocol buffer definitions');      const protoc_step = protobuf.runprotocstep.create(b, protobuf_dep.builder, target, .{         // out directory for the generated zig files         .destination_directory = b.path('src/proto'),         .source_files = &.{             'protocol/all.proto',         },         .include_directories = &.{},     });      gen_proto.dependon(&protoc_step.step); } ```  if you're really bored, you can buy me a coffe here.  [![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/n4n7vms4f) ","ziglibs/known-folders":"Provides access to well-known folders across several operating systems # zig known folders project  ## design goals  - minimal api surface - provide the user with an option to either obtain a directory handle or a path name - keep to folders that are available on all operating systems  ## api  ```zig pub const knownfolder = enum {     home,     documents,     pictures,     music,     videos,     desktop,     downloads,     public,     fonts,     app_menu,     cache,     roaming_configuration,     local_configuration,     global_configuration,     data,     runtime,     executable_dir, };  pub const error = error{ parseerror, outofmemory };  pub const knownfolderconfig = struct {     xdg_force_default: bool = false,     xdg_on_mac: bool = false, };  /// returns a directory handle, or, if the folder does not exist, `null`. pub fn open(allocator: std.mem.allocator, folder: knownfolder, args: std.fs.dir.openoptions) (std.fs.dir.openerror || error)!?std.fs.dir;  /// returns the path to the folder or, if the folder does not exist, `null`. pub fn getpath(allocator: std.mem.allocator, folder: knownfolder) error!?[]const u8; ```  ## installation  initialize a `zig build` project if you haven't already.  ```bash zig init ```  add the `known-folders` package to your `build.zig.zon`.  ```bash zig fetch --save git+https://github.com/ziglibs/known-folders.git ```  you can then import `known-folders` in your `build.zig` with:  ```zig const known_folders = b.dependency('known-folders', .{}).module('known-folders'); const exe = b.addexecutable(...); // this adds the known-folders module to the executable which can then be imported with `@import('known-folders')` exe.root_module.addimport('known-folders', known_folders); ```  ## configuration  in your root file, add something like this to configure known-folders:  ```zig pub const known_folders_config = .{     .xdg_on_mac = true, } ``` ","ikskuh/LoLa":"LoLa is a small programming language meant to be embedded into games. # lola programming language  ![lola logo](design/logo.png)  lola is a small programming language meant to be embedded into games to be programmed by the players. the compiler and runtime are implemented in zig and c++.  ## short example ```js var list = [ 'hello', 'world' ]; for(text in list) {   print(text); } ```  you can find more examples in the [examples](examples/lola) folder.  ## why lola when there is *x*? lola isn't meant to be your next best day-to-day scripting language. its design is focused on embedding the language in environments where the users want/need/should write some small scripts like games or scriptable applications. in most script languages, you as a script host don't have control over the execution time of the scripts you're executing. lola protects you against programming errors like endless loops and such:  ### controlled execution environment  every script invocation gets a limit of instructions it might execute. when either this limit is reached or the script yields for other reasons (asynchronous functions), the execution is returned to the host.  this means, you can execute the following script 'in parallel' to your application main loop without blocking your application *and* without requiring complex multithreading setups:  ```js var timer = 0; while(true) {   print('script running for ', timer, ' seconds.');   timer += 1;   sleep(1.0); } ```  ### native asynchronous design  lola features both synchronous and asynchronous host functions. synchronous host function calls are short-lived and will be executed in-place. asynchronous functions, in contrast, will be executed multiple times until they yield a value. when they don't yield a value, control will be returned to the script host.  this script will not exhaust the instruction limit, but will only increment the counter, then return control back to the host: ```js var counter = 0; while(true) {   counter += 1;   yield(); } ```  this behaviour can be utilized to wait for certain events in the host environment, for example to react to key presses, a script could look like this: ```js while(true) {   var input = waitforkey();   if(input == ' ') {     print('space was pressed!');   } } ```  *note that the current implementation is not thread-safe, but requires to use the limited execution for running scripts in parallel.*  ### native 'rpc' design  lola also allows executing multiple scripts on the same *environment*, meaning that you can easily create cross-script communications:  ```js // script a: var buffer; function set(val) { buffer = val; } function get() { return val; }  // script b: // getbuffer() returns a object referencing a environment for 'script a' var buffer = getbuffer(); buffer.set('hello, world!');  // script c: // getbuffer() returns a object referencing a environment for 'script a' var buffer = getbuffer();  print('buffer contains: ', buffer.get()); ```  with a fitting network stack and library, this can even be utilized cross-computer.  this example implements a small chat client and server that could work with lola rpc capabilities: ```js // chat client implementation: var server = connect('lola-rpc://random-projects.net/chat'); if(server == void) {   print('could not connect to chat server!');   exit(1); }  while(true) {   var list = server.getmessages(getuser());   for(msg in list) {     print('< ', msg);   }      print('> ');   var msg = readline();   if(msg == void)     break;   if(msg == '')     continue;   server.send(getuser(), msg); } ```  ```js // chat server implementation var messages = createdictionary();  function send(user, msg) {   for(other in messages.getkeys())   {     if(other != user) {       var log = messages.get(other);       if(log != void) {         log = log ++ [ user + ': ' + msg ];       } else {         log = [];       }       messages.set(other, log);     }   } }  function getmessages(user) {   var log = messages.get(user);   if(log != void) {     messages.set(user, []);     return log;   } else {     return [];   } } ```  ### serializable state  as lola has no reference semantics except for objects, it is easy to understand and learn. it is also simple in its implementation and does not require a complex garbage collector or advanced programming knowledge. each lola value can be serialized/deserialized into a sequence of bytes (only exception are object handles, those require some special attention), so saving the current state of a environment/vm to disk and loading it at a later point is a first-class supported use case.  this is especially useful for games where it is favourable to save your script state into a save game as well without having any drawbacks.  ### simple error handling  lola provides little to no in-language error handling, as it's not designed to be robust against user programming errors. each error is passed to the host as a panic, so it can show the user that there was an error (like `outofmemory` or `typemismatch`).  in-language error handling is based on the dynamic typing: functions that allow in-language error handling just return `void` instead of a actual return value or `true`/`false` for *success* or *failure*.   this allows simple error checking like this: ```js var string = readfile('demo.data'); if(string != void) {   print('file contained ', string); } ```  this design decision was made with the idea in mind that most lola programmers won't write the next best security critical software, but just do a quick hack in game to reach their next item unlock.  ### smart compiler  as lola isn't the most complex language, the compiler can support the programmer. even though the language has fully dynamic typing, the compiler can do some type checking at compile time already:  ```js // warning: possible type mismatch detected: expected number|string|array, found boolean if(a < true) { } ```  right now, this is only used for validating expressions, but it is planned to extend this behaviour to annotate variables as well, so even more type errors can be found during compile time.  note that this is a fairly new feature, it does not catch all your type mismatches, but can prevent the obvious ones.  ## starting points  to get familiar with lola, you can check out these starting points:  - [documentation](documentation/readme.md) - [lola examples](examples/lola/readme.md) - [script host examples](examples/host)  when you want to contribute to the compiler, check out the following documents:  - [source code](src/) - [bison grammar](src/library/compiler/grammar.yy) - [flex tokenizer](src/library/compiler/yy.l) - [issue list](https://github.com/masterq32/lola/issues)  ## visual studio code extension if you want syntax highlighting in vscode, you can install the [`lola-vscode`](https://github.com/masterq32/lola-vscode) extension.  right now, it's not published in the gallery, so to install the extension, you have to sideload it. [see the vscode documentation for this](https://vscode-docs.readthedocs.io/en/stable/extensions/install-extension/).  ## building  ### continous integration  [![build](https://github.com/masterq32/lola/actions/workflows/build.yml/badge.svg)](https://github.com/masterq32/lola/actions/workflows/build.yml) [![render website](https://github.com/masterq32/lola/actions/workflows/website.yml/badge.svg)](https://github.com/masterq32/lola/actions/workflows/website.yml)  ### requirements  - the [zig compiler](https://ziglang.org/) (version 0.12.0-dev.3438+5c628312b or newer)  ### building  ```sh zig build ./zig-cache/bin/lola ```  ### examples  to compile the host examples, you can use `zig build examples` to build all provided examples. these will be available in `./zig-cache/bin` then.  ### running the test suite  when you change things in the compiler or vm implementation, run the test suite:  ```sh zig build test ```  this will execute all zig tests, and also runs a set of predefined tests within the [`src/test/`](src/test/) folder. these tests will verify that the compiler and language runtime behave correctly.  ### building the website  the website generator is gated behind `-denable-website` which removes a lot of dependencies for people not wanting to render a new version of the website. if you still want to update/change the website or documentation, use the following command:  ```sh zig build -denable-website '-dversion=$(git describe --tags || git rev-parse --short head)' website ```  it will depend on [koino](https://github.com/kivikakk/koino), which is included as a git submodule. adding new pages to the documentation is done by modifying the `menu_items` array in `src/tools/render-md-page.zig`. ","fabioarnold/nanovg-zig":"A small anti-aliased hardware-accelerated vector graphics library nanovg - zig version ==========  this is a rewrite of the original [nanovg library](https://github.com/memononen/nanovg) using the [zig programming language](https://ziglang.org).  nanovg is a small anti-aliased hardware-accelerated vector graphics library. it has a lean api modeled after the html5 canvas api. it is aimed to be a practical and fun toolset for building scalable user interfaces or any other real time visualizations.  ## screenshot  ![screenshot of some text rendered with the example program](/examples/screenshot-01.png?raw=true)  ## examples  there's a webassembly example using webgl which you can immediately try here: https://fabioarnold.github.io/nanovg-zig. the source for this example can be found in [example_wasm.zig](/examples/example_wasm.zig) and can be built by running `zig build -dtarget=wasm32-freestanding`.  a native cross-platform example using [glfw](https://glfw.org) can be found in [example_glfw.zig](/examples/example_glfw.zig) and can be built and run with `zig build run`. it requires glfw to be installed. on windows [vcpkg](https://github.com/microsoft/vcpkg) is an additional requirement.  for an example on how to use nanovg-zig in your project's `build.zig` you can take a look at https://github.com/fabioarnold/minipixel/blob/main/build.zig.  ## features  * basic shapes: rect, rounded rect, ellipse, arc * arbitrary paths of bezier curves with holes * arbitrary stack-based 2d transforms * strokes with different types of caps and joins * fills with gradient support * types of gradients: linear, box (useful for shadows), radial * text with automatic linebreaks and blurring * images as pattern for fills and strokes  ### features exclusive to the zig version  * clip paths * image blurring  usage =====  the nanovg api is modeled loosely on the html5 canvas api. if you know canvas, you're up to speed with nanovg in no time.  ## creating a drawing context  the drawing context is created using a backend-specific initialization function. if you're using the opengl backend the context is created as follows: ```zig const nvg = @import('nanovg'); ... var vg = try nvg.gl.init(allocator, .{   .debug = true, }); defer vg.deinit(); ```  the second parameter defines options for creating the renderer.  - `antialias` means that the renderer adjusts the geometry to include anti-aliasing. if you're using msaa, you can omit this option to be default initialized as false.  - `stencil_strokes` means that the render uses better quality rendering for (overlapping) strokes. the quality is mostly visible on wider strokes. if you want speed, you can omit this option to be default initialized as false.  currently, there is an opengl backend for nanovg: [nanovg_gl.zig](/src/nanovg_gl.zig) for opengl 2.0 and webgl. webgl is automatically chosen when targeting webassembly. there's an interface called `params` defined in [internal.zig](src/internal.zig), which can be implemented by additional backends.  *note:* the render target you're rendering to must have a stencil buffer.  ## drawing shapes with nanovg  drawing a simple shape using nanovg consists of four steps: 1) begin a new shape, 2) define the path to draw,  3) set fill or stroke, 4) and finally fill or stroke the path.  ```zig vg.beginpath(); vg.rect(100,100, 120,30); vg.fillcolor(nvg.rgba(255,192,0,255)); vg.fill(); ```  calling `beginpath()` will clear any existing paths and start drawing from a blank slate. there are a number of functions to define the path to draw, such as rectangle, rounded rectangle and ellipse, or you can use the common moveto, lineto, bezierto and arcto api to compose a path step-by-step.  ## understanding composite paths  because of the way the rendering backend is built in nanovg, drawing a composite path - that is a path consisting of multiple paths defining holes and fills - is a bit more involved. nanovg uses the even-odd filling rule and by default the paths are wound in counterclockwise order. keep that in mind when drawing using the low-level drawing api. in order to wind one of the predefined shapes as a hole, you should call `pathwinding(nvg.winding.solidity(.hole))`, or `pathwinding(.cw)` **_after_** defining the path.  ```zig vg.beginpath(); vg.rect(100,100, 120,30); vg.circle(120,120, 5); vg.pathwinding(.cw); // mark circle as a hole. vg.fillcolor(nvg.rgba(255,192,0,255)); vg.fill(); ```  ## api reference  see [nanovg.zig](/src/nanovg.zig) for an api reference.  ## projects using nanovg-zig  - [minipixel by fabioarnold](https://github.com/fabioarnold/minipixel) - [snake by fabioarnold](https://fabioarnold.itch.io/snake)  ## license the original library and this rewrite are licensed under the [zlib license](license.txt)  fonts used in the examples: - roboto licensed under [apache license](http://www.apache.org/licenses/license-2.0) - entypo licensed under cc by-sa 4.0. - noto emoji licensed under [sil open font license, version 1.1](http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=ofl)  ## links uses [stb_truetype](http://nothings.org) for font rendering. uses [stb_image](http://nothings.org) for image loading. ","allyourcodebase/ffmpeg":"FFmpeg Zig package # ffmpeg packaged for zig  this is a fork of [ffmpeg](https://ffmpeg.org/), packaged for zig. unnecessary files have been deleted, and the build system has been replaced with `build.zig`.  there are no system dependencies; the only thing required to build this package is [zig](https://ziglang.org/download/).  zig api bindings are also provided via the 'av' module. see `doc/examples` for api usage examples.  ## differences from upstream  * only a single static library is produced. there is no option to create a   dynamic library. * the ffmpeg command line tool is not provided. perhaps this could be added if   desired. * documentation, tests, and tools are not provided. * this package enables everything supported by the target; it does not expose   configuration options to choose the set of supported codecs and formats. * the set of external library integrations is fixed.  ## external libraries included  * [x] libmp3lame * [x] libvorbis * [x] libogg  more can be added as desired.  ## update process  these are the instructions to update this package when a new ffmpeg version is released upstream.  1. merge the new tag into main and resolve all conflicts by replacing the    conflicting files with the files from upstream. 2. `find libavcodec/ libavdevice/ libavfilter/ libavformat libavutil/ libswscale/ libswresample/ -type f -name '*.asm' -o -name '*.c' -o -name '*.s'`    * edit to omit files ending in `_template.c` or `_tablegen.c`    * sort the list    * update the `all_sources` list in `build.zig`. 3. inspect the git diff to keep some of the source files commented out like    they were before. some handy filtering rules apply:    * `/l` prefix means linux-only    * `/w` prefix means windows-only 4. run `./configure --prefix=$home/local/ffmpeg --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-programs --enable-libmp3lame --enable-libvorbis --disable-shared --enable-static`    against upstream and diff the generated `config.h` file to the one generated    by this build script. apply appropriate changes to `build.zig`. 5. update these files which are generated by the upstream configure script:    * `config_components.h`    * `libavfilter/filter_list.c`    * `libavcodec/codec_list.c`    * `libavcodec/parser_list.c`    * `libavcodec/bsf_list.c`    * `libavformat/demuxer_list.c`    * `libavformat/muxer_list.c`    * `libavdevice/indev_list.c`    * `libavdevice/outdev_list.c`    * `libavformat/protocol_list.c` 6. update the `headers` list in `build.zig` based on what files are present in    `$home/local/ffmpeg/include`. ","ziglibs/zlm":"Zig linear mathemathics # zlm zig linear mathemathics library.  current provides the following types:  - `vec2` - `vec3` - `vec4` - `mat2` - `mat3` - `mat4`  the library is currently built around the opengl coordinate system and is fully generic on the basic data type.  ## example  ```zig const math = @import('zlm');  // use this namespace to get access to a vec3 with f16 fields instead of f32 const math_f16 = math.specializeon(f16);  /// accelerate the given velocity `v` by `a` over `t`. fn accelerate(v: math.vec3, a: math.vec3, t: f32) math.vec3 {   return v.add(a.scale(t)); } ``` ","alexnask/interface.zig":"Dynamic dispatch for zig made easy # zig interfaces  easy solution for all your zig dynamic dispatch needs!    ## features  - fully decoupled interfaces and implementations  - control over the storage/ownership of interface objects  - comptime support (including comptime-only interfaces)  - async function partial support (blocking on [#4621](https://github.com/ziglang/zig/issues/4621))  - optional function support  - support for manually written vtables    ## example    ```zig    const interface = @import('interface.zig');  const interface = interface.interface;  const selftype = interface.selftype;    // let us create a reader interface.  // we wrap it in our own struct to make function calls more natural.  const reader = struct {      pub const readerror = error { couldnotread };        const iface = interface(struct {            // our interface requires a single non optional, non-const read function.          read: fn (*selftype, buf: []u8) readerror!usize,        }, interface.storage.nonowning); // this is a non owning interface, similar to rust dyn traits.        iface: iface,        // wrap the interface's init, since the interface is non owning it requires no allocator argument.      pub fn init(impl_ptr: var) reader {          return .{ .iface = try iface.init(.{impl_ptr}) };      }        // wrap the read function call      pub fn read(self: *reader, buf: []u8) readerror!usize {          return self.iface.call('read', .{buf});      }        // define additional, non-dynamic functions!      pub fn readall(self: *self, buf: []u8) readerror!usize {          var index: usize = 0;          while (index != buf.len) {              const partial_amt = try self.read(buffer[index..]);              if (partial_amt == 0) return index;              index += partial_amt;          }          return index;      }  };    // let's create an example reader  const examplereader = struct {      state: u8,        // note that this reader cannot return an error, the return type      // of our implementation functions only needs to coerce to the      // interface's function return type.      pub fn read(self: examplereader, buf: []u8) usize {          for (buf) |*c| {              c.* = self.state;          }          return buf.len;      }  };    test 'use our reader interface!' {      var example_reader = examplereader{ .state=42 };        var reader = reader.init(&example_reader);        var buf: [100]u8 = undefined;      _ = reader.read(&buf) catch unreachable;  }    ```    see examples.zig for more examples.  ","ikskuh/zero-graphics":"Application framework based on OpenGL ES 2.0. Runs on desktop machines, Android phones and the web # zero graphics  a very minimal opengl es 2.0 library for zig. opens you a window and let's you draw things. comes with a pixel-perfect 2d renderer and maybe some day even with a bit of a 3d api.  ![logo](design/logo.png)  ## features  - multi-platform support   - desktop (linux, macos, windows, ...)   - webassembly   - android - pixel perfect 2d rendering   - primitives (line, rectangle, triangle, ...)   - text / ttf fonts   - textures - basic 3d rendering   - multi-mesh models with flat textures - zig-style immediate-mode user interface - proper dpi scaling support in renderer  ## project status  ### ci  the ci coverage currently looks like this:  | ·              | windows | macos | linux | | -------------- | ------- | ----- | ----- | | desktop        | ✅      | ✅    | ✅    | | webassembly    | ✅      | ✅    | ✅    | | android        | ✅      | ✅    | ✅    | | `zero-init`    | ✅      | ✅    | ✅    | | `zero-convert` | ✅      | ✅    | ✅    |  status: [![nightly build](https://github.com/masterq32/zero-graphics/actions/workflows/nightly.yml/badge.svg)](https://github.com/masterq32/zero-graphics/actions/workflows/nightly.yml)  ### previews  work-in-progress, but works quite well already. there is one [big project](https://github.com/dunstwolke/core) depending on it and is used as a _real-world application_ driver behind _zero graphics_.  ![preview screenshot for sdl2](documentation/screen01.png)  ![preview screenshot in firefox](https://mq32.de/public/7207fdc86224d69a7af0e8289c6b7a687c757cf8.png)  ## project goals  ### basic framework  - [ ] support the following platforms   - [x] wasm     - [x] create opengl es 2.0 context     - [x] input mouse     - [x] input keyboard   - [ ] linux desktop     - [x] create opengl es 2.0 context     - [x] input mouse     - [ ] input keyboard   - [ ] windows desktop (not tested, but should work via sdl2)   - [ ] android     - [x] create opengl es 2.0 context     - [x] input mouse     - [ ] input keyboard - [x] create an opengl es 2.0 context - [x] provide input events   - [x] single pointer motion (finger or mouse)   - [x] single click event (finger, mouse)   - [ ] text input for keyboard (utf-8 encoded) - [x] provide window events   - [x] resize   - [x] close - [x] provide access to the underlying backend - [ ] allow creation of single-file applications   - [ ] single executable for easy distribution   - [ ] embedded resources  ### 2d rendering library  - [ ] pixel perfect drawing of   - [x] lines   - [x] rectangles   - [ ] images     - [x] basic 'copy full texture to rectangle'     - [ ] copy portion of texture ('atlas rendering') - [x] ttf font rendering via [`stb_ttf`](https://github.com/nothings/stb) - [x] image loading via [`zigimg`](https://github.com/zigimg/zigimg) - [ ] stack based/nested scissoring  ### 3d rendering library  - [ ] tool based on assimp to convert models into loadable format   - [x] static geometry   - [ ] dynamic/animated geometry - [ ] blender export script - [x] draw static geometry - [ ] draw animated geometry   - [ ] skinning based on skeletons - [ ] axis- and camera aligned billboards - [ ] basic particles - [ ] tiny built-in pipeline with   - [ ] shadow mapping   - [ ] planar reflections   - [ ] water reflections  ## dependencies  ### desktop  - [sdl2](https://www.libsdl.org/)  ### web  - [js glue code](www/zero-graphics.js) - [root page](www/application.ztt)  ### android  - android sdk - android ndk - android build tools - openjdk - some other tools  ## building / running  this project uses [submodules](https://git-scm.com/book/en/v2/git-tools-submodules), so to get started, clone the repo with submodules recursively:  ```sh-session [user@computer work]$ git clone https://github.com/masterq32/zero-graphics --recurse-submodules ```  or, if you already cloned the repository:  ```sh-session [user@computer work]$ git clone https://github.com/masterq32/zero-graphics [user@computer work]$ cd zero-graphics/ [user@computer zero-graphics]$ git submodule update --init --recursive ```  ### desktop pc  requires `sdl2` to be installed.  ```sh-session [user@computer zero-graphics]$ zig build run ```  a window should open with the application in fullscreen.  the following environment variables can control how zero-graphics behaves:  - `zerog_fullscreen` is `y` for forced fullscreen or `n` for forced window mode. - `zerog_resizeable` is `y` for forced resizable window. - `zerog_dpi` is a number specifying the pixel density.  ### web/wasm version  includes a teeny tiny web server for debugging.  ```sh-session [user@computer zero-graphics]$ zig build install run-wasm ```  now visit http://127.0.0.1:8000/demo_application.htm to see the demo.  ### android  connect your phone first and install both a jdk as well as the android sdk with ndk included. the zerographics build system will tell you if it couldn't auto-detect the sdk paths.  ```sh-session [user@computer zero-graphics]$ zig build -denable-android run-app ```  the app should now be installed and started on your phone.  ## documentation  ### getting started  to create a new project, build this repository with `zig build` first. then use the tool `zero-init` from `zig-out/bin` to initialize a new project:  ```sh-session [felix@denkplatte-v2 ~]$ mkdir game [felix@denkplatte-v2 ~]$ cd game [felix@denkplatte-v2 game]$ /path/to/zero-graphics/zig-out/bin/zero-init symlink # initialize via symlink, quickest option. use zero-init -h to see all options [felix@denkplatte-v2 game]$ ls src  vendor  build.zig [felix@denkplatte-v2 game]$ zig build [felix@denkplatte-v2 game]$ zig build run info(sdl): sdl video driver:     x11 info(sdl): render resolution:  1280×720 info(sdl): virtual resolution: 1280×720 info(demo): opengl version:       opengl es 3.2 mesa 21.2.3 info(demo): opengl vendor:        amd info(demo): opengl renderer:      amd radeon(tm) vega 10 graphics (raven, drm 3.41.0, 5.13.19_1, llvm 12.0.1) info(demo): opengl glsl:          opengl es glsl es 3.20 info(zero_graphics): [shader compiler] [other] shader stats: sgprs: 16 vgprs: 8 code size: 212 lds: 0 scratch: 0 max waves: 10 spilled sgprs: 0 spilled vgprs: 0 privmem vgprs: 0 info(zero_graphics): [shader compiler] [other] shader stats: sgprs: 16 vgprs: 8 code size: 40 lds: 0 scratch: 0 max waves: 10 spilled sgprs: 0 spilled vgprs: 0 privmem vgprs: 0 info(zero_graphics): [shader compiler] [other] shader stats: sgprs: 8 vgprs: 24 code size: 52 lds: 0 scratch: 0 max waves: 10 spilled sgprs: 0 spilled vgprs: 0 privmem vgprs: 0 info(zero_graphics): [shader compiler] [other] shader stats: sgprs: 8 vgprs: 24 code size: 24 lds: 0 scratch: 0 max waves: 10 spilled sgprs: 0 spilled vgprs: 0 privmem vgprs: 0 info(zero_graphics): [shader compiler] [other] shader stats: sgprs: 8 vgprs: 8 code size: 60 lds: 0 scratch: 0 max waves: 10 spilled sgprs: 0 spilled vgprs: 0 privmem vgprs: 0 info(zero_graphics): [shader compiler] [other] shader stats: sgprs: 16 vgprs: 20 code size: 392 lds: 0 scratch: 0 max waves: 10 spilled sgprs: 0 spilled vgprs: 0 privmem vgprs: 0 ```  check out the file [`src/main.zig`](tools/zero-init/template/src/main.zig) to see your app skeleton. you can also adjust the [`build.zig`](tools/zero-init/template/build.zig) to set your project name.  the functions are roughly called in this order:  ![application workflow](documentation/app_flow.svg)  the separation between _application init_ and _graphics init_ is relevant for android apps which will destroy their window when you send it into the background and will recreate it when it is selected again. this means that all gpu content will be lost then and must be restored.  your application state will not be destroyed, so the rendering can render the same data as before.  ### architecture  `zero-graphics` follows a somewhat unusual architecture for zig applications. your applications is a _package_ that will be consumed by a `zero-graphics` host. this host is implementing the 'main loop' and will invoke both `update` and `render` periodically. it will also initialize and open the window and pump events.  this design allows `zero-graphics` to run on several different platforms, including most desktop pcs, android and even web browsers via webassembly.  you can check out the [sdk.zig](sdk.zig) file to find out how a application is built. ","akarpovskii/tuile":"A cross-platform Text UI (TUI) library in Zig <a name='readme-top'></a>  <!-- [![contributors][contributors-shield]][contributors-url] [![forks][forks-shield]][forks-url] [![stargazers][stars-shield]][stars-url] [![issues][issues-shield]][issues-url] [![mit license][license-shield]][license-url] [![linkedin][linkedin-shield]][linkedin-url] <br /> -->  <!-- project logo --> <div align='center'>   <!--a href='https://github.com/akarpovskii/tuile'>     <img src='images/logo.png' alt='logo' width='80' height='80'>   </a-->  <h3 align='center'>tuile</h3>    <p align='center'>     a text user interface library for zig.     <br />     breaking changes are possible.     <br />     <a href='https://github.com/akarpovskii/tuile'><strong>explore the docs »</strong></a>     <br />     <br />     <a href='https://github.com/akarpovskii/tuile/tree/main/examples'>view examples</a>     ·     <a href='https://github.com/akarpovskii/tuile/issues/new?labels=bug&template=bug-report.md'>report bug</a>     ·     <a href='https://github.com/akarpovskii/tuile/issues/new?labels=enhancement&template=feature-request.md'>request feature</a>   </p> </div>    <!-- table of contents --> <details>   <summary>table of contents</summary>   <ol>     <li>       <a href='#about-the-project'>about the project</a>     </li>     <li>       <a href='#getting-started'>getting started</a>       <ul>         <li><a href='#prerequisites'>prerequisites</a></li>         <li><a href='#installation'>installation</a></li>       </ul>     </li>     <li><a href='#usage'>usage</a></li>     <li><a href='#cross-compilation'>cross-compilation</a></li>     <li><a href='#roadmap'>roadmap</a></li>     <li><a href='#contributing'>contributing</a></li>     <li><a href='#license'>license</a></li>     <li><a href='#contact'>contact</a></li>     <li><a href='#acknowledgments'>acknowledgments</a></li>   </ol> </details>    <!-- about the project --> ## about the project  tuile is a text user interface library written in zig.  tuile uses [`crossterm`](docs/backends.md#crossterm) backend by default which works on all unix and windows terminals and supports cross-compilation (powered by [`build.crab`](https://github.com/akarpovskii/build.crab)).  see [`backends`](docs/backends.md) for the list of supported backends, or file a [feature request](https://github.com/akarpovskii/tuile/issues/new?labels=enhancement&template=feature-request.md) if you want to have another one added.  ![demo vhs recording](./examples/images/demo.png)  checkout the other examples [here](./examples/).  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>   <!-- getting started --> ## getting started  ### prerequisites  * zig 0.12.0+  * non-default [`backends`](docs/backends.md) may have additional requirements.  ### installation  1. add dependency to your `build.zig.zon`  ```sh zig fetch --save https://github.com/akarpovskii/tuile/archive/refs/tags/v0.1.3.tar.gz ```  2. import tuile in `build.zig`:  ```zig const tuile = b.dependency('tuile', .{}); exe.root_module.addimport('tuile', tuile.module('tuile')); ```  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>    <!-- usage examples --> ## usage  ```zig const tuile = @import('tuile');  pub fn main() !void {     var tui = try tuile.tuile.init(.{});     defer tui.deinit();      try tui.add(         tuile.block(             .{                 .border = tuile.border.all(),                 .border_type = .rounded,                 .layout = .{ .flex = 1 },             },             tuile.label(.{ .text = 'hello world!' }),         ),     );      try tui.run(); } ```  you can find more examples in the [examples folder](./examples/)  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>    <!-- cross-compilation --> ## cross-compilation  to compile an application that uses tuile for another target, just add `-dtarget=<desired target>` when building your app and make sure to forward it to tuile:  #### **`build.zig`** ```zig const target = b.standardtargetoptions(.{}); const tuile = b.dependency('tuile', .{   .target = target }); ```  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>    <!-- roadmap --> ## roadmap  in no particular order:  - [ ] documentation - [ ] grid layout - [ ] windows and dialogs - [ ] menu bar - [ ] more widgets  see the [open issues][issues-url] for a full list of proposed features (and known issues).  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>    <!-- contributing --> ## contributing  if you have a suggestion that would make this better, please fork the repo and create a pull request. you can also simply open an issue with the tag 'enhancement'. don't forget to give the project a star! thanks!  1. fork the project 2. create your feature branch (`git checkout -b feature/amazing-feature`) 3. commit your changes (`git commit -m 'add some amazing feature'`) 4. push to the branch (`git push origin feature/amazing-feature`) 5. open a pull request  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>    <!-- license --> ## license  distributed under the mit license. see [`license`][license-url] for more information.  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>    <!-- acknowledgments --> ## acknowledgments  * [best-readme-template](https://github.com/othneildrew/best-readme-template)  <p align='right'>(<a href='#readme-top'>back to top</a>)</p>    <!-- markdown links & images --> <!-- https://www.markdownguide.org/basic-syntax/#reference-style-links --> [contributors-shield]: https://img.shields.io/github/contributors/akarpovskii/tuile.svg?style=for-the-badge [contributors-url]: https://github.com/akarpovskii/tuile/graphs/contributors [forks-shield]: https://img.shields.io/github/forks/akarpovskii/tuile.svg?style=for-the-badge [forks-url]: https://github.com/akarpovskii/tuile/network/members [stars-shield]: https://img.shields.io/github/stars/akarpovskii/tuile.svg?style=for-the-badge [stars-url]: https://github.com/akarpovskii/tuile/stargazers [issues-shield]: https://img.shields.io/github/issues/akarpovskii/tuile.svg?style=for-the-badge [issues-url]: https://github.com/akarpovskii/tuile/issues [license-shield]: https://img.shields.io/github/license/akarpovskii/tuile.svg?style=for-the-badge [license-url]: https://github.com/akarpovskii/tuile/blob/master/license.txt [examples-url]: https://github.com/akarpovskii/tuile/tree/main/examples [linkedin-shield]: https://img.shields.io/badge/-linkedin-black.svg?style=for-the-badge&logo=linkedin&colorb=555 [linkedin-url]: https://linkedin.com/in/akarpovskii [product-screenshot]: images/screenshot.png ","hexops-graveyard/mach-gpu-dawn":"Google's Dawn WebGPU implementation, cross-compiled with Zig into a single static library ## deprecated  this project has been deprecated and is no longer maintained.  rationale: https://github.com/hexops/mach/issues/1166 ","karlseguin/zul":"zig utility library 404: not found","freref/fancy-cat":"PDF reader for terminal emulators using the Kitty image protocol # fancy-cat a pdf viewer for terminals using the kitty image protocol. ![demo](https://github.com/user-attachments/assets/b1edc9d2-3b1f-437d-9b48-c196d22fcbbd) [^1] [^1]: this demo shows me editing a typst file that automatically compiles with each change, prompting fancy-cat to re-render whenever the pdf updates. > [!note]   > this project is under active development ## usage the keymappings and other options can be found and changed in the config file [here](./src/config.zig). ## build instructions ### requirements - zig version ``0.13.0`` - terminal emulator with the kitty image protocol (e.g. kitty, ghostty, wezterm, etc.) - [mupdf](https://mupdf.readthedocs.io/en/latest/quick-start-guide.html) #### macos ``` sh brew install mupdf ``` #### linux ``` sh apt install ╲     libmupdf-dev ╲     libharfbuzz-dev ╲     libfreetype6-dev ╲     libjbig2dec0-dev ╲     libjpeg-dev ╲     libopenjp2-7-dev ╲     libgumbo-dev ╲     libmujs-dev ╲     zlib1g-dev ``` > [!important]   > on some linux distributions (e.g., fedora, arch), replace `mupdf-third` with `mupdf` in ``build.zig`` to compile successfully. ### build ```sh zig build --fetch ``` ### run ``` zig build run -- <path-to-pdf> <optional-page-number> ``` ## features - [x] filewatch (hot-reload) - [x] custom keymapping - [x] dark-mode - [x] zoom - [x] status bar - [ ] cache - [ ] search ## contributing contributions are welcome. ","ikskuh/zig-qoi":"Quite OK Image format encoder/decoder written in Zig # zig-qoi  a implementation of the [_quite ok image format_](https://qoiformat.org/) for zig. this implementation conforms to the [qoi specification](https://qoiformat.org/qoi-specification.pdf).  ![](design/logo.png)  ## api  add `src/qoi.zig` to your zig project as a package.  ```zig pub const decodeerror = error{ outofmemory, invaliddata, endofstream }; pub const encodeerror = error{ outofmemory };  // simple api:  pub fn isqoi(bytes: []const u8) bool; pub fn decodebuffer(allocator: std.mem.allocator, buffer: []const u8) decodeerror!image; pub fn decodestream(allocator: std.mem.allocator, reader: anytype) !image;  pub fn encodebuffer(allocator: std.mem.allocator, image: constimage) encodeerror![]u8; pub fn encodestream(image: constimage, writer: anytype) !void;  // streaming api: pub fn encoder(writer: anytype) encoder(@typeof(writer)); pub fn encoder(comptime writer: type) type {    return struct {       writer: writer,       pub fn reset(self: *self) void;       pub fn flush(self: *self) (encodeerror || writer.error)!void;       pub fn push(self: *self, pixel: color) (encodeerror || writer.error)!void;    }; }  pub const colorrun = struct {    color: color,    length: usize, };  pub fn decoder(reader: anytype) decoder(@typeof(reader)); pub fn decoder(comptime reader: type) type {    return struct {       reader: reader,       pub fn fetch(self: *self) reader.error!colorrun;    }; } ```  ## implementation status  everything specified in https://github.com/phoboslab/qoi/issues/37 is implemented and accessible via the api.  ## performance  on my machine (amd ryzen 7 3700u), i did a small benchmark with decoding `bench.zig`, which will decode `zero.qoi`:  | build mode   | qoi bytes   | raw bytes      | encoding time | decoding time | | ------------ | ----------- | -------------- | ------------- | ------------- | | debug        | 75.024 byte | 1.048.576 byte | 14.439ms      | 7.061ms       | | releasesmall | 75.024 byte | 1.048.576 byte | 1.888ms       | 1.499ms       | | releasesafe  | 75.024 byte | 1.048.576 byte | 1.392ms       | 512.706us     | | releasefast  | 75.024 byte | 1.048.576 byte | 1.186ms       | 456.762us     |  this means that this implementation is roughly able to decode ~2.1 gb/s raw texture data and is considered 'fast enough' for now. if you find some performance improvements, feel free to pr it!  running perf on the benchmark compiled with releasefast showed that the implementation is quite optimal for the cpu, utilizing it to 100% and executing up to 3 instructions per cycle on my machine.  ```sh-console [felix@denkplatte-v2 zig-qoi]$ perf stat ./zig-out/bin/qoi-bench benchmark [4067/4096] encoding time for 1048576 => 75024 bytes: 1.019ms benchmark [4067/4096] decoding time for 75024 => 1048576 bytes: 419.223us   performance counter stats for './zig-out/bin/qoi-bench':            9.665,11 msec task-clock:u              #    0,997 cpus utilized                  0      context-switches:u        #    0,000 k/sec                  0      cpu-migrations:u          #    0,000 k/sec             21.066      page-faults:u             #    0,002 m/sec     29.757.225.002      cycles:u                  #    3,079 ghz                      (83,33%)        317.453.390      stalled-cycles-frontend:u #    1,07% frontend cycles idle     (83,33%)        515.819.113      stalled-cycles-backend:u  #    1,73% backend cycles idle      (83,32%)     83.377.885.642      instructions:u            #    2,80  insn per cycle                                                   #    0,01  stalled cycles per insn  (83,36%)     18.947.655.057      branches:u                # 1960,417 m/sec                    (83,31%)        193.594.708      branch-misses:u           #    1,02% of all branches          (83,35%)         9,693303129 seconds time elapsed         9,553127000 seconds user        0,112001000 seconds sys ```  also, running the [benchmark dataset](https://qoiformat.org/benchmark/) of the original author, it yielded the [following data](data/benchmark.csv):  ``` number of total images:             1351 average png compression:              18.57% average qoi compression:              22.70% average compression rate (mb/s):     438.31 mb/s minimal compression rate (mb/s):      27.06 mb/s maximum compression rate (mb/s):    1390.15 mb/s average decompression rate (mb/s):  1128.46 mb/s maximum decompression rate (mb/s):    39.77 mb/s maximum deompression rate (mb/s):  13307.20 mb/s ```  [see also the original analysis on google docs](https://docs.google.com/spreadsheets/d/1gutm4a2txfzxeb6mrwbcmfidju3s2iv-s3om_soo_4q/edit?usp=sharing)  ## contribution  run the test suite like this:  ```sh-console [user@host zig-qoi]$ zig build test all 5 tests passed. ```  run the benchmark like this:  ```sh-console [user@host zig-qoi]$ zig build benchmark benchmark [4096/4096] encoding time for 1048576 => 67076 bytes: 16.649ms benchmark [4095/4096] decoding time for 67076 => 1048576 bytes: 5.681ms ```  to run the benchmark for batch files, run this:  ```sh-console [user@host zig-qoi]$ zig build install && ./zig-out/bin/qoi-bench-files $(folder_a) $(folder_b) ... file name       width   height  total raw bytes  total png bytes png compression  total qoi bytes  qoi compression  qoi to png          decode time (ns)  encode time (ns) data/zero.png   512     512     1048576          80591           0.08             67076            0.06             0.8323013782501221  5628360           14499346 total sum       0       0       1048576          80591           0.08             67076            0.06             0.8323013782501221  5628360           14499346 ```  pass as many folders you like to the benchmarking tool. it will render a csv file on the `stderr`. ","ziglibs/s2s":"A zig binary serialization format. # struct to stream | stream to struct  a zig binary serialization format and library.  ![project logo](design/logo.png)  ## features  - convert (nearly) any zig runtime datatype to binary data and back. - computes a stream signature that prevents deserialization of invalid data. - no support for graph like structures. everything is considered to be tree data.  **unsupported types**:  - all `comptime` only types - unbound pointers (c pointers, pointer to many) - `volatile` pointers - untagged or `external` unions - opaque types - function pointers - frames  ## api  the library itself provides only some apis, as most of the serialization process is not configurable.  ```zig /// serializes the given `value: t` into the `stream`. /// - `stream` is a instance of `std.io.writer` /// - `t` is the type to serialize /// - `value` is the instance to serialize. fn serialize(stream: anytype, comptime t: type, value: t) streamerror!void;  /// deserializes a value of type `t` from the `stream`. /// - `stream` is a instance of `std.io.reader` /// - `t` is the type to deserialize fn deserialize(stream: anytype, comptime t: type) (streamerror || error{unexpecteddata,endofstream})!t;  /// deserializes a value of type `t` from the `stream`. /// - `stream` is a instance of `std.io.reader` /// - `t` is the type to deserialize /// - `allocator` is an allocator require to allocate slices and pointers. /// result must be freed by using `free()`. fn deserializealloc(stream: anytype, comptime t: type, allocator: std.mem.allocator) (streamerror || error{ unexpecteddata, outofmemory,endofstream })!t;  /// releases all memory allocated by `deserializealloc`. /// - `allocator` is the allocator passed to `deserializealloc`. /// - `t` is the type that was passed to `deserializealloc`. /// - `value` is the value that was returned by `deserializealloc`. fn free(allocator: std.mem.allocator, comptime t: type, value: t) void; ```  ## usage and development  ### adding the library  just add the `s2s.zig` as a package to your zig project. it has no external dependencies.  ### running the test suite  ```sh-session [user@host s2s]$ zig test s2s.zig all 3 tests passed. [user@host s2s]$ ```  ## project status  most of the serialization/deserialization is implemented for the _trivial_ case.  pointers/slices with non-standard alignment aren't properly supported yet. ","alexnask/ctregex.zig":"Compile time regular expressions in zig # zig compile time regular expressions generating fast code since 2020  ## features - comptime regular expression compilation - comptime and runtime matching - utf8, utf16le, ascii, codepoint array support - captures (with named `(:<name>...)` support) - `|`, `*`, `+`, `?`, `(:?...)`, `[...]`, `[^...]`, `{n}`, `{min,}`, `{min,max}` - '╲d', '╲s' character classes  ## todo - faster generated code using dfas when possible - search, findall, etc. - more character classes - more features (backreferences etc.)  ## example  ```zig test 'runtime matching' {     @setevalbranchquota(1250);     // the encoding is utf8 by default, you can use .ascii, .utf16le, .codepoint here instead.     if (try match('(?<test>def|abc)([😇ω])+', .{.encoding = .utf8}, 'abc😇ωωωωω')) |res| {         std.debug.warn('test: {}, 1: {}╲n', .{ res.capture('test'), res.captures[1] });     } }  test 'comptime matching' {     @setevalbranchquota(2700);     if (comptime try match('(?<test>def|abc)([😇ω])+', .{}, 'abc😇ωωωωω')) |res| {         @compileerror('test: ' ++ res.capture('test').? ++ ', 1: ' ++ res.captures[1].?);     } } ```  see tests.zig for more examples.   [small benchmark with ctregex, pcre2](https://gist.github.com/alexnask/c537360ae0163863564fba6e660f442b)   ","batiati/mustache-zig":"Logic-less templates for Zig 404: not found","saltzm/async_io_uring":"An event loop in Zig using io_uring and coroutines  # overview  `asynciouring` is an event loop that wraps the `io_uring` library with coroutines support. it supports all `io_uring` operations (with the intentional exception of `poll_update`╲*).   in addition, it allows: * adding timeouts to operations * manual cancellation of operations * writing custom operations for advanced use cases  it is currently functionally complete, though there are a few `todo`s marked in the source related to polishing the api. it's not used in production anywhere currently.  see `src/async_io_uring.zig` for full api documentation.  see the `examples` directory for an echo client and server that use the event loop.  ╲* if you need this for some reason, please create an issue.  > :warning: **the `main` branch of `async_io_uring` will follow changes to zig's `master` branch to stay up-to-date with changes to the `io_uring` api (among others).** see the tagged releases of `async_io_uring` that are marked to work with specific stable versions of zig. (e.g., release v0.1.0 works with zig 0.9.1)  ## table of contents * [background](#background) * [goals](#goals) * [installation](#installation) * [example usage](#example-usage)     * [echo client](#echo-client)     * [operation timeouts](#operation-cancellation)     * [operation cancellation](#operation-cancellation)  --- # background  as an overview for the unfamiliar, `io_uring` is a new-ish linux kernel feature  that allows users to enqueue requests to perform syscalls into a submission queue (e.g. a request to read from a socket) and then submit the submission queue to the kernel for processing.  when requests from the submission queue have been satisfied, the result is placed onto completion queue by the kernel. the user is able to either poll the kernel for completion queue results or block until results are available.  zig's `io_uring` library provides a convenient interface to the kernel's `io_uring` functionality. the user of `io_uring`, however, still has to manually deal with submitting requests to the kernel and retrieving events from the completion queue, which can be tedious.  this library wraps the `io_uring` library by adding an event loop that handles request submission and completion, and provides an interface for each syscall that uses zig's `async` functionality to suspend execution of the calling code until the syscall has been completed. this lets the user write code that looks like blocking code, while still allowing for concurrency even within a single thread.  # goals  * **minimal**: wraps the `io_uring` library in the most lightweight way   possible. this means it still uses the `io_uring` data structures in many   places, like for completion queue entries. there are no additional internal   data structures other than the submission queue and completion queue used by   the `io_uring` library. this means there's no heap allocation. it also relies   entirely on kernel functionality for timeouts and cancellation. * **complete**: you should be able to do anything with this that you could do   with `io_uring`. * **easy to use**: because of the use of coroutines, code written with this   library looks almost identical to blocking code. in addition, operation   timeouts and cancellation support is integrated into the api for all operations. * **performant**: the library does no heap allocation and there's minimal   additional logic on top of `suspend`/`resume`.   # installation   this library integrates with the [zigmod](https://github.com/nektro/zigmod) package manager. if you've installed `zigmod`, you can add a line like the following to your `root_dependencies` in the `zig.mod` file of your project  and run `zigmod fetch`: ```yml root_dependencies:   - ...   - src: git https://github.com/saltzm/async_io_uring.git ```  you'll then be able to include `async_io_uring.zig` by doing something like: ```zig const io = @import('async_io_uring'); ```  the examples directory is structured roughly as you might structure a project that uses `async_io_uring`, with a working `zig.mod` file and `build.zig` that can serve as examples.  you'll also need a linux kernel version that supports all of the `io_uring` features you'd like to use. (all testing was done on version 5.13.0.)  # example usage  ## echo client  jumping right into a realistic example, the following is a snippet of code from the echo client in the `examples` directory:  ```zig const io = @import('async_io_uring');  pub fn run_client(ring: *asynciouring) !void {     // make a data structure that lets us do async file i/o with the same     // syntax as `std.debug.print`.     var writer = try asyncwriter.init(ring, std.io.getstderr().handle);      // address of the echo server.     const address = try net.address.parseip4('127.0.0.1', 3131);      // open a socket for connecting to the server.     const server = try os.socket(address.any.family, os.sock.stream | os.sock.cloexec, 0);     defer {         _ = ring.close(server, null, null) catch {             std.os.exit(1);         };     }      // connect to the server.     _ = try ring.connect(server, &address.any, address.getossocklen(), null, null);      const stdin_file = std.io.getstdin();     const stdin_fd = stdin_file.handle;     var input_buffer: [256]u8 = undefined;      while (true) {         // prompt the user for input.         try writer.print('input: ', .{});          const read_timeout = os.linux.kernel_timespec{ .tv_sec = 10, .tv_nsec = 0 };         // read a line from stdin with a 10 second timeout.         // this is the more verbose api - you can also do `ring.read`.         const read_cqe = ring.do(             io.read{ .fd = stdin_fd, .buffer = input_buffer[0..], .offset = input_buffer.len },             io.timeout{ .ts = &read_timeout, .flags = 0 },             null,         ) catch |err| {             if (err == error.cancelled) {                 try writer.print('╲ntimed out waiting for input, exiting...╲n', .{});                 return;             } else return err;         };          const num_bytes_read = @intcast(usize, read_cqe.res);          // send it to the server.         _ = try ring.send(server, input_buffer[0..num_bytes_read], 0, null, null);          // receive response.         const recv_cqe = try ring.recv(server, input_buffer[0..], 0, null, null);          const num_bytes_received = @intcast(usize, recv_cqe.res);         try writer.print('received: {s}╲n', .{input_buffer[0..num_bytes_received]});     } } ```  ## operation timeouts  `asynciouring` supports adding timeouts to all operations. adding a timeout to an operation causes it to be cancelled after the specified timeout, returning an error code `error.cancelled` if cancellation was successful.  an example from the unit tests:  ```zig fn testreadthattimesout(ring: *asynciouring) !void {     var read_buffer = [_]u8{0} ** 20;      const ts = os.linux.kernel_timespec{ .tv_sec = 0, .tv_nsec = 10000 };     // try to read from stdin - there won't be any input so this should     // reliably time out.     const read_cqe = ring.do(         read{ .fd = std.io.getstdin().handle, .buffer = read_buffer[0..], .offset = 0 },         timeout{ .ts = &ts, .flags = 0 },         null,     );     try std.testing.expectequal(read_cqe, error.cancelled); } ```  ## operation cancellation  `asynciouring` supports cancellation for all operations. each operation is  identified by an `id` that is set via a `maybe_id` 'output parameter' in all operation submission functions (e.g. `read`, `send`, etc.). this `id` can then be passed to `asynciouring.cancel` to cancel that operation.  an example from the unit tests:  ```zig fn testreadthatiscancelled(ring: *asynciouring) !void {     var read_buffer = [_]u8{0} ** 20;      var op_id: u64 = undefined;      // try to read from stdin - there won't be any input so this operation should     // reliably hang until cancellation.     var read_frame = async ring.do(         read{ .fd = std.io.getstdin().handle, .buffer = read_buffer[0..], .offset = 0 },         null,         &op_id,     );      const cancel_cqe = try ring.cancel(op_id, 0, null, null);     // expect that cancellation succeeded.     try std.testing.expectequal(cancel_cqe.res, 0);      const read_cqe = await read_frame;     try std.testing.expectequal(read_cqe, error.cancelled); } ``` ","batiati/IUPforZig":"IUP (Portable User Interface Toolkit) bindings for the Zig language. 404: not found","cryptocode/zigfsm":"A finite state machine library for Zig <img align='right' width='160' height='160' src='https://user-images.githubusercontent.com/34946442/152222895-9c8adb22-a22d-4bce-a513-3486ca28bdd5.png'> zig**fsm** is a [finite state machine](https://en.wikipedia.org/wiki/finite-state_machine) library for zig.  this library supports zig 0.12.x, 0.13 as well as zig master. last test was on zig version `0.14.0-dev.1912+9fd61f746`  use the zigfsm main branch to compile with zig master. use the appropriate zig-*version* tag to target a zig version not compatible with the main branch.  tested on linux, macos, freebsd and windows.  ## table of contents * [features](#features) * [motivation](#motivation) * [using zigfsm](#using-zigfsm)   * [building](#building)   * [importing the library](#importing-the-library)   * [learning from the tests](#learning-from-the-tests)   * [creating a state machine type](#creating-a-state-machine-type)   * [making an instance](#making-an-instance)   * [adding state transitions](#adding-state-transitions)   * [optionally defining events](#optionally-defining-events)   * [defining transitions and events at the same time](#defining-transitions-and-events-at-the-same-time)   * [defining transitions and events as a table](#defining-transitions-and-events-as-a-table)   * [changing state](#changing-state)   * [probing the current state](#probing-the-current-state)   * [inspecting what transition happened](#inspecting-what-transition-happened)   * [valid states iterator](#valid-states-iterator)   * [importing state machines](#importing-state-machines)   * [transition handlers](#transition-handlers)      * [canceling transitions](#canceling-transitions)  ## features * never allocates * works at both comptime and runtime * fast transition validation * compact memory representation * state machines can export themselves to the graphviz dot format * defined programmatically or by importing graphviz or libfsm text (even at compile time) * imported state machines can autogenerate state- and event enums * optional event listeners can add functionality and cancel transitions * push-down automaton wrappers are easy to write (see gamestate example in tests.zig) * comprehensive test coverage which also serves as examples  ## motivation using an fsm library may have some benefits over hand-written state machines: * many real-world processes, algorithms, and protocols have rigorously defined state machines available. these can be imported directly or programmatically into zigfsm. * can lead to significant simplification of code, as transition rules are explicitly stated in one place. contrast this with the brittleness of manually checking and documenting which states can follow a certain state when a certain event happens. * an invalid state transition is an immediate error with useful contextual information.  * you get visualization for free, which is helpful during development, debugging and as documentation.  ## using zigfsm before diving into code, it's worth repeating that zigfsm state machines can generate their own diagram, as well as import them. this can be immensely helpful when working on your state machines, as you get a simple visualization of all transitions and events. obviously, the diagrams can be used as part of your documentation as well.  here's the diagram from the csv parser test, as generated by the library:  ![csv](https://user-images.githubusercontent.com/34946442/150114019-8dc15ab1-35b9-4631-98b4-976dbb1217c3.png)  diagrams can be exported to any writer using `exportgraphviz(...)`, which accepts `statemachine.exportoptions` to change style and layout.  a png can be produced using the following command: `dot -tpng csv.gv -o csv.png`  ### building to build, test and benchmark:  ``` zig build -doptimize=releasefast zig build test zig build benchmark ```  the benchmark always runs under releasefast.  ### importing the library  add zigfsm as a zig package to your `zon` file, or simply import `main.zig` directly if vendoring.  here's how to update your zon file using the latest commit of zigfsm:  ```bash zig fetch --save git+https://github.com/cryptocode/zigfsm ```  next, update your `build.zig` to add zigfsm as an import. for example:  ```zig exe.root_module.addimport('zigfsm', b.dependency('zigfsm', .{}).module('zigfsm')); ```  now you can import zigfsm from any zig file:  ```zig // this example implements a simple moore machine: a three-level intensity lightswitch const std = @import('std'); const zigfsm = @import('zigfsm');  pub fn main() !void {     // a state machine type is defined using state enums and, optionally, event enums.     // an event takes the state machine from one state to another, but you can also switch to     // other states without using events.     //     // state and event enums can be explicit enum types, comptime generated enums, or     // anonymous enums like in this example.     //     // if you don't want to use events, simply pass null to the second argument.     // we also define what state is the initial one, in this case .off     var fsm = zigfsm.statemachine(enum { off, dim, medium, bright }, enum { click }, .off).init();      // there are many ways to define transitions (and optionally events), including importing     // from graphviz. in this example we use a simple api to add events and transitions.     try fsm.addeventandtransition(.click, .off, .dim);     try fsm.addeventandtransition(.click, .dim, .medium);     try fsm.addeventandtransition(.click, .medium, .bright);     try fsm.addeventandtransition(.click, .bright, .off);      std.debug.assert(fsm.iscurrently(.off));      // do a full cycle: off -> dim -> medium -> bright -> off     _ = try fsm.do(.click);     _ = try fsm.do(.click);     _ = try fsm.do(.click);     _ = try fsm.do(.click);      // make sure we're in the expected state     std.debug.assert(fsm.iscurrently(.off));     std.debug.assert(fsm.cantransitionto(.dim)); } ```  ### learning from the tests  a good way to learn zigfsm is to study the [tests](https://github.com/cryptocode/zigfsm/blob/main/src/tests.zig) file.  this file contains a number of self-contained tests that also demonstrates various aspects of the library.  ### creating a state machine type  a state machine type is defined using state enums and, optionally, event enums.  here we create an fsm for a button that can be clicked to flip between on and off states. the initial state is `.off`:  ```zig const state = enum { on, off }; const event = enum { click }; const fsm = zigfsm.statemachine(state, event, .off); ```  if you don't need events, simply pass null:  ```zig const fsm = zigfsm.statemachine(state, null, .off); ```  ### making an instance now that we have a state machine *type*, let's create an instance with an initial state :  ```zig var fsm = fsm.init(); ```  if you don't need to reference the state machine type, you can define the type and get an instance like this:  ```zig var fsm = zigfsm.statemachine(state, event, .off).init(); ```  you can also pass anonymous state/event enums:  ```zig var fsm = zigfsm.statemachine(enum { on, off }, enum { click }, .off).init(); ```  ### adding state transitions  ```zig try fsm.addtransition(.on, .off); try fsm.addtransition(.off, .on); ```  ### optionally defining events  while `transitionto` can now be used to change state, it's also common to invoke state transitions using events. this can vastly simplify using and reasoning about your state machine.  the same event can cause different transitions to happen, depending on the current state.  let's define what `.click` means for the on and off states:  ```zig try fsm.addevent(.click, .on, .off); try fsm.addevent(.click, .off, .on); ```  this expresses that if `.click` happens in the `.on` state, then transition to the `.off` state, and vice versa.  ### defining transitions and events at the same time a helper function is available to define events and state transitions at the same time:  ```zig try fsm.addeventandtransition(.click, .on, .off); try fsm.addeventandtransition(.click, .off, .on); ```  which approach to use depends on the application.  ### defining transitions and events as a table  rather than calling addtransition and addevent, `statemachinefromtable` can be used to pass a table of event- and state transitions.  ```zig const state = enum { on, off }; const event = enum { click }; const definition = [_]transition(state, event){     .{ .event = .click, .from = .on, .to = .off },     .{ .event = .click, .from = .off, .to = .on }, }; var fsm = zigfsm.statemachinefromtable(state, event, &definition, .off, &.{}).init(); ```  note that the `.event` field is optional, in which case only transition validation is added.  ### changing state  let's flip the lights on by directly transitioning to the on state:  ```zig try fsm.transitionto(.on); ```  this will fail with `stateerror.invalid` if the transition is not valid.  next, let's change state using the click event. in fact, let's do it several times, flipping the switch off and on and off again:  ```zig try fsm.do(.click); try fsm.do(.click); try fsm.do(.click); ```  again, this will fail with `stateerror.invalid` if a transition is not valid.  finally, it's possible to change state through the more generic `apply` function, which takes either a new state or an event.  ```zig try fsm.apply(.{ .state = .on }); try fsm.apply(.{ .event = .click }); ```  ### probing the current state  the current state is available through `currentstate()`. to check if the current state is a specific state, call `iscurrently(...)`  if final states have been added through `addfinalstate(...)`, you can check if the current state is in a final state by calling `isinfinalstate()`  to check if the current state is in the start state, call `isinstartstate()`  see the api docstring for more information about these are related functions.  ### inspecting what transition happened  ```zig const transition = try fsm.do(.identifier);  if (transition.to == .jumping and transition.from == .running) {     ... } ```  ... where `transition` contains the fields `from`, `to` and `event`.  followed by an if/else chain that checks relevant combinations of from- and to states. this could, as an example, be used in a parser loop.  see the tests for examples.  ### valid states iterator  it's occasionally useful to know which states are possible to reach from the current state. this is done using an iterator:  ```zig while (fsm.validnextstatesiterator()) |valid_next_state| {     ... } ```  ### importing state machines  it's possible, even at compile time, to parse a `graphviz` or `libfsm` text file and create a state machine from this.  * `importtext` is used when you already have state- and event enums defined in zig. `importtext` can also be called at runtime to define state transitions.  * `generatestatemachinefromtext` is used when you want the compiler to generate these enums for you. while this saves you from writing enums manually, a downside is that editors and language servers are unlikely to support autocomplete on generated types.  the source input can be a string literal, or brought in by `@embedfile`.  see the test cases for examples on how to use the import features.  ### transition handlers  a previous section explained how to inspect the source and target state. there's another way to do this, using callbacks.  this gets called when a transition happens. the main benefit is that it allows you to cancel a transition.  handlers also makes it easy to keep additional state, such as source locations when writing a parser.  let's keep track of the number of times a light switch transition happens:  ```zig var countinghandler = countinghandler.init(); try fsm.addtransitionhandler(&countinghandler.handler); ```  whenever a transition happens, the handler's public `ontransition` function will be called. see tests for complete examples of usage.  #### canceling transitions  the transition handler can conditionally stop a transition from happening by returning `handlerresult.cancel`. the callsite of `transitionto` or `do` will then fail with `stateerror.invalid`  alternatively,`handlerresult.cancelnoerror` can be used to cancel without failure (in other words, the current state remains but the callsite succeeds) ","00JCIV00/cova":"Commands, Options, Values, Arguments. A simple yet robust cross-platform command line argument parsing library for Zig. ![cova_icon_v2 1](https://github.com/00jciv00/cova/assets/68087632/0b485f6b-ddf4-4772-96eb-899d4606f9cc)  # commands **⋅** options **⋅** values **⋅** arguments  a simple yet robust cross-platform command line argument parsing library for zig.  [![static badge](https://img.shields.io/badge/v0.13(stable)-orange?logo=zig&logocolor=orange&label=zig&labelcolor=orange)](https://ziglang.org/download/) [![static badge](https://img.shields.io/badge/v0.10.1b-blue?logo=github&label=release)](https://github.com/00jciv00/cova/releases/tag/v0.10.1-beta) [![github commit activity](https://img.shields.io/github/commits-difference/00jciv00/cova?base=v0.10.1&head=main&logo=github&label=commits%20(v0.11.0b))](https://github.com/00jciv00/cova/commits/main/) [![static badge](https://img.shields.io/badge/mit-silver?label=license)](https://github.com/00jciv00/cova/blob/main/license)  ___  ## overview `command --option value`  cova is based on the idea that arguments will fall into one of three types: commands, options, or values. these types are assembled into a single command struct which is then used to parse argument tokens. whether you're looking for simple argument parsing or want to create something as complex as the [`ip`](https://www.man7.org/linux/man-pages/man8/ip.8.html) or [`git`](https://www.man7.org/linux/man-pages/man1/git.1.html) commands, cova makes it easy.  ## get started quickly! - [quick start guide](https://github.com/00jciv00/cova/wiki/getting-started) - [full wiki guide](https://github.com/00jciv00/cova/wiki/) - [api docs](https://00jciv00.github.io/cova/)  ### quick example [logger example](https://github.com/00jciv00/cova/blob/main/examples/logger.zig) ```shell logger --log-level info ``` #### set up a command ```zig // ... pub const commandt = cova.command.custom(.{...}); pub const setup_cmd = commandt{     .name = 'logger',     .description = 'a small demo of using the log level enum as an option.',     .examples = &.{ 'logger --log-level info' },     .opts = &.{         .{             .name = 'log_level',             .description = 'an option using the `log.level` enum.',             .long_name = 'log-level',             .mandatory = true,             .val = commandt.valuet.oftype(log.level, .{                 .name = 'log_level_val',                 .description = ' this value will handle the enum.'             })         }     }, }; ``` #### parse the command ```zig pub fn main() !void {     // ...     var main_cmd = try setup_cmd.init(alloc, .{});     defer main_cmd.deinit();     var args_iter = try cova.argiteratorgeneric.init(alloc);     defer args_iter.deinit();      cova.parseargs(&args_iter, commandt, main_cmd, stdout, .{}) catch |err| switch (err) {         error.usagehelpcalled => {},         else => return err,     };     // ... ``` #### use the data ```zig     // ...     const main_opts = try main_cmd.getopts(.{});     const log_lvl_opt = main_opts.get('log_level').?;     const log_lvl = log_lvl_opt.val.getas(log.level) catch {         log.err('the provided log level was invalid.', .{});         return;     };     log.info('provided log level: {s}', .{ @tagname(log_lvl) }); } ```  ## features - **[comptime setup](#comptime-setup). [runtime use](#runtime-use).**   - cova is designed to have argument types set up at ***compile time*** so they can be validated during each compilation, thus providing you with immediate feedback.   - once validated, argument types are initialized to memory for ***runtime*** use where end user argument tokens are parsed then made ready to be analyzed by your code. - **[build-time bonuses!](#build-time-bonuses)** cova also provides a simple build step to generate help docs, tab completion scripts, and argument templates at ***build-time***! - **simple design:**   - all argument tokens are parsed to argument types: commands, options, or values.     - options = _flags_ and values = _positional arguments_   - these argument types can be *created from* or *converted to* your structs, unions, and functions along with their corresponding fields and parameters.   - default arguments such as `usage` and `help` can be automatically added to all commands easily.    - this design allows for **infinitely nestable** commands, options, and values in a way that's simple to parse, analyze, and use in your projects. - **multiplatform.** tested across common architectures of linux, mac, and windows. - **granular, robust customization:**   - [posix compliant](https://www.gnu.org/software/libc/manual/html_node/argument-syntax.html) by default, with plenty of ways to configure to **whatever standard you'd like**.     - posix: `command --option option_string 'standalone value' subcmd -i 42 --bool`     - windows: `your-command -stringoption 'value' -fileoption .╲user╲file╲path`   - cova offers deep customization through the argument types and several config structs. these customizations all provide simple and predictable defaults, allowing you to only configure what you need. - [***and much more!***](https://github.com/00jciv00/cova/wiki/feature-list)  ## usage cova makes it easy to set up your argument types at _comptime_ and use the input provided by your end users at _runtime_!  ### comptime setup there are two main ways to set up your argument types. you can either convert existing zig types within your project or create them manually. you can even mix and match these techniques to get the best of both!  <details> <summary>code example</summary>  ```zig const std = @import('std'); const cova = @import('cova'); pub const commandt = cova.command.base(); pub const optiont = commandt.optiont; pub const valuet = commandt.valuet;  // the root command for your program. pub const setup_cmd: commandt = .{     .name = 'basic-app',     .description = 'a basic user management application designed to highlight key features of the cova library.',     .cmd_groups = &.{ 'interact', 'view' },     .sub_cmds = &.{         // a sub command created from converting a struct named `user`.         // usage ex: `basic-app new -f bruce -l wayne -a 40 -p '555 555 5555' -a ' 1007 mountain drive, gotham' true`         commandt.from(user, .{             .cmd_name = 'new',             .cmd_description = 'add a new user.',             .cmd_group = 'interact',             .sub_descriptions = &.{                 .{ 'is_admin', 'add this user as an admin?' },                 .{ 'first_name', 'user's first name.' },                  .{ 'last_name', 'user's last name.' },                 .{ 'age', 'user's age.' },                 .{ 'phone', 'user's phone #.' },                 .{ 'address', 'user's address.' },             },         }),         // a sub command created from a function named `open`.         // usage ex: `basic-app open users.csv`         commandt.from(@typeof(open), .{             .cmd_name = 'open',             .cmd_description = 'open or create a users file.',             .cmd_group = 'interact',         }),         // a manually created sub command, same as the root `setup_cmd`.         // usage ex: `basic-app clean` or `basic-app delete --file users.csv`         commandt{             .name = 'clean',             .description = 'clean (delete) the default users file (users.csv) and persistent variable file (.ba_persist).',             .alias_names = &.{ 'delete', 'wipe' },             .cmd_group = 'interact',             .opts = &.{                 optiont{                     .name = 'clean_file',                     .description = 'specify a single file to be cleaned (deleted) instead of the defaults.',                     .alias_long_names = &.{ 'delete_file' },                     .short_name = 'f',                     .long_name = 'file',                     .val = valuet.oftype([]const u8, .{                         .name = 'clean_file',                         .description = 'the file to be cleaned.',                         .alias_child_type = 'filepath',                         .valid_fn = cova.value.validationfns.validfilepath,                     }),                 },             },         },     } }; // continue to runtime use... ``` </details>  ### runtime use once cova has parsed input from your end users, it puts that data into the command you set up.  you can call various methods on the command to use that data however you need.  <details> <summary>code example</summary>  ```zig // ...continued from the comptime setup. pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{ .verbose_log = builtin.mode == .debug }){};     const alloc = gpa.allocator();      // initializing the `setup_cmd` with an allocator will make it available for runtime use.     const main_cmd = try setup_cmd.init(alloc, .{});      defer main_cmd.deinit();      // parsing     var args_iter = try cova.argiteratorgeneric.init(alloc);     defer args_iter.deinit();     const stdout = std.io.getstdout().writer();      cova.parseargs(&args_iter, commandt, &main_cmd, stdout, .{}) catch |err| switch (err) {         error.usagehelpcalled,         error.toomanyvalues,         error.unrecognizedargument,         error.unexpectedargument,         error.couldnotparseoption => {},         else => return err,     };      // analysis (using the data.)     if (builtin.mode == .debug) try cova.utils.displaycmdinfo(commandt, &main_cmd, alloc, &stdout);          // glossing over some project variables here.      // convert a command back into a struct.     if (main_cmd.matchsubcmd('new')) |new_cmd| {         var new_user = try new_cmd.to(user, .{});         new_user._id = getnextid();         try users.append(new_user);         try stdout.print('added:╲n{s}╲n', .{ new_user });     }     // convert a command back into a function and call it.     if (main_cmd.matchsubcmd('open')) |open_cmd| {         user_file = try open_cmd.callas(open, null, std.fs.file);     }     // get the provided sub command and check an option from that sub command.     if (main_cmd.matchsubcmd('clean')) |clean_cmd| cleancmd: {         if ((try clean_cmd.getopts(.{})).get('clean_file')) |clean_opt| {             if (clean_opt.val.isset()) {                 const filename = try clean_opt.val.getas([]const u8);                 try delete(filename);                 break :cleancmd;             }         }         try delete('users.csv');         try delete('.ba_persist');     } } ``` </details>  ### more examples - [logger](./examples/logger.zig): the simple example from the top of the readme. - [basic-app](./examples/basic_app.zig): where the above examples come from. - [covademo](./examples/covademo.zig): this is the testbed for cova, but its a good demo of virtually every feature in the library.  ## build-time bonuses cova's simple meta doc generator build step lets you quickly and easily generate documents in the following formats based on the commands you set up at comptime: - help docs:   - manpages   - markdown - tab completion scripts:   - bash   - zsh   - powershell - argument templates:   - json   - kdl   <details> <summary>code example</summary>     ```zig // within 'build.zig' pub fn build(b: *std.build) void {     // set up your build variables as normal.      const cova_dep = b.dependency('cova', .{ .target = target, .optimize = optimize });     const cova_mod = cova_dep.module('cova');      // set up your exe step as you normally would.      const cova_gen = @import('cova').addcovadocgenstep(b, cova_dep, exe, .{         .kinds = &.{ .all },         .version = '0.10.1',         .ver_date = '12 sep 2024',         .author = '00jciv00',         .copyright = 'mit license',     });     const meta_doc_gen = b.step('gen-meta', 'generate meta docs using cova');     meta_doc_gen.dependon(&cova_gen.step); } ``` </details>  ## demo ![cova_demo](./docs/cova_demo.gif)    ## alternatives - [flags](https://github.com/n0s4/flags) - [snek](https://github.com/bitlytwiser/snek) - [yazap](https://github.com/prajwalch/yazap) - [zig-args](https://github.com/masterq32/zig-args) - [zig-clap](https://github.com/hejsil/zig-clap) - [zig-cli](https://github.com/sam701/zig-cli) - [zli](https://gitlab.com/ziglang/zig) ","octopus-foundation/gremlin.zig":"A zero-dependency Google Protocol Buffers implementation in pure Zig. Single allocation encode and lazy decode # gremlin  a zero-dependency google protocol buffers implementation in pure zig (no protoc required)  ## installation & setup  single command setup: ```bash zig fetch --save https://github.com/octopus-foundation/gremlin.zig/archive/refs/tags/0.0.0.tar.gz ```  this command will: 1. download gremlin 2. add it to your `build.zig.zon` 3. generate the correct dependency hash  in your `build.zig`: ```zig const std = @import('std'); const protogenstep = @import('gremlin').protogenstep;  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      // get the parser dependency     const gremlin_dep = b.dependency('gremlin', .{         .target = target,         .optimize = optimize,     }).module('gremlin');      // generate zig code from .proto files     // this will process all .proto files in the proto/ directory     // and output generated zig code to src/gen/     const protobuf = protogenstep.create(         b,         .{             .proto_sources = b.path('proto'),    // directory containing .proto files             .target = b.path('src/gen'),         // output directory for generated zig code         },     );      // create binary     const exe = b.addexecutable(.{         .name = 'example',         .root_source_file = b.path('src/main.zig'),         .target = target,         .optimize = optimize,     });      // add the parser module     exe.root_module.addimport('gremlin', gremlin_dep);     exe.step.dependon(&protobuf.step);      b.installartifact(exe); } ```  ## features  - zero dependencies - pure zig implementation (no protoc required) - compatible with protocol buffers version 2 and 3 - simple integration with zig build system - single! allocation for serialization (including complex recursive messages) - lazy parsing - parses only required complex fields - tested with zig 0.14.0-dev  ## generated code  see the complete working example in the [`example`](./example) folder.  given a protobuf definition: ```protobuf syntax = 'proto3';  message user {   string name = 1;   uint64 id   = 2;   repeated string tags = 10; } ```  gremlin will generate equivalent zig code (see [example.proto.zig](./example/src/gen/example.proto.zig)): ```zig const std = @import('std'); const gremlin = @import('gremlin');  // wire numbers for fields const userwire = struct {     const name_wire: gremlin.protowirenumber = 1;     const id_wire: gremlin.protowirenumber = 2;     const tags_wire: gremlin.protowirenumber = 10; };  // message struct pub const user = struct {     name: ?[]const u8 = null,     id: u64 = 0,     tags: ?[]const ?[]const u8 = null,          // calculate size for allocation     pub fn calcprotobufsize(self: *const user) usize { ... }          // encode to new buffer     pub fn encode(self: *const user, allocator: std.mem.allocator) gremlin.error![]const u8 { ... }          // encode to existing buffer     pub fn encodeto(self: *const user, target: *gremlin.writer) void { ... } };  // reader for lazy parsing pub const userreader = struct {     allocator: std.mem.allocator,     buf: gremlin.reader,     _name: ?[]const u8 = null,      _id: u64 = 0,     _tags: ?std.arraylist([]const u8) = null,      pub fn init(allocator: std.mem.allocator, src: []const u8) gremlin.error!userreader { ... }     pub fn deinit(self: *const userreader) void { ... }          // accessor methods     pub inline fn getname(self: *const userreader) []const u8 { ... }     pub inline fn getid(self: *const userreader) u64 { ... }     pub fn gettags(self: *const userreader) []const []const u8 { ... } }; ```","jetzig-framework/zmpl":"Zmpl is a templating language written in Zig ![zmpl logo](public/zmpl.png)  _zmpl_ is a templating language for [zig](https://ziglang.org/) :lizard:  * use _zig_ code directly in templates for control flow. * simple and intuitive dsl for building flexible, _json_-compatible data objects. * compiles to _zig_ code for syntax and type validation. * used by the [jetzig](https://github.com/jetzig-framework/jetzig) web framework.  ## documentation  visit the [jetzig documentation](https://jetzig.dev/documentation.html) page to see detailed _zmpl_ documentation with usage examples.  ## syntax highlighting  * [vim](https://github.com/jetzig-framework/zmpl.vim) * [vscode](https://github.com/z1fire/zmpl-syntax-highlighting-vscode) by [zackary housend](https://github.com/z1fire)  ## example  see [src/templates](src/templates) for more examples.  ### template  ```zig <!-- zig mode for template logic --> @zig {   if (std.mem.eql(u8, 'zmpl is simple', 'zmpl' ++ ' is ' ++ 'simple')) {     <span>zmpl is simple!</span>   } }  <!-- easy data lookup syntax --> <div>email: {{.user.email}}</div> <div>token: {{.auth.token}}</div>  <!-- partials --> @partial example_partial  <!-- partials with positional args --> @partial mailto(.user.email, 'welcome to jetzig!')  <!-- partials with keyword args ---> @partial mailto(email: .user.email, subject: 'welcome to jetzig!')  <!-- partials with slots ---> @partial mailto(email: .user.email, subject: 'welcome to jetzig!') {   <a href='https://example.com/auth/{{.auth.token}}'>sign in</a>   <a href='https://example.com/unsubscribe/{{.auth.token}}'>unsubscribe</a> }  @markdown {   # built-in markdown support    * [jetzig.dev](https://www.jetzig.dev/) } ```  ### `mailto` partial  ```zig @args email: *zmplvalue, subject: []const u8 <a href='mailto:{{email}}?subject={{subject}}'>{{email}}</a>  @zig {     for (slots, 0..) |slot, slot_index| {         <div class='slot-{{slot_index}}'>{{slot}}</div>     } } ```  ### output html  ```html <!-- zig mode for template logic -->     <span>zmpl is simple!</span>   <!-- easy data lookup syntax --> <div>email: user@example.com</div> <div>token: abc123-456-def</div>  <!-- partials --> <span>an example partial</span>  <!-- partials with positional args --> <a href='mailto:user@example.com?subject=welcome to jetzig!'>user@example.com</a>  <!-- partials with keyword args ---> <a href='mailto:user@example.com?subject=welcome to jetzig!'>user@example.com</a>  <!-- partials with slots ---> <a href='mailto:user@example.com?subject=welcome to jetzig!'>user@example.com</a>         <div class='slot-0'><a href='https://example.com/auth/abc123-456-def'>sign in</a></div>         <div class='slot-1'><a href='https://example.com/unsubscribe/abc123-456-def'>unsubscribe</a></div>   <div><h1>built-in markdown support</h1> <ul><li><a href='https://www.jetzig.dev/'>jetzig.dev</a></li></ul></div> ```  ### example usage  default template path is `src/templates`. use `-dzmpl_templates_path=...` to set an alternative (relative or absolute) path.  ```zig const std = @import('std'); const zmpl = @import('zmpl');  test 'readme example' {     var data = zmpl.data.init(std.testing.allocator);     defer data.deinit();      var body = try data.object();     var user = try data.object();     var auth = try data.object();      try user.put('email', data.string('user@example.com'));     try auth.put('token', data.string('abc123-456-def'));      try body.put('user', user);     try body.put('auth', auth);      if (zmpl.find('example')) |template| {         const output = try template.render(&data);         defer std.testing.allocator.free(output);          try std.testing.expectequalstrings(             ╲╲<!-- zig mode for template logic -->             ╲╲    <span>zmpl is simple!</span>             ╲╲             ╲╲             ╲╲<!-- easy data lookup syntax -->             ╲╲<div>email: user@example.com</div>             ╲╲<div>token: abc123-456-def</div>             ╲╲             ╲╲<!-- partials -->             ╲╲<span>an example partial</span>             ╲╲<!-- partials with positional args -->             ╲╲<a href='mailto:user@example.com?subject=welcome to jetzig!'>user@example.com</a>             ╲╲<!-- partials with keyword args --->             ╲╲<a href='mailto:user@example.com?subject=welcome to jetzig!'>user@example.com</a>             ╲╲<!-- partials with slots --->             ╲╲<a href='mailto:user@example.com?subject=welcome to jetzig!'>user@example.com</a>             ╲╲        <div class='slot-0'><a href='https://example.com/auth/abc123-456-def'>sign in</a></div>             ╲╲        <div class='slot-1'><a href='https://example.com/unsubscribe/abc123-456-def'>unsubscribe</a></div>             ╲╲             ╲╲<div><h1>built-in markdown support</h1>             ╲╲<ul><li><a href='https://www.jetzig.dev/'>jetzig.dev</a></li></ul></div>         , output);     } else {         try std.testing.expect(false);     } } ```  ## license  [mit](license)  ## credits  [templ](https://github.com/a-h/templ) - inspiration for template layout. ","travisstaloch/simdjzon":"simdjson ported to zig :warning: **work in progress.  expect bugs and/or missing features** :warning:  # simdjzon this is a port of [simdjson](https://github.com/simdjson/simdjson), a high performance json parser developed by daniel lemire and geoff langdale to [zig](https://ziglang.org/).    # cpu support only 64 bit cpus are supported so far.  #### x86_64 a cpu with avx is required and clmul is preferred. the following usually have both * intel - haswell from 2013 onwards * amd - ryzen/epyc cpu (q1 2017)  these commands show how to test for specific target and cpu support ```console zig build test -dtarget=x86_64-linux -dcpu=x86_64+avx # uses clmulsoft - missing pclmul zig build test -dtarget=x86_64-linux -dcpu=x86_64+avx+pclmul # zig build test -dtarget=x86_64-linux # doesn't work - missing avx # zig build test -dcpu=x86_64_v2 # doesn't work - missing avx ```  #### aarch64 a cpu with aes is preferred. ```console zig build test -dtarget=aarch64-linux -dcpu=apple_latest-aes -fqemu # uses clmulsoft zig build test -dtarget=aarch64-linux -fqemu ```  #### powerpc not supported yet ```console # zig build test -dtarget=powerpc-linux -fqemu # doesn't work - no classify() + 32bit errors # zig build test -dtarget=powerpc64-linux -fqemu # doesn't work - no classify() ```  #### fallback no fallback for unsupported cpus is provided yet.  ```console # zig build test -dcpu=baseline # doesn't work - no classify() ```  # zig compiler support the main branch is meant to compile with zig's master branch.  it is tested weekly on linux, windows and macos.   for older compiler versions, use a [tagged version](https://github.com/travisstaloch/simdjzon/tags).  # usage ```console # json validation $ git clone https://github.com/travisstaloch/simdjzon $ cd simdjzon $ zig build -drelease-fast # uses the dom api by default $ zig-out/bin/simdjzon test/test.json $ echo $? # 0 on success 0 $ zig build -drelease-fast -dondemand # use the ondemand api $ zig-out/bin/simdjzon test/test.json $ echo $? # 0 on success 0 $ zig build test all 19 tests passed. ```  ```zig const dom = @import('dom.zig'); test 'get with struct' {     const s = struct { a: u8, b: []const u8, c: struct { d: u8 } };     const input =         ╲╲{'a': 42, 'b': 'b-string', 'c': {'d': 126}}     ;     var parser = try dom.parser.initfixedbuffer(allr, input, .{});     defer parser.deinit();     try parser.parse();     var s: s = undefined;     try parser.element().get(&s);     try testing.expectequal(@as(u8, 42), s.a);     try testing.expectequalstrings('b-string', s.b);     try testing.expectequal(@as(u8, 126), s.c.d); }  test 'at_pointer' {     const input =         ╲╲{'a': {'b': [1,2,3]}}     ;     var parser = try dom.parser.initfixedbuffer(allr, input, .{});     defer parser.deinit();     try parser.parse();     const b0 = try parser.element().at_pointer('/a/b/0');     try testing.expectequal(@as(i64, 1), try b0.get_int64()); }  const ondemand = @import('ondemand.zig'); // ondemand api users must specify `pub const read_buf_cap = n;` in their // root source file.  in tests, this defaults to `std.mem.page_size`.  test 'ondemand get with struct' {     const s = struct { a: struct { b: []const u8 } };     const input =         ╲╲{'a': {'b': 'b-string'}}     ;     var src = std.io.streamsource{ .const_buffer = std.io.fixedbufferstream(input) };     var parser = try ondemand.parser.init(&src, allr, '<fba>', .{});     defer parser.deinit();     var doc = try parser.iterate();      var s: s = undefined;     try doc.get(&s, .{ .allocator = allr });     defer allr.free(s.a.b);     try testing.expectequalstrings('b-string', s.a.b); }  test 'ondemand at_pointer' {     const input =         ╲╲{'a': {'b': [1,2,3]}}     ;     var src = std.io.streamsource{ .const_buffer = std.io.fixedbufferstream(input) };     var parser = try ondemand.parser.init(&src, allr, '<fba>', .{});     defer parser.deinit();     var doc = try parser.iterate();     var b0 = try doc.at_pointer('/a/b/0');     try testing.expectequal(@as(u8, 1), try b0.get_int(u8)); } ```  # performance ## parsing/validating twitter.json (630kb) ### simdjson  ```console $ wget https://raw.githubusercontent.com/simdjson/simdjson/master/singleheader/simdjson.h https://raw.githubusercontent.com/simdjson/simdjson/master/singleheader/simdjson.cpp https://raw.githubusercontent.com/simdjson/simdjson/master/jsonexamples/twitter.json  $ cat main.cpp #include 'simdjson.h' using namespace simdjson; int main(int argc, char** argv) {     if(argc != 2) {         std::cout << 'usage: ./simdjson <file.json>' << std::endl;         exit(1);     }     dom::parser parser;      try     {         const dom::element doc = parser.load(argv[1]);     }     catch(const std::exception& e)     {         std::cerr << e.what() << '╲n';         return 1;     }     return 0; }  $ g++ main.cpp simdjson.cpp -o simdjson -o3 -march=native $ time ./simdjson twitter.json  real  0m0.003s user  0m0.002s sys  0m0.001s  $ echo $? 0 ```  ### simdjzon ```console $ time zig-out/bin/simdjzon twitter.json   real  0m0.002s user  0m0.000s sys  0m0.002s  $ echo $? 0  ```  ### timed against simdjson, go, nim, zig std lib the simdjson binary was compiled as shown above.  go and nim binaries created with sources from jsontestsuite. [zig std lib driver](bench/src/zig_json.zig). validation times for several large json files.  created with [benchmark_and_plot.jl](bench/benchmark_and_plot.jl) ![results](https://github.com/travisstaloch/simdjson-zig/blob/media/bench/validation_grouped.png)  # jsontestsuite  results of running simdjson and simdjzon through [jsontestsuite](https://github.com/nst/jsontestsuite).  results are equal as of 8/7/21  ![results](https://github.com/travisstaloch/simdjson-zig/blob/media/jsontestsuiteresults.png) ","ikskuh/zig-opengl":"OpenGL binding generator based on the opengl registry # zig opengl binding  this is a pragmatic binding to different opengl versions.  it uses the official [opengl registry](https://github.com/khronosgroup/opengl-registry) by khronos to generate the zig code.  right now, it does minimal adjustments like removing the `gl` prefix from functions or the `gl_` prefix from constants. everything else is the same as the c api.  there is a single non-opengl function exported:  ```zig pub fn load(load_ctx: anytype, get_proc_address: fn(@typeof(load_ctx), [:0]const u8) ?*functionpointer) !void { ```  this function will load all opengl entry points with the help of `get_proc_address`. it receives the `load_ctx` as well as the function name.  **note:** please do not reference `zig-opengl` as a submodule or a package. generate a binding and copy the output of that into your repository and update the file on demand. the opengl registry is just too huge to be used conveniently.  cloning submodules is required, so use `--recursive`:  ```bash git clone --recursive https://github.com/ikskuh/zig-opengl.git ```  ## example  this example uses [zwl](https://github.com/aransentin/zwl/) by @aransentin.  ```zig const zwl = @import('zwl');  const platform = zwl.platform(…);  pub fn initanddraw(window: platform.window) !void {   try gl.load(window.platform, platform.getopenglprocaddress);    while(true) {     gl.clearcolor(1, 0, 1, 1);     gl.clear(gl.color_buffer_bit);      try window.present();   } } ```  ### usage with mach-glfw  there is an example of `mach-glfw` + `zig-opengl` usage available here: https://github.com/hexops/mach-glfw-opengl-example  ## pregenerated loaders  this repository contains pre-generated bindings for all extension-free opengl versions.  ## generating your own loader  ### from source  to generate your own loader, you have to clone this repository and build the generator with `dotnet`:  ```sh-session user@machine:~/zig-opengl$ dotnet run usage: generator <registry> <result> <api_version> [<extension>] [<extension>] ... user@machine:~/zig-opengl$ dotnet run opengl-registry/xml/gl.xml gl3v3.zig gl_version_3_3 final api has 344 commands and 818 enums types. user@machine:~/zig-opengl$ ```  ```sh-session dotnet run ╲   opengl-registry/xml/gl.xml ╲ # path to the opengl registry   my_binding.zig             ╲ # path to the generated file   gl_version_3_3             ╲ # feature level, options listed below   …                            # add your extensions here, each as a single arg. or let them out, you don't need extensions ```  possible feature levels (at the time of writing) are:  - `gl_version_1_0` - `gl_version_1_1` - `gl_version_1_2` - `gl_version_1_3` - `gl_version_1_4` - `gl_version_1_5` - `gl_version_2_0` - `gl_version_2_1` - `gl_version_3_0` - `gl_version_3_1` - `gl_version_3_2` - `gl_version_3_3` - `gl_version_4_0` - `gl_version_4_1` - `gl_version_4_2` - `gl_version_4_3` - `gl_version_4_4` - `gl_version_4_5` - `gl_version_4_6` - `gl_version_es_cm_1_0` - `gl_es_version_2_0` - `gl_es_version_3_0` - `gl_es_version_3_1` - `gl_es_version_3_2` - `gl_sc_version_2_0`  ## contribution  this library uses a small c# script that generates the zig bindings. it is located in `src/generator.cs`  ## what is missing right now?  - option to specify `core` or `compatibility` profile. ","karlseguin/log.zig":"A structured logger for Zig 404: not found","yamafaktory/hypergraphz":"HypergraphZ - A Hypergraph Implementation in Zig # hypergraphz - a hypergraph implementation in zig  ![github actions workflow status](https://img.shields.io/github/actions/workflow/status/yamafaktory/hypergraphz/ci.yml?branch=main&style=flat-square)  hypergraphz is a directed hypergraph implementation in zig (https://en.wikipedia.org/wiki/hypergraph):  - each hyperedge can contain zero, one (unary) or multiple vertices. - each hyperedge can contain vertices directed to themselves one or more times.  ## usage  add `hypergraphz` as a dependency to your `build.zig.zon`:  ```sh zig fetch --save https://github.com/yamafaktory/hypergraphz/archive/<commit-hash>.tar.gz ```  add `hypergraphz` as a dependency to your `build.zig`:  ```zig const hypergraphz = b.dependency('hypergraphz', .{     .target = target,     .optimize = optimize, }); exe.root_module.addimport('hypergraphz', hypergraphz.module('hypergraphz')); ```  ## documentation  the latest online documentation can be found [here](https://yamafaktory.github.io/hypergraphz/). ","rdunnington/bytebox":"Standalone WebAssembly VM. # bytebox  <div align='center'> <a href=https://webassembly.org/><img src='https://avatars.githubusercontent.com/u/11578470?s=200&v=4' alt='markdown logo' width='150'/></a>  bytebox is a webassembly vm. </div>  # getting started  ### requirements bytebox currently builds with [zig 0.13.x](https://ziglang.org/download) to avoid churn on zig master.  to run the tests: * `wasm-tools` is required to run the wasm testsuite. you can install it via the rust toolchain `cargo install wasm-tools` or directly from the [release page](https://github.com/bytecodealliance/wasm-tools/releases). * `python3` is required to run the wasi testsuite. you may need to run `python3 -m pip install -r test/wasi/wasi-testsuite/test-runner/requirements.txt` to ensure the wasi test runner has all the necessary dependencies installed.  ## run tests  ```sh git clone --recurse-submodules https://github.com/rdunnington/bytebox.git cd bytebox zig build test-unit # run builtin zig unit tests zig build test-wasm # run official wasm spec testsuite zig build test-wasi # run official wasi spec testsuite zig build test-mem64 # run memory64 compat test zig build test # run all of the above in parallel (output will not be pretty!) ```  ## usage  you can use the standalone runtime to load and execute webassembly programs: ```sh zig build run -- <file> [function] [function args]... ```  or embed bytebox in your own programs:  ```zig // build.zig const std = @import('std');  pub fn build(b: *std.build.builder) void {     const exe = b.addexecutable('my_program', 'src/main.zig');     exe.addpackage(std.build.pkg{         .name = 'bytebox',         .source = .{ .path = 'bytebox/src/core.zig' }, // submodule in the root dir     });     exe.settarget(b.standardtargetoptions(.{}));     exe.setbuildmode(b.standardreleaseoptions());     exe.install();     const run = exe.run();     const step = b.step('run', 'runs my_program');     step.dependon(&run.step); }  // main.zig const std = @import('std'); const bytebox = @import('bytebox');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     var allocator: std.mem.allocator = gpa.allocator();      const wasm_data: []u8 = try std.fs.cwd().readfilealloc(allocator, 'example.wasm', 1024 * 128);     defer allocator.free(wasm_data);      const module_def = try bytebox.createmoduledefinition(allocator, .{});     defer module_def.destroy();     try module_def.decode(wasm_data);      const module_instance = try bytebox.createmoduleinstance(.stack, module_def, allocator);     defer module_instance.destroy();     try module_instance.instantiate(.{}); } ```  inter-language ffi is also supported. see `src/bytebox.h` for an overview in c. to use bytebox as a static library, link with the built library in `zig-out/lib/`. note that zig assumes a default stack size of 8mb, so you'll need to ensure the same in your program.  # status  this project is still in the alpha stage.  | legend | meaning | | --- | --- | |✅|implemented| |❌|todo| |💀|not planned/removed from spec|  ## [webassembly](https://webassembly.github.io/spec/core/index.html) support:  | status | feature | | --- | --- | |✅|webassembly 1.0| |✅|sign extension instructions| |✅|non-trapping float-to-int conversion| |✅|multiple values| |✅|reference types| |✅|table instructions| |✅|multiple tables| |✅|bulk memory and table instructions| |✅|vector instructions|  ## [wasi preview 1](https://github.com/webassembly/wasi/tree/main) support:  | status | feature | | --- | --- | |✅|args_get| |✅|args_sizes_get| |✅|environ_get| |✅|environ_sizes_get| |✅|clock_res_get| |✅|clock_time_get| |✅|fd_advise| |✅|fd_allocate| |✅|fd_close| |✅|fd_datasync| |✅|fd_fdstat_get| |✅|fd_fdstat_set_flags| |💀|fd_fdstat_set_rights| |✅|fd_filestat_get| |✅|fd_filestat_set_size| |✅|fd_filestat_set_times| |✅|fd_pread| |✅|fd_prestat_get| |✅|fd_prestat_dir_name| |✅|fd_pwrite| |✅|fd_read| |✅|fd_readdir| |✅|fd_renumber| |✅|fd_seek| |❌|fd_sync| |✅|fd_tell| |✅|fd_write| |✅|path_create_directory| |✅|path_filestat_get| |✅|path_filestat_set_times| |❌|path_link| |✅|path_open| |❌|path_readlink| |✅|path_remove_directory| |❌|path_rename| |✅|path_symlink| |✅|path_unlink_file| |❌|poll_oneoff| |✅|proc_exit| |💀|proc_raise| |❌|sched_yield| |✅|random_get| |❌|sock_accept| |❌|sock_recv| |❌|sock_send| |❌|sock_shutdown|  ### roadmap these tasks must be completed to enter alpha: * api ergonomics pass * documentation * general todo/code cleanup * crash hardening/fuzzing  to enter beta: * no breaking api changes after this point * performance competitive with other well-known interpreters (e.g. [micro-wasm-runtime](https://github.com/bytecodealliance/wasm-micro-runtime), [wasm3](https://github.com/wasm3/wasm3))  to have a 1.0 release: * tested with a wide variety of wasm programs * successfully used in other beta-quality projects ","karlseguin/zuckdb.zig":"A DuckDB driver for Zig 404: not found","zPSP-Dev/Zig-PSP":"A project to bring the Zig Programming Language to the Sony PlayStation Portable! <h1 align='center'>zig-psp</h1> <p align='center'>a project to bring zig to the sony playstation portable</p>  ## why zig on the psp?  in the psp programming community, many libraries, tools, and other features are written in c or c++, which as we know has its problems with writing clean, reusable, and high quality code. given that the core objectives of zig as a language are to allow us to create well-designed and reusable software, zig seems like a perfect fit for integrating older psp libraries while striving to develop higher quality software!  ## special thanks  special thanks is given to the [rust-psp team](https://github.com/overdrivenpotato/rust-psp) whose efforts influenced and helped to get this project off the ground. no harm is intended, and it's thanks to you rustaceans that fellow ziguanas can program for the psp.  ## usage  currently, using zig-psp is rather straight forward - one must use the psp folder in their project's src folder in order to have the psp's function definitions, alongside with some custom utilities i have created. one also must include the tools/ folder to use the post-build tools. to build a psp app, use the included `build.zig` script to generate a psp executable! (eboot.pbp / app.prx) this script is well commented for explanation and documentation.  for a main.zig file one should include something like:  ```zig const psp = @import('psp/utils/psp.zig');  comptime {     asm(psp.module_info('zig psp app', 0, 1, 0)); }  pub fn main() !void {     psp.utils.enablehbcb();     psp.debug.screeninit();      psp.debug.print('hello from zig!'); } ```  a quick call to `zig build` will build your program and should emit an eboot.pbp and app.prx in your root. these are the two psp executable formats - .prx for debugging, and .pbp for running normally.  one can run a .pbp file on their psp (assuming cfw is installed) by adding their application to `psp_drive:/psp/game/yourappname/eboot.pbp` and it will be available under the games->memory stick list in the psp's xmb.  ## eboot customization in order to customize the eboot, one can look into the `build.zig` file and modify the constant fields to change their application icon, background, and even add animations or sounds to the eboot on the xmb screen.  ## comparisons to c/c++ when comparing zig code to c/c++, it would be rather apparent that by default, zig is much smaller and tightly knit. llvm is an excellent backend which produces some very small code, and zig is an example of that. without the weight of the entire c standard library needing to be imported, a simple naive hello world, as seen above, generates in 10,195 bytes, compared to the c/c++ size of 68,098 bytes. that's an 85% reduction in size! with a few structural changes, as seen in `hello-min.zig` sample, that size can get down to 6,674 bytes! that's 90.2% smaller!    hopefully in the future, one could reference track the functions used in the sdk for imports, and dynamically generate module import information. this way, the psp applications could go as small as 3,200 bytes for a hello world! this repository is distributed as part of a template, allowing one to customize their module imports, meaning that full release applications built with small tweaks to the toolchain nids directory could result in extraordinarily small executables for release applications!  ## documentation  currently zig-psp does not include documentation of the pspsdk in the sdk's .zig files - but rather they are [well documented in c](http://psp.jim.sh/pspsdk-doc/). it is planned to add documentation in the future to resolve this  ## debugging  if one has an installed copy of the legacy pspsdk, one can use psplink - a usb debugging software, to connect their psp to their computer and run debugging functions on the application. with legacy pspsdk, you'll also have access to psp-gdb, a psp-specific version of gdb to use as well. psp-gdb with zig is untested at the moment, but in theory should work. ","kassane/qml_zig":"QML bindings for the Zig programming language # qml-zig ![github all releases](https://img.shields.io/github/downloads/kassane/qml_zig/total?style=flat-square) ![github release (latest by date)](https://img.shields.io/github/v/release/kassane/qml_zig?style=flat-square) ![github](https://img.shields.io/github/license/kassane/qml_zig?style=flat-square)  bindings are based on [dotherside](https://github.com/filcuc/dotherside) c bindings for qml library is mostly feature-compliant with other bindings based on the library, but lacks some minor features and has quite a few bugs.  # preview ![qml_zig](https://user-images.githubusercontent.com/6756180/102698635-a5518500-421d-11eb-8705-98013d2328d7.jpg)  # build - steps  ## requirements  all software required for building.  - qt 5.15 or higher - zig v0.12.0, 0.13.0 or master - cmake v3.2 or higher (dotherside build)  ### question  #### works on qt6?  maybe, check [dotherside](https://github.com/filcuc/dotherside) support!!  ## instructions  ~~~bash # clone repo git clone --recursive https://github.com/kassane/qml_zig  # open folder cd qml_zig  # build dotherside zig build cmake  # build zig build examplename -doptimize=releasesafe|-doptimize=releasefast|-doptimize=releasesmall ~~~  # examples  `zig build animated` - run an animated box  `zig build hello` - hello world, with menu and clickable button  `zig build cells` - cells example from qml tute, click a color to change the text  `zig build button` - button with 2-way comms to the zig code  `zig build layouts` - layouts examples  `zig build splits` - splitview example  `zig build tables` - tableview example  # work in progres examples  `zig build particle` - particle system example - needs qobject wrapper working yet, to pass zig objects to the qml side  # status  - basic initialization and execution - more examples - thanks [@zigster64](https://github.com/zigster64)! - providing properties to qml files  # todo  - [ ] qabstractlistmodels - [ ] qobject - **working progress** - [ ] qstyle ","IridescenceTech/zglfw":"A thin, idiomatic wrapper for GLFW. Written in Zig, for Zig! <h1 align='center'>zglfw</h1> <p align='center'>a thin, idiomatic wrapper for glfw. written in zig, for zig!</p>  # why write a wrapper? while zig is perfectly capable of simply `@cimport`ing glfw3.h and using it in your application, i think it lacks a lot of cleanliness and succinctness that can be expressed with zig. i decided to write this wrapper to provide glfw with a nicer interface, error handling options, and quality of life changes (for example `[]const u8` instead of `[*c]const u8`). it also uses nicely named constants in place of `#define`s.  zglfw is not 100% tested. i am happy to fix any errors that may arise, and i will accept contributions! errors that arise from glfw will be printed to `stderr`.  # examples  ```zig const std = @import('std'); const glfw = @import('glfw');  pub fn main() !void {     var major: i32 = 0;     var minor: i32 = 0;     var rev: i32 = 0;      glfw.getversion(&major, &minor, &rev);     std.debug.print('glfw {}.{}.{}╲n', .{ major, minor, rev });      //example of something that fails with glfw_not_initialized - but will continue with execution     //var monitor: ?*glfw.monitor = glfw.getprimarymonitor();      try glfw.init();     defer glfw.terminate();     std.debug.print('glfw init succeeded.╲n', .{});      var window: *glfw.window = try glfw.createwindow(800, 640, 'hello world', null, null);     defer glfw.destroywindow(window);      while (!glfw.windowshouldclose(window)) {         if (glfw.getkey(window, glfw.keyescape) == glfw.press) {             glfw.setwindowshouldclose(window, true);         }          glfw.pollevents();     } } ```  # documentation  i would suggest you look into the `glfw.zig` file themselves, as most of the changes are simple syntactically, but i have made some comments in cases where it may be different than you expect. obviously [glfw's documentation](https://www.glfw.org/documentation.html) should cover most things that you want to know. ","jedisct1/zigly":"The easiest way to write services for Fastly's Compute@Edge in Zig. ![zigly](logo.png) ========  the easiest way to write fastly compute services in zig.  - [](#)   - [what is fastly compute?](#what-is-fastly-compute)   - [what is zigly?](#what-is-zigly)   - [usage](#usage)     - [example application](#example-application)     - [adding zigly as a dependency](#adding-zigly-as-a-dependency)     - [a minimal webassembly program](#a-minimal-webassembly-program)     - [testing fastly compute modules](#testing-fastly-compute-modules)     - [using zigly](#using-zigly)       - [hello world!](#hello-world)       - [inspecting incoming requests](#inspecting-incoming-requests)       - [making http queries](#making-http-queries)       - [cache override](#cache-override)       - [pipes](#pipes)     - [proxying](#proxying)     - [redirects](#redirects)     - [response decompression](#response-decompression)       - [dictionaries](#dictionaries)       - [logging](#logging)   - [deployment to fastly's platform](#deployment-to-fastlys-platform)  ## what is fastly compute?  [fastly compute](https://www.fastly.com/products/compute) is [fastly](https://fastly.com)'s service to run custom code directly on cdn nodes.  the service runs anything that can be compiled to webassembly, and exports a convenient set of functions to interact with the platform.  ## what is zigly?  zigly is a library that makes it easy to write fastly compute modules in [zig](https://ziglang.org).  beyond the functions exported by the fastly platform, zigly will eventually include additional utility functions (cookie manipulation, jwt tokens, tracing...) to make application development as simple as possible.  zigly is written for zig 0.12.x.  ## usage  ### example application  check out the `example` directory.  this contains an example fastly application that relays all incoming traffic to a backend server, with transparent caching.  if you just want to use fastly as a cdn, this is all you need!  ### adding zigly as a dependency  add the dependency to your project:  ```sh zig fetch --save=zigly https://github.com/jedisct1/zigly/archive/refs/tags/0.1.8.tar.gz ```  and the following to your `build.zig` file:  ```zig     const zigly = b.dependency('zigly', .{         .target = target,         .optimize = optimize,     });     exe.root_module.addimport('zigly', zigly.module('zigly'));     exe.linklibrary(zigly.artifact('zigly')); ```  the `zigly` structure can be imported in your application with:  ```zig const zigly = @import('zigly'); ```  ### a minimal webassembly program  ```zig const std = @import('std');  pub fn main() !void     std.debug.print('hello from webassembly and zig!╲n', .{}); } ```  the program can be compiled with (replace `example.zig` with the source file name):  ```sh zig build-exe -target wasm32-wasi example.zig ```  happy with the result? add `-doptimize=releasesmall` or `-doptimize=releasefast` to get very small or very fast module:  ```sh zig build-exe -target wasm32-wasi -doptimize=releasesmall example.zig ```  the example above should not compile to more than 411 bytes.  if you are using a build file instead, define the target as `wasm32-wasi` in the `build.zig` file:  ```zig const target =  b.standardtargetoptions(.{ .default_target = .{ .cpu_arch = .wasm32, .os_tag = .wasi } }); ```  ...and build with `zig build -doptimize=releasesmall` or `-doptimize=releasefast` to get optimized modules.  ### testing fastly compute modules  the easiest way to test the resulting modules is to use [viceroy](https://github.com/fastly/viceroy), a reimplementation of the fastly api that runs locally.  ### using zigly  #### hello world!  ```zig const downstream = try zigly.downstream(); var response = downstream.response; try response.body.writeall('hello world!'); try response.finish(); ```  `downstream()` returns a type representing the initial connection, from a client to the proxy.  that type includes `response`, that can be used to send a response, as well as `request`, that can be used to inspect the incoming request.  every function call may fail with an error from the `fastlyerror` set.  slightly more complicated example:  ```zig const downstream = try zigly.downstream(); var response = downstream.response;  response.setstatus(201); response.headers.set('x-example', 'header');  try response.body.writeall('partial'); try response.flush(); try response.body.writeall('response'); try response.finish();  var logger = logger.open('logging_endpoint'); logger.write('operation sucessful!'); ```  note that calling `finish()` is always required in order to actually send a response to the client.  but realistically, most responses will either be simple redirects:  ```zig var downstream = try zigly.downstream(); try downstream.redirect(302, 'https://www.perdu.com'); ```  or responding directly from the cache, proxying to the origin if the cached entry is nonexistent or expired:  ```zig var downstream = try zigly.downstream(); try downstream.proxy('google', 'www.google.com'); ```  #### inspecting incoming requests  applications can read the body of an incoming requests as well as other informations such as the headers:  ```zig const request = downstream.request; const user_agent = try request.headers.get(allocator, 'user-agent'); if (request.ispost()) {     // method is post, read the body until the end, up to 1000000 bytes     const body = try request.body.readall(allocator, 1000000); } ```  as usual in zig, memory allocations are never hidden, and applications can choose the allocator they want to use for individual function calls.  #### making http queries  making http queries is easy:  ```zig var query = try zigly.request.new('get', 'https://example.com'); var response = try query.send('backend'); const body = try response.body.readall(allocator, 0); ```  arbitrary headers can be added the the outgoing `query`:  ```zig try query.headers.set('x-custom-header', 'custom value'); ```  body content can also be pushed, even as chunks:  ```zig try query.body.write('x'); try query.body.write('y'); try query.body.close(); ```  and the resulting `response` contains `headers` and `body` properties, that can be inspected the same way as a downstream query.  #### cache override  caching can be disabled or configured on a per-query basis with `setcachingpolicy()`:  ```zig try query.setcachingpolicy(.{ .serve_stale = 600, .pci = true }); ```  attributes include:  - `no_cache` - `ttl` - `serve_stale` - `pci` - `surrogate_key`  #### pipes  with `pipe()`, the response sent to a client can be a direct copy of another response. the application will then act as a proxy, optionally also copying the original status and headers.  ```zig var query = try zigly.request.new('get', 'https://google.com'); var upstream_response = try query.send('google'); const downstream = try zigly.downstream(); try downstream.response.pipe(&upstream_response, true, true); ```  ### proxying  proxying is even easier to use than pipes when a query should be sent unmodified (with the exception of the `host` header) to the origin:  ```zig var downstream = try zigly.downstream(); try downstream.proxy('google', 'www.google.com'); ```  the second parameter is optional. if `null`, the original `host` header will not be modified.  ### redirects  redirecting the client to another address can be done with a single function call on the downstream object:  ```zig const downstream = try zigly.downstream(); try downstream.redirect(302, 'https://www.perdu.com'); ```  ### response decompression  by default, responses are left as-is. which means that if compression (`content-encoding`) was accepted by the client, the response can be compressed.  calling `setautodecompressresponse(true)` on a `request` object configures the fastly compute runtime to decompress gzip-encoded responses before streaming them to the application.  #### dictionaries  ```zig const dict = try zigly.dictionary.open('name'); const value = try dict.get(allocator, 'key'); ```  #### logging  ```zig const logger = try zigly.logger.open('endpoint); try logger.write('log entry'); ```  ## deployment to fastly's platform  the `fastly` command-line tool only supports compilation of rust and assemblyscript at the moment. however, it can still be used to upload pre-compiled code written in other languages, including zig.  1. create a new project:  ```sh fastly compute init ```  for the language, select `other (pre-compiled wasm binary)`.  2. add a build script:  add the following lines to the fastly.toml file:  ```toml [scripts] build = 'zig build -doptimize=releasesmall -dtarget=wasm32-wasi && mkdir -p bin && cp zig-out/bin/*.wasm bin/main.wasm' ```  3. compile and package the fastly compute module:  ```sh fastly compute build ```  4. test locally  ```sh fastly compute serve ```  5. deploy!  ```sh fastly compute deploy ```  in order to deploy new versions, repeat steps 3 and 5. ","tr1ckydev/chameleon":"🦎 Terminal string styling for zig. ![](./res/banner.png)  # chameleon  🦎 terminal string styling for zig.  *currently the only fully featured terminal color solution for zig. ⚡*  - expressive api - highly performant - ability to nest styles - ability for custom themes - no dependencies - clean and focused - truecolor support - 140+ built in color presets  ![](./res/showcase.png)    ## installation  - install the package.    ```bash   zig fetch --save git+https://github.com/tr1ckydev/chameleon   ```  - add the package in `build.zig`.    ```zig   const cham = b.dependency('chameleon', .{});   exe.root_module.addimport('chameleon', cham.module('chameleon'));   ```  - import it in your project.    ```zig   const chameleon = @import('chameleon');   ```    ## usage  chameleon is divided into two apis — **comptime** and **runtime**.  - **comptime:** the comptime api is simplest way to implement colors in your terminal. - **runtime:** the runtime api is much more flexible and is the recommended way when building for production.  at the end, choose what fits best for your use case.    ## documentation  check out the full documentation [here](https://github.com/tr1ckydev/chameleon/blob/main/documentation.md).    ## `no_color` support  > according to [no-color.org](https://no-color.org/), *'command-line software which adds ansi color to its output by default should check for a `no_color` environment variable that, when present and not an empty string (regardless of its value), prevents the addition of ansi color.'* >  chameleon supports this standard only in it's **runtime api** by detecting the presence of the *no_color* environment variable (regardless of it's value), if present disables any ansi colors or styles, and can also be configured to not do so if you want to implement a different way of detection, although highly not recommended.    ## license  this repository uses the mit license. check [license](https://github.com/tr1ckydev/chameleon/blob/main/license) for full license text. ","thechampagne/webview-zig":"⚡ Zig binding & wrapper for a tiny cross-platform webview library to build modern cross-platform GUIs. # webview-zig  [![](https://img.shields.io/github/v/tag/thechampagne/webview-zig?label=version)](https://github.com/thechampagne/webview-zig/releases/latest) [![](https://img.shields.io/github/license/thechampagne/webview-zig)](https://github.com/thechampagne/webview-zig/blob/main/license)  zig binding for a tiny cross-platform **webview** library to build modern cross-platform guis.  <p align='center'> <img src='https://raw.githubusercontent.com/thechampagne/webview-zig/main/.github/assets/screenshot.png'/> </p>  ### requirements  - [zig compiler](https://ziglang.org/) - **0.12.0**  - unix    - [gtk3](https://gtk.org/) and [webkitgtk](https://webkitgtk.org/)  - windows    - [webview2 runtime](https://developer.microsoft.com/en-us/microsoft-edge/webview2/)  - macos    - [webkit](https://webkit.org/)  ### usage #### auto ``` zig fetch --save https://github.com/thechampagne/webview-zig/archive/refs/heads/main.tar.gz ``` #### manual `build.zig.zon`: ```zig .{     .dependencies = .{         .webview = .{             .url = 'https://github.com/thechampagne/webview-zig/archive/refs/heads/main.tar.gz' ,           //.hash = '12208586373679a455aa8ef874112c93c1613196f60137878d90ce9d2ae8fb9cd511',         },     }, } ``` `build.zig`: ```zig const webview = b.dependency('webview', .{     .target = target,     .optimize = optimize, }); exe.root_module.addimport('webview', webview.module('webview')); exe.linklibrary(webview.artifact('webviewstatic')); // or 'webviewshared' for shared library // exe.linksystemlibrary('webview'); to link with installed prebuilt library without building ```  ### references  - [webview](https://github.com/webview/webview) - **0.10.0**  ### license  this repo is released under the [mit license](https://github.com/thechampagne/webview-zig/blob/main/license).  third party code:  - [external/webview](https://github.com/thechampagne/webview-zig/tree/main/external/webview) licensed under the [mit license](https://github.com/thechampagne/webview-zig/tree/main/external/webview/license).  - [external/webview2](https://github.com/thechampagne/webview-zig/tree/main/external/webview2) licensed under the [bsd-3-clause license](https://github.com/thechampagne/webview-zig/tree/main/external/webview2/license). ","allyourcodebase/SDL":"SDL with the build system replaced by Zig this is a fork of [sdl](https://www.libsdl.org/), packaged for zig. unnecessary files have been deleted, and the build system has been replaced with `build.zig`. ","Arnau478/hevi":"Hex viewer <div align='center'>     <h1 align='center'>hevi</h1>     <h3>a hex viewer</h3> </div>  ![ci status](https://github.com/arnau478/hevi/actions/workflows/ci.yml/badge.svg)  ![example image](web/example.png)  ## what is hevi? hevi (pronounced like 'heavy') is a hex viewer, just like `xxd` or `hexdump`.  ## features ### parsers hevi can parse things like elf or pe files and give you syntax-highlighting. ![parser example](web/parser.png)  ### custom color palettes you can specify custom color palettes. color palettes can use standard ansi colors or truecolor.  ## usage the command should be used as `hevi <file> [flags]`. the flags are described [below](#flags).  ### flags | flag(s)                          | description                                             | | -------------------------------- | ------------------------------------------------------- | | `-h`/`--help`                    | show a help message                                     | | `-v`/`--version`                 | show version information                                | | `--color`/`--no-color`           | enable or disable colored output                        | | `--lowercase`/`--uppercase`      | toggle between lowercase and uppercase hex              | | `--size`/`--no-size`             | enable or disable the line showing the size at the end  | | `--offset`/`--no-offset`         | enable or disable showing the offset                    | | `--ascii`/`--no-ascii`           | enable or disable ascii interpretation                  | | `--skip-lines`/`--no-skip-lines` | enable or disable skipping of identical lines           | | `--raw`                          | raw format (disables most features)                     | | `--show-palette`                 | show the current color palette in a table               | | `--parser`                       | specify the parser to use. for a list use `hevi --help` |  ### environment variables the `no_color` variable is supported, and disables color (see <https://no-color.org/>) printing. note that it can be overwritten by an explicit `--color`.  ### config file the config file is a [ziggy](https://ziggy-lang.io) file. the following fields are available: ```zig color: bool, uppercase: bool, show_size: bool, show_offset: bool, show_ascii: bool, skip_lines: bool, raw: bool, palette: palette, ```  all fields are optional.  **note**: for the `palette` field you must specify all styles!  #### example config ```zig .color = true, .skip_lines = false, .palette = palette{     .normal = @color('yellow'),     .normal_alt = @color('yellow::dim'),     .normal_accent = @color('yellow:bright_black:bold'),     .c1 = @color('red'),     .c1_alt = @color('red::dim'),     .c1_accent = @color('red:bright_black:bold'),     .c2 = @color('green'),     .c2_alt = @color('green::dim'),     .c2_accent = @color('green:bright_black:bold'),     .c3 = @color('blue'),     .c3_alt = @color('blue::dim'),     .c3_accent = @color('blue:bright_black:bold'),     .c4 = @color('cyan'),     .c4_alt = @color('cyan::dim'),     .c4_accent = @color('cyan:bright_black:bold'),     .c5 = @color('magenta'),     .c5_alt = @color('magenta::dim'),     .c5_accent = @color('magenta:bright_black:bold'), }, ```  #### location  the config file is located at: | os                                     | path                                                                                             | | -------------------------------------- | ------------------------------------------------------------------------------------------------ | | linux, macos, freebsd, openbsd, netbsd | `$xdg_config_home/hevi/config.ziggy` or if the env doesn't exist `$home/.config/hevi/config.ziggy` | | windows                                | `%appdata%/hevi/config.ziggy`                                                                     | | other                                  | not supported. no config file will be read                                                       |  #### precedence hevi has a precedence for configuration and it is: 1. flags 2. environment variables 3. config file 4. defaults  ## about it is written in [zig](https://github.com/ziglang/zig), in an attempt to simplify hex viewers.  ## installation ### some linux package managers if your package manager is in the following list (and preferably in green), you can simply install it from there: [![packaging status](https://repology.org/badge/vertical-allrepos/hevi.svg)](https://repology.org/project/hevi/versions) ### other platforms you can download a binary from the [releases](https://github.com/arnau478/hevi/releases/) page. you can also clone the repository and compile it with `zig build`.  ## contribute contributions are welcome! even if you don't want to write code, you can help a lot creating new issues or testing this software.  ## license see [license](license)  [![license: gpl v3](https://img.shields.io/badge/license-gplv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) ","hendriknielaender/zBench":"📊 zig benchmark # ⚡ zbench - a zig benchmarking library  [![mit license](https://img.shields.io/badge/license-mit-blue.svg)](https://github.com/hendriknielaender/zbench/blob/head/license) ![github code size in bytes](https://img.shields.io/github/languages/code-size/hendriknielaender/zbench) [![prs welcome](https://img.shields.io/badge/prs-welcome-brightgreen.svg)](https://github.com/hendriknielaender/zbench/blob/head/contributing.md) <img src='logo.png' alt='zbench logo' align='right' width='20%'/>  zbench is a benchmarking library for the zig programming language. it is designed to provide easy-to-use functionality to measure and compare the performance of your code.  ## content  * [installation](docs/install.md) * [usage](#usage) * [configuration](#configuration)   * [compatibility notes](#compatibility-notes)   * [reporting benchmarks](#reporting-benchmarks)   * [running zbench examples](#running-zbench-examples)   * [troubleshooting](#troubleshooting) * [contributing](#contributing) * [license](#license)  ## installation  for installation instructions, please refer to the [documentation](docs/install.md).  ## usage  create a new benchmark function in your zig code. this function takes a single argument of type `std.mem.allocator` and runs the code you wish to benchmark.  ```zig fn benchmarkmyfunction(allocator: std.mem.allocator) void {     // code to benchmark here } ```  you can then run your benchmarks in a test:  ```zig test 'bench test' {     var bench = zbench.benchmark.init(std.testing.allocator, .{});     defer bench.deinit();     try bench.add('my benchmark', mybenchmark, .{});     try bench.run(std.io.getstdout().writer()); } ```  ## configuration  to customize your benchmark runs, zbench provides a `config` struct that allows you to specify several options:  ```zig pub const config = struct {     iterations: u16 = 0,     max_iterations: u16 = 16384,     time_budget_ns: u64 = 2e9, // 2 seconds     hooks: hooks = .{},     track_allocations: bool = false,  }; ```  * `iterations`: the number of iterations the benchmark has been run. this field is usually managed by zbench itself. * `max_iterations`: set the maximum number of iterations for a benchmark. useful for controlling long-running benchmarks. * `time_budget_ns`: define a time budget for the benchmark in nanoseconds. helps in limiting the total execution time of the benchmark. * `hooks`: set `before_all`, `after_all`, `before_each`, and `after_each` hooks to function pointers. * `track_allocations`: boolean to enable or disable tracking memory allocations during the benchmark.  ### compatibility notes  #### zig version  zig is in active development and the apis can change frequently, making it challenging to support every dev build. this project currently aims to be compatible with stable, non-development builds to provide a consistent experience for the users. as of now, zbench is tested and supported on zig version **_0.13.0_**.  #### performance note  it's important to acknowledge that a no-op time of ca. 15 ns (or more) is expected and is not an issue with zbench itself (see also [#77](https://github.com/hendriknielaender/zbench/issues/77)). this does not reflect an inefficiency in the benchmarking process.  ### reporting benchmarks  zbench provides a comprehensive report for each benchmark run. it includes the total operations performed, the average, min, and max durations of operations, and the percentile distribution (p75, p99, p995) of operation durations.  ```shell benchmark              runs     time (avg ± σ)         (min ... max)                p75        p99        p995 --------------------------------------------------------------------------------------------------------------- benchmarkmyfunction    1000     1200ms ± 10ms          (100ms ... 2000ms)           1100ms     1900ms     1950ms ```  this example report indicates that the benchmark 'benchmarkmyfunction' ran with an average of 1200 ms per execution and a standard deviation of 10 ms. the minimum and maximum execution times were 100 ms and 2000 ms, respectively. the 75th, 99th and 99.5th percentiles of execution times were 1100 ms, 1900 ms, and 1950 ms, respectively.  ### running zbench examples  you can build all examples with the following command:  ```shell zig build examples ```  executables can then be found in `./zig-out/bin` by default.  ### troubleshooting  * if zig doesn't detect changes in a dependency, clear the project's `zig-cache` folder and `~/.cache/zig`. * [non-ascii characters not printed correctly on windows](docs/advanced.md)  ## contributing  the main purpose of this repository is to continue to evolve zbench, making it faster and more efficient. we are grateful to the community for contributing bugfixes and improvements. read below to learn how you help improve zbench.  ### contributing guide  read our [contributing guide](contributing.md) to learn about our development process, how to propose bugfixes and improvements, and how to build and test your changes to zbench.  ### license  zbench is [mit licensed](./license). ","jedisct1/zig-charm":"A Zig version of the Charm crypto library. # charm  a tiny, self-contained cryptography library, implementing authenticated encryption and keyed hashing.  charm was especially designed for memory-constrained devices, but can also be used to add encryption support to webassembly modules with minimal overhead.  any number of hashing and authenticated encryption operations can be freely chained using a single rolling state. in this mode, each authentication tag authenticates the whole transcript since the beginning of the session.  the [original implementation](https://github.com/jedisct1/charm) was written in c and is used by the [dsvpn](https://github.com/jedisct1/dsvpn) vpn software.  this is a port to the [zig](https://ziglang.org) language. it is fully compatible with the c version.  ## usage  ### setting up a session  charm requires a 256-bit key, and, if the key is reused for different sessions, a unique session identifier (`nonce`):  ```zig var key: [charm.key_length]u8 = undefined; std.crypto.random.bytes(&key);  var charm = charm.new(key, null); ```  ### hashing  ```zig const h = charm.hash('data'); ```  ### authenticated encryption  #### encryption  ```zig const tag = charm.encrypt(msg[0..]); ```  encrypts `msg` in-place and returns a 128-bit authentication tag.  #### decryption  starting from the same state as the one used for encryption:  ```zig try charm.decrypt(msg[0..], tag); ```  returns `error.authenticationfailed` if the authentication tag is invalid for the given message and the previous transcript.  ## security guarantees  128-bit security, no practical limits on the size and length of messages.  ## other implementations:  - [charm](https://github.com/jedisct1/charm) original implementation in c. - [charm.js](https://github.com/jedisct1/charm.js) a javascript (typescript) implementation. ","Hejsil/ziter":"The missing iterators for Zig <!--- readme.md is autogenerated. please edit example/readme.md.template instead. --> # ziter  an iterator library for zig inspired by the iterators in the rust standard libary.  ```zig const iter = @import('ziter'); const std = @import('std');  test 'ascii' {     const ascii_digits = iter.range(u8, 0, 255)         .filter({}, iter.void_ctx(std.ascii.isdigit));      const ascii_alpha = try iter.range(u8, 0, 255)         .filter({}, iter.void_ctx(std.ascii.isalphabetic))         .collect_no_allocator(std.boundedarray(u8, 255){});      try iter.expectequal(iter.deref('0123456789'), ascii_digits);     try std.testing.expectequalstrings(         'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',         ascii_alpha.slice(),     ); }  test 'fibonacci' {     const fib = fibonacci{};      const fib_sum_first_5 = fib.take(5).sum(usize);     const fib_first_alphabetic = fib.map({}, to_u8)         .find({}, iter.void_ctx(std.ascii.isalphabetic));      try std.testing.expectequal(@as(usize, 7), fib_sum_first_5);     try std.testing.expectequal(@as(?u8, 'y'), fib_first_alphabetic); }  pub const fibonacci = struct {     c: usize = 0,     n: usize = 1,      pub fn next(it: *@this()) ?usize {         const curr = it.c;         it.c = it.n;         it.n = curr + it.n;         return curr;     }      pub usingnamespace iter; };  fn to_u8(_: void, item: usize) u8 {     return @truncate(item); }  ```  ","ikskuh/parser-toolkit":"A toolkit that makes it easier to write recursive-descent parsers in Zig. # a parser toolkit  ![project logo](design/logo.png)  this repo contains a tiny parser toolkit that can be used to build new parsers and programming languages.  it provides: - [x] configurable tokenizer - [x] parser core (accept functions with state restoration) - [ ] compiler error management (emission, rendering, source locations)   ## demo  invoke `zig build run` to run a tiny command line calculator that can evaluate basic expressions, parens and invoke functions: ``` $ zig build run ? 10 = 10 ? 10 + 10 = 20 ? 5 * 3 = 15 ? a = 10 = 10 ? sqrt(a) = 3.1622776601683795 ? sin(3.14) = 0.0015926529164868282 ? a = a + 1 = 11 ? a = a + 1 = 12 ? ^d ```  available functions are: ```zig fn sin(v: f64) f64 fn cos(v: f64) f64 fn tan(v: f64) f64 fn sqrt(v: f64) f64 fn pow(a: f64, b: f64) f64 fn ln(v: f64) f64 fn ln10(v: f64) f64 fn ln2(v: f64) f64 fn log(b: f64, v: f64) f64 ``` ","jiacai2050/zig-curl":"Zig bindings for libcurl 404: not found","ziglibs/ansi-term":"Zig library for dealing with ANSI terminals # ansi-term  ![ci](https://github.com/ziglibs/ansi-term/workflows/ci/badge.svg)  zig library for dealing with ansi terminals (escape codes, styles, etc.)  this was originally code which was extracted from [lscolors](https://github.com/ziglibs/lscolors) for use in other zig libraries. more features have been added since.  `ansi-term` is designed to work with zig 0.13.0.  ## documentation  automatically generated documentation for the project can be found at https://ziglibs.github.io/ansi-term/. note that autodoc is currently in beta; the website may be broken or incomplete. ","castholm/zigglgen":"Zig OpenGL binding generator # zigglgen  the only zig opengl binding generator you need.  ## installation and usage  zigglgen currently supports the following versions of the zig compiler:  - `0.12.1` - `0.13.0` - master (last tested with `0.14.0-dev.1767+d23db9427`)  older or more recent versions of the compiler are not guaranteed to be compatible.  1╲. run `zig fetch` to add the zigglgen package to your `build.zig.zon` manifest:  ```sh zig fetch --save git+https://github.com/castholm/zigglgen ```  2╲. generate a set of opengl bindings in your `build.zig` build script:  ```zig const std = @import('std');  pub fn build(b: *std.build) void {     const exe = b.addexecutable(...);      // choose the opengl api, version, profile and extensions you want to generate bindings for.     const gl_bindings = @import('zigglgen').generatebindingsmodule(b, .{         .api = .gl,         .version = .@'4.1',         .profile = .core,         .extensions = &.{ .arb_clip_control, .nv_scissor_exclusive },     });      // import the generated module.     exe.root_module.addimport('gl', gl_bindings);      b.installartifact(exe); } ```  3╲. initialize opengl and start issuing commands:  ```zig const windowing = @import(...); const gl = @import('gl');  // procedure table that will hold opengl functions loaded at runtime. var procs: gl.proctable = undefined;  pub fn main() !void {     // create an opengl context using a windowing system of your choice.     const context = windowing.createcontext(...);     defer context.destroy();      // make the opengl context current on the calling thread.     windowing.makecontextcurrent(context);     defer windowing.makecontextcurrent(null);      // initialize the procedure table.     if (!procs.init(windowing.getprocaddress)) return error.initfailed;      // make the procedure table current on the calling thread.     gl.makeproctablecurrent(&procs);     defer gl.makeproctablecurrent(null);      // issue opengl commands to your heart's content!     const alpha: gl.float = 1;     gl.clearcolor(1, 1, 1, alpha);     gl.clear(gl.color_buffer_bit);  } ```  see [`zigglgen-example/`](zigglgen-example/) for a complete example project that creates a window using [mach-glfw](https://machengine.org/pkg/mach-glfw/) and draws a triangle to it.  ## api  if you're curious what a generated set of bindings looks like, take a look at [`zigglgen-example/gles3.zig`](zigglgen-example/gles3.zig).  ### opengl symbols  zigglgen generates declarations for opengl functions, constants, types and extensions using the original names as defined in the various opengl specifications (as opposed to the prefixed names used in c).  |           | c                     | zig                | |-----------|:----------------------|:-------------------| | command   | `glclearcolor`        | `clearcolor`       | | constant  | `gl_triangles`        | `triangles`        | | type      | `glfloat`             | `float`            | | extension | `gl_arb_clip_control` | `arb_clip_control` |  ### `info`  ```zig pub const info = struct {}; ```  contains information about the generated set of opengl bindings, such as the opengl api, version and profile the bindings were generated for.  ### `proctable`  ```zig pub const proctable = struct {}; ```  holds pointers to opengl functions loaded at runtime.  this struct is very large, so you should avoid storing instances of it on the stack. use global variables or allocate them on the heap instead.  ### `proctable.init`  ```zig pub fn init(procs: *proctable, loader: anytype) bool {} ```  initializes the specified procedure table and returns `true` if successful, `false` otherwise.  a procedure table must be successfully initialized before passing it to `makeproctablecurrent` or accessing any of its fields.  `loader` is duck-typed. given the prefixed name of an opengl command (e.g. `'glclear'`), it should return a pointer to the corresponding function. it should be able to be used in one of the following two ways:  - `@as(?proc, loader(@as([*:0]const u8, prefixed_name)))` - `@as(?proc, loader.getprocaddress(@as([*:0]const u8, prefixed_name)))`  if your windowing system has a 'get procedure address' function, it is usually enough to simply pass that function as the `loader` argument.  no references to `loader` are retained after this function returns.  there is no corresponding `deinit` function.  ### `makeproctablecurrent`  ```zig pub fn makeproctablecurrent(procs: ?*const proctable) void {} ```  makes the specified procedure table current on the calling thread.  a valid procedure table must be made current on a thread before issuing any opengl commands from that same thread.  ### `getcurrentproctable`  ```zig pub fn getcurrentproctable() ?*const proctable {} ```  returns the procedure table that is current on the calling thread.  ### `extensionsupported`  (only generated if at least one extension is specified.)  ```zig pub fn extensionsupported(comptime extension: extension) bool {} ```  returns `true` if the specified opengl extension is supported by the procedure table that is current on the calling thread, `false` otherwise.  ## faq  ### which opengl apis are supported?  any apis, versions, profiles and extensions included in khronos's [opengl xml api registry](https://github.com/khronosgroup/opengl-registry/tree/main/xml) are supported. these include:  - opengl 1.0 through 3.1 - opengl 3.2 through 4.6 (compatibility/core profile) - opengl es 1.1 (common/common-lite profile) - opengl es 2.0 through 3.2 - opengl sc 2.0  the [`updateapiregistry.ps1`](updateapiregistry.ps1) powershell script is used to fetch the api registry and convert it to a set of zig source files that are committed to revision control and used by zigglgen.  ### why is a thread-local procedure table required?  per the opengl spec, opengl function pointers loaded when one opengl context is current are not guaranteed to remain valid when a different context becomes current. this means that it would be incorrect to load a single set of function pointers to global memory just once at application startup and then have them be shared by all current and future opengl contexts.  in order to support portable multi-threaded multi-context opengl applications, it must be possible to load multiple sets of function pointers. because opengl contexts are already thread-local, it makes a lot of sense to handle function pointers in a similar manner.  ### why aren't opengl constants represented as zig enums?  the short answer is that it's simply not possible to represent groups of opengl constants as zig enums in a satisfying manner:  - the api registry currently specifies some of these groups, but far from all of them, and the groups are not guaranteed   to be complete. groups can be extended by extensions, so zig enums would need to be defined as non-exhaustive, and   using constants not specified as part of a group would require casting. - some commands like *getintegerv* that can return constants will return them as plain integers. comparing the returned   values against zig enum fields would require casting. - some constants in the same group are aliases for the same value, which makes them impossible to represent as   zig enums.  ### why did calling a supported extension function result in a null pointer dereference?  certain opengl extension add features that are only conditionally available under certain opengl versions/profiles or when certain other extensions are also supported; for example, the *vertexweighthnv* command from the *nv_half_float* extension is only available when the *ext_vertex_weighting* extension is also supported. unfortunately, the api registry does not specify these interactions in a consistent manner, so it's not possible for zigglgen to generate code that ensures that calls to supported extension functions are always safe.  if you use opengl extensions it is your responsibility to read the extension specifications carefully and understand under which conditions their features are available.  ## contributing  if you have any issues or suggestions, please open an issue or a pull request.  ### help us define overrides for function parameters and return types!  due to the nature of the api registry being designed for c, zigglgen currently generates most pointers types as `[*c]` pointers, which is less than ideal. a long-term goal for zigglgen is for every single pointer type to be correctly annotated. there are approximately 3300 commands defined in the api registry and if we work together, we can achieve that goal sooner. even fixing up just a few commands would mean a lot!  overriding parameters/return types is very easy; all you need to do is add additional entries to the `paramoverride`/`returntypeoverride` functions in [`zigglgen.zig`](zigglgen.zig), then open a pull request with your changes (bonus points if you also reference relevant opengl references page or specifications in the description of your pull request).  ## license  zigglgen is licensed under the [mit license](license.md).  see [`third-party-notices.txt`](third-party-notices.txt) for third-party license notices. ","bfactory-ai/zignal":"Image processing library # zignal [![test](https://github.com/bfactory-ai/zignal/actions/workflows/test.yml/badge.svg)](https://github.com/bfactory-ai/zignal/actions/workflows/test.yml) [![documentation](https://github.com/bfactory-ai/zignal/actions/workflows/documentation.yml/badge.svg)](https://github.com/bfactory-ai/zignal/actions/workflows/documentation.yml)  <img src='https://github.com/bfactory-ai/zignal/blob/master/assets/liza.jpg' width=400>  zignal is an image processing library heavily inspired by the amazing [dlib](http://dlib.net).  ## disclaimer  this library is in early stages of development and being used internally. as a result, the api might change often.   ## reason of being  this library is used by [ameli](https://ameli.co.kr/) for its makeup virtual try on.  ## features  initially, the features in this library are the ones required to get the virtual makeup try on working. however, we hope that it can be a foundation from which we can build a high quality image processing library, collaboratively.  current features include:  - color space conversions - simple matrix struct with common linear algebra operations - singular value decomposition (svd) ported from dlib - geometry   - points and rectangles   - projective and similarity transforms   - convex hull - simple image struct with common operations   - resize   - rotate   - crop   - blur   - sharpen - drawing functions   - lines   - circles   - polygons  ## examples  i plan to add examples for most of the features of this library as simple html/js + wasm. one of the greatest things about dlib is the large amount of examples illustrating how to use many of that library features. they can be accessed from [here](https://bfactory-ai.github.io/zignal/examples/).  currently, there are examples for: - [color space conversions](https://bfactory-ai.github.io/zignal/examples/colorspace.html) - [face alignment](https://bfactory-ai.github.io/zignal/examples/face-alignment.html) - [perlin noise generation](https://bfactory-ai.github.io/zignal/examples/perlin-noise.html)  ## acknowledgements  first of all, this project would not have been possible without the existance of [dlib](http://dlib.net). in fact, the first version of the virtual makeup try on was written in c++ with dlib and emscripten. however, we decided to give zig a go, even if that meant rewriting the world, but we have no dependencies now.  finally, [b factory, inc](https://www.bfactory.ai/), which is my employer and graciously agreed to release this library to the public. ","nektro/zig-tracy":"Zig bindings for the Tracy profiler. # zig-tracy ![loc](https://sloc.xyz/github/nektro/zig-tracy) [![license](https://img.shields.io/github/license/nektro/zig-tracy.svg)](https://github.com/nektro/zig-tracy/blob/master/license) [![discord](https://img.shields.io/discord/551971034593755159.svg?logo=discord)](https://discord.gg/p6y4zqc)  zig integration for the tracy profiler.  https://github.com/wolfpld/tracy  currently uses tracy v0.7.8  ## adding to your project using the https://github.com/nektro/zigmod package manager.  ```yml root_dependencies:   - src: git https://github.com/nektro/zig-tracy ```  ## adding it to your code ```zig const tracy = @import('tracy');  fn function_i_wish_to_trace() void {     const t = tracy.trace(@src(), null);     defer t.end();     // ...     // the rest of the function body } ```  the second parameter to `trace` can be used to give a name to the zone, otherwise it will simply be the inferred function name and location in the source code.  ```zig const tracy = @import('tracy');  fn main() !void {     var quit = false;     while (!quit) {         const frame = tracy.frame(null);         defer frame.end();          // ...         // the rest of the loop     } } ```  ## building ``` $ zigmod fetch $ zig build -dtarget=native-native-gnu.2.18 ```  ## license mit ","Raiden1411/zabi":"Interact with ethereum and EVM based chains via Zig! <br/>  <p align='center'>     <picture>       <source media='(prefers-color-scheme: dark)' srcset='https://raw.githubusercontent.com/raiden1411/zabi/main/.github/zabi.svg'>       <img alt='zabi logo' src='https://raw.githubusercontent.com/raiden1411/zabi/main/.github/zabi.svg' width='auto' height='150'>     </picture> </p>  <p align='center'>   a zig library to interact with evm blockchains  <p>  <p align='center'>   <picture>     <source media='(prefers-color-scheme: dark)' srcset='https://codecov.io/github/raiden1411/zabi/graph/badge.svg'>     <img alt='zabi logo' src='https://codecov.io/github/raiden1411/zabi/graph/badge.svg' width='auto' height='25'>   </picture> <p>  ### overview zabi aims to add support for interacting with ethereum or any compatible evm based chain.   ### zig versions  zabi will support zig v0.13 in separate branches. if you would like to use it you can find it in the `zig_version_0.13.0` branch where you can build it against zig 0.13.0. the main branch of zabi will follow the latest commits from zig and the other branch will be stable in terms of zig versions but not features from zabi.  ### integration you can check how to integrate zabi in your project [here](https://www.zabi.sh/integration)  ### example usage ```zig const args_parser = zabi.args; const std = @import('std'); const zabi = @import('zabi'); const wallet = zabi.clients.wallet.wallet(.http);  const clioptions = struct {     priv_key: [32]u8,     url: []const u8, };  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();      var iter = try std.process.argswithallocator(gpa.allocator());     defer iter.deinit();      const parsed = args_parser.parseargs(clioptions, gpa.allocator(), &iter);      const uri = try std.uri.parse(parsed.url);      var wallet = try wallet.init(parsed.priv_key, .{         .allocator = gpa.allocator(),         .network_config = .{ .endpoint = .{ .uri = uri } },     }, false);     defer wallet.deinit();      const message = try wallet.signethereummessage('hello world');      const hexed = try message.tohex(wallet.allocator);     defer gpa.allocator().free(hexed);      std.debug.print('ethereum message: {s}╲n', .{hexed}); } ```  ### usage  explore the [docs](https://zabi.sh) to find out more on how you can use or integrate zabi in your project!  ### installing zig  you can install the latest version of zig [here](https://ziglang.org/download/) or you can also use a version manager like [zvm](https://www.zvm.app/guides/install-zvm/) to manage your zig version.  ### features  - json rpc with support for http/s, ws/s and ipc connections. - evm interpreter that you can use to run contract bytecode. - wallet instances and contract instances to use for interacting with nodes/json rpc. - wallet nonce manager that uses a json rpc as a source of truth. - blockexplorer support. only the free methods from those api endpoints are supported. - custom secp256k1 ecdsa signer using only zig and implementation of rfc6979 nonce generator. - custom schnorr signer. bip0340 and erc-7816 are both supported. - custom json parser that can be used to deserialize and serialized rpc data at runtime. - custom solidity tokenizer and parser generator. - ability to translate solidity source code to zig. - abi to zig types. - support for eip712. - support for eip3074 authorization message. - parsing of human readable abis into zig types with custom parser and lexer. - hd wallet and mnemonic passphrases. - rlp encoding/decoding. - ssz encoding/decoding. - abi encoding/decoding with support for log topics encoding and decoding. - parsing of encoded transactions and serialization of transaction objects. - support for all transaction types and the new eip4844 kzg commitments. - support for opstack and ens. - custom meta programming functions to translate abi's into zig types. - support for interacting with test chains such as anvil or hardhat. - custom rpc server used to fuzz data. support http, ws and ipc. - custom cli args parser that translates commands to zig types and can be used to pass data to methods. - custom data generator usefull for fuzzing.  and a lot more yet to come...  ### goal  the goal of zabi is to be one of the best library to use by the ethereum ecosystem and to expose to more people to the zig programming language.  ### contributing  contributions to zabi are greatly appreciated! if you're interested in contributing to zabi, feel free to create a pull request with a feature or a bug fix. ╲ you can also read the [contributing guide](/.github/contributing.md) **before submitting a pull request**  ### sponsors  if you find zabi useful or use it for work, please consider supporting development on [github sponsors]( https://github.com/sponsors/raiden1411) or sending crypto to [zzabi.eth](https://etherscan.io/name-lookup-search?id=zzabi.eth) or interacting with the [drip](https://www.drips.network/app/projects/github/raiden1411/zabi?exact) platform where 40% of the revenue gets sent to zabi's dependencies. thank you 🙏 ","Hejsil/zig-bench":"Simple benchmarking library # zig-bench  a simple benchmarking lib in zig  ``` test [0/2] test 'debug benchmark'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_slice(block=16)       100000         90       2690        243        107 sum_slice(block=32)       100000        170       1760        338        190 sum_slice(block=64)       100000        320       2340        476        352 sum_slice(block=128)      100000        630       2290        862        678 sum_slice(block=256)      100000       1270       3170       2402       1336 sum_slice(block=512)      100000       2550       8490       4835       2651 sum_reader(block=16)      100000        990       2640       1592       1039 sum_reader(block=32)      100000       1930       3890       3292       2012 sum_reader(block=64)      100000       3830       6250       6806       3962 sum_reader(block=128)      63673       7660      12830      15703       7852 sum_reader(block=256)      31967      15360      22190      31847      15641 sum_reader(block=512)      16031      30800      34690      59444      31191 test [1/2] test 'debug benchmark generics'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_vectors(vec4f16)      100000       2730      13390       3620       2775 sum_vectors(vec4f32)      100000       1289       5800       1277       1296 sum_vectors(vec4f64)      100000       1389       6870       1358       1400 sum_vectors(vec8f16)      100000       4400       9680       4613       4479 sum_vectors(vec8f32)      100000       1389       5180       1231       1400 sum_vectors(vec8f64)      100000       1390       6170       2260       1457 sum_vectors(vec16f16)      61088       8090      13980      15455       8184 sum_vectors(vec16f32)     100000       1399       4560       2069       1441 sum_vectors(vec16f64)     100000       1440       6080       1664       1475 all 2 tests passed. test [0/2] test 'releasesafe benchmark'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_slice(block=16)       100000          9       3550        164         18 sum_slice(block=32)       100000          9        940         22         18 sum_slice(block=64)       100000         49       1530         66         52 sum_slice(block=128)      100000         89       1280        102         92 sum_slice(block=256)      100000        169       1690        210        171 sum_slice(block=512)      100000        319       5530        724        329 sum_reader(block=16)      100000         60       2840        180         69 sum_reader(block=32)      100000        110       3059        288        121 sum_reader(block=64)      100000        209       2810        323        224 sum_reader(block=128)     100000        400       1780        387        431 sum_reader(block=256)     100000        790       2220        681        843 sum_reader(block=512)     100000       1550       4300       3805       1669 test [1/2] test 'releasesafe benchmark generics'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_vectors(vec4f16)      100000       1269       3790       1799       1283 sum_vectors(vec4f32)      100000        319       1680        300        328 sum_vectors(vec4f64)      100000        319       1860        355        329 sum_vectors(vec8f16)      100000       2399       5010       5014       2420 sum_vectors(vec8f32)      100000        319       2660        641        329 sum_vectors(vec8f64)      100000        319       7740       1019        330 sum_vectors(vec16f16)     100000       4599       9970      22580       4636 sum_vectors(vec16f32)     100000        319       4310       1231        330 sum_vectors(vec16f64)     100000        429       4070       1783        439 all 2 tests passed. test [0/2] test 'releasefast benchmark'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_slice(block=16)       100000         19       2840        128         21 sum_slice(block=32)       100000         19       1600         78         20 sum_slice(block=64)       100000         19       1970         74         21 sum_slice(block=128)      100000         19       1530         68         21 sum_slice(block=256)      100000         39       1250         74         44 sum_slice(block=512)      100000         59       1150         85         68 sum_reader(block=16)      100000         19       1170         21         20 sum_reader(block=32)      100000         19       1650         74         20 sum_reader(block=64)      100000         19       1250         34         20 sum_reader(block=128)     100000         19       1240         32         20 sum_reader(block=256)     100000         39       2180        177         44 sum_reader(block=512)     100000         59       2470        148         68 test [1/2] test 'releasefast benchmark generics'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_vectors(vec4f16)      100000       1259       8590       1678       1284 sum_vectors(vec4f32)      100000        319       1440        279        327 sum_vectors(vec4f64)      100000        319       1760        303        327 sum_vectors(vec8f16)      100000       2399       5260       1861       2417 sum_vectors(vec8f32)      100000        319       2080        434        327 sum_vectors(vec8f64)      100000        319       1710        329        328 sum_vectors(vec16f16)     100000       4599       9010       3883       4634 sum_vectors(vec16f32)     100000        319       2800        356        329 sum_vectors(vec16f64)     100000        429       1750        404        436 all 2 tests passed. test [0/2] test 'releasesmall benchmark'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_slice(block=16)       100000         19       2760        247         27 sum_slice(block=32)       100000         29       5090        363         37 sum_slice(block=64)       100000         50       2640        177         63 sum_slice(block=128)      100000         90       1830        157        102 sum_slice(block=256)      100000        169       5860        733        201 sum_slice(block=512)      100000        330       3690       1560        365 sum_reader(block=16)      100000        219       1430        276        226 sum_reader(block=32)      100000        420       1870        460        432 sum_reader(block=64)      100000        819       2690        770        837 sum_reader(block=128)     100000       1629       5390       1696       1649 sum_reader(block=256)     100000       3240       9080       3240       3274 sum_reader(block=512)      76638       6469       9780       5302       6524 test [1/2] test 'releasesmall benchmark generics'...  benchmark             iterations    min(ns)    max(ns)   variance   mean(ns) ---------------------------------------------------------------------------- sum_vectors(vec4f16)      100000       4859      16710       5250       4902 sum_vectors(vec4f32)      100000        319       1650        326        328 sum_vectors(vec4f64)      100000        319       1470        295        327 sum_vectors(vec8f16)      100000       3980       9070       3382       4254 sum_vectors(vec8f32)      100000        319       3740        459        328 sum_vectors(vec8f64)      100000        319       4100        534        330 sum_vectors(vec16f16)      79800       6219      15130      10000       6265 sum_vectors(vec16f32)     100000        319       3340        455        330 sum_vectors(vec16f64)     100000        429       2020        454        438 all 2 tests passed. ``` ","jiacai2050/zigcli":"A toolkit for building command lines programs in Zig. 404: not found","rockorager/zeit":"a date and time library written in zig. Timezone, DST, and leap second aware # zeit  a time library written in zig.  ## usage  [api documentation](https://rockorager.github.io/zeit/)  ```zig const std = @import('std'); const zeit = @import('zeit');  pub fn main() void {     const allocator = std.heap.page_allocator;     var env = try std.process.getenvmap(allocator);     defer env.deinit();      // get an instant in time. the default gets 'now' in utc     const now = try zeit.instant(.{});      // load our local timezone. this needs an allocator. optionally pass in a     // *const std.process.envmap to support tz and tzdir environment variables     const local = try zeit.local(alloc, &env);      // convert our instant to a new timezone     const now_local = now.in(&local);      // generate date/time info for this instant     const dt = now_local.time();      // print it out     std.debug.print('{}', .{dt});      // zeit.time{     //    .year = 2024,     //    .month = zeit.month.mar,     //    .day = 16,     //    .hour = 8,     //    .minute = 38,     //    .second = 29,     //    .millisecond = 496,     //    .microsecond = 706,     //    .nanosecond = 64     //    .offset = -18000,     // }      // format using strftime specifier. format strings are not required to be comptime     try dt.strftime(anywriter, '%y-%m-%d %h:%m:%s %z');      // or...golang magic date specifiers. format strings are not required to be comptime     try dt.gofmt(anywriter, '2006-01-02 15:04:05 mst');      // load an arbitrary location using iana location syntax. the location name     // comes from an enum which will automatically map iana location names to     // windows names, as needed. pass an optional envmap to support tzdir     const vienna = try zeit.loadtimezone(alloc, .@'europe/vienna', &env);     defer vienna.deinit();      // parse an instant from an iso8601 or rfc3339 string     const iso = try zeit.instant(.{   .source = .{       .iso8601 = '2024-03-16t08:38:29.496-1200',   },     });      const rfc3339 = try zeit.instant(.{   .source = .{       .rfc3339 = '2024-03-16t08:38:29.496706064-1200',   },     }); } ``` ","alichraghi/zort":"Sorting algorithms in zig # zort  ![logo](/media/logo.png)  implementation of 13 sorting algorithms in zig  | algorithm               | custom comparison | zero allocation | | ----------------------- | ----------------- | --------------- | | bubble                  | ✅                | ✅              | | comb                    | ✅                | ✅              | | heap                    | ✅                | ✅              | | insertion               | ✅                | ✅              | | merge                   | ✅                | ❌              | | pdq                     | ✅                | ✅              | | quick                   | ✅                | ✅              | | radix (no negative yet) | ❌                | ❌              | | selection               | ✅                | ✅              | | shell                   | ✅                | ✅              | | tail                    | ✅                | ❌              | | tim                     | ✅                | ❌              | | twin                    | ✅                | ❌              |  ## usage  ```zig const zort = @import('zort');  fn asc(a: u8, b: u8) bool {     return a < b; }  pub fn main() !void {     var arr = [_]u8{ 9, 1, 4, 12, 3, 4 };     try zort.quicksort(u8, &arr, asc); } ```  ## benchmarks  run this to see results on your machine: ``` zig build bench -doptimize=releasefast -- comb quick radix shell std_block std_heap std_pdq tail tim twin ```  ### 12th gen intel(r) core(tm) i5-12400f  ```mermaid gantt     title sorting (ascending) 10000000 usize     dateformat x     axisformat %s s     section random     quick 1.670: 0,1670     comb 3.156: 0,3155     shell 5.469: 0,5467     radix 0.304: 0,304     tim 2.893: 0,2893     tail 2.400: 0,2399     twin 2.377: 0,2377     std_block 3.371: 0,3372     std_pdq 2.250: 0,2250     std_heap 5.512: 0,5514     section sorted     quick 0.829: 0,829     comb 1.179: 0,1179     shell 0.740: 0,740     radix 0.301: 0,301     tim 0.025: 0,25     tail 0.058: 0,58     twin 0.071: 0,71     std_block 0.266: 0,266     std_pdq 0.041: 0,41     std_heap 3.912: 0,3913     section reverse     quick 1.544: 0,1544     comb 1.375: 0,1375     shell 1.378: 0,1378     radix 0.303: 0,303     tim 0.822: 0,822     tail 1.364: 0,1364     twin 1.280: 0,1280     std_block 1.304: 0,1304     std_pdq 0.199: 0,199     std_heap 3.844: 0,3845     section ascending saw     quick 2.979: 0,2978     comb 2.088: 0,2089     shell 1.807: 0,1807     radix 0.322: 0,322     tim 0.473: 0,473     tail 0.486: 0,486     twin 0.465: 0,465     std_block 1.129: 0,1129     std_pdq 1.604: 0,1604     std_heap 4.246: 0,4249     section descending saw     comb 1.949: 0,1949     shell 1.694: 0,1694     radix 0.299: 0,299     tim 1.339: 0,1339     tail 1.478: 0,1478     twin 1.288: 0,1288     std_block 1.618: 0,1618     std_pdq 1.613: 0,1613     std_heap 4.262: 0,4261 ```  ```mermaid gantt     title sorting (ascending) 10000000 isize     dateformat x     axisformat %s s     section random     quick 1.691: 0,1691     comb 3.084: 0,3084     shell 5.410: 0,5413     radix 0.332: 0,332     tim 2.951: 0,2953     tail 2.414: 0,2414     twin 2.414: 0,2414     std_block 3.346: 0,3346     std_pdq 2.309: 0,2309     std_heap 5.449: 0,5447     section sorted     quick 0.798: 0,798     comb 1.166: 0,1166     shell 0.739: 0,739     radix 0.247: 0,247     tim 0.025: 0,25     tail 0.059: 0,59     twin 0.048: 0,48     std_block 0.270: 0,270     std_pdq 0.039: 0,39     std_heap 3.816: 0,3815     section reverse     quick 1.581: 0,1581     comb 1.347: 0,1347     shell 1.234: 0,1234     radix 0.262: 0,262     tim 0.044: 0,44     tail 1.396: 0,1396     twin 0.041: 0,41     std_block 0.953: 0,953     std_pdq 0.204: 0,204     std_heap 3.713: 0,3713     section ascending saw     quick 5.516: 0,5516     comb 2.064: 0,2064     shell 1.632: 0,1632     radix 0.280: 0,280     tim 0.449: 0,449     tail 0.466: 0,466     twin 0.478: 0,478     std_block 1.157: 0,1157     std_pdq 1.618: 0,1618     std_heap 4.281: 0,4279     section descending saw     comb 2.039: 0,2040     shell 1.644: 0,1644     radix 0.279: 0,279     tim 0.465: 0,465     tail 1.492: 0,1492     twin 0.481: 0,481     std_block 1.596: 0,1596     std_pdq 1.576: 0,1576     std_heap 4.199: 0,4199 ```  ### big thank to  [voroskoi](https://github.com/voroskoi) and other contributors ","ZigEmbeddedGroup/serial":"Serial port configuration library for Zig # zig serial port library  library for configuring and listing serial ports.  ## features  - basic serial port configuration   - baud rate   - parity (none, even, odd, mark, space)   - stop bits (one, two)   - handshake (none, hardware, software)   - byte size (5, 6, 7, 8) - flush serial port send/receive buffers - list available serial ports - api: supports windows, linux and mac  ## example  ```zig // port configuration. // serial ports are just files, ╲╲.╲com1 for com1 on windows: var serial = try std.fs.cwd().openfile('╲╲╲╲.╲╲com1', .{ .mode = .read_write }) ; defer serial.close();  try zig_serial.configureserialport(serial, zig_serial.serialconfig{     .baud_rate = 19200,     .word_size = 8,     .parity = .none,     .stop_bits = .one,     .handshake = .none, }); ```  ## usage  ### library integration  integrate the library in your project via the zig package manager:  - add `serial` to your `.zig.zon` file by providing the url to the archive of a tag or specific commit of the library - to update the hash, run `zig fetch --save [url/to/tag/or/commit.tar.gz]`  ### running tests  the `build.zig` file contains a test step that can be called with `zig build test`. note that this requires a serial port to be available on the system;  - linux: `/dev/ttyusb0` - mac: `/dev/cu.usbmodem101` - windows: `com3`  ### building the examples  you can build the examples from the `./examples` directory by calling `zig build examples`. binaries will be generated in `./zig-out/bin` by default.  - note that the `list_port_info` example currently only works on windows ","MoAlyousef/zfltk":"Zig bindings for the FLTK gui library # zfltk a zig wrapper for the fltk gui library.  ## running the examples ``` git clone https://github.com/moalyousef/zfltk --recurse-submodules cd zfltk zig build run-simple zig build run-capi zig build run-editor zig build run-input zig build run-image zig build run-mixed ```  ## usage until an official zig package manager is published, the easiest way to use the library is to add it as a subdirectory to your project, either via git submodules or git clone: ``` git submodule add https://github.com/moalyousef/zfltk cd zfltk git checkout pre_zpm cd .. git submodule update --init --recursive ``` then you will need a build.zig file as follows: ```zig const std = @import('std'); const sdk = @import('zfltk/sdk.zig'); const builder = std.build.builder;  pub fn build(b: *builder) !void {     const target = b.standardtargetoptions(.{});     const mode = b.standardreleaseoptions();     const sdk = sdk.init(b);     const exe = b.addexecutable('main', 'src/main.zig');     exe.addpackagepath('zfltk', 'zfltk/src/zfltk.zig');     exe.settarget(target);     exe.setbuildmode(mode);     try sdk.link('zfltk', exe); // takes the sdk path     exe.install();      const run_cmd = exe.run();     run_cmd.step.dependon(b.getinstallstep());     if (b.args) |args| {         run_cmd.addargs(args);     }      const run_step = b.step('run', 'run the app');     run_step.dependon(&run_cmd.step); } ``` then you can run: ``` zig build run ```  ## dependencies   this repo tracks cfltk, the c bindings to fltk. it (along with fltk) is statically linked to your application. this requires cmake (and ninja on windows) as a build system, and is only required once.  - windows: no dependencies. - macos: no dependencies. - linux: x11 and opengl development headers need to be installed for development. the libraries themselves are available on linux distros with a graphical user interface.  for debian-based gui distributions, that means running: ``` sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libpng-dev libgl1-mesa-dev libglu1-mesa-dev ``` for rhel-based gui distributions, that means running: ``` sudo yum groupinstall 'x software development' && yum install pango-devel libxinerama-devel libpng-devel libstdc++-static ``` for arch-based gui distributions, that means running: ``` sudo pacman -s libx11 libxext libxft libxinerama libxcursor libxrender libxfixes libpng pango cairo libgl mesa --needed ``` for alpine linux: ``` apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev libpng-dev mesa-gl ``` for nixos: ``` nix-shell --packages rustc cmake git gcc xorg.libxext xorg.libxft xorg.libxinerama xorg.libxcursor xorg.libxrender xorg.libxfixes libcerf pango cairo libgl mesa pkg-config ```  ## api using the zig wrapper (under development): ```zig const zfltk = @import('zfltk'); const app = zfltk.app; const window = zfltk.window; const button = zfltk.button; const box = zfltk.box; const color = zfltk.enums.color;  fn butcb(but: *button(.normal), data: ?*anyopaque) void {     var box = box.fromraw(data.?);      box.setlabel('hello world!');      but.setcolor(color.fromname(.cyan)); }  pub fn main() !void {     try app.init();     app.setscheme(.gtk);      var win = try window.init(.{         .w = 400,         .h = 300,          .label = 'hello',     });      var but = try button(.normal).init(.{         .x = 160,         .y = 220,         .w = 80,         .h = 40,          .label = 'click me!',     });      var box = try box.init(.{         .x = 10,         .y = 10,         .w = 380,         .h = 180,          .boxtype = .up,     });      box.setlabelfont(.courier);     box.setlabelsize(18);      win.group().end();     win.widget().show();      but.setcallbackex(butcb, box);     try app.run(); } ``` the messaging api can also be used: ```zig const zfltk = @import('zfltk'); const app = zfltk.app; const widget = zfltk.widget; const window = zfltk.window; const button = zfltk.button; const box = zfltk.box; const enums = zfltk.enums;  pub const message = enum(usize) {     // can't begin with zero!     first = 1,     second, };  pub fn main() !void {     try app.init();     app.setscheme(.gtk);      var win = try window.init(.{         .w = 400,         .h = 300,          .label = 'hello',     });      var but1 = try button(.normal).init(.{         .x = 100,         .y = 220,         .w = 80,         .h = 40,          .label = 'button 1',     });      var but2 = try button(.normal).init(.{         .x = 200,         .y = 220,         .w = 80,         .h = 40,          .label = 'button 2',     });      var mybox = try box.init(.{         .x = 10,         .y = 10,         .w = 380,         .h = 180,          .boxtype = .up,     });      mybox.setlabelfont(.courier);     mybox.setlabelsize(18);      win.group().end();     win.show();     but1.emit(message, .first);     but2.emit(message, .second);      while (app.wait()) {         if (app.recv(message)) |msg| switch (msg) {             .first => mybox.setlabel('button 1 clicked!'),             .second => mybox.setlabel('button 2 clicked!'),         };     } } ```  using the c api directly: ```zig const c = @cimport({     @cinclude('cfl.h'); // fl_run     @cinclude('cfl_enums.h'); // fl_color_*     @cinclude('cfl_button.h'); // fl_button     @cinclude('cfl_box.h'); // fl_box     @cinclude('cfl_window.h'); // fl_window });  pub fn butcb(w: ?*c.fl_widget, data: ?*anyopaque) callconv(.c) void {     c.fl_box_set_label(@ptrcast(?*c.fl_box, data), 'hello world!');     c.fl_button_set_color(@ptrcast(?*c.fl_button, w), c.fl_color_cyan); }  pub fn main() void {     c.fl_set_scheme('gtk+');     var win = c.fl_window_new(100, 100, 400, 300, 'hello');     var but = c.fl_button_new(160, 220, 80, 40, 'click me!');     var box = c.fl_box_new(10, 10, 380, 180, '');     c.fl_window_end(win);     c.fl_window_show(win);     c.fl_button_set_callback(but, butcb, box);     _ = c.fl_run(); } ``` you can also mix and match for any missing functionalities in the zig wrapper (see examples/mixed.zig)  ![alt_test](screenshots/image.jpg) ![alt_test](screenshots/editor.jpg)  ","joachimschmidt557/linenoize":"A port of linenoise to zig # linenoize  a port of [linenoise](https://github.com/antirez/linenoise) to zig aiming to be a simple readline for command-line applications written in zig. it is written in pure zig and doesn't require libc. `linenoize` works with the latest stable zig version (0.13.0).  in addition to being a full-fledged zig library, `linenoize` also serves as a drop-in replacement for linenoise. as a proof of concept, the example application from linenoise can be built with `zig build c-example`.  ## features  - line editing - completions - hints - history - multi line mode - mask input mode  ### supported platforms  - linux - macos (experimental) - todo: windows - todo: freebsd  ## examples  ### minimal example  ```zig const std = @import('std'); const linenoise = @import('linenoise').linenoise;  pub fn main() !void {     const allocator = std.heap.page_allocator;      var ln = linenoise.init(allocator);     defer ln.deinit();      while (try ln.linenoise('hello> ')) |input| {         defer allocator.free(input);         std.debug.print('input: {s}╲n', .{input});         try ln.history.add(input);     } } ```  ### example of more features  ``` zig const std = @import('std'); const allocator = std.mem.allocator; const arraylist = std.arraylist;  const linenoise = @import('linenoise').linenoise;  fn completion(alloc: *allocator, buf: []const u8) ![][]const u8 {     if (std.mem.eql(u8, 'z', buf)) {         var result = arraylist([]const u8).init(alloc);         try result.append(try alloc.dupe(u8, 'zig'));         try result.append(try alloc.dupe(u8, 'ziglang'));         return result.toownedslice();     } else {         return &[_][]const u8{};     } }  fn hints(alloc: *allocator, buf: []const u8) !?[]const u8 {     if (std.mem.eql(u8, 'hello', buf)) {         return try alloc.dupe(u8, ' world');     } else {         return null;     } }  pub fn main() !void {     var arena = std.heap.arenaallocator.init(std.heap.page_allocator);     defer arena.deinit();     const allocator = &arena.allocator;      var ln = linenoise.init(allocator);     defer ln.deinit();      // load history and save history later     ln.history.load('history.txt') catch std.debug.print('failed to load history╲n', .{});     defer ln.history.save('history.txt') catch std.debug.print('failed to save history╲n', .{});      // set up hints callback     ln.hints_callback = hints;      // set up completions callback     ln.completions_callback = completion;      // enable mask mode     // ln.mask_mode = true;      // enable multiline mode     // ln.multiline_mode = true;      while (try ln.linenoise('hello> ')) |input| {         defer allocator.free(input);         std.debug.print('input: {s}╲n', .{input});         try ln.history.add(input);     } } ``` ","SimonLSchlee/zigraylib":"a fairly minimal raylib zig example codebase using the zig package manager # zigraylib a fairly minimal [raylib](https://www.raylib.com/) [zig](https://ziglang.org/download/) example codebase using the zig package manager.  ## install ```bash git clone https://github.com/simonlschlee/zigraylib.git cd zigraylib zig build run ```  tested with zig version: `0.13.0`   using raylib commit: https://github.com/raysan5/raylib/tree/52f2a10db610d0e9f619fd7c521db08a876547d0  ## resources [raylib cheatsheet](https://www.raylib.com/cheatsheet/cheatsheet.html)   [learn ⚡ zig programming language](https://ziglang.org/learn/)   [zig community](https://github.com/ziglang/zig/wiki/community)    ## raygui  if you want to use raygui checkout the [raygui](https://github.com/simonlschlee/zigraylib/tree/raygui) branch.  ## code completion [zls installation](https://github.com/zigtools/zls/wiki/installation)  ## ideas or improvements? let me know if you have ideas about things that could make this example better. i want to keep it fairly minimal, but maybe we can add some more links to useful resources, or point out common problems. ziggit topic for discussion: https://ziggit.dev/t/raylib-example-using-the-package-manager/1787  ## license public domain or mit ","karlseguin/zqlite.zig":"A thin SQLite wrapper for Zig 404: not found","Guigui220D/zig-sfml-wrapper":"A zig wrapper for csfml 404: not found","andrewrk/StaticHttpFileServer":"Zig module for serving a directory of files from memory via HTTP # simple static http file server zig module  upon initialization, this module recursively walks the specified directory and permanently caches all file contents to memory. when handling an http request, this module will never touch the file system.  as part of this process, it will compress the file contents using gzip, and then choose whether to keep the compressed version or uncompressed version based on a configurable compression ratio (defaulting to 95%).  this module is well-suited for web applications that have a fixed set of unchanging assets that have no problem fitting into memory.  i have a [similar project for node.js](https://github.com/andrewrk/connect-static).  ## status  basic features work, but see the roadmap below for planned enhancements.  ## synopsis  initialize:  ```zig const statichttpfileserver = @import('statichttpfileserver');  var static_http_file_server = try statichttpfileserver.init(.{     .allocator = gpa,     .root_dir = tmp.dir, }); defer static_http_file_server.deinit(gpa); ```  then hand off a request to be serviced:  ```zig try static_http_file_server.serve(&http_request); ```  see also `serve.zig` for a standalone example.  ## roadmap  1. gzip compression 2. support more http headers    * `etag`    * `if-none-match`    * `if-modified-since`    * `accept-encoding`    * `content-encoding`  ## testing  standard unit tests:  ``` zig build test ```  there is also this:  ``` zig build serve -- [path] ```  starts listening on localhost and serves static files at [path] so you can poke around manually. ","greenfork/jzignet":"Zig library to connect Janet and Zig together # jzignet  [zig](https://ziglang.org/) is a general-purpose programming language and toolchain for maintaining robust, optimal, and reusable software.  [janet](https://janet-lang.org/) is a functional and imperative programming language and bytecode interpreter. it is a lisp-like language, but lists are replaced by other data structures (arrays, tables (hash table), struct (immutable hash table), tuples). the language also supports bridging to native code written in c, meta-programming with macros, and bytecode assembly.  [jzignet](https://git.sr.ht/~greenfork/jzignet) - zig library to connect janet and zig together.  you can: * embed janet programs into zig * write janet modules in zig * write bindings in zig for a c library to be used as a janet module  why use these bindings, besides obvious reasons such as connecting together two wonderful languages: * you don't need to care about conversion between zig and c. but you have full   access to c internals if you need to. * plenty of tests which are great examples and guarantee minimal regressions   when updating. * idiomatic zig code - everything is typed, names are properly cased,   operations on types use methods instead of prefixed global functions.  currently supported versions: * zig 0.13.0 * janet 1.31.0  repository is available at [sourcehut](https://git.sr.ht/~greenfork/jzignet) and at [github](https://github.com/greenfork/jzignet).  ## how to use  if you want to just start using it, jump to the examples. copy them or look at the source code, it is heavily commented.  * [embed janet into zig](examples/embed_janet.zig) --   run this example with `zig build run-embed_janet`.     for a more in-depth overview of this use case you can take a look at   @iacore's [blog post](https://www.1a-insec.net/blog/16-buy-janet-get-gc-free/)   as well as the [example repository](https://git.envs.net/iacore/janet-zig-test).  warning: examples are currently **not working**:  * [write janet module in zig](examples/zig_module) -- the template is broken   and needs some investigation on how to fix it.  write bindings in zig for a c library to be used as a janet module - this is very close to 'write janet module in zig' example, you just need to know how to wrap a c library in zig, this repository is a perfect example for this.  ## how to include as a dependency (with zon)  1. create a file named `build.zig.zon` with the following content.  ```zig .{     .name = 'janet-zig-test',     .version = '0.0.1',     .dependencies = .{         .jzignet = .{             .url = 'https://git.sr.ht/~greenfork/jzignet/archive/0.7.2.tar.gz',             .hash = '122087fa45b016bd8ce5fbadd17ef2bd84cd1389119edd3c345486870032ea2b7217',         },     }, } ```  2. add this to `build.zig`.  ```zig     const jzignet = b.dependency('jzignet', .{ .target=target, .optimize=optimize });      // your executable defined here     // const exe = ...;      exe.addmodule('jzignet', jzignet.module('jzignet'));     exe.linklibrary(jzignet.artifact('jzignet')); ```  3. use in your zig code  ```zig const jzignet = @import('jzignet'); ```  ## how to include as a dependency (with git submodule)  currently you can include jzignet as a git submodule. janet is bundled as a single c source amalgamation file and is compiled directly into this library.  1. include git submodule into your library, assuming further that `libpath` is    the directory where this library is installed  ```shell git submodule add https://github.com/greenfork/jzignet libpath ```  2. include the library in `build.zig`  ```zig     const jzignet = b.anonymousdependency('lib/jzignet', @import('lib/jzignet/build.zig'), .{});      // your executable defined here     // const exe = ...;      exe.addmodule('jzignet', jzignet.module('jzignet'));     exe.linklibrary(jzignet.artifact('jzignet')); ```  3. use in your zig code  ```zig const jzignet = @import('jzignet'); ```  ## differences with c api  ### naming * `janet_` prefix is mostly not present. * every type is a zig struct and corresponding functions are called as   methods, for example, `janet_table_get(table, key)` becomes `table.get(key)`. * **all** bindings have idiomatic zig naming even when janet uses different   ones, for example `arity` and `fixarity` are `arity` and `fixarity` in zig. * functions like `janet_table` are available as `table.init`, please consult   the source code for that.  ### semantics * function return types return error sets as well as optional values where it   makes sense to do so, for example, `table.get` returns `?janet` and `pcall`   returns `signal.error!void`. * all types are wrapped into structs. most of the types support this natively   since they are structs in c too, others (tuple, struct, string, keyword,   symbol) cannot be represented as structs directly and they are wrappers   with a `ptr` or `slice` field containing the original value. * all functions that have a type at the end, for example, `janet_get_number`,   instead use this signature: `get(comptime t: type, ...)`. currently these   functions exist: `get`, `opt`, `wrap`, `janet.unwrap`. * when you need to supply a pointer to the array and a length in the c version,   in zig version you need to supply just a slice since it has both the pointer   and the length, so it's one parameter instead of two. for example,   ```c   int janet_dobytes(janettable *env, const uint8_t *bytes, int32_t len, const char *sourcepath, janet *out);   ```      becomes   ```zig   pub fn dobytes(env: *environment, bytes: []const u8, source_path: [:0]const u8) !janet   ``` * abstracts are fully typed, no *void pointers to @ptrcast. take a look at   tests for examples with abstracts, they are generally reworked to make   them easier to use. * all functions returning `signal` instead return `void` on `ok` and return   error otherwise with the specified signal, signature is `signal.error!void`. * `dostring` and `dobytes` are aliases and return `!janet` directly instead of   accepting a reference for the return value. * `string`, `keyword`, `symbol`, `nil` top-level functions are the only ones to   create these types and they do what you want. * `environment` type introduced which is internally a `table` but allows   conceptually different operations such as defining values and executing code.  ## completeness  bindings are not complete 100% but all the generally useful things are there. if you need any specific part of the api, feel free to contribute or just ask (and you shall receive).  ## q'n'a  q: what's with the name?  a: 'janet'.replace('a', 'zig')  q: i hate that name.  a: yes, i know.  ## license  mit, see license file. ","jedisct1/zig-minisign":"Minisign reimplemented in Zig. # zig-minisign  a zig implementation of [minisign](https://jedisct1.github.io/minisign/).  `minizign` was primarily designed to verify signatures, although signing is likely to be implemented next.  ## compilation  requires the current `master` version of [zig](https://ziglang.org).  compile with:  ```sh zig build -doptimize=releasesmall ```  for a size-optimized version, or  ```sh zig build -doptimize=releasefast ```  for a speed-optimized version.  ## usage  ```text usage:     -h, --help                  display this help and exit     -p, --publickey-path <path> public key path to a file     -p, --publickey <string>    public key, as a base64-encoded string     -l, --legacy                accept legacy signatures     -m, --input <path>          input file     -q, --quiet                 quiet mode     -v, --verify                verify     -c, --convert               convert the given public key to ssh format ```  ## example  verify `public-resolvers.md` using `public-resolvers.md.minisig` and the public key file `minisig.pub`:  ```sh minizign -p minisign.pub -vm public-resolvers.md ```  verify `public-resolvers.md` by directly providing the public key on the command-line:  ```sh minizign -p rwqf6lrcga9i53mlyeco4izt51tgppvwucnsch1cbm0qtaln73y7gfo3 -vm public-resolvers.md ```  ## ssh-encoded public keys  `minizign` can encode public keys in ssh format, so that they can be uploaded to github:  ```sh minizign -p minisign.pub -c ```  ```text ssh-ed25519 aaaac3nzac1lzdi1nte5aaaaihmlyeco4izt51tgppvwucnsch1cbm0qtaln73y7gfo3 minisign key e7620f1842b4e81f ```  github makes public ssh keys available at `https://github.com/<username>.keys`.  ssh-encoded keys can be loaded by `minizign` the same way as native keys, with `-p <key file>`. they will be automatically recognized as such.  ## features  `minizign` supports prehashing (which can be forced if you know this is how the signature was created), has zero dependencies and can be cross-compiled to anything that zig can cross-compile to, including webassembly. ","judofyr/zini":"Succinct data structures for Zig # zini  zini (zig + mini) is a [zig](https://ziglang.org/) library providing some succinct data structures:  - `zini.pthash`, a [**minimal perfect hash function**](https://en.wikipedia.org/wiki/perfect_hash_function) construction algorithm, using less than 4 bits per element. - `zini.ribbon`, a **retrieval data structure** (sometimes called a 'static function') construction algorithm, having less than 1% overhead. - `zini.compactarray` stores n-bit numbers tightly packed, leaving no bits unused.   if the largest value in an array is `m` then you actually only need `n = log2(m) + 1` bits per element.   e.g. if the largest value is 270, you will get 7x compression using compactarray over `[]u64` as it stores each element using only 9 bits (and 64 divided by 9 is roughly 7). - `zini.dictarray` finds all distinct elements in the array, stores each once into a compactarray (the dictionary), and creates a new compactarray containing indexes into the dictionary.   this will give excellent compression if there's a lot of repetition in the original array. - `zini.eliasfano` stores increasing 64-bit numbers in a compact manner. - `zini.darray` provides constant-time support for the `select1(i)` operation which returns the _i_-th set bit in a `std.dynamicbitsetunmanaged`.  ## overview  ### pthash, minimal perfect hash function  `zini.pthash` contains an implementation of [pthash][pthash], a [minimal perfect hash function](https://en.wikipedia.org/wiki/perfect_hash_function) construction algorithm. given a set of `n` elements, with the only requirement being that you can hash them, it generates a hash function which maps each element to a distinct number between `0` and `n - 1`. the generated hash function is extremely small, typically consuming less than **4 _bits_ per element**, regardless of the size of the input type. the algorithm provides multiple parameters to tune making it possible to optimize for (small) size, (short) construction time, or (short) lookup time.  to give a practical example: in ~0.6 seconds zini was able to create a hash function for /usr/share/dict/words containing 235886 words. the resulting hash function required in total 865682 bits in memory. this corresponds to 108.2 kb in total or 3.67 bits per word. in comparison, the original file was 2.49 mb and compressing it with `gzip -9` only gets it down to 754 kb (which you can't use directly in memory without decompressing it). it should of course be noted that they don't store the equivalent data as you can't use the generated hash function to determine if a word is present or not in the list. the comparison is mainly useful to get a feeling of the magnitudes.  ### bumped ribbon retrieval, a retrieval data structure  `zini.ribbon` contains an implementation of [bumped ribbon retrieval][burr] (_burr_), a retrieval data structure. given `n` keys (with the only requirement being that you can hash them) which each have an `r`-bit value, we'll build a data structure which will return the value for all of the `n` keys. however, the keys are actually not stored (we're only using the hash) so if you ask for the value for an _unknown_ key you will get a seemingly random answer; there's no way of knowing whether the key was present in the original dataset or not.  the theoretically minimal amount of space needed to store the _values_ is `n * r` (we have `n` `r`-bit values after all). we use the term 'overhead' to refer to how much _extra_ amount of data we need. the bumped ribbon retrieval will often have **less than 1% overhead**.  ## usage  zini is intended to be used as a library, but also ships the command-line tools `zini-pthash` and `zini-ribbon`. as the documentation is a bit lacking it might be useful to look through `tools/zini-{pthash,ribbon}/main.zig` to understand how it's used.  ``` usage   ./zig-out/bin/zini-pthash [build | lookup] <options>  command: build   builds hash function for plain text file.    -i, --input <file>   -o, --output <file>   -c <int>   -a, --alpha <float>   -s, --seed <int>  command: lookup    -i, --input <file>   -k, --key <key>   -b, --benchmark ```  and here's an example run of using `zini-pthash`.  ``` # build zini-pthash: $ zig build -drelease-safe  # build a hash function: $ ./zig-out/bin/zini-pthash build -i /usr/share/dict/words -o words.pth reading /usr/share/dict/words...  building hash function...  successfully built hash function:   seed: 12323441790160983030   bits: 865554   bits/n: 3.6693741892269993  writing to words.pth  # look up an index in the hash function: $ ./zig-out/bin/zini-pthash lookup -i words.pth --key hello reading words.pth...  successfully loaded hash function:   seed: 12323441790160983030   bits: 865554   bits/n: 3.6693741892269993  looking up key=hello: 112576 ```  ## acknowledgments  zini is merely an implementation of existing algorithms and techniques already described in the literature:  - the [pthash][pthash] algorithm is described by giulio ermanno pibiri and roberto trani in arxiv:2104.10402. - they also implemented pthash as a c++ library in <https://github.com/jermp/pthash> under the mit license.   zini uses no code directly from that repository, but it has been an invaluable resource for understanding how to implement pthash in practice. - the [burr][burr] data structure is described by peter c. dillinger, lorenz hübschle-schneider, peter sanders and stefan walzer in arxiv:2109.01892.  [pthash]: https://arxiv.org/abs/2104.10402 [burr]: https://arxiv.org/abs/2109.01892  ## license  zini is licensed under the [0bsd license](https://spdx.org/licenses/0bsd.html). ","r4gus/keylib":"FIDO2/ PassKey compatible authentication library fido2 compatible authenticator and client library written in [zig](https://ziglang.org/). the authenticator part requires __zero dynamic allocations__.  > we track the latest stable release of zig (`0.12.0`)  if you want to see an example on how the library could be used, check out [passkeez](https://github.com/r4gus/keypass).  ## qa  <details> <summary><ins>what is fido2?</ins></summary>  fido2 is a protocol designed for authentication purposes. it can be used as single factor (e.g., as a replacement for password based authentication) or as a second factor (e.g., instead of otps).  </details>  <details> <summary><ins>i've heard the term passkey but what is that?</ins></summary>  passkey is a marketing term which is used to refer to a specific fido2 authenticator configuration. a authenticator can be configured to use so called discoverable credentials (also referred to as resident keys). those credentials are stored somewhere on your device, e.g. in a encrypted database. devices can also be protected by some form of user verification. this can be a pin or a built in user verification method like a finger print scanner. passkey refers to fido2 using discoverable credentials and some form of user verification.   please note that this is only one interpretation of what passkey means as the term itself is nowhere defined (see also [passkeys's: a shattered dream](https://fy.blackhats.net.au/blog/2024-04-26-passkeys-a-shattered-dream/)).  </details>  <details> <summary><ins>how does it work?</ins></summary>  fido2 uses asymmetric cryptography to ensure the authenticity of the user. a unique credential (key-pair) is created for each relying party (typically a web server) and bound to the relying party id (e.g., google.com). the private key stays on the authenticator and the public key is stored by the relying party. when a user wants to authenticate herself, the relying party sends a nonce (a random byte string meant to be only used once) and some other data, over the client (typically your web browser), to the authenticator. the authenticator looks up the required private key and signs the data with it. the generated signature can then be verified by the relying party using the corresponding public key.  </details>  <details> <summary><ins>what is the difference between fido2, passkey and webauthn?</ins></summary>  you might have noticed that fido2, passkey and even webauthn are often used interchangeably by some articles and people which can be confusing, especially for people new to the protocol. here is a short overview:  * `fido2` protocol consisting of two sub-protocols: client to authenticator protocol 2 (`ctap2`) and web authentication (`webauthn`) * `ctap2` specification that governs how a authenticator (e.g. yubikey) should behave and how a authenticator and a client (e.g. web-browser) can communicate with each other. * `webauthn` specification that defines how web applications can use a authenticator for authentication. this includes the declaration of data structures and java script apis. * `passkey`: a authenticator with a specific configuration (see above).  </details>   <details> <summary><ins>why should i use fido2?</ins></summary>  fido2 has a lot of advantages compared to passwords:  1. no secret information is shared, i.e. the private key stays on the authenticator or is protected, e.g. using key wrapping. 2. each credential is bound to a relying party id (e.g. google.com), which makes social engineering attacks, like phishing websites, quite difficult (as long as the client verifies the relying party id properly). 3. users don't have to be concerned with problems like password complexity. 4. if well implemented, fido2 provides a better user experience (e.g., faster logins). 5. a recent paper showed that with some adoptions, fido2 is ready for a post quantum world under certain conditions ([fido2, ctap 2.1, and webauthn 2: provable security and post-quantum instantiation, cryptology eprint archive, paper 2022/1029](https://eprint.iacr.org/2022/1029.pdf)).  </details>  <details> <summary><ins>are there problems with fido2?</ins></summary>  yes, there are:  1. the two fido2 subprotocols (ctap2 and webauthn) are way more difficult to implement, compared to password authentication.  2. there are more points of failure because you have three parties that are involved in the authentication process (authenticator, client, relying party). 3. currently not all browsers support the ctap2 protocol well (especially on linux). 4. there is no way to verify that a client is trustworthy:     * rogue clients may communicate with a authenticator without your consent     * clients may display wrong information 5. the 4th layer introduced for android, ios, and windows to connect authenticators and clients internally could be used as a man in the middle.  </details>  <details> <summary><ins>does this library work with all browsers?</ins></summary>  answering this question isn't straightforward. the library, by its nature, is designed to be independent of any particular platform, meaning that you have the responsibility of supplying it with data for processing. to put it differently, you're in charge of creating a functional interface for communicating with a client, typically a web browser. on linux, we offer a wrapper for the uhid interface, simplifying the process of presenting an application as a usb hid device with a usage page of f1d0 on the bus.  **there are known issues with older browsers (including firefox)**. newer browser versions should work fine. tested with:  | browser | supported? | tested version| notes | |:-------:|:----------:|:-------------:|:-----:| | cromium   | &#9989;    | 119.0.6045.159 (official build) arch linux (64-bit) | | | brave | &#9989; | version 1.62.153 chromium: 121.0.6167.85 (official build) (64-bit) | | | firefox | &#9989; | 122.0 (64-bit) |  | | opera | &#9989; | version: 105.0.4970.16 chromium: 119.0.6045.159 | |  **please let me know if you run into issues!**  </details>  <details> <summary><ins>does this library implement the whole ctap2 sepc?</ins></summary>  no, we do not fully implement the entire [ctap2](https://fidoalliance.org/specs/fido-v2.2-rd-20230321/fido-client-to-authenticator-protocol-v2.2-rd-20230321.html#intro) specification. in the initial version of this library, which can be found on github, our aim was to remain completely platform-agnostic and cover most of the ctap2 specification. however, this approach introduced complexities for both users and developers. the current version of this library strikes a balance between usability and feature completeness.  we offer support for operations like __authenticatormakecredential__, __authenticatorgetassertion__, __authenticatorgetinfo__, and __authenticatorclientpin__, with built-in support for __user verification__ and the __pinuvauth protocol__ (versions 1 and 2). you are responsible for handling data management tasks (such as secure storage, updates, and deletions), verifying user presence, and conducting user verification. these responsibilities are fulfilled by implementing the necessary callbacks used to instantiate an authenticator (refer to the 'getting started' section for details).  </details>  <details> <summary><ins>zero dynamic allocations?</ins></summary>  the authenticator part of this library doesn't allocate any memory dynamically. this has some draw backs like a fixed size for strings (e.g., rpid, user name, etc.) but also reduces the complexity of the code.  the authenticator example uses `88655` bytes of stack space when compiled with `-doptimize=releasesmall` on linux (x86╲_64).  > the authenticator example has been profiled using valgrind.  > * `zig build auth-example -doptimize=releasesmall`  > * `valgrind --tool=drd --show-stack-usage=yes ./zig-out/bin/authenticator` > * test page: [webauthn.io](https://webauthn.io/) - register + authentication > `thread 1 finished and used 88655 bytes out of 8388608 on its stack.` > `thinkpad-x1-yoga-3rd 6.5.0-35-generic #35~22.04.1-ubuntu smp preempt_dynamic x86_64 gnu/linux`  </details>  ## design  ![keylib design](static/design.png)  ## getting started  we maintain two examples on how to use the library:  * `authenticator` - [https://github.com/r4gus/keylib/blob/master/example/authenticator.zig](https://github.com/r4gus/keylib/blob/master/example/authenticator.zig)     * **please read the description at the top of the source code for instructions on how to setup uhid correctly** * `client` - [https://github.com/r4gus/keylib/blob/master/example/client.zig](https://github.com/r4gus/keylib/blob/master/example/client.zig)  ## resources  - [ctap2](https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#intro) - fido alliance - [webauthn](https://www.w3.org/tr/webauthn-3/) - w3c - [cbor rfc8949](https://www.rfc-editor.org/rfc/rfc8949.html) - c. bormann and p. hoffman  ---  __fido2/passkey test sites__: - [passkey.org](https://passkey.org/) - [webauthn.io](https://webauthn.io/)  ## random ideas  <details> <summary><ins>protecting secrets using a pin</ins></summary>  microcontrollers like the rp2040 allow the creation of cheap authenticators but they provide no means to somehow protect secrets like master passwords, pins, or credentials. one way one could securely store sensitive data is by making pin protection mandatory. note that this is a tradeof and will render some counters (like the pin retry counter) useless if an attacker has physical access to the chip, as one can not protect the counters from manipulation.  1. your authenticator has pin protection enabled by default, i.e. on first boot a default password is set. you should also set the _force pin change_ flag to 'encourge' the user to change his password. 2. also on first boot, you create a master password which will encrypt all sensitive data using a aead cipher. the master password itself is encrypted using a secret derived from the pin. 3. metadata like retry counters are not encrypted (make sure you __dont__ store the pin unencrypted!). this still allows the blocking of a authenticator (in fact you should automatically reset the authenticator if the retry counter hits zero) but an attack with physical access could potentially reset the counters giving him unlimited retries. 4. make sure you disallow any operations on sensitive data without prior authentication (__alwaysuv__). 5. make sure you only use pin authentication. 6. during authentication you intercept the pin hash (after decryption) and derive a deterministic secret from it using a key derivation function of you choice (e.g. hkdf; but it must always be the same). this secret must have the same lifetime as the pinuvauthtoken!  7. when the application requires a credential (or other sensitive data) you decrypt the master secret using the derived secret and the decrypt the actual data with the master secret. if the application wants to overwrite data, you decrypt the data, update it and the encrypt it using the master secret. 8. after you're done, make sure to overwrite any plain text information no longer required. 9. on pin change, just decrypt the master secret and then re-encrypt it using the secret derived from the new pin hash.  </details> ","nektro/zig-extras":"An assortment of random utility functions that aren't in std and don't need to be their own pacakge. # zig-extras  an assortment of random utility functions that aren't in std and don't deserve their own package.  ## license mit ","fabioarnold/nfd-zig":"OS-native file dialogs on Linux, macOS and Windows  # nfd-zig  `nfd-zig` is a zig binding to the library [nativefiledialog](https://github.com/mlabbe/nativefiledialog) which provides a convenient cross-platform interface to opening file dialogs on linux, macos and windows.  this library has been tested on windows 10, macos 11.1 and linux.  ## usage  you can run a demo with `zig build run`. the demo's source is in `src/demo.zig`.  if you want to add the library to your own project...  - add the `nfd` dependency to your `build.zig.zon`   ```zig   .{     .dependencies = .{       .nfd = .{ .path = 'libs/nfd-zig' }, // assuming nfd-zig is available in the local directory. use .url otherwise.     }   }   ``` - add the import in your `build.zig`:   ```zig   const nfd = b.dependency('nfd', .{});   const nfd_mod = nfd.module('nfd');   exe.root_module.addimport('nfd', nfd_mod);   ```  ## screenshot  ![open dialog on windows 10](https://raw.githubusercontent.com/mlabbe/nativefiledialog/67345b80ebb429ecc2aeda94c478b3bcc5f7888e/screens/open_win.png) ","akhildevelops/cudaz":"Cuda library for Zig 404: not found","ziglibs/zinput":"A Zig command-line input library! # zinput    a zig command-line input library!    - [zinput](#zinput)    - [usage](#usage)    ## usage  ```zig  const zinput = @import('zinput');    const my_string = try zinput.askstring(allocator, 'i need a string!', 128);  defer allocator.free(my_string);  ```    check out the test in `main.zig` for an example!  ","allyourcodebase/zlib":"zlib ported to the zig build system # zlib  this is [zlib](https://www.zlib.net/), packaged for [zig](https://ziglang.org/).  ## how to use it  first, update your `build.zig.zon`:  ``` zig fetch --save https://github.com/allyourcodebase/zlib/archive/refs/tags/1.3.1.tar.gz ```  next, add this snippet to your `build.zig` script:  ```zig const zlib_dep = b.dependency('zlib', .{     .target = target,     .optimize = optimize, }); your_compilation.linklibrary(libz_dep.artifact('z')); ```  this will provide zlib as a static library to `your_compilation`. ","ikskuh/TextEditor":"A backbone for text editors. No rendering, no input, but everything else. # texteditor  a backend for text editors. it implements the common textbox editing options, but is both rendering and input agnostic.  keyboard input must be translated into operations like `editor.delete(.right, .word)` to emulate what a typical text box implementation would do when `ctrl delete` is pressed.  for mouse input, the editor component needs to be made aware about the font that is used. for this, an abstract font interface is required.  ## api  ```zig const texteditor = @import('src/texteditor.zig');  fn init(texteditor.buffer, initial_text: []const u8) inserterror!texteditor { fn deinit(*texteditor) void; fn settext(*texteditor, text: []const u8) inserterror!void; fn gettext(texteditor) []const u8; fn getsubstring(editor: texteditor, start: usize, length: ?usize) []const u8; fn setcursor(*texteditor, offset: usize) setcursorerror!void; fn movecursor(*texteditor, direction: editdirection, unit: editunit) void; fn delete(*texteditor, direction: editdirection, unit: editunit) void; fn inserttext(*texteditor, text: []const u8) inserterror!void; fn graphemecount(texteditor) usize; ```  ## common key mappings  | keyboard input   | editor call                          | | ---------------- | ------------------------------------ | | `left`           | `editor.movecursor(.left, .letter)`  | | `right`          | `editor.movecursor(.right, .letter)` | | `ctrl+left`      | `editor.movecursor(.left, .word)`    | | `ctrl+right`     | `editor.movecursor(.right, .word)`   | | `home`           | `editor.movecursor(.left, .line)`    | | `end`            | `editor.movecursor(.right, .line)`   | | `backspace`      | `editor.delete(.left, .letter)`      | | `delete`         | `editor.delete(.right, .letter)`     | | `ctrl+backspace` | `editor.delete(.left, .word)`        | | `ctrl+delete`    | `editor.delete(.right, .word)`       | | _text input_     | `try editor.insert('string')`        | ","travisstaloch/art.zig":"An Adaptive Radix Tree ported from c 404: not found","mookums/tardy":"An asynchronous runtime for writing applications and services. Supports io_uring and epoll for Linux, kqueue for Darwin & BSD, and a busy loop for the rest. # tardy  tardy *(def: delaying or delayed beyond the right or expected time; late.)* is an asynchronous runtime for writing applications and services in zig. most of the code for this project originated in [zzz](https://github.com/mookums/zzz), a performance oriented networking framework.  - **performant**: tardy utilizes the latest asynchronous apis while minimizing allocations. - **portable**: tardy natively supports linux, mac and windows. easy to port through the custom async i/o system. - **scalable**: tardy uses very little memory initially and can be tuned using various configuration options.  ## installing latest zig stable: `0.13.0`  latest tardy release: `0.1.0` ``` zig fetch --save git+https://github.com/mookums/tardy#v0.1.0 ```  you can then add the dependency in your `build.zig` file: ```zig const tardy = b.dependency('tardy', .{     .target = target,     .optimize = optimize, }).module('tardy');  exe.root_module.addimport(tardy); ```  > [!important] > tardy is currently **alpha** software. it's fast and it works but is still experimental!  ## features - modular asynchronous implementation     - `io_uring` for linux (>= 5.1.0).     - `epoll` for linux (>= 2.5.45).     - `kqueue` for bsd & mac.     - `busy_loop` for linux, mac and windows. - single and multi-threaded support - callbacks on async i/o events (through `runtime.[net/fs]`) - green threads (through `runtime.spawn`) - channels for asynchronous communcation across tasks  ## ecosystem - [zzz](https://github.com/mookums/zzz): a framework for writing performant and reliable networked services.  ## contribution unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in tardy by you, shall be licensed as mpl2.0, without any additional terms or conditions. ","kubkon/zig-snapshots":"Preview Zig's incremental linker state in interactive HTML # zig-snapshots  a tool allowing you to preview a series of snapshots of zig's incremental linker.  ## usage  you will need to build zig's stage2/self-hosted compiler with `-dlink-snapshot` flag on:  ``` $ zig build -dlink-snapshot ```  then, you can run the compiler either in a fire-and-forget or watch-for-updates manner with `--debug-link-snapshot` flag on to generate a snapshot of the linker's state per incremental update, all saved in the same json output file:  ``` $ zig build-exe hello.zig --watch --debug-link-snapshot > update-and-run > update-and-run > exit  $ file snapshots.json snapshots.json: json data ```  you should then feed the output json file to `zig-snapshots` which will generate an html file with the linker's state per each incremental update that you can interative with:  ``` $ zig-out/bin/zig-snapshots snapshots.json $ open snapshots.html ```  ![zig-snapshots demo](zig_snapshots_demo.png) ","nektro/zig-time":"A date and time parsing and formatting library for Zig. # zig-time ![loc](https://sloc.xyz/github/nektro/zig-time) [![license](https://img.shields.io/github/license/nektro/zig-time.svg)](https://github.com/nektro/zig-time/blob/master/license)  exposes a `datetime` structure that can be initialized and acted upon using various methods. all public methods return a new structure.  currently handles dates and times based on the [proleptic gregorian calendar](https://en.wikipedia.org/wiki/proleptic_gregorian_calendar) in adherence to [iso 8601](https://en.wikipedia.org/wiki/iso_8601).  does not currently support time zones outside of utc.  does not handle leap seconds.  see the `formatseq` structure for display information on what to pass as a `fmt` string. ","mnemnion/ohsnap":"Oh Snap! Easy Snapshot Testing for Zig # oh snap! easy snapshot testing for zig  it's hard to know if a program, or part of one, actually works.  but it's easy to know if it doesn't: if there isn't a test for some part of the program, then that part doesn't work.  [snapshot testing](https://tigerbeetle.com/blog/2024-05-14-snapshot-testing-for-the-masses) is a great way to get fast coverage for _data invariants_ in a program or library.  the article i just linked to goes into great detail about the advantages of snapshot testing, and you should read it.  `ohsnap` is a zig library for doing snapshot testing, one which is, in fact, based on the [tigerbeetle library](https://github.com/tigerbeetle/tigerbeetle/blob/main/src/testing/snaptest.zig) used in that post.  it includes some features not found in the original. tigerbeetle has a no-dependencies policy, and i'm confident that what they have serves their needs just fine.  but a library like this is a dependency by definition, and i didn't mind adding a couple more.  let me show you its features!  ## installation  the best way to use `ohsnap` is to install it using the [zig build system](https://ziglang.org/learn/build-system/).  from your project repo root, use `zig fetch` like this:  ```sh zig fetch --save 'https://github.com/mnemnion/ohsnap/archive/refs/tags/v0.3.1.tar.gz' ```  then add it to your test artifact like so:  ```zig     if (b.lazydependency('ohsnap', .{         .target = target,         .optimize = optimize,     })) |ohsnap_dep| {         lib_unit_tests.root_module.addimport('ohsnap', ohsnap_dep.module('ohsnap'));     } ```  that should be it!  now you're ready to write some snaps!  ## using `ohsnap`  the interface will be familiar if you read the linked blog post, which, really, you should.  one difference between `ohsnap` and the original, is that `ohsnap` includes [pretty](https://github.com/timfayz/pretty), a clever pretty-printer for arbitrary data structures.  so you don't need to write a custom `.format` method to use `ohsnap`, although if you have one, you can use that instead.  or both.  belt and suspenders kinda thing.  writing a snap is simple, to get started, do something like this:  ```zig const ohsnap = @import('ohsnap');  test 'snap something' {     const oh = ohsnap{};     // you can configure `pretty` by using `var oh` and changing settings     // in `oh.pretty_options`.     const snap_me = somefn();     try oh.snap(@src(),         ╲╲         ,     ).expectequal(snap_me); } ```  note that the call to `@src()` has to be directly above the string, and the string has to be multi-line style, with the double backslashes: `╲╲`.  both this:  ```zig try oh.snap(@src(),     ╲╲ etc     ,).expectequal(snap_me); ```  and this:  ```zig try oh.snap(     @src(),     ╲╲ etc   ,).expectequal(snap_me); ```  will work just fine.  this test will fail, because the snapshot generated by `pretty` won't be equal to the empty string.  `ohsnap` will diff that empty string with what it gets out of `snap_me`, and print what it got in all-green, because that's what happens when you diff an empty string against a string which isn't empty.  if you like what you see, updating is simple.  change the file to the following:  ```zig const ohsnap = @import('ohsnap');  test 'snap something' {     const oh = ohsnap{};     // you can configure `pretty` by using `var oh` and changing settings     // in `oh.pretty_options`.     const snap_me = somefn();     try oh.snap(@src(),     ╲╲<!update>     ,     ).expectequal(snap_me); } ```  the snaptest will see the `<!update>`, which must be the beginning of the string, and replace it in your file with the output of the pretty printing.  easy!  if your data structure has a `.format` method, and you'd prefer to use that as a basis, simply use `.expectequalfmt` instead of `.expectequal`.  if, down the road, the snapshot doesn't compare to the expected string, `ohsnap` will use [diffz](https://github.com/mnemnion/diffz/tree/more-port)[^1], a zig port of [diff-match-patch](https://github.com/google/diff-match-patch), to produce a terminal-colored character-level diff of the expected string with the actual string, making it easy to see exactly what's changed.  these changes are either a bug, or a new feature.  if it's the former, fix it, if it's the latter, just add `<!update>` to the head of the string again, and `ohsnap` will oblige.  ## pattern-matching snapshots  this is fine and dandy, if the data structure, exactly as it prints, will always be the same on every test run.  but what if that's only true of some of the data?  consider this example.  we have a struct which looks like this:  ```zig const stampedstruct = struct {     message: []const u8,     tag: u64,     timestamp: isize,     pub fn init(msg: []const u8, tag: u64) stampedstruct {         return stampedstruct{             .message = msg,             .tag = tag,             .timestamp = std.time.timestamp(),         };     } }; ```  which we want to snapshot test, like this:  ```zig test 'snap with timestamp' {     const oh = ohsnap{};     const with_stamp = stampedstruct.init(         'frobnicate the turbo-encabulator',         31337,     );     try oh.snap(         @src(),         ╲╲ohsnap.stampedstruct         ╲╲  .message: []const u8         ╲╲    'frobnicate the turbo-encabulator'         ╲╲  .tag: u64 = 31337         ╲╲  .timestamp: isize = 1721501316         ,     ).expectequal(with_stamp); } ```  but of course, the next time we run the test, the timestamp will be different, so the test will fail.  we care about the message and the tag, we care that there _is_ a timestamp, but we don't care what the timestamp is, because we know it will be changing.  for cases like this, `ohsnap` includes [mvzr](https://github.com/mnemnion/mvzr), the minimum viable zig regex library, which i wrote specifically for this purpose.  simply replace the timestamp like so:  ```zig     try oh.snap(         @src(),         ╲╲ohsnap.stampedstruct         ╲╲  .message: []const u8         ╲╲    'frobnicate the turbo-encabulator'         ╲╲  .tag: u64 = 31337         ╲╲  .timestamp: isize = <^╲d+$>         ,     ).expectequal(with_stamp); ```  through the magic of diffing, `ohsnap` will identify the part of the new string which matches `<^╲d+$>`, and try to match the regular expression against that part of the string.  since this matches, the test now passes.  note that the regex must be in the form `<^.+?$>` (the exact regex we use is `<╲^[^╲n]+?╲$>`, in fact), the `^` and `$` are essential and are load-bearing parts of the expression.  this prevents partial matches, as well as making the regex portions of a snapshot test easier for `ohsnap` to find.  note that because this is a multi-line string, you don't have to do double-backslashes: its `<^╲d+$>`, not `<^╲╲d+$>`.  to be very clear, the `<` and `>` demarcate the regex, they aren't part of it.  let's say you make a change:  ```zig     const with_stamp = stampedstruct.init(         'thoroughly frobnicate the encabulator',         31337,     ); ```  the test will now fail: the word 'thoroughly' will be highlighted in green, `turbo-` will be marked in red, and the timestamp will be cyan, indicating that the regex is still matching the pattern string.  if a change in the test data means that the regex no longer matches, then the part of the test string which should match is highlighted in magenta.  since this was an intentional change, we need to update the snap:  ```zig     try oh.snap(         @src(),         ╲╲<!update>         ╲╲ohsnap.stampedstruct         ╲╲  .message: []const u8         ╲╲    'frobnicate the turbo-encabulator'         ╲╲  .tag: u64 = 31337         ╲╲  .timestamp: isize = <^╲d+$>         ,     ).expectequal(with_stamp); ```  once again, through the magic of diffing, `ohsnap` will locate the regexen in the old string, and patch them over the new one.  ```zig     try oh.snap(         @src(),         ╲╲ohsnap.stampedstruct         ╲╲  .message: []const u8         ╲╲    'thoroughly frobnicate the encabulator'         ╲╲  .tag: u64 = 31337         ╲╲  .timestamp: isize = <^╲d+$>         ,     ).expectequal(with_stamp); ```  voila!  usage note: in some cases, the changes to the new string will displace the regex, you can tell because some part of the regex itself will be exposed in red.  when that happens, the update may not apply correctly either: the regex will always be moved to the new string intact, but it may or may not be in the correct place (usually, not).  this can generally be fixed by making changes to the expected-value string until whatever part of the regex was sticking out of the diff is no longer exposed.  sometimes running `<!update>` twice will fix it as well.  ## developing with snapshots  when we're programming, there are always points in the process where a data structure is in flux, and `ohsnap` can help you out with that as well.  instead of `.expectequal(var)`, use `.show(var)`, or `.showfmt(var)`.  this will print the snapshot, whether it diffs or not, and it doesn't count as a test.  `<!update>` continues to work in the same way, but an updated `.show` snapshot counts as a failed test.  the update logic is fairly simple, and updating often changes the line numbering of the file, so this helps update one at a time.  note that you can add the `<!update>` string to any number of snapshots, and just keep recompiling the test suite until they all pass.  also, if `ohsnap` can't find the snapshot because it moved, nothing untoward will happen, it will just report a failed test, and running it again will fix the problem if it was caused by a previous update.  this also works as a minimalist way to regress a snapshot test, when you aren't sure what the final value will be.  whenever you're satisfied with the output, just change `.show` to its `.expect` cousin, and now you've got a test.  ## that's it!  one of the great advantages of snapshot testing is that it's easy, so `ohsnap`, like the library it's based upon, is intentionally quite simple.  simple, yet versatile, the latter to a large degree is owed to `pretty`, which can handle anything i've thrown at it, types, unions, you name it.  it's a new library, but i expect the core interface to remain stable.  it's meant to do one thing, well, and otherwise stay out of the way.  i'm willing to consider suggestions for ways to make `ohsnap` better at what it already does, however.  that said, the regex library `mvzr` is pretty new, and so is the added code in `diffz`, so version-bumps to fix any bugs in those can be expected over time.  the build system doesn't currently do update checks, so you'll need to check for updates manually, for now.  i hope you enjoy it! test early, test often, and do it the easy way.  [^1]: the link is to a fork of the library which has the necessary changes for terminal printing.  that branch is in code review, and these things take time. `ohsnap` will be updated to fetch from the [main repo](https://github.com/ziglibs/diffz) when that's possible. ","cztomsik/napigen":"Automatic N-API bindings for your Zig project. # zig-napigen  comptime n-api bindings for zig.  > **note: this library is still in early development and the api is subject to > change.** > > you need to use latest zig master to use this library. > > see [ggml-js](https://github.com/cztomsik/ggml-js) for a complete, real-world > example.  ## features  - primitives, tuples, structs (value types), optionals - strings (valid for the function scope) - struct pointers (see below) - functions (no classes, see below) - all the `napi_xxx` functions and types are re-exported as `napigen.napi_xxx`,╲   so you can do pretty much anything if you don't mind going lower-level.  ## limited scope  the library provides a simple and thin api, supporting only basic types. this design choice is intentional, as it is often difficult to determine the ideal mapping for more complex types. the library allows users to hook into the mapping process or use the n-api directly for finer control.  specifically, there is no support for classes.  ## structs/tuples (value types)  when returning a struct/tuple by value, it is mapped to an anonymous javascript object/array with all properties/elements mapped recursively. similarly, when accepting a struct/tuple by value, it is mapped back from javascript to the respective native type.  in both cases, a copy is created, so changes to the js object are not reflected in the native part and vice versa.  ## struct pointers (╲*t)  when returning a pointer to a struct, an empty javascript object will be created with the pointer wrapped inside. if this javascript object is passed to a function that accepts a pointer, the pointer is unwrapped back.  the same javascript object is obtained for the same pointer, unless it has already been collected. this is useful for attaching state to the javascript counterpart and accessing that data later.  changes to javascript objects are not reflected in the native part, but getters/setters can be provided in javascript and native functions can be called as necessary.  ## functions  javascript functions can be created with ctx.createfunction(zig_fn) and then exported like any other value. only comptime-known functions are supported. if an error is returned from a function call, an exception is thrown in javascript.  ```zig fn add(a: i32, b: i32) i32 {     return a + b; }  // somewhere where the jscontext is available const js_fun: napigen.napi_value = try js.createfunction(add);  // make the function accessible to javascript try js.setnamedproperty(exports, 'add', js_fun); ```  note that **the number of arguments must match exactly**. so if you need to support optional arguments, you will have to provide a wrapper function in js, which calls the native function with the correct arguments.  ## callbacks, ╲*jscontext, napi_value  functions can also accept the current `*jscontext`, which is useful for calling the n-api directly or performing callbacks. to get a raw javascript value, simply use `napi_value` as an argument type.  ```zig fn callmeback(js: *napigen.jscontext, recv: napigen.napi_value, fun: napigen.napi_value) !void {     try js.callfunction(recv, fun, .{ 'hello from zig' }); } ```  and then  ```javascript native.callmeback(console, console.log) ```  if you need to store the callback for a longer period of time, you should create a ref. for now, you have to do that directly, using `napi_create_reference()`.  ## definemodule(init_fn), exports  n-api modules need to export a function which will also init & return the `exports` object. you could export `napi_register_module_v1` and call `jscontext.init()` yourself but there's also a shorthand using `comptime` block which will allow you to use `try` anywhere inside:  ```zig comptime { napigen.definemodule(initmodule) }  fn initmodule(js: *napigen.jscontext, exports: napigen.napi_value) anyerror!napigen.napi_value {     try js.setnamedproperty(exports, ...);     ...      return exports; } ```  ## hooks  whenever a value is passed from zig to js or vice versa, the library will call a hook function, if one is defined. this allows you to customize the mapping process.  hooks have to be defined in the root module, and they need to be named `napigenread` and `napigenwrite` respectively. they must have the following signature:  ```zig fn napigenread(js: *napigen.jscontext, comptime t: type, value: napigen.napi_value) !t {     return switch (t) {         // we can easily customize the mapping for specific types         // for example, we can allow passing regular js strings anywhere where we expect an internedstring         internedstring => internedstring.from(try js.read([]const u8)),          // otherwise, just use the default mapping, note that this time         // we call js.defaultread() explicitly, to avoid infinite recursion         else => js.defaultread(t, value),     } }  pub fn napigenwrite(js: *napigen.jscontext, value: anytype) !napigen.napi_value {     return switch (@typeof(value) {         // convert internedstring to back to a js string (hypothetically)         internedstring => try js.write(value.ptr),          // same thing here         else => js.defaultwrite(value),     } } ```  ---  ## complete example  first, create a new library:  ```bash mkdir example cd example zig init-lib ```  then, change your `build.zig` to something like this:  ```zig ...  const lib = b.addsharedlibrary(.{     .name = 'example',     .root_source_file = .{ .path = 'src/main.zig' },     .target = target,     .optimize = optimize, });  // weak-linkage lib.linker_allow_shlib_undefined = true;  // add correct path to this lib const napigen = b.createmodule(.{ .root_source_file = .{ .path = 'deps/napigen/napigen.zig' } }); lib.root_module.addimport('napigen', napigen);  // build the lib b.installartifact(lib);  // copy the result to a *.node file so we can require() it const copy_node_step = b.addinstalllibfile(lib.getemittedbin(), 'example.node'); b.getinstallstep().dependon(&copy_node_step.step);  ... ```  next, define some functions and the n-api module itself in `src/main.zig`  ```zig const std = @import('std'); const napigen = @import('napigen');  export fn add(a: i32, b: i32) i32 {     return a + b; }  comptime {     napigen.definemodule(initmodule); }  fn initmodule(js: *napigen.jscontext, exports: napigen.napi_value) !napigen.napi_value {     try js.setnamedproperty(exports, 'add', try js.createfunction(add));      return exports; } ```  finally, use it from javascript as expected:  ```javascript import { createrequire } from 'node:module' const require = createrequire(import.meta.url) const native = require('./zig-out/lib/example.node')  console.log('1 + 2 =', native.add(1, 2)) ```  to build the library and run the script:  ``` > zig build && node example.js 1 + 2 = 3 ```  ## license  mit ","karlseguin/cache.zig":"A thread-safe, expiration-aware, LRU cache for Zig 404: not found","karlseguin/metrics.zig":"Prometheus metrics for library and application developers 404: not found","judofyr/parg":"Lightweight argument parser for Zig # parg  **parg** is a lightweight argument parser for zig which focuses on a single task: parsing command-line arguments into positional arguments and long/short flags. it doesn't concern itself _anything_ else. you may find this useful as a quick way of parsing some arguments, or use it as a building block for a more elaborate cli toolkit.  ## features / non-features  * parses command-line arguments into **positional arguments**, **long flags** and **short flags**. * provides an iterator interface (`while (parser.next()) |token| …`). * supports boolean flags (`--force`, `-f`). * supports multiple short flags (`-avz`). * values can be provided as separate arguments (`--message hello`), with a delimiter (`--message=hello`) and also part of short flag (`-mhello`). * automatically detects `--` and skips any further parsing. * licensed under 0bsd.  ## usage  the principles of `parg` are as follows:  * use `parseprocess`, `parseslice` or `parse` to create a new parser. * remember to call `deinit()` when you're done with the parser. * call `next()` in a loop to parse arguments. * call `nextvalue()` whenever you need a plain value. * there's a few more knobs you can tweak with.  let's go over these steps a bit more in detail.  ### create a new parser instance  there's three ways of creating a parser instance. all of these accept some _options_ as the last argument.  ```zig const parg = @import('parg');  // (1) parse arguments given to the current process: var p = try parg.parseprocess(allocator, .{});  // (2) parse arguments from a `[]const []const u8`: var p = parg.parseslice(slice, .{});  // (3) parse arguments from an iterator (advanced usage): var p = parg.parse(it, .{});  // always remember to deinit: defer p.deinit(); ```  in addition, remember that the first parameter given to a process is the file name of the executable. you typically want to call `nextvalue()` to retrieve this value before you continue parsing any arguments.  ```zig const program_name = p.nextvalue() orelse @panic('no executable name'); ```  ### parsing boolean flags and positional arguments  once you have a parser you want to call `next()` in a loop. this returns a token which has three different possibilities:  * `.flag` when it encounters a flag (e.g. `--verbose` or `-v`).   this flag has a `.name` field which contains the name of the flag (without the dashes) and a `.kind` field if you need to distinguish between long and short flags.   there are also a helper functions `islong` and `isshort` to easily check the name of the field. * `.arg` when it encounters a positional argument. * `.unexpected_value` when it encounters an unexpected value.   you should just quit the program with an error when this happens.   we'll come back to this in the next section.  also note that this will automatically split up short flags as expected: if you give the program `-fv` then `next()` will first return a flag with name `f`, and then a flag with name `v`.  ```zig // see examples/ex1.zig for full example.  var verbose = false; var force = false; var arg: ?[]const u8 = null;  while (p.next()) |token| {     switch (token) {         .flag => |flag| {             if (flag.islong('force') or flag.isshort('f')) {                 force = true;             } else if (flag.islong('verbose') or flag.isshort('v')) {                 verbose = true;             } else if (flag.islong('version')) {                 std.debug.print('v1╲n', .{});                 std.os.exit(0);             }         },         .arg => |val| {             if (arg != null) @panic('only one argument supported');             arg = val;         },         .unexpected_value => @panic('unexpected value'),     } } ```  ### parsing flags with values  when you find a flag which require a value you need to invoke `nextvalue()`. this returns an optional slice:  ```zig // see examples/ex2.zig for full example.  while (p.next()) |token| {     switch (token) {         .flag => |flag| {             if (flag.islong('file') or flag.isshort('f')) {                 file = p.nextvalue() orelse @panic('--file requires value');             } else if (flag.islong('verbose') or flag.isshort('v')) {                 verbose = true;             } else if (flag.islong('version')) {                 std.debug.print('v1╲n', .{});                 std.os.exit(0);             }         },         .arg => @panic('unexpected argument'),         .unexpected_value => @panic('unexpected value'),     } } ```  all of these will be treated the same way:  * `--file build.zig` * `--file=build.zig` * `-f build.zig` * `-f=build.zig` * `-fbuild.zig`  most notably, notice that when you call `nextvalue()` it will 'break out' of parsing short flags. without the call to `nextvalue()` the code would parse `-fbuild.zig` as the short flags `-f`, `-b`, `-u`, and so on.  this also explains the need for `.unexpected_value` in `next()`: if you pass `--force=yes` to the first example it will parse the `--force` as a long flag. when you then _don't_ invoke `nextvalue()` (since it's a boolean flag) then we need to later bail out since we didn't expect a value.  ### options and other functionality  there's currently only one option (which you configure when instantiate the parser):  * `auto_double_dash` (defaults to `true`).   when this is `true` it will look for `--` and then stop parsing anything as a flag.   your program will _not_ observe the `--` token at all, and all tokens after this point will be returned as `.arg` (even though they start with a dash).   when this is `false` it will return `--` as a regular argument (`.arg`) and argument parsing will continue as usual.  there's also one additional method:  * `p.skipflagparsing()`.   this turns off any further argument parsing.   all tokens after this point will be returned as `.arg` (even though they start with a dash). ","ziglibs/tres":"ValueTree-based JSON parser # tres  `std.json.parse` but on `valuetree`s. stringify that supports undefinedables, arraylists, and hashmaps.  ## features  - `parse` (std.json.value -> t) - `stringify` (t -> []const u8) - `tovalue` (t -> std.json.value)  all the above modes support `std.json` standard features as well as: - enhanced optionals (`tres_null_meaning`, see test 'parse and stringify null meaning') - string enums (`tres_string_enum`, see test 'json.stringify enums') - field name remapping (`tres_remap`, see test 'remapping') - map and arraylist support (unmanaged too!)  ## license  mit ","ikskuh/zig-serve":"Server implementations for several protocols in Zig. Includes http(s), gemini and gopher # zig-serve  ![project logo](design/logo.png)  a implementation of several network protocols for zig:  - http 1.1 - gemini - gopher - finger  ## disclaimer  **do not use these server implementations in production!**  they are very much work-in-progress without any warranty of function or correctness. don't even think about security right now!  ## status  | protocol | status          | | -------- | --------------- | | finger   | ⏸ not started   | | gopher   | 🧪 experimental | | gemini   | 🧪 experimental | | http(s)  | 🧪 experimental |  _experimental_ means that there is basic support for the protocol, but no spec compliance has been proven yet.  ## development / tasks  ### create a new self-signed ssl certificate  ```sh-console openssl req -new -x509 -config examples/data/cert-config.cfg -nodes -newkey rsa:2048 -keyout examples/data/key.pem -out examples/data/cert.pem -days 36500 ```  ### rfcs & specs  - [rfc1945](https://datatracker.ietf.org/doc/html/rfc1945) - hypertext transfer protocol -- http/1.0 - [rfc2616](https://datatracker.ietf.org/doc/html/rfc2616) - hypertext transfer protocol -- http/1.1 - [rfc7231](https://datatracker.ietf.org/doc/html/rfc7231) - hypertext transfer protocol (http/1.1): semantics and content - [rfc1436](https://datatracker.ietf.org/doc/html/rfc1436) - the internet gopher protocol (a distributed document search and retrieval protocol) - [project gemini](https://gemini.circumlunar.space/docs/specification.gmi) - speculative specification - [rfc1288](https://datatracker.ietf.org/doc/html/rfc1288) - the finger user information protocol ","nektro/zig-pek":"A comptime HTML preprocessor with a builtin template engine for Zig. # pek  a comptime html preprocessor with a builtin template engine for zig.  ## example document  ```fsharp html[lang='en'](     head(         title('pek example')         meta[charset='utf-8']         meta[name='viewport' content='width=device-width,initial-scale=1']     )     body(         h1('pek example')         hr         p('this is an example html document written in 'a[href='https://github.com/nektro/zig-pek']('pek')'.')     ) ) ```  ## example usage [src/main.zig](src/main.zig)  ## built with - [zig](https://github.com/ziglang/zig) master - [zigmod](https://github.com/nektro/zigmod) package manager  ## add me ``` $ zigmod aq add 1/nektro/pek ``` ","speed2exe/tree-fmt":"Tree-like pretty formatter for Zig # tree formattar for zig - pretty prints out zig values for your debugging needs. - if you faces any issue with formatting, kindly open an issue.  ## versioning - current `main` branch tracks zig latest version - if you need a stable version, see release tags  ## objective - provide a colored tree-like visual representation of a zig value to aid in debugging.  ## features - colored output to distinguish between types and values - indentation to show the structure of the value - special formatters for following types (do file a pr or fr if you think there are more types that can require special formatting)   - `std.multiarraylist`   - `std.hashmapunmanaged`  ## screenshot ![screenshot](./images/screenshot.png)  ## example - you can run on of the examples in the `examples` by executing the following command: ```bash zig build test -dtest-filter='anon struct 1' ``` - you might need to require to remove `zig-cache` to run it again without changes.  ## usage - zig package manager example: https://github.com/speed2exe/tree-fmt-example - `zig.build.zon` ```zon .{     .name = 'your_package_name',     .version = '0.0.1',     .dependencies = .{         .tree_fmt = .{             // c6398b225f15cdbe35b3951920f634ffd1c65c12 is just commit hash             .url = 'https://github.com/speed2exe/tree-fmt/archive/c6398b225f15cdbe35b3951920f634ffd1c65c12.tar.gz',             // just do `zig build`, get the error code and replace with expected hash             .hash = '12201dceb9a9c2c9a6fc83105a7f408132b9ab69173b266e7df2af2c1dd6f814cd51',         },     },     .paths = .{ '' }, } ``` - `build.zig` ```zig pub fn build(b: *std.build) void {     // ...     const dep = b.dependency('tree_fmt', .{});     const tree_fmt = dep.module('tree-fmt');     your_program.root_module.addimport('tree-fmt', tree_fmt); } ```  ### quick setup - fastest and easiest way to if you want to save time and effort. - this example is in `example_default_tree_formatter.zig`  ```zig var tree_formatter = @import('tree-fmt').defaultformatter();  pub fn main() !void {     const my_struct = .{ 1, 2.4, 'hi' };     try tree_formatter.format(my_struct, .{         .name = 'my_struct', // (optional) just an identifier to the root of the tree     }); } ``` - output: ``` some_anon_struct: tuple{comptime comptime_int = 1, comptime comptime_float = 2.4, comptime *const [2:0]u8 = 'hi'} ├─.0: comptime_int => 1 ├─.1: comptime_float => 2.4e+00 └─.2: *const [2:0]u8 @21d169   └─.*: [2:0]u8 hi     ├─[0]: u8 => 104     └─[1]: u8 => 105 ```   ### proper setup - this is recommended, as it gives you more control over writer, allocator and settings.  ```zig const std = @import('std');  // add imports here const treeformatter = @import('tree-fmt').treeformatter;  pub fn main() !void {     // initialize your allocator     var gpa = std.heap.generalpurposeallocator(.{}){};     const allocator = gpa.allocator();     defer {         const leaked = gpa.deinit();         if (leaked) {             @panic('leaked memory!');         }     }      // initialize a writer (std.io.writer)     // tips if you print a lot: wrap with std.io.bufferedwriter to improve performance     var w = std.io.getstdout().writer();      // initialize treeformatter with allocator and writer     var tree_formatter = treeformatter(allocator, w);      // initialize your value     var sentinel_array: [*:0]const u8 = 'hello world';      // call the method with writer and value     try tree_formatter.formatvaluewithid(sentinel_array, .{         // .name = 'sentinel_array', <-- example setting         // you can find settings at @import('./src/tree_fmt.zig').treeformattersettings;         // you can also leave it blank to use default settings     }); } ```  - output: ``` sentinel_array: [*:0]const u8 @20a71e 'hello world' ├─[0]: u8 => 104 ├─[1]: u8 => 101 ├─[2]: u8 => 108 ├─[3]: u8 => 108 ├─[4]: u8 => 111 ├─[5]: u8 => 32 ├─[6]: u8 => 119 ├─[7]: u8 => 111 ├─[8]: u8 => 114 ├─[9]: u8 => 108 └─... (showed first 10 out of 11 items only) ```  - you can find other examples in the `examples` directory. to run specific example(s): ```bash     zig build test -dtest-filter='name of test'     # e.g. zig build test -dtest-filter='anon struct 1' ```  ## example - `std.arraylist(u8)` ``` .: array_list.arraylistaligned(u8,null) ├─.items: []u8 @7efcc912f000 │ ├─[0]: u8 => 0 │ ├─[1]: u8 => 1 │ ├─[2]: u8 => 2 │ ├─[3]: u8 => 3 │ ├─[4]: u8 => 4 │ └─... (showed first 5 out of 100 items only) ├─.capacity: usize => 105 └─.allocator: mem.allocator   ├─.ptr: *anyopaque @7fffadc5b3d8   └─.vtable: *const mem.allocator.vtable @202a38     └─.*: mem.allocator.vtable       ├─.alloc: *const fn(*anyopaque, usize, u8, usize) ?[*]u8 @238e00       ├─.resize: *const fn(*anyopaque, []u8, u8, usize, usize) bool @2393c0       └─.free: *const fn(*anyopaque, []u8, u8, usize) void @23a2d0 ```  - `std.autohashmap(u8, u8)` ``` map: hash_map.hashmap(u8,u8,hash_map.autocontext(u8),80) ├─.unmanaged: hash_map.hashmapunmanaged(u8,u8,hash_map.autocontext(u8),80) │ ├─.iterator() │ │ ├─.next(): hash_map.hashmapunmanaged(u8,u8,hash_map.autocontext(u8),80).entry │ │ │ ├─.key_ptr: *u8 @7fcad47f5021 │ │ │ │ └─.*: u8 => 1 │ │ │ └─.value_ptr: *u8 @7fcad47f5029 │ │ │   └─.*: u8 => 2 │ │ ├─.next(): hash_map.hashmapunmanaged(u8,u8,hash_map.autocontext(u8),80).entry │ │ │ ├─.key_ptr: *u8 @7fcad47f5022 │ │ │ │ └─.*: u8 => 0 │ │ │ └─.value_ptr: *u8 @7fcad47f502a │ │ │   └─.*: u8 => 0 │ │ └─.next(): hash_map.hashmapunmanaged(u8,u8,hash_map.autocontext(u8),80).entry │ │   ├─.key_ptr: *u8 @7fcad47f5026 │ │   │ └─.*: u8 => 2 │ │   └─.value_ptr: *u8 @7fcad47f502e │ │     └─.*: u8 => 4 │ ├─.metadata: ?[*]hash_map.hashmapunmanaged(u8,u8,hash_map.autocontext(u8),80).metadata │ │ └─.?: [*]hash_map.hashmapunmanaged(u8,u8,hash_map.autocontext(u8),80).metadata @7fcad47f5018 │ ├─.size: u32 => 3 │ └─.available: u32 => 3 ├─.allocator: mem.allocator │ ├─.ptr: *anyopaque @7ffc3b6baca0 │ └─.vtable: *const mem.allocator.vtable @2045b8 │   └─.*: mem.allocator.vtable │     ├─.alloc: *const fn(*anyopaque, usize, u8, usize) ?[*]u8 @2433a0 │     ├─.resize: *const fn(*anyopaque, []u8, u8, usize, usize) bool @243960 │     └─.free: *const fn(*anyopaque, []u8, u8, usize) void @244870 └─.ctx: hash_map.autocontext(u8) => .{} ```  - `std.multiarraylist...` (see `example_multi_array_list.zig`) ``` multi_array_list: multi_array_list.multiarraylist(example_multi_array_list.person) ├─.slice(): multi_array_list.multiarraylist(example_multi_array_list.person).slice │ └─.items │   ├─(.id): []u64 @7f8cf20c3000 │   │ ├─[0]: u64 => 0 │   │ ├─[1]: u64 => 1 │   │ ├─[2]: u64 => 2 │   │ ├─[3]: u64 => 3 │   │ ├─[4]: u64 => 4 │   │ └─... (showed first 5 out of 7 items only) │   ├─(.age): []u8 @7f8cf20c3080 │   │ ├─[0]: u8 => 0 │   │ ├─[1]: u8 => 1 │   │ ├─[2]: u8 => 2 │   │ ├─[3]: u8 => 3 │   │ ├─[4]: u8 => 4 │   │ └─... (showed first 5 out of 7 items only) │   └─(.car): []example_multi_array_list.car @7f8cf20c3040 │     ├─[0]: example_multi_array_list.car │     │ └─.license_plate_no: u64 => 555 │     ├─[1]: example_multi_array_list.car │     │ └─.license_plate_no: u64 => 555 │     ├─[2]: example_multi_array_list.car │     │ └─.license_plate_no: u64 => 555 │     ├─[3]: example_multi_array_list.car │     │ └─.license_plate_no: u64 => 555 │     ├─[4]: example_multi_array_list.car │     │ └─.license_plate_no: u64 => 555 │     └─... (showed first 5 out of 7 items only) ├─.get │ ├─(0): example_multi_array_list.person │ │ ├─.id: u64 => 0 │ │ ├─.age: u8 => 0 │ │ └─.car: example_multi_array_list.car │ │   └─.license_plate_no: u64 => 555 │ ├─(1): example_multi_array_list.person │ │ ├─.id: u64 => 1 │ │ ├─.age: u8 => 1 │ │ └─.car: example_multi_array_list.car │ │   └─.license_plate_no: u64 => 555 │ ├─(2): example_multi_array_list.person │ │ ├─.id: u64 => 2 │ │ ├─.age: u8 => 2 │ │ └─.car: example_multi_array_list.car │ │   └─.license_plate_no: u64 => 555 │ ├─(3): example_multi_array_list.person │ │ ├─.id: u64 => 3 │ │ ├─.age: u8 => 3 │ │ └─.car: example_multi_array_list.car │ │   └─.license_plate_no: u64 => 555 │ └─... (showed first 4 out of 7 items only) ├─.bytes: [*]align(8) u8 @7f8cf20c3000 ├─.len: usize => 7 └─.capacity: usize => 8 ```  - `multi_array_list.multiarraylist(zig.ast.tokenlist__struct_4206).slice` ``` ast: multi_array_list.multiarraylist(zig.ast.tokenlist__struct_4200).slice ├─.tomultiarraylist(): multi_array_list.multiarraylist(zig.ast.tokenlist__struct_4200) │ ├─.slice(): multi_array_list.multiarraylist(zig.ast.tokenlist__struct_4200).slice │ │ └─.items │ │   ├─(.tag): []zig.tokenizer.token.tag @7ff3c81f7098 │ │   │ ├─[0]: zig.tokenizer.token.tag => zig.tokenizer.token.tag.keyword_const (86) │ │   │ ├─[1]: zig.tokenizer.token.tag => zig.tokenizer.token.tag.identifier (2) │ │   │ ├─[2]: zig.tokenizer.token.tag => zig.tokenizer.token.tag.equal (12) │ │   │ ├─[3]: zig.tokenizer.token.tag => zig.tokenizer.token.tag.builtin (7) │ │   │ ├─[4]: zig.tokenizer.token.tag => zig.tokenizer.token.tag.l_paren (16) │ │   │ └─... (showed first 5 out of 31 items only) │ │   └─(.start): []u32 @7ff3c81f7000 │ │     ├─[0]: u32 => 1 │ │     ├─[1]: u32 => 7 │ │     ├─[2]: u32 => 11 │ │     ├─[3]: u32 => 13 │ │     ├─[4]: u32 => 20 │ │     └─... (showed first 5 out of 31 items only) │ ├─.get │ │ ├─(0): zig.ast.tokenlist__struct_4200 │ │ │ ├─.tag: zig.tokenizer.token.tag => zig.tokenizer.token.tag.keyword_const (86) │ │ │ └─.start: u32 => 1 │ │ ├─(1): zig.ast.tokenlist__struct_4200 │ │ │ ├─.tag: zig.tokenizer.token.tag => zig.tokenizer.token.tag.identifier (2) │ │ │ └─.start: u32 => 7 │ │ ├─(2): zig.ast.tokenlist__struct_4200 │ │ │ ├─.tag: zig.tokenizer.token.tag => zig.tokenizer.token.tag.equal (12) │ │ │ └─.start: u32 => 11 │ │ ├─(3): zig.ast.tokenlist__struct_4200 │ │ │ ├─.tag: zig.tokenizer.token.tag => zig.tokenizer.token.tag.builtin (7) │ │ │ └─.start: u32 => 13 │ │ ├─(4): zig.ast.tokenlist__struct_4200 │ │ │ ├─.tag: zig.tokenizer.token.tag => zig.tokenizer.token.tag.l_paren (16) │ │ │ └─.start: u32 => 20 │ │ └─... (showed first 5 out of 31 items only) │ ├─.bytes: [*]align(4) u8 @7ff3c81f7000 │ ├─.len: usize => 31 │ └─.capacity: usize => 38 ├─.ptrs: [2][*]u8 │ ├─[0]: [*]u8 @7ff3c81f7098 │ └─[1]: [*]u8 @7ff3c81f7000 ├─.len: usize => 31 └─.capacity: usize => 38 ``` ","kubkon/zacho":"Zig's Mach-O parser # zacho  ...or zig's mach-o parser. this project started off as a dummy scratchpad for reinforcing my understanding of the mach-o file format while i was working on the zig's stage2 mach-o linker (i still am working on it, in case anyone was asking).  my current vision for `zacho` is for it to be a cross-platform version of `otool` and `pagestuff` macos utilities. these seem to be very useful when battling the darwin kernel and `dyld` when those refuse to load your hand-crafter binary, or you just like looking at mach-o dissected output.  ## usage  ``` usage: zacho [options] file  general options: -c, --code-signature        print the contents of code signature (if any) -d, --dyld-info             print the contents of dyld rebase and bind opcodes -e, --exports-trie          print export trie (if any) -h, --header                print the mach-o header -i, --indirect-symbol-table print the indirect symbol table -l, --load-commands         print load commands -r, --relocations           print relocation entries (if any) -s, --symbol-table          print the symbol table -u, --unwind-info           print the contents of (compact) unwind info section (if any) -v, --verbose               print more detailed info for each flag --archive-index             print archive index (if any) --string-table              print the string table --data-in-code              print data-in-code entries (if any) --hex-dump=[name]           dump section contents as bytes --string-dump=[name]        dump section contents as strings --verify-memory-layout      print virtual memory layout and verify there is no overlap --help                      display this help and exit ```  ## building from source  building from source requires [zig nightly](https://ziglang.org/download/).  ``` $ git clone https://github.com/kubkon/zacho.git $ zig build ``` ","r4gus/zbor":"CBOR parser written in Zig # zbor - zig cbor  ![github](https://img.shields.io/github/license/r4gus/zbor?style=flat-square) ![github workflow status](https://img.shields.io/github/actions/workflow/status/r4gus/zbor/main.yml?style=flat-square) ![github all releases](https://img.shields.io/github/downloads/r4gus/zbor/total?style=flat-square)  the concise binary object representation (cbor) is a data format whose design  goals include the possibility of extremely small code size, fairly small  message size, and extensibility without the need for version negotiation ([rfc8949](https://www.rfc-editor.org/rfc/rfc8949.html#abstract)). it is used in different protocols like the client to authenticator protocol  [ctap2](https://fidoalliance.org/specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol-v2.0-ps-20190130.html#ctap2-canonical-cbor-encoding-form)  which is a essential part of fido2 authenticators/ passkeys.  i have utilized this library in several projects throughout the previous year, primarily in conjunction with my [fido2 library](https://github.com/r4gus/fido2). i'd consider it stable.  with the introduction of [zig version `0.11.0`](https://ziglang.org/download/), this library will remain aligned with the most recent stable release. if you have any problems or want to share some ideas feel free to open an issue or write me a mail, but please be kind.  ## getting started  first add this library as a dependency to your `build.zig.zon` file:  ```zig .{     .name = 'your-project',     .version = 0.0.1,      .dependencies = .{         .zbor = .{             // for a specific release use:             // .url = 'https://github.com/r4gus/zbor/archive/refs/tags/0.13.1.tar.gz',             // for the current master use:             .url = 'https://github.com/r4gus/zbor/archive/master.tar.gz',             .hash = <hash>,         }     },     .paths = .{         // your paths...     }, } ```  then within you `build.zig` add the following code:  ```zig // first fetch the dependency... const zbor_dep = b.dependency('zbor', .{     .target = target,     .optimize = optimize, }); const zbor_module = zbor_dep.module('zbor');  // if you have a module that has zbor as a dependency... const your_module = b.addmodule('your-module', .{     .root_source_file = .{ .path = 'src/main.zig' },     .imports = &.{         .{ .name = 'zbor', .module = zbor_module },     }, });  // or as a dependency for a executable... exe.root_module.addimport('zbor', zbor_module); ```  > the easiest way to get the required __hash__ is to use a wrong one and then copy the correct one > from the error message.  ## usage  this library lets you inspect and parse cbor data without having to allocate additional memory.  ### inspect cbor data  to inspect cbor data you must first create a new `dataitem`.  ```zig const cbor = @import('zbor');  const di = dataitem.new('╲x1b╲xff╲xff╲xff╲xff╲xff╲xff╲xff╲xff') catch {     // handle the case that the given data is malformed }; ```  `dataitem.new()` will check if the given data is well-formed before returning a `dataitem`. the data is well formed if it's syntactically correct.   to check the type of the given `dataitem` use the `gettype()` function.  ```zig std.debug.assert(di.gettype() == .int); ```  possible types include `int` (major type 0 and 1) `bytestring` (major type 2), `textstring` (major type 3), `array` (major type 4), `map` (major type 5), `tagged` (major type 6) and `float` (major type 7).  based on the given type you can the access the underlying value.  ```zig std.debug.assert(di.int().? == 18446744073709551615); ```  all getter functions return either a value or `null`. you can use a pattern like `if (di.int()) |v| v else return error.oops;` to access the value in a safe way. if you've used `dataitem.new()` and know the type of the data item, you should be safe to just do `di.int().?`.  the following getter functions are supported: * `int` - returns `?i65` * `string` - returns `?[]const u8` * `array` - returns `?arrayiterator` * `map` - returns `?mapiterator` * `simple` - returns `?u8` * `float` - returns `?f64` * `tagged` - returns `?tag` * `boolean` - returns `?bool`  #### iterators  the functions `array` and `map` will return an iterator. every time you call `next()` you will either get a `dataitem`/ `pair` or `null`.  ```zig const di = dataitem.new('╲x98╲x19╲x01╲x02╲x03╲x04╲x05╲x06╲x07╲x08╲x09╲x0a╲x0b╲x0c╲x0d╲x0e╲x0f╲x10╲x11╲x12╲x13╲x14╲x15╲x16╲x17╲x18╲x18╲x18╲x19');  var iter = di.array().?; while (iter.next()) |value| {   _ = value;   // doe something } ```  ### encoding and decoding  #### serialization  you can serialize zig objects into cbor using the `stringify()` function.  ```zig const allocator = std.testing.allocator; var str = std.arraylist(u8).init(allocator); defer str.deinit();  const info = struct {     versions: []const []const u8, };  const i = info{     .versions = &.{'fido_2_0'}, };  try stringify(i, .{}, str.writer()); ```  > note: compile time floats are always encoded as single precision floats (f32). please use `@floatcast` > before passing a float to `stringify()`.  the `stringify()` function is convenient but also adds extra overhead. if you want full control over the serialization process you can use the following functions defined in `zbor.build`: `writeint`, `writebytestring`, `writetextstring`, `writetag`, `writesimple`, `writearray`, `writemap`. for more details check out the [manual serialization example](examples/manual_serialization.zig) and the corresponding [source code](src/build.zig).  ##### stringify options  you can pass options to the `stringify` function to influence its behavior. without passing any options, `stringify` will behave as follows:  * enums will be serialized to their textual representation * `u8` slices will be serialized to byte strings * for structs and unions:     * `null` fields are skipped by default     * fields of type `std.mem.allocator` are always skipped.     * the names of fields are serialized to text strings  you can modify that behavior by changing the default options, e.g.:  ```zig const ecdsap256key = struct {     /// kty:     kty: u8 = 2,     /// alg:     alg: i8 = -7,     /// crv:     crv: u8 = 1,     /// x-coordinate     x: [32]u8,     /// y-coordinate     y: [32]u8,      pub fn new(k: ecdsap256.publickey) @this() {                                                                                                                                                  const xy = k.touncompressedsec1();         return .{             .x = xy[1..33].*,             .y = xy[33..65].*,         };     } };  //...  try stringify(k, .{ .field_settings = &.{     .{ .name = 'kty', .field_options = .{ .alias = '1', .serialization_type = .integer } },     .{ .name = 'alg', .field_options = .{ .alias = '3', .serialization_type = .integer } },     .{ .name = 'crv', .field_options = .{ .alias = '-1', .serialization_type = .integer } },     .{ .name = 'x', .field_options = .{ .alias = '-2', .serialization_type = .integer } },     .{ .name = 'y', .field_options = .{ .alias = '-3', .serialization_type = .integer } }, } }, str.writer()); ```  here we define a alias for every field of the struct and tell `serialize` that it should treat those aliases as integers instead of text strings.  __see `options` and `fieldsettings` in `src/parse.zig` for all available options!__  #### deserialization  you can deserialize cbor data into zig objects using the `parse()` function.  ```zig const e = [5]u8{ 1, 2, 3, 4, 5 }; const di = dataitem.new('╲x85╲x01╲x02╲x03╲x04╲x05');  const x = try parse([5]u8, di, .{});  try std.testing.expectequalslices(u8, e[0..], x[0..]); ```  ##### parse options  you can pass options to the `parse` function to influence its behaviour.  this includes:  * `allocator` - the allocator to be used. this is required if your data type has any pointers, slices, etc. * `duplicate_field_behavior` - how to handle duplicate fields (`.usefirst`, `.error`) * `ignore_unknown_fields` - ignore unknown fields (default is `true`) * `field_settings` - lets you specify aliases for struct fields * `from_cborparse` - flag to break infinity loops (see overriding parse)  #### builder  you can also dynamically create cbor data using the `builder`.  ```zig const allocator = std.testing.allocator;  var b = try builder.withtype(allocator, .map); try b.pushtextstring('a'); try b.pushint(1); try b.pushtextstring('b'); try b.enter(.array); try b.pushint(2); try b.pushint(3); //try b.leave();            <-- you can leave out the return at the end const x = try b.finish(); defer allocator.free(x);  // { 'a': 1, 'b': [2, 3] } try std.testing.expectequalslices(u8, '╲xa2╲x61╲x61╲x01╲x61╲x62╲x82╲x02╲x03', x); ```  ##### commands  - the `push*` functions append a data item - the `enter` function takes a container type and pushes it on the builder stack - the `leave` function leaves the current container. the container is appended to the wrapping container - the `finish` function returns the cbor data as owned slice  #### overriding stringify  you can override the `stringify` function for structs and tagged unions by implementing `cborstringify`.  ```zig const foo = struct {     x: u32 = 1234,     y: struct {         a: []const u8 = 'public-key',         b: u64 = 0x1122334455667788,     },      pub fn cborstringify(self: *const @this(), options: options, out: anytype) !void {          // first stringify the 'y' struct         const allocator = std.testing.allocator;         var o = std.arraylist(u8).init(allocator);         defer o.deinit();         try stringify(self.y, options, o.writer());          // then use the builder to alter the cbor output         var b = try build.builder.withtype(allocator, .map);         try b.pushtextstring('x');         try b.pushint(self.x);         try b.pushtextstring('y');         try b.pushbytestring(o.items);         const x = try b.finish();         defer allocator.free(x);          try out.writeall(x);     } }; ```  the `stringifyoptions` can be used to indirectly pass an `allocator` to the function.  please make sure to set `from_cborstringify` to `true` when calling recursively into `stringify(self)` to prevent infinite loops.  #### overriding parse  you can override the `parse` function for structs and tagged unions by implementing `cborparse`. this is helpful if you have aliases for your struct members.  ```zig const ecdsap256key = struct {     /// kty:     kty: u8 = 2,     /// alg:     alg: i8 = -7,     /// crv:     crv: u8 = 1,     /// x-coordinate     x: [32]u8,     /// y-coordinate     y: [32]u8,      pub fn cborparse(item: dataitem, options: options) !@this() {         _ = options;         return try parse(@this(), item, .{             .from_callback = true, // prevent infinite loops             .field_settings = &.{                 .{ .name = 'kty', .field_options = .{ .alias = '1' } },                 .{ .name = 'alg', .field_options = .{ .alias = '3' } },                 .{ .name = 'crv', .field_options = .{ .alias = '-1' } },                 .{ .name = 'x', .field_options = .{ .alias = '-2' } },                 .{ .name = 'y', .field_options = .{ .alias = '-3' } },             },         });     } }; ```  the `options` can be used to indirectly pass an `allocator` to the function.  please make sure to set `from_callback` to `true` when calling recursively into `parse(self)` to prevent infinite loops.  #### structs with fields of type `std.mem.allocator`  if you have a struct with a field of type `std.mem.allocator` you have to override the `stringify`  funcation for that struct, e.g.:  ```zig pub fn cborstringify(self: *const @this(), options: cbor.stringifyoptions, out: anytype) !void {     _ = options;      try cbor.stringify(self, .{         .from_cborstringify = true,         .field_settings = &.{             .{ .name = 'allocator', .options = .{ .skip = true } },         },     }, out); } ```  when using `parse` make sure you pass a allocator to the function. the passed allocator will be assigned to the field of type `std.mem.allocator`.  ### arraybackedslice  this library offers a convenient function named arraybackedslice, which enables you to create a wrapper for an array of any size and type. this wrapper implements the cborstringify and cborparse methods, allowing it to seamlessly replace slices (e.g., []const u8) with an array.  ```zig test 'arraybackedslice test' {     const allocator = std.testing.allocator;      const s64b = arraybackedslice(64, u8, .byte);     var x = s64b{};     try x.set('╲x01╲x02╲x03╲x04');      var str = std.arraylist(u8).init(allocator);     defer str.deinit();      try stringify(x, .{}, str.writer());     try std.testing.expectequalslices(u8, '╲x44╲x01╲x02╲x03╲x04', str.items);      const di = try dataitem.new(str.items);     const y = try parse(s64b, di, .{});      try std.testing.expectequalslices(u8, '╲x01╲x02╲x03╲x04', y.get()); } ``` ","deckarep/ziglang-set":"A generic and general purpose Set implementation for the Zig language ### ziglang set  ![license](https://img.shields.io/github/license/deckarep/ziglang-set) ![issue](https://img.shields.io/github/issues-raw/deckarep/ziglang-set?style=flat) ![commit](https://img.shields.io/github/last-commit/deckarep/ziglang-set) ![ci](https://github.com/deckarep/ziglang-set/workflows/ci/badge.svg)  <p align='center'> ziglang-set: a generic and general-purpose set implementation for zig. <br/> 🚧 pre-alpha 🚧 </p>  #  <p align='center'>   <img src='assets/zigsetgraphic.png' width='512'/> </p>  # <p align='center'>   <a href='https://deckarep.github.io/ziglang-set/'><img src='https://img.shields.io/badge/api-reference-blue.svg?style=flat-square' alt='api reference'></a> </p>  #  zig currently [does not have](https://github.com/ziglang/zig/issues/6919) a built-in, general purpose set data structure at this point in time. until it does, try this!  rationale: it may be common knowledge that a dictionary or map or hashset can be used as a set where the value is basically void. while this is true, there's a lot to think about in terms of supporting all the common set operations in a performant and correct way and there's no good reason why a common module for this can't exist. after studying the zig stdlib, i'm hoping this implementation can fill that gap and provide some value.  #  this module offers a set implementation built in the same vein and spirit of the other data structures within the zig standard library. this is my attempt to model one that can get better over time and grow with community interest and support. see a problem, file a bug! or better yet contribute and let's build the best implementation together.  i am the original author of the popular go based set package: [golang-set](https://github.com/deckarep/golang-set) that is used by software components built by docker, 1password, ethereum, sendgrid, crowdstrike and hashicorp. at just shy of `4k stars`, i figured i'd take a crack at building a comprehensive and generic zig-based set that goes above and beyond the original go implementation. after using zig for over 2.5 years on personal projects, i thought it was time that zig had a robust set implementation for itself.  this implementation gives credit and acknowledgement to the [zig language](https://ziglang.org) and powerful [std library](https://ziglang.org/documentation/master/std/#std) [hashmap](https://ziglang.org/documentation/master/std/#std.hash_map.hashmap) data structure of which this set implementation is built on top of. without that, this probably wouldn't exist. efforts will be made to keep the ziglang set code fast and straightforward but this set's raw speed will largely be bounded by the performance of the zig hashmap of which it is built on top of.  #  #### features   * offers idiomatic, generic-based zig api - allocators, iterators, capacity hints, clearing, resizing, etc.   * a few flavors to choose from     * hash-based: everyday usecase, optimized for lookups primarily, insertion/removal secondarily - [further reading](https://devlog.hexops.com/2022/zig-hashmaps-explained/)       * hashsetmanaged - initializes with an allocator and holds it internally (built on top of unmanaged)       * hashsetunmanaged - does not hold an allocator, smaller footprint     * array-based: more specialized, iteration much faster, insertion order preserved, indexing into underylying data - [further reading](https://devlog.hexops.com/2022/zig-hashmaps-explained/)       * arrayhashsetmanaged - initializes with an allocator and holds it internally (built on top of unmanaged)       * arrayhashsetunmanaged - does not hold an allocator, smaller footprint   * common set operations     * add, append, appendslice     * remove, removeall     * containsone, containsany, containsall     * clone, clonewithallocator     * equals, isempty, cardinality     * intersection, intersectionupdate (in-place variant)     * union, unionupdate (in-place variant)     * difference, differenceupdate (in-place variant)     * symmetricdifference, symmetricdifferenceupdate (in-place variant)     * issubset     * issuperset     * ispropersubset     * ispropersuperset     * pop   * fully documented and robustly tested - in progress   * performance aware to minimize unecessary allocs/iteration internally   * 'string' support - coming soon   * benchmarks - coming soon # #### why use a set?   * a set offers a fast way to manipulate data and avoid excessive looping. look into it as there is already tons of literature on the advantages of having a set in your arsenal of tools. # #### example ```zig     // import the namespace.     const set = @import('ziglangset');      // create a set of u32s called a     var a = set.set(u32).init(std.testing.allocator);     defer a.deinit();      // add some data     _ = try a.add(5);     _ = try a.add(6);     _ = try a.add(7);      // add more data; single shot, duplicate data is ignored.     _ = try a.appendslice(&.{ 5, 3, 0, 9 });      // create another set called b     var b = set.set(u32).init(std.testing.allocator);     defer b.deinit();      // add data to b     _ = try b.appendslice(&.{ 50, 30, 20 });      // get the union of a | b     var un = try a.unionof(b);     defer un.deinit();      // grab an iterator and dump the contents.     var iter = un.iterator();     while (iter.next()) |el| {         std.log.debug('element: {d}', .{el.*});     } ``` #  output of `a | b` - the union of a and b (order is not guaranteed) ```sh > element: 5 > element: 6 > element: 7 > element: 3 > element: 0 > element: 9 > element: 50 > element: 30 > element: 20 ```  #  #### installation of module  to add this module, update your applications build.zig.zon file by adding the `.ziglang-set` dependency definition.   ```zig .{     .name = 'your-app',     .version = '0.1.0',     .dependencies = .{         .ziglangset = .{             .url = 'https://github.com/deckarep/ziglang-set/archive/$commit_you_want_to_use.tar.gz',         },     }, } ```  when running zig build now, zig will tell you you need a hash for the dependency and provide one. put it in your dependency so it looks like:  ```zig .{   .ziglangset = .{       .url = 'https://github.com/deckarep/ziglang-set/archive/$commit_you_want_to_use.tar.gz',       .hash = '$hash_zig_gave_you',   }, } ```  with the dependency in place, you can now put the following in your build.zig file:  ```zig     const ziglangset = b.dependency('ziglangset', .{});     exe.root_module.addimport('ziglangset', ziglangset.module('ziglangset')); ```  in the above change `exe` to whatever compilestep you are using. for an executable it will probably be exe, but `main_tests` or lib are also common.  with the build file in order, you can now use the module in your zig source. for example:  ```zig const std = @import('std'); const set = @import('ziglangset');  pub fn main() void {     // 1. this datastructure requires an allocator.     //    setup and choose your respective allocator.     // see: https://zig.guide/standard-library/allocators      // 2. go to town!     var a = set.set(u32).init(allocator);     defer a.deinit();      // now do something cool with your set!     // ... } ```  check the tests for more comprehensive examples on how to use this package.  #### testing  ```sh zig build test ``` ","scottredig/zig-javascript-bridge":"Easily call Javascript from Zig wasm # zig-javascript-bridge  this library creates bindings for accessing javascript from within a wasm runtime.  for example:  ```zig const zjb = @import('zjb');  export fn main() void {     zjb.global('console').call('log', .{zjb.conststring('hello from zig')}, void); }  ```  is equivalent to this javascript: ```javascript console.log('hello from zig'); ```  ## project status  zjb is fully functional and is ready to be used in other projects.  however 1.0 will not be tagged until there is significant enough usage that confidence in the api not needing further changes is high.  ## why  calling javascript functions from zig is a pain.  wasm has restrictions on the function api surface, and how references to the runtime environment (javascript) can be stored.  so to access javascript functionality from zig, you must create: a function in zig which is friendly to call, a function export, and a function in javascript which translates into the call you actually want.  this isn't too bad so far, but the javascript api surface is large, has a lot of variadic functions, and accepts many types.  the result is that your programming loop of just wanting to write code slows down writing a large amount of ill fitting boilerplate whenever you must cross the zig to javascript boundary.  this package is clearly inspired by go's solution to this problem: https://pkg.go.dev/syscall/js  however, there are a few significant deviations to note if you're familiar with that library:  1. every call from go's package involves string decoding, garbage creation, and reflection calls. 2. go has a one size fits all javascript file, while zjb uses a generator to produce javascript for the calls you use. 3. go's garbage collection and finalizers allows for automatically cleaning up references from go to javascript, while zjb requires manual handle releasing. 4. zig has no runtime, so there's none of go's weirdness about blocking on the main thread.  ## usage  as of may 2024, zjb requires zig 0.12.0 or greater.  the simple folder provides a good template to start from.  you'll need to update to reference to zjb in `build.zig.zon`.  there's currently no release schedule for point releases, so you should use the latest available code.  eg, copy the entire `simple` folder into your empty project, then run `zig fetch --save=zjb https://github.com/scottredig/zig-javascript-bridge/archive/<put hash of latest commit to main here>.zip`  call into javascript using `zjb`, generate the javascript side code, and then build an html page to combine them.  ### example  an example which demonstrates usage of all of the components of `zjb` is in the example folder.  it includes:  - `src/main.zig` has usage examples for the `zjb` zig import. - `build.zig`'s example for how to set up your build file. - `static` includes html and javascript files to run the example.  to view the example in action, run `zig build example` from inside the example folder.  then host a webserver from `zig-out/bin`.  ### details  zjb functions which return a value from javascript require specifying which type is returned.  as arguments or return types to be passed into javascript, zjb supports:  - `i32`, `i64`, `f32`, `f64`.  these are the only numerical types that are supported by the webassembly javascript interface, so you must cast to one of these before passing. - `comptime_int`, `comptime_float`.  these are valid as arguments, and are passed as f64 to javascript, which is javascript's main number type. - `zjb.handle`.  the zig side type for referring to javascript values.  most of the time this will be a javascript object of some kind, but in some rare cases it might be something else, such as null, a number, nan, or undefined.  used as an argument, it is automatically converted into the value that is held in zjb's javascript `_handles` map.  when used as a return value, it is automatically added to zjb's javascript `_handles` map.  it is the caller's responsibility to call `release` to remove it from the `_handles` map when you're done using it. - `zjb.consthandle` as arguments but not return types.  these values are returned by `zjb.conststring`, `zjb.global`, and `zjb.fnhandle`.  `zjb.consthandle` works similarly to `zjb.handle`, with a few notable exceptions: 1. values are memoized upon first use on the zig side, so they can be used any number of times without churning garbage.  2. there is no `release` function.  these values are intended to be around for the lifetime of your program, with reduced friction of using them.  as the functions which produce consthandle values all take only comptime arguments, these cannot balloon uncontrolably at runtime.  some values are always defined as handles, `zjb.consthandle.null` is javascript's `null`, `zjb.consthandle.global` is the global scope, and `zjb.consthandle.empty_string` is a javascript empty string. - `void` is a valid type for method calls which have no return value.  zjb supports multiple ways to expose zig functions to javascript: - `zjb.exportfn` exposes the function with the passed name to javascript.  this supports `zjb.handle`, so if you pass an object from a javascript function, a handle will automatically be created and passed into zig.  it is the responsibility of the zig function being called to call `release` on any handles in its arguments at the appropriate time to avoid memory leaks. - `zjb.fnhandle` uses `zjb.exportfn` and additionally returns a `zjb.consthandle` to that function.  this can be used as a callback argument in javascript functions. - zig's `export` keyword on functions works as it always does in wasm, but doesn't support `zjb.handle` correctly.  simple zig global variables can also be exposed to javascript: - `zjb.exportglobal` exposes the variable with the passed address to javascript. this supports `bool`, `i32`, `i64`, `u32`, `u64`, `f32`, and `f64`. property descriptors will be created with get/set methods that provide access to the variable.  a few extra notes:   `zjb.string([]const u8)` decodes the slice of memory as a utf-8 string, returning a handle.  the string will not update to reflect changes in the slice in zig.  `zjb.global` will be set to the value of that global variable the first time it is called.  as it is intended to be used for javascript objects or classes defined in the global scope, that usage will be safe.  for example, `console`, `document` or `map`.  if you use it to retrieve a value or object you've defined in javascript, ensure it's defined before your program runs and doesn't change.  the ╲_arrayview functions (`i8arrayview`, `u8arrayview`, etc) create the respective javascript typed array backed by the same memory as the zig wasm instance.  `dataview` is similar in functionality to the arrayview functions, but returns a dataview object.  accepts any pointer or slice.  the generated javascript also includes a shortcut function named `dataview` to get an up-to-date cached `dataview` of the entire webassembly `memory`.   > [!caution] > there are three important notes about using the ╲_arrayview and dataview functions: > > the ╲_arrayview and dataview functions will accept const values.  if you pass one (such as []const u8), you are exposing zig's memory to javascript.  changing the values from javascript may lead to undefined behavior.  zjb allows this as there are plenty of use cases which only read the data, and requiring non-const values throughout your program if they are eventually passed to javascript isn't a desirable api.  it's up to you to be safe here. > > changes to the values in either zig or javascript will be visible in the other.  however, if the wasm memory grows for whatever reason (either through a direct @wasmmemorygrow call or through allocators), all ╲_arrayviews and dataviews are invalided, and their length will be zero.  you have (roughly speaking) three choices to handle this: > 1. always create just before using, and release immediately after use. > 1. never allocate after using these functions. > 1. check their length before any use, if it does not match the intended length, release and recreate the handle. > > javascripts's dataview allows pulling out arbitrary values from offsets.  this may be useful for working with zig structs from javascript, however remember that zig may reorder the fields for structs.  use `extern struct` to be safe here.  ## how  to solve the general problem of referencing javascript objects from zig, an object on the javascript side with integer indices is used.  when passing to javascript, the object is added to the map with a unique id, and that id is passed to zig.  when calling from zig, javascript will translate the id into the object stored on the map before calling the intended function.  to avoid building up garbage endlessly inside the object map, zjb code must call release to delete the reference from the map.  zjb works with two steps:  1. your zig code calls zjb functions.  many functions use comptime to create export functions with specialized export signatures.  only methods which are actually used are in the final wasm file. 2. run an extract methods program on the wasm file, producing a javascript file to use along with your wasm file.  the example above produces this export, for example:  ```javascript const zjb = class {   new_handle(value) {     if (value === null) {       return 0;     }     const result = this._next_handle;     this._handles.set(result, value);     this._next_handle++;     return result;   }   dataview() {     if (this._cached_data_view.buffer.bytelength !== this.instance.exports.memory.buffer.bytelength) {       this._cached_data_view = new dataview(this.instance.exports.memory.buffer);     }     return this._cached_data_view;   }   constructor() {     this._decoder = new textdecoder();     this.imports = {       'call_o_v_log': (arg0, id) => {         this._handles.get(id).log(this._handles.get(arg0));       },       'get_o_console': (id) => {         return this.new_handle(this._handles.get(id).console);       },       'string': (ptr, len) => {         return this.new_handle(this._decoder.decode(new uint8array(this.instance.exports.memory.buffer, ptr, len)));       },     };     this.exports = {     };     this.instance = null;     this._cached_data_view = null;     this._export_reverse_handles = {};     this._handles = new map();     this._handles.set(0, null);     this._handles.set(1, window);     this._handles.set(2, '');     this._handles.set(3, this.exports);     this._next_handle = 4;   }   setinstance(instance) {     this.instance = instance;     const initialview = new dataview(instance.exports.memory.buffer);     this._cached_data_view = initialview;   } };  ``` ","griush/zm":"zm - Fast, Zig math library, fully cross-platform <img src='https://raw.githubusercontent.com/griush/resources/f5f9659dd5c4d18d63ff9bc2e67b8feee874e482/logos/zm-dark.svg#gh-dark-mode-only' alt='zm logo' width='400px'> <img src='https://raw.githubusercontent.com/griush/resources/f5f9659dd5c4d18d63ff9bc2e67b8feee874e482/logos/zm-light.svg#gh-light-mode-only' alt='zm logo' width='400px'>  ![github actions workflow status](https://img.shields.io/github/actions/workflow/status/griush/zm/ci.yaml?style=flat&logo=github&label=ci)  # zm - fast math library zm is a zig math library. it is fast, easy to use and cross-platform.  ## usage > [!note] > this library is tracking zig's master branch. last tested with `0.14.0-dev.2126+e27b4647d`. > it does not compile in `0.13.0`.  run `zig fetch --save git+https://github.com/griush/zm` on the directory of your `build.zig` and `build.zig.zon`.  then in the `build.zig` add: ```zig const zm = b.dependency('zm', .{}); exe.root_module.addimport('zm', zm.module('zm')); ``` now, in your code, you can use: ```zig const zm = @import('zm'); ```  ### getting started for an example using zig's build system see: [example](/example/). there is a working example using opengl and glfw [here](https://github.com/griush/zig-opengl-example).  simple example for game development. ```zig const zm = @import('zm'); const std = @import('std');  pub fn main() !void {     // initialize window (with glfw for example)      // create opengl/vulkan... context      const projection = zm.mat4.perspective(zm.toradians(60.0), 16.0 / 9.0, 0.05, 100.0);     const view = zm.mat4.translation(0.0, 0.75, 5.0);     const view_proj = projection.multiply(view);      // upload data     gl.namedbuffersubdata(ubo, 0, @sizeof(zm.mat4), &view_proj);      // render loop      // cleanup } ```  ## benchmarks see [benchmarks](/test/benchmark.zig). ","ikskuh/any-pointer":"A type erasure library for Zig that is meant to be eventually upstreamed to std # any-pointer type erasure  this package provides a single file `any-pointer.zig` that implements a type-erased pointer for zig.  this pointer type supports three functions `make`, `cast` and `isnull` and exports the symbol `null_pointer`.  ```zig const anypointer = @import('any-pointer').anypointer;  var i: u32 = 0;  const erased = anypointer.make(*u32, &i);  const ptr = erased.cast(*u32);  ptr.* = 42;  std.debug.assert(!ptr.isnull()); std.debug.assert(i == 42); ```  in safe modes (`debug` and `releasesafe`) `cast` will type-check the pointer and might `@panic` when a type confusion would happen.  ## usage  just add a package pointing to `any-pointer.zig` to your project.  the package will export three types:  - `safepointer`, which will provide type checking and panics in safe modes. - `unsafepointer`, which will not provide type checking and will only have the size of a single pointer. - `anypointer`, which will be `safepointer` in safe modes and `unsafepointer` in unsafe modes.  in addition to `make`, `cast` and `isnull`, `safepointer` also has the function `trycast` which works like `cast`, but will return an optional. ","r4gus/keypass":"PassKeeZ is a FIDO2/ Passkey compatible authenticator implementation for Linux # passkeez  a fido2/ passkey compatible authenticator for linux based on [keylib](https://github.com/r4gus/keylib).  the project exclusively supports linux due to the absence of a standardized api for interprocess communication (ipc) between the client and authenticator. as a workaround, platform authenticators on linux act as virtual usb hid devices utilizing uhid. however, extending this functionality to other platforms remains unexplored as i haven't had the opportunity to investigate the equivalent mechanisms elsewhere.  | browser | supported? | tested version| notes | |:-------:|:----------:|:-------------:|:-----:| | cromium   | &#9989;    | 119.0.6045.159 (official build) arch linux (64-bit) | | | brave | &#9989; | version 1.62.153 chromium: 121.0.6167.85 (official build) (64-bit) | | | firefox | &#9989; | 122.0 (64-bit) |  | | opera | &#9989; | version: 105.0.4970.16 chromium: 119.0.6045.159 | |  > [!note] > all tests were conducted using passkey for github.  > [!important] > browsers running in sandboxed environments might not be able to communicate with the authenticator out of the box (e.g. when installing browsers with the ubuntu app center).  ## features  * works with all services that support passkeys * store your passkeys (just a private key + related data) in a local, encrypted database * constant sign-counter, i.e. you can safely sync your credentials/passkeys between devices.  > [!note] > the release of version 0.3.0 removed the gui. this means that you need version 0.2.5 if > you want to delete credentials. a upcoming update will add credential management, which > should also allow to modify credentials using a tool like `fido2-token`. the overall goal > is to write a dedicated tool that allows the configuration of passkeez via official commands.  ## install  this project is installed by running the following command in your terminal.  ### beta  ``` sudo bash -c '$(curl -fssl https://raw.githubusercontent.com/r4gus/keypass/master/script/install-beta.sh)' ```  > [!note] > the following dependencies are required: > * `curl` > * `git` > * `libgtk-3-0`  the script will make the following modifications: * `passkeez` is installed to `/usr/local/bin` * `zigenity` (used for the user interface) is installed to `/usr/local/bin` * the user is added to the `fido` group * a udev rule is copied to `/etc/udev/rules.d/90-uinput.rules` * the `uhid` module is added to `/etc/modules-load.d/fido.conf`  > [!note] > databases generated by older versions are not compatible.  ### database management  currently the only way to manage your credentials is by using the [ccdb command line application](https://github.com/r4gus/ccdb).  ### file synchronization  you can synchronize your database files using a service like [syncthing](https://docs.syncthing.net/intro/getting-started.html) between your devices. this allows you to use the same passkeys to login to your accounts on multiple devices.  #### syncthing  please see the [getting started guide](https://docs.syncthing.net/intro/getting-started.html) on how to setup syncthing on your device. make sure you also setup syncthing to [startup automatically](https://docs.syncthing.net/users/autostart.html#linux), to prevent a situation where your databases are out of sync.  > note: for now, please make sure that you don't have the same database open on multiple devices simultaneously.  ## contributing  currently this application and the surrounding infrastructure  ([keylib](https://github.com/r4gus/keylib), [zbor](https://github.com/r4gus/zbor), [tresor](https://github.com/r4gus/tresor)) is only maintained by me. one exception is the graphics library [dvui](https://github.com/david-vanderson/dvui) i use for the frontend.  if you find a bug or want to help out, feel free to either open a issue for one of the mentioned projects or write me a mail.  all contributions are wellcome! including:  * bug fixes * documentation * new features * support for other systems (linux distros, oss, ...) * ...  ## qa  <details> <summary><ins>what is this project about?</ins></summary>  fido2 stands as a dedicated authentication protocol crafted for diverse authentication needs. whether employed as a standalone method, supplanting traditional password-based authentication, or as an additional layer of security, fido2 serves both purposes. the fido alliance has actively advocated for the widespread adoption of this protocol for several years, with 2023 witnessing a substantial surge in its adoption. however, it's crucial to note that fido2 introduces a heightened level of complexity in comparison to conventional passwords. notably, the use of roaming authenticators, such as yubikey, can be a cost-intensive aspect.  upon initiating the keylib project in october 2022, my primary objective was to develop a library empowering individuals to transform their own hardware, such as esp32, into a functional authenticator. i believe i've achieved this goal successfully. however, during this process, i also recognized the evolving trend favoring hybrid/platform authenticators with discoverable credentials, now commonly marketed as passkeys.  while traditional authenticators like yubikeys provide robust protection against various attacks, they come with notable drawbacks. their high cost, limited update/patching capabilities, and restricted storage for discoverable credentials (for instance, my yubikey 5 supports around 25 credentials) underscore these challenges. additionally, the inability to back up data, although enhancing confidentiality, poses availability concerns. the official solution offered for this predicament is surprisingly simple: 'buy a second one.'  conversely, platform authenticators present a more flexible and cost-effective alternative. unlike traditional counterparts, they can undergo regular updates and patches, akin to any software component. furthermore, these authenticators permit the backup and secure sharing of credentials, leveraging an encrypted database within this project.  one key advantage lies in their cost-effectiveness, eliminating the need for additional hardware. when implemented with precision, platform authenticators can attain a commendable level of security, providing a compelling alternative to their more expensive counterparts.  the primary objective of this project is to furnish an alternative —keeping in mind that the term 'alternative' is subjective and, due to resource constraints, i may not offer a polished, 'commercial-grade' product— to existing commercial passkey implementations.  </details>  <details> <summary><ins>what is fido2/ passkey?</ins></summary> please read the qa of the [keylib](https://github.com/r4gus/keylib) project. </details>  <!-- ## showcase  <table>   <tr>     <td><img src='static/login.png' width='400'></td>     <td><img src='static/new-database.png' width='400'></td>   </tr>   <tr>     <td><img src='static/main.png' width='400'></td>     <td><img src='static/assertion.png' width='400'></td>   </tr> </table> --> ","mnemnion/mvzr":"Minimum Viable Zig Regex # mvzr: the minimum viable zig regex library  finding myself in need of a regular expressions library for a zig project, and needing it to build regex at runtime, not just comptime, i ended up speedrunning a little library for just that purpose.  this is that library.  it's a simple bytecode-based commander pike-style vm.  just under 1500 lines of load-bearing code, no dependencies other than `std`.  the provided regex type allows 64 'operations' and 8 unique ascii character sets.  if you would like more, or less, you can call `sizedregex(num_ops, num_sets)` to customize the type.  ## installation  drop the file into your project, or use the zig build system:  ```zig zig fetch --save 'https://github.com/mnemnion/mvzr/archive/refs/tags/v0.2.4.tar.gz' ```  i'll do my best to keep that url fresh, but it pays to check over here: ➔  for the latest release version.  ## features  - zero allocation, comptime and runtime compiling and matching - x operations per regex - y character sets per regex - greedy qualifiers: `*`, `+`, `?` - lazy qualifiers: `*?`, `+?`, `??` - possessive/eager qualifiers: `*+`, `++`, `?+` - alternation: `foo|bar|baz` - grouping `foo|(bar|baz)+|quux` - sets: `[abc]`, `[^abc]`, `[a-z]`, `[^a-z]`, `[╲w+-]`, `[╲x04-╲x1b]` - built-in character groups (ascii): `╲w`, `╲w`, `╲s`, `╲s`, `╲d`, `╲d` - escape sequences: `╲t`, `╲n`, `╲r`, `╲xxx` hex format     - same set as zig: if you need the weird c ones, use `╲x` format - begin and end `^` and `$` - word boundaries `╲b`, `╲b` - `{m}`, `{m,}`, `{m,n}`, `{,n}`  ## limitations and quirks  - no unicode support to speak of - no fancy modifiers (you want case-insensitive, great, lowercase your string) - `.` matches any one byte.  `[^╲n╲r]` works fine if that's not what you want     - or split into lines first, divide and conquer     - note: `$` permits a final newline, but `^` must be the beginning of a string, and `$` _only_ matches a final newline. - backtracks (sorry. for this to work without backtracking, we need async back)     - preliminary tests indicate that this backtracking is non-catastrophic - compiler does some best-effort validation but i haven't really pounded on it - no capture groups.  divide and conquer  as long as you color within the lines, it should be fine.  this library is not intended for use where an attacker could conceivably control the regex pattern.  much like managing your own memory, if you know your tools and are smart about it, you can get a lot done with `mvzr`.  ## interface  `mvzr.regex` is available at `comptime` or runtime, and returns an `mvzr.match`, consisting of a `.slice` field containing the match, as well as the `.start` and `.end` locations in the haystack.  this is a borrowed slice, to own it, call `match.toownedmatch(allocator)`, and deallocate later with `match.deinit(allocator)`, or just free the `.slice`.  similarly, if you need to store a `regex` or `sizedregex` for later, call `regex.toownedregex(allocator)`, freeing later with `allocator.destroy(heap_regex)`.  ```zig // aka sizedregex(64, 8) const regex: mvzr.regex = mvzr.compile(patt_str).?; // or mvzr.regex.compile(patt_str) const match: mvzr.match = regex.match(haystack).?; const match2: mvzr.match = match(haystack, patt_str).?; const did_match: bool = regex.ismatch(haystack); const iter: mvzr.regexiterator = regex.iterator(haystack);  while (iter.next()) |m| {     // ... }  // comptime-only const ops, const sets = mvzr.resourcesneeded('abc?d*[^efgh]++2');  // i suggest adding the values directly here once they're established const slimmeddownregex = mvzr.sizedregex(ops, sets); ```  ## compile errors  if a regex string is unable to compile, `mvzr` will return `null`.  it will also log an informative error message.  while this is useful, it may not be desirable, so `mvzr` uses a [scoped logger](https://ziglang.org/documentation/0.12.0/std/#std.log) with the scope `.mvzr`, to make it easy for a custom logging function to filter those messages out.  ## bugs  fewer over time, i hope.  the test suite never shrinks.  ### bug reports  always welcome.  ideally, presented as a failing test block, with a note on expected behavior.  ","nektro/zig-xml":"A pure-Zig fully spec-compliant XML parser. # zig-xml  a pure-zig spec-compliant xml parser.  https://www.w3.org/tr/xml/  passes all standalone tests from https://www.w3.org/xml/test/xmlconf-20020606.htm, even more coverage coming soon.  one caveat is that this parser expects utf-8.  ``` build summary: 3/3 steps succeeded; 120/120 tests passed test success └─ run test 120 passed 5ms maxrss:1m    └─ zig test debug native success 1s maxrss:247m ```  ## license  mpl-2.0 ","g41797/mailbox":"Zig Mailbox  is convenient  inter-thread communication mechanizm. ![](_logo/mailboxes.png)   # mailbox - old new way of inter-thread communication.            [![ci](https://github.com/g41797/yazq/actions/workflows/ci.yml/badge.svg)](https://github.com/g41797/yazq/actions/workflows/ci.yml) <img src='https://img.shields.io/badge/linux-fcc624?style=flat&logo=linux&logocolor=black' width='48' height='24'>&nbsp; <img src='https://img.shields.io/badge/macos-000000?style=flat&logo=apple&logocolor=white' width='48' height='24'>&nbsp; <img src='https://img.shields.io/badge/windows-0078d6?style=flat&logo=windows&logocolor=white' width='48' height='24'>&nbsp;  ## a bit of history, a bit of theory  mailboxes are one of the fundamental parts of the [actor model originated in **1973**](https://en.wikipedia.org/wiki/actor_model):  > an actor is an object that carries out its actions in response to communications it receives. > through the mailbox mechanism, actors can decouple the reception of a message from its elaboration. > a mailbox is nothing more than the data structure (fifo) that holds messages.  i first encountered mailbox in the late 80s while working on a real-time system:  > 'a **mailbox** is object that can be used for inter-task communication. when task a wants to send an object to task b, task a must send the object to the mailbox, and task b must visit the mailbox, where, if an object isn't there, it has the option of *waiting for any desired length of time*...'  > **irmx 86™ nucleus reference manual** _copyright @ 1980, 1981 intel corporation.  since than i have used it in:  |     os      | language(s) | |:-----------:|:-----------:| |    irmx     |  *pl/m-86*  | |     aix     |     *c*     | |   windows   |  *c++/c#*   | |    linux    |    *go*     |  **now it's zig time!!!**  ## why? if your thread runs in 'fire and forget' mode, you don't need mailbox.   but in real multithreaded applications, threads communicate with each other as members of a work team.  **mailbox** provides a convenient and simple inter-thread communication: - thread safe - asynchronous - non-blocking  - cancelable - no own allocations - unbounded - fan-out/fan-in     ## example of usage - 'echo'  ```zig     // mbx is mailbox with usize letter(data)     const mbx = mailbox.mailbox(usize);      // echo - runs on own thread     // it has two mailboxes     // 'to' and 'from' - from the client point of the view     // receives letter via 'to' mailbox     // replies letter without change (echo) to 'from' mailbox     const echo = struct {         const self = @this();          to: mbx = undefined,         from: mbx = undefined,         thread: thread = undefined,          // mailboxes creation and start of the thread         // pay attention, that client code does not use         // any thread 'api' - all embedded within echo         pub fn start(echo: *self) void {             echo.to = .{};             echo.from = .{};             echo.thread = std.thread.spawn(.{}, run, .{echo}) catch unreachable;         }          // echo thread function         fn run(echo: *self) void {             // main loop:             while (true) {                 // receive - exit from the thread if mailbox was closed                 const envelope = echo.to.receive(100000000) catch break;                 // reply to the client                 // exit from the thread if mailbox was closed                 _ = echo.from.send(envelope) catch break;             }         }          // wait exit from the thread         pub fn waitfinish(echo: *self) void {             echo.thread.join();         }          // close mailboxes         // as result echo should stop processing         // and exit from the thread.         pub fn stop(echo: *self) !void {             _ = echo.to.close();             _ = echo.from.close();         }     };      var echo = try std.testing.allocator.create(echo);      // start echo(on own thread)     echo.start();     defer echo.stop();      defer {         // wait finish of echo         echo.waitfinish();         std.testing.allocator.destroy(echo);     }      // because nothing was send to 'to' mailbox, nothing should be received     // from 'from' mailbox     try testing.expecterror(error.timeout, echo.from.receive(100));      // create wrapper for the data     const envl = try std.testing.allocator.create(mbx.envelope);     defer std.testing.allocator.destroy(envl);      // send/receive loop     for (0..6) |indx| {         // set value for send [0-5]         envl.letter = indx;          // send to 'to' mailbox         try echo.to.send(envl);          // wait received data from out mailbox         const back = echo.from.receive(1000000);          if (back) |val| {             // expected value == index [0-5]             try testing.expect(val.letter == indx);         } else |_| {             try testing.expect(false);         }     } ```  ## boring details  mailbox of *[]const u8* 'letters': ```zig const rumors = mailbox.mailbox([]const u8); const rmrsmbx : rumors = .{}; ```  **envelope** is a wrapper of actual user defined type **letter**. ```zig         pub const envelope = struct {             prev: ?*envelope = null,             next: ?*envelope = null,             letter: letter,         }; ``` in fact mailbox is a queue(fifo) of envelope(s).  mailbox supports following operations: - send *envelope* to mailbox (*enqueue*) and wakeup waiting receiver(s) - receive *envelope* from mailbox (*dequeue*) with time-out - close mailbox:   - disables further operations   - first close returns list of non-processed *envelope(s)* for free/reuse etc.  feel free to suggest improvements in doc and code.   ## license [mit](license)  ## installation you finally got to installation!  ### submodules  create folder *'deps'* under *'src'* and mailbox submodule:   ```bash mkdif src/deps         git submodule add https://github.com/g41797/mailbox src/deps/mailbox ``` import mailbox: ```zig const mailbox = @import('deps/mailbox/src/mailbox.zig'); ``` use mailbox: ```zig const msgblock = struct {     len: usize = undefined,     buff: [1024]u8 = undefined, };  const msgs = mailbox.mailbox(msgblock);  var msgs: msgs = .{}; ................... _ = msgs.close(); ```  periodically update submodule(s): ```bash git submodule update --remote ```  ### package manager  with an existing zig project, adding mailbox to it is easy:  1. add mailbox to your `build.zig.zon` 2. add mailbox to your `build.zig`  to add mailbox to `build.zig.zon` simply run the following in your terminal:  ```sh cd my-example-project zig fetch --save=mailbox git+https://github.com/g41797/mailbox ```  and in your `build.zig.zon` you should find a new dependency like:  ```zig .{     .name = 'my example project',     .version = '0.0.1',      .dependencies = .{         .mailbox = .{             .url = 'git+https://github.com/g41797/mailbox#3f794f34f5d859e7090c608da998f3b8856f8329',             .hash = '122068e7811ec1bfc2a81c9250078dd5dafa9dca4eb3f1910191ba060585526f03fe',         },     },     .paths = .{         '',     }, } ```  then, in your `build.zig`'s `build` function, add the following before `b.installartifact(exe)`:  ```zig     const mailbox = b.dependency('mailbox', .{         .target = target,         .optimize = optimize,     });      exe.root_module.addimport('mailbox', mailbox.module('mailbox')); ```  from then on, you can use the mailbox package in your project.  ## last warning first rule of multithreading: >**if you can do without multithreading - do without.** <br>      *powered by*  [![clion](_logo/clion_icon.png)][refclion]  [refclion]: https://www.jetbrains.com/clion/   ","ziglibs/antiphony":"A zig remote procedure call solution # antiphony  a simple zig remote procedure call library.  ![project logo](design/logo.png)  ## features  - transport layer agnostic - support for nearly every non-generic function signature. - nestable remote calls (peer calls host calls peer calls host calls ...) - easy to use  ## api  ```zig // (comptime details left out for brevity)  pub fn createdefinition(spec: anytype) type {     return struct {         pub fn hostendpoint(reader: type, writer: type, implementation: type) type {             return createendpoint(.host, reader, writer, implementation);         }         pub fn clientendpoint(reader: type, writer: type, implementation: type) type {             return createendpoint(.client, reader, writer, implementation);         }         pub fn createendpoint(role: role, readertype: type, writertype: type, implementationtype: type) type {             return struct {                 const endpoint = @this();                  pub const reader = reader;                 pub const writer = writer;                 pub const implementation = implementation;                  pub const ioerror = error{ ... };                 pub const protocolerror = error{ ... };                 pub const invokeerror = error{ ... };                 pub const connecterror = error{ ... };                  pub fn init(allocator: std.mem.allocator, reader: reader, writer: writer) endpoint;                 pub fn destroy(self: *endpoint) void;                 pub fn connect(self: *endpoint, impl: *implementation) connecterror!void;                 pub fn shutdown(self: *endpoint) ioerror!void;                 pub fn acceptcalls(self: *endpoint) invokeerror!void;                 pub fn invoke(self: *endpoint, func_name: []const u8, args: anytype) invokeerror!result(func_name);             };         }     }; }  // example for createdefinition(spec): const definition = antiphony.createdefinition(.{     .host = .{         // add all functions the host implements:         .createcounter = fn () createerror!u32,         .destroycounter = fn (u32) void,         .increment = fn (u32, u32) usageerror!u32,         .getcount = fn (u32) usageerror!u32,     },     .client = .{         // add all functions the client implements:         .signalerror = fn (msg: []const u8) void,     },      // this is optional and can be left out:     .config = .{         // defines how to handle remote error sets:         .merge_error_sets = true,     }, }); ```  ## project status  this project is currently in testing phase, all core features are already implemented and functional.  ## contribution  contributions are welcome as long as they don't change unnecessarily increase the complexity of the library. this library is meant to be the bare minimum rpc implementation that is well usable. bug fixes and updates to new versions are always welcome.  ### compile and run the examples  ```sh-session [user@host antiphony]$ zig build install [user@host antiphony]$ ./zig-out/bin/socketpair-example info: first increment:  0 info: second increment: 5 info: third increment:  8 info: final count:      15 error: remote error: this counter was already deleted! info: error while calling getcount()  with invalid handle: unknowncounter [user@host antiphony]$ ```  ### run the test suite  ```sh-session [user@host antiphony]$ zig build test test [3/6] test 'invoke function (emulated client, no self parameter)'... some(1334, 3.1415927410125732, 'hello, host!'); test [4/6] test 'invoke function (emulated client, with self parameter)'... some(123, 1334, 3.1415927410125732, 'hello, host!'); test [5/6] test 'invoke function with callback (emulated host, no self parameter)'... callback('hello, world!'); test [6/6] test 'invoke function with callback (emulated host, with self parameter)'... callback(clientimpl@7ffd33f6cdc0, 'hello, world!'); all 6 tests passed. [user@host antiphony]$ ``` ","cryptocode/marble":"A metamorphic testing library for Zig <img align='right' width='320' src='https://user-images.githubusercontent.com/34946442/159163318-432052e3-69c7-4598-aaac-74d54f67c8b4.png'>  marble is a [metamorphic testing](https://en.wikipedia.org/wiki/metamorphic_testing) library for zig.  this library tracks zig master and was last tested on `0.12.0-dev.4472+1c7798a3c`  metamorphic testing is a powerful technique that provides additional test coverage by applying a number of transformations to test input, and then checking if certain relations still hold between the outputs. marble will automatically run through all possible combinations of these transformations.  here's a [great introduction by](https://www.cockroachlabs.com/blog/metamorphic-testing-the-database/) cockroach labs. i highly recommend reading before using this library.  the repository contains a few [test examples](https://github.com/cryptocode/marble/blob/main/src/example_tests.zig)  ## resources * [hillel wayne's blog post on metamorphic testing (highly recommended)](https://www.hillelwayne.com/post/metamorphic-testing/) * [test your machine learning algorithm with metamorphic testing](https://medium.com/trustableai/testing-ai-with-metamorphic-testing-61d690001f5c) * [original paper by t.y. chen et al](https://www.cse.ust.hk/~scc/publ/cs98-01-metamorphictesting.pdf) * [case study t.y. chen et al](http://grise.upm.es/rearviewmirror/conferencias/jiisic04/papers/25.pdf) * [metamorphic testing and beyond t.y. chen et al](https://www.cs.hku.hk/data/techreps/document/tr-2003-06.pdf) * [survey on metamorphic testing](http://www.cs.ecu.edu/reu/reufiles/read/metamorphictesting-16.pdf) * [performance metamorphic testing](http://www.lsi.us.es/~jtroya/publications/nier17_at_icse17.pdf) * [experiences from three fuzzer tools](https://johnwickerson.github.io/papers/dreamingup_met21.pdf) * [monarch, a similar library for rust](https://github.com/zmitchell/monarch/blob/master/src/runner.rs)  ## building  to build and run test examples:  ```bash zig build zig build test ```  ## importing the library add marble as a zig package in your build file, or simply import it directly after vendoring/adding a submodule:  ```zig const marble = @import('marble/main.zig'); ```  ## writing tests  a metamorphic zig test looks something like this:  ```zig const sinustest = struct {     const tolerance = std.math.epsilon(f64) * 20;      /// this test has a single value, but you could also design the test to take an     /// array as input. the transformations, check and execute functions would then     /// loop through them all. alternatively, the test can be run multiple times     /// with different inputs.     value: f64,      /// the mathematical property 'sin(x) = sin(π − x)' must hold     pub fn transformpi(self: *sinustest) void {         self.value = std.math.pi - self.value;     }      /// adding half the epsilon must still cause the relation to hold given the tolerance     pub fn transformepsilon(self: *sinustest) void {         self.value = self.value + std.math.epsilon(f64) / 2.0;     }      /// a metamorphic relation is a relation between outputs in different executions.     /// this relation must hold after every execution of transformation combinations.     pub fn check(_: *sinustest, original_output: f64, transformed_output: f64) bool {         return std.math.approxeqabs(f64, original_output, transformed_output, tolerance);     }      /// called initially to compute the baseline output, and after every transformation combination     pub fn execute(self: *sinustest) f64 {         return std.math.sin(self.value);     } };  test 'sinus' {     var i: f64 = 1;     while (i < 100) : (i += 1) {         var t = sinustest{ .value = i };         try std.testing.expect(try marble.run(sinustest, &t, .{}));     } } ```  you will get compile time errors if the requirements for a metamorphic test are not met.  in short, you must provide a `value` field, a `check` function, an `execute` function and one or more `transform...` functions.  ### writing transformations add one or more functions starting with `transform...`  marble will execute all combinations of the transformation functions. after every combination, `execute` is called followed by `check`.  transformations should change the `value` property - marble will remember what it was originally. the transformations must be such that `check` succeeds. that is, the relations between the inital output and the transformed output must still hold.  ### checking if relations still hold you must provide a `check` function to see if one or more relations hold, and return true if so. if false is returned, the test fails with a print-out of the current transformation-combination.  relation checks may be conditional; check out the tests for examples on how this works.  ### executing you must provide an `execute` function that computes a result based on the current value. the simplest form will simply return the current value, but you can do any arbitrary operation here. this function is called before any transformations to form a baseline. this baseline is passed as the first argument to `check`  ### optional before/after calls  before and after the test, and every combination, `before(...)` and `after(...)` is called if present. this is useful to reset state, initialize test cases, and perform clean-up.  ### what happens during a test run?  using the example above, the following pseudocode runs will be performed:  ``` baseline = execute()  // first combination transformpi() out = execute() check(baseline, out)  // second combination transformepsilon() out = execute() check(baseline, out)  // third combination transformpi() transformepsilon() out = execute() check(baseline, out) ```  ### configuring runs  the `run` function takes a `runconfiguration`:  ```zig /// if set to true, only run each transformation once separately skip_combinations: bool = false,  /// if true, print detailed information during the run verbose: bool = false, ```  ### error reporting  if a test fails, the current combination being executed is printed. for instance, the following tells us that the combination of `transformadditionalterm` and `transformcase` caused the metamorphic relation to fail:  ``` test [2/2] test 'query'... test case failed with transformation(s):   >> transformadditionalterm   >> transformcase ```  ### terminology  * source test case output: the output produced by `execute()` on the initial input. this is also known as the baseline. * derived test case output: the output produced by `execute()` after applying a specific combination of transformations. * metamorphic relation: a property that must hold when considering a source test case and a derived test case. ","lun-4/zigdig":"naive dns client library in zig # zigdig  naive dns client library in zig  help me decide if this api is good: https://github.com/lun-4/zigdig/issues/10  ## what does it do  - serialization and deserialization of dns packets as per rfc1035  - supports a subset of rdata (i do not have any plans to support 100% of dns, but srv/mx/txt/a/aaaa   are there, which most likely will be enough for your use cases)  - has helpers for reading `/etc/resolv.conf` (not that much, really)  ## what does it not do  - no edns0  - support all resolv.conf options  - can deserialize pointer labels, but does not serialize into pointers  - follow cname records, this provides only the basic    serialization/deserializtion  ## how do   - zig 0.12.0: https://ziglang.org  - have a `/etc/resolv.conf`  - tested on linux, should work on bsd i think  ``` git clone ... cd zigdig  zig build test zig build install --prefix ~/.local/ ```  and then  ```bash zigdig google.com a ```  or, for the host(1) equivalent  ```bash zigdig-tiny google.com ```  ## using the library  ### getaddresslist-style api  ```zig const dns = @import('dns');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer {         _ = gpa.deinit();     }     var allocator = gpa.alloator();      var addresses = try dns.helpers.getaddresslist('ziglang.org', allocator);     defer addresses.deinit();      for (addresses.addrs) |address| {         std.debug.print('we live in a society {}╲n', .{address});     } } ```  ### full api  ```zig const dns = @import('dns');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer {         _ = gpa.deinit();     }     var allocator = gpa.alloator();      var name_buffer: [128][]const u8 = undefined;     const name = try dns.name.fromstring('ziglang.org', &name_buffer);      var questions = [_]dns.question{         .{             .name = name,             .typ = .a,             .class = .in,         },     };      var packet = dns.packet{         .header = .{             .id = dns.helpers.randomheaderid(),             .is_response = false,             .wanted_recursion = true,             .question_length = 1,         },         .questions = &questions,         .answers = &[_]dns.resource{},         .nameservers = &[_]dns.resource{},         .additionals = &[_]dns.resource{},     };      // use helper function to connect to a resolver in the systems'     // resolv.conf      const conn = try dns.helpers.connecttosystemresolver();     defer conn.close();      try conn.sendpacket(packet);      // you can also do this to support any writer     // const written_bytes = try packet.writeto(some_fun_writer_goes_here);      const reply = try conn.receivepacket(allocator, 4096);     defer reply.deinit();      // you can also do this to support any reader     // const packet = try dns.packet.readfrom(some_fun_reader, allocator);     // defer packet.deinit();      const reply_packet = reply.packet;     logger.info('reply: {}', .{reply_packet});      try std.testing.expectequal(packet.header.id, reply_packet.header.id);     try std.testing.expect(reply_packet.header.is_response);      // asserts that there's one a resource in the answer!!! you should verify     // reply_packet.header.opcode to see if there's any errors      const resource = reply_packet.answers[0];     var resource_data = try dns.resourcedata.fromopaque(         reply_packet,         resource.typ,         resource.opaque_rdata,         allocator     );     defer resource_data.deinit(allocator);      // you now have an std.net.address to use to your hearts content     const ziglang_address = resource_data.a; }  ```  it is recommended to look at zigdig's source on `src/main.zig` to understand how things tick using the library, but it boils down to three things:  - packet generation and serialization  - sending/receiving (via a small shim on top of std.os.socket)  - packet deserialization ","leecannon/zig-libgit2":"Zig bindings to libgit2 # zig-libgit2  ## warning this project is not currently in a good state and is not 100% compatible with any of libgit2's releases.  work on this project stalled at step one in [todo](todo.md)  ---  zig bindings to [libgit2](https://github.com/libgit2/libgit2)  this is an in-progress zig binding to libgit2, unfortunately libgit2 doesn't full document all possible errors so every errorable function returns the full errorset.  there is currently no plan to port all the headers within 'include/git2/sys', if anyone requires any of that functionailty raise an issue.  ## files fully wrapped (others maybe partially complete)  - [x] annotated_commit.h - [x] apply.h - [x] attr.h - [x] blame.h - [x] blob.h - [x] branch.h - [x] buffer.h - [x] cert.h - [x] checkout.h - [x] cherrypick.h - [x] clone.h - [x] commit.h - [x] common.h - [x] config.h - [x] credential.h - [x] describe.h - [ ] diff.h - [x] errors.h - [x] filter.h - [x] global.h - [x] graph.h - [x] ignore.h - [x] index.h - [x] indexer.h - [x] mailmap.h - [ ] merge.h - [x] message.h - [x] notes.h - [x] object.h - [ ] odb.h - [x] oid.h - [x] oidarray.h - [x] pack.h - [x] patch.h - [x] pathspec.h - [x] proxy.h - [x] rebase.h - [x] refdb.h - [x] reflog.h - [ ] refs.h - [x] refspec.h - [x] remote.h - [x] repository.h - [x] reset.h - [x] revert.h - [x] revparse.h - [x] revwalk.h - [x] signature.h - [x] stash.h - [x] status.h - [x] strarray.h - [ ] submodule.h - [x] tag.h - [x] trace.h - [x] transaction.h - [x] tree.h - [x] worktree.h - [x] sys/alloc.h - [x] sys/credential.h - [x] sys/diff.h - [x] sys/hashsig.h - [x] sys/path.h - [x] sys/repository.h ","dweiller/zimalloc":"General purpose allocator for Zig # zimalloc  zimalloc is general purpose allocator for zig, inspired by [mimalloc](https://github.com/microsoft/mimalloc).  ## status  this project is under development and should currently be considered experimental/exploratory; there is no documentation and it has not been battle-tested. in particular there may be issues with multi-threaded workloads. contributions of any kind (prs, suggestions for improvements, resources or ideas related to benchmarking or testing) are welcome.  the allocator is significantly faster than `std.heap.generalpurposeallocator(.{})` but should not (yet) be expected to be competitive with other established general purpose allocators.  ## usage  to use the allocator in your own project you can use the zig package manager by putting this in your `build.zig` ```zig pub fn build(b: *std.build) void {     // -- snip --     const zimalloc = b.dependency('zimalloc').module('zimalloc'); // get the zimalloc module     // -- snip --     exe.addmodule(zimalloc); // add the zimalloc module as a dependency of exe     // -- snip -- } ``` and this to the dependencies section of your `build.zig.zon` ```zig     .zimalloc = .{         .url = 'https://github.com/dweiller/zimalloc/archive/[[commit_sha]].tar.gz'     }, ``` where `[[commit_sha]]` should be replaced with full sha of the desired revision. you can then import and initialise an instance of the allocator as follows: ```zig const zimalloc = @import('zimalloc'); pub fn main() !void {     var gpa = try zimalloc.allocator(.{}){};     defer gpa.deinit();      const allocator = gpa.allocator();     // -- snip -- } ```  ### shared library  there is a shared library that can be used for overriding standard libc allocation functions. it can be accessed from your `build.zig` like so: ```zig pub fn build(b: *std.build) void {     // -- snip --     const libzimalloc = b.dependency('zimalloc').artifact('zimalloc'); // get the zimalloc shared library     // -- snip --     exe.linklibrary(zimalloc); // link to libzimalloc     // -- snip -- } ```  if you just want to build the shared library and use it outside the zig build system, you can build it with the `libzimalloc` or `install` steps, for example: ```sh zig build libzimalloc -doptimize=releasesafe ```  ## notes    - the current implementation works on linux, with other systems untested.   - the main suite of tests currently used is `https://github.com/daanx/mimalloc-bench`     which are run using `ld_preload`. not all tests have been tried, but all those that have been tested     run successfully.   - no attempt has been made to make the allocator signal-safe. ","speed2exe/myzql":"MySQL and MariaDB  driver in native Zig # myzql - mysql and mariadb driver in native zig  ## status - beta  ## version compatibility | myzql       | zig                       | |-------------|---------------------------| | 0.0.9.1     | 0.12.0                    | | 0.13.2      | 0.13.0                    | | main        | 0.14.0-dev.1820+ea527f7a8 |  ## features - native zig code, no external dependencies - tcp protocol - prepared statement - structs from query result - data insertion - mysql datetime and time support  ## requirements - mysql/mariadb 5.7.5 and up  ## todos - config from url - connection pooling - tls support  ## add as dependency to your zig project - `build.zig` ```zig     //...     const myzql_dep = b.dependency('myzql', .{});     const myzql = myzql_dep.module('myzql');     exe.addmodule('myzql', myzql);     //... ```  - `build.zig.zon` ```zon     // ...     .dependencies = .{       .myzql = .{         // choose a tag according to 'version compatibility' table         .url = 'https://github.com/speed2exe/myzql/archive/refs/tags/0.13.2.tar.gz',         .hash = '1220582ea45580eec6b16aa93d2a9404467db8bc1d911806d367513aa40f3817f84c',       }     },     // ... ```  ## usage - project integration example: [usage](https://github.com/speed2exe/myzql-example)  ### connection ```zig const myzql = @import('myzql'); const conn = myzql.conn.conn;  pub fn main() !void {     // setting up client     var client = try conn.init(         allocator,         &.{             .username = 'some-user',   // default: 'root'             .password = 'password123', // default: ''             .database = 'customers',   // default: ''              // current default value.             // use std.net.getaddresslist if you need to look up ip based on hostname             .address =  std.net.address.initip4(.{ 127, 0, 0, 1 }, 3306),             // ...         },     );     defer client.deinit();      // connection and authentication     try client.ping(); } ```  ## querying ```zig  const okpacket = protocol.generic_response.okpacket;  pub fn main() !void {     // ...     // you can do a text query (text protocol) by using `query` method on `conn`     const result = try c.query('create database testdb');      // query results can have a few variant:     // - ok:   okpacket     => query is ok     // - err:  errorpacket  => error occurred     // in this example, res will either be `ok` or `err`.     // we are using the convenient method `expect` for simplified error handling.     // if the result variant does not match the kind of result you have specified,     // a message will be printed and you will get an error instead.     const ok: okpacket = try result.expect(.ok);      // alternatively, you can also handle results manually for more control.     // here, we do a switch statement to handle all possible variant or results.     switch (result.value) {         .ok => |ok| {},          // `aserror` is also another convenient method to print message and return as zig error.         // you may also choose to inspect individual fields for more control.         .err => |err| return err.aserror(),     } } ```  ## querying returning rows (text results) - if you want to have query results to be represented by custom created structs, this is not the section, scroll down to 'executing prepared statements returning results' instead. ```zig const myzql = @import('myzql'); const queryresult = myzql.result.queryresult; const resultset = myzql.result.resultset; const resultrow = myzql.result.resultrow; const textresultrow = myzql.result.textresultdata; const resultsetiter = myzql.result.resultsetiter; const tabletexts = myzql.result.tabletexts; const textelemiter = myzql.result.textelemiter;  pub fn main() !void {     const result = try c.queryrows('select * from customers.purchases');      // this is a query that returns rows, you have to collect the result.     // you can use `expect(.rows)` to try interpret query result as resultset(textresultrow)     const rows: resultset(textresultrow) = try query_res.expect(.rows);      // allocation free interators     const rows_iter: resultrowiter(textresultrow) = rows.iter();     { // option 1: iterate through every row and elem         while (try rows_iter.next()) |row| { // resultrow(textresultrow)             var elems_iter: textelemiter = row.iter();             while (elems_iter.next()) |elem| { // ?[] const u8                 std.debug.print('{?s} ', .{elem});             }         }     }     { // option 2: iterating over rows, collecting elements into []const ?[]const u8         while (try rows_iter.next()) |row| {             const text_elems: textelems = try row.textelems(allocator);             defer text_elems.deinit(allocator); // elems are valid until deinit is called             const elems: []const ?[]const u8 = text_elems.elems;             std.debug.print('elems: {any}╲n', .{elems});         }     }      // you can also use `collecttexts` method to collect all rows.     // under the hood, it does network call and allocations, until eof or error     // results are valid until `deinit` is called on tabletexts.     const rows: resultset(textresultrow) = try query_res.expect(.rows);     const table = try rows.tabletexts(allocator);     defer table.deinit(allocator); // table is valid until deinit is called     std.debug.print('table: {any}╲n', .{table.table}); }  ```  ### data insertion - let's assume that you have a table of this structure: ```sql create table test.person (     id int not null auto_increment primary key,     name varchar(255),     age int ) ```  ```zig const myzql = @import('myzql'); const queryresult = myzql.result.queryresult; const preparedstatement = myzql.result.preparedstatement; const okpacket = myzql.protocol.generic_response.okpacket;  pub fn main() void {     // in order to do a insertion, you would first need to do a prepared statement.     // allocation is required as we need to store metadata of parameters and return type     const prep_res = try c.prepare(allocator, 'insert into test.person (name, age) values (?, ?)');     defer prep_res.deinit(allocator);     const prep_stmt: preparedstatement = try prep_res.expect(.stmt);      // data to be inserted     const params = .{         .{ 'john', 42 },         .{ 'sam', 24 },     };     inline for (params) |param| {         const exe_res = try c.execute(&prep_stmt, param);         const ok: okpacket = try exe_res.expect(.ok); // expecting ok here because there's no rows returned         const last_insert_id: u64 = ok.last_insert_id;         std.debug.print('last_insert_id: {any}╲n', .{last_insert_id});     }      // currently only tuples are supported as an argument for insertion.     // there are plans to include named structs in the future. } ```  ### executing prepared statements returning results as structs ```zig const resultsetiter = myzql.result.resultsetiter; const queryresult = myzql.result.queryresult; const binaryresultrow = myzql.result.binaryresultrow; const tablestructs = myzql.result.tablestructs; const resultset = myzql.result.resultset;  fn main() !void {     const prep_res = try c.prepare(allocator, 'select name, age from test.person');     defer prep_res.deinit(allocator);     const prep_stmt: preparedstatement = try prep_res.expect(.stmt);      // this is the struct that represents the columns of a single row.     const person = struct {         name: []const u8,         age: u8,     };      // execute query and get an iterator from results     const res: queryresult(binaryresultrow) = try c.executerows(&prep_stmt, .{});     const rows: resultset(binaryresultrow) = try res.expect(.rows);     const iter: resultsetiter(binaryresultrow) = rows.iter();      { // iterating over rows, scanning into struct or creating struct         const query_res = try c.executerows(&prep_stmt, .{}); // no parameters because there's no ? in the query         const rows: resultset(binaryresultrow) = try query_res.expect(.rows);         const rows_iter = rows.iter();         while (try rows_iter.next()) |row| {             { // option 1: scanning into preallocated person                 var person: person = undefined;                 try row.scan(&person);                 person.greet();                 // important: if any field is a string, it will be valid until the next row is scanned                 // or next query. if your rows return have strings and you want to keep the data longer,                 // use the method below instead.             }             { // option 2: passing in allocator to create person                 const person_ptr = try row.structcreate(person, allocator);                  // important: please use binaryresultrow.structdestroy                 // to destroy the struct created by binaryresultrow.structcreate                 // if your struct contains strings.                 // person is valid until binaryresultrow.structdestroy is called.                 defer binaryresultrow.structdestroy(person_ptr, allocator);                 person_ptr.greet();             }         }     }      { // collect all rows into a table ([]const person)         const query_res = try c.executerows(&prep_stmt, .{}); // no parameters because there's no ? in the query         const rows: resultset(binaryresultrow) = try query_res.expect(.rows);         const rows_iter = rows.iter();         const person_structs = try rows_iter.tablestructs(person, allocator);         defer person_structs.deinit(allocator); // data is valid until deinit is called         std.debug.print('person_structs: {any}╲n', .{person_structs.struct_list.items});     } } ```  ### temporal types support (datetime, time) - example of using datetime and time mysql column types. - let's assume you already got this table set up: ```sql create table test.temporal_types_example (     event_time datetime(6) not null,     duration time(6) not null ) ```   ```zig  const datetime = myzql.temporal.datetime; const duration = myzql.temporal.duration;  fn main() !void {     { // insert         const prep_res = try c.prepare(allocator, 'insert into test.temporal_types_example values (?, ?)');         defer prep_res.deinit(allocator);         const prep_stmt: preparedstatement = try prep_res.expect(.stmt);          const my_time: datetime = .{             .year = 2023,             .month = 11,             .day = 30,             .hour = 6,             .minute = 50,             .second = 58,             .microsecond = 123456,         };         const my_duration: duration = .{             .days = 1,             .hours = 23,             .minutes = 59,             .seconds = 59,             .microseconds = 123456,         };         const params = .{.{ my_time, my_duration }};         inline for (params) |param| {             const exe_res = try c.execute(&prep_stmt, param);             _ = try exe_res.expect(.ok);         }     }      { // select         const datetimeduration = struct {             event_time: datetime,             duration: duration,         };         const prep_res = try c.prepare(allocator, 'select * from test.temporal_types_example');         defer prep_res.deinit(allocator);         const prep_stmt: preparedstatement = try prep_res.expect(.stmt);         const res = try c.executerows(&prep_stmt, .{});         const rows: resultset(binaryresultrow) = try res.expect(.rows);         const rows_iter = rows.iter();          const structs = try rows_iter.tablestructs(datetimeduration, allocator);         defer structs.deinit(allocator);         std.debug.print('structs: {any}╲n', .{structs.struct_list.items}); // structs.rows: []const datetimeduration         // do something with structs     } } ```  ## unit tests - `zig test src/myzql.zig`  ## integration tests - start up mysql/mariadb in docker: ```bash # mysql docker run --name some-mysql --env mysql_root_password=password -p 3306:3306 -d mysql ```bash # mariadb docker run --name some-mariadb --env mariadb_root_password=password -p 3306:3306 -d mariadb ``` - run all the test: in root directory of project: ```bash zig build -dtest-filer='...' integration_test ```  ## philosophy ### correctness focused on correct representation of server client protocol. ### low-level and high-level apis low-level apis should contain all functionality you need. high-level apis are built on top of low-level ones for convenience and developer ergonomics.  ### binary column types support - mysql colums types to zig values ``` - null -> ?t - int -> u64, u32, u16, u8 - float -> f32, f64 - string -> []u8, []const u8, enum ``` ","andrewrk/mime":"zig package for mapping extensions to mime types  # zig module for mime types  ## synopsis  ```zig const std = @import('std'); const mime = @import('mime');  test 'html smoke test' {     const mime_type = mime.extension_map.get('.html').?;     try std.testing.expectequalstrings('text/html', @tagname(mime_type)); }  test 'bogus extension' {     try std.testing.expect(mime.extension_map.get('.sillybogo') == null); } ``` ","kassane/llvm-zig":"LLVM bindings written in Zig # llvm kaleidoscope written on zig  the purpose of this repository is to learn about the [`llvm`][llvm] compiler infrastructure and practice some [`ziglang`][zig].  to reach the goals set, we follow the official llvm tutorial [`kaleidoscope: implementing a language with llvm`][llvm-tutorial]. this tutorial is written in `c++` and structured in multiple chapters, we will try to follow along and implement every chapter in zig.  ### requirement  - [zig v0.13.0](https://ziglang.org/download) or higher.   ## references  | rust | go | c | | --- | --- | --- | |[llvm-sys] / [inkwell] | [go-llvm] | llvm-c | | [llvm-kaleidoscope-rs] | [llvm-tuto-kaleidoscope-golang] | [llvm-c-kaleidoscope] |  ## license  this project is licensed under the [mit](license) license.  [llvm]: https://llvm.org [llvm-sys]: https://gitlab.com/taricorp/llvm-sys.rs [go-llvm]: https://github.com/tinygo-org/go-llvm [inkwell]: https://github.com/thedan64/inkwell [llvm-kaleidoscope-rs]: https://github.com/johannst/llvm-kaleidoscope-rs [llvm-c-kaleidoscope]: https://github.com/benbjohnson/llvm-c-kaleidoscope [llvm-tuto-kaleidoscope-golang]: https://github.com/vhiribarren/llvm-tuto-kaleidoscope-golang [llvm-tutorial]: https://llvm.org/docs/tutorial/myfirstlanguagefrontend/index.html [llvm-ch1]: https://llvm.org/docs/tutorial/myfirstlanguagefrontend/langimpl01.html [llvm-ch2]: https://llvm.org/docs/tutorial/myfirstlanguagefrontend/langimpl02.html [llvm-ch3]: https://llvm.org/docs/tutorial/myfirstlanguagefrontend/langimpl03.html [llvm-ch4]: https://llvm.org/docs/tutorial/myfirstlanguagefrontend/langimpl04.html [llvm-ch5]: https://llvm.org/docs/tutorial/myfirstlanguagefrontend/langimpl05.html [zig]: https://ziglang.org","ikskuh/zig-bearssl":"A BearSSL binding for Zig # zig-bearssl a [bearssl](https://bearssl.org/) binding for zig, providing primitive (and probably unsafe, i'm no ssl expert) bindings for ssl and tls connections to generic zig code. ","ikskuh/ZTT":"Precompiled Zig text template engine # zig text templates  this project implements a template generator for zig that works similar to how php works.  it allows you to mix plain text and zig code to generate automatic text files.  consider the following example:  ```zig <# // this tag let's you import global statements available to the `render()` function const std = @import('std'); #>  # zig text template  the following syntax inserts `ctx.intro` formattet with the format string `{s:-^10}`.  <= ctx.intro : {s:-^10} =>  the list has the following <= ctx.list.len => items:  <? for(ctx.list) |item| { ?>     - <= item.name : {s} => *(weight <= item.weight : {d:.1} => kg)* <? } ?>  you can pass arbitrary format strings and expressions to the direct formatter: - <= 'hello:world' : {s} => - <= (10 + 20 * 30) => - <= std.math.log10(10 + 20 * 30) =>  note that for using a `:` inside the format expression itself, use braces to encapsulate the items.  ```  this was inspired by both [php](https://www.php.net/manual/en/intro-whatis.php) and [microsofts t4](https://docs.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates?view=vs-2019) engine.  ## usage  each generated template will yield a `zig` file which exports a function called `render`: ```zig pub fn render(stream: anytype, ctx: anytype) !void {   … } ```  this function must be invoked with a `std.io.writer` for the first argument and *any* value for the second argument. `ctx` is meant to pass information from the caller to the template engine to allow dynamic content generation.  to generate templates in your build script, just run the executable with `filesource`s.  ```zig < to be done > ```  for a full example, see `build.zig` and the `example` folder.  ## syntax  the syntax knows these constructs:  - `<? … ?>` will paste everything between the start and end sigil verbatim into the `render` function code. this can be used to generate loops, conditions, ... - `<= expr => will print a default-formatted (`{}`) expression into the stream. - `<= expr : format =>` will behave similar to the default-formatted version, but you can specify your own format string in `format`. this accepts any format string that `std.fmt.format` accepts for the type of `expr`. - `<# … #>` will paste everything between the start and end sigil verbatim into the global scope of the zig code. this can be used to create custom functions or exports.  note that both `<# … #>` and `<? … ?>` will swallow a directly following line break, while `<= … =>` will not. this makes writing templates more intuitive.","Hejsil/zig-midi":"This repository has no description. 404: not found","zon-dev/zinc":"Zinc is a web framework written in pure Zig with a focus on high performance, usability, security, and extensibility. # zinc  ----  zinc is a framework written in pure zig with a focus on high performance, usability, security, and extensibility.  **:construction: it's still under development. built on std.net. not the fastest zig framework in the universe, but fast enough.**  **in the works**:   * remove std.http.server * blocking mode auto change to kqueue for macos and bsd * non-blocking mode auto change to io_uring for linux  a basic example: ```zig const zinc = @import('zinc');  pub fn main() !void {     var z = try zinc.init(.{ .port = 8080 });      var router = z.getrouter();     try router.get('/', helloworld);      try z.run(); }  fn helloworld(ctx: *zinc.context) anyerror!void {     try ctx.text('hello world!', .{}); } ```  ### some features are: - **fast** - **custom allocator** - **multithreading** - **middleware** - **routes grouping** - **rendering built-in** - **extensible** - **suite of unit tests** - **usability**   ### documentation see more at https://zinc.zon.dev/  #### quick start learn and practice with the zinc [quick start](https://zinc.zon.dev/src/quickstart.html), which includes api examples and builds tag.  #### examples a number of examples demonstrating various use cases of zinc in the [zinc-examples](https://github.com/zon-dev/zinc-examples) repository.","ziglibs/zig-lv2":"Zig-intuitive bindings for LV2. # zig-lv2    a toolkit for lv2 plugin authors written in zig.    **warning: here be dragons; tons of lv2 features aren't implemented and this isn't ready for production at all.**    ## installing  ```bash  git clone --recurse-submodules https://github.com/ziglibs/zig-lv2  ```    ## getting started  check out the example in `examples` which contains both sample zig code as well as its corresponding turtle manifest.  ","GoNZooo/zig-win32":"Bindings for win32, with and without WIN32_LEAN_AND_MEAN # zig-win32  ## archived  i would suggest using [this library](https://github.com/marlersoft/zigwin32) instead. if there is some reason you cannot, feel free to reach out and i'll unarchive this so people can continue to work on it if they want.  ## linking  you will need to add something like the following to your `build.zig` depending on what you end up using:  if you're using the `win32.c` module, most functions are annotated with their library information, so you don't need to link anything, but at the time of writing the `lean_and_mean` module is not annotated. with that in mind, you may have to add build instructions like the following, depending on which functions you use:  ```zig const exe = b.addexecutable('executable-name', 'src/main.zig'); exe.addpackagepath('win32', './dependencies/zig-win32/src/main.zig'); exe.linksystemlibrary('c'); exe.linksystemlibrary('gdi32'); exe.linksystemlibrary('user32'); exe.linksystemlibrary('kernel32'); ```  ## usage in files  a simple import will do it, access the sub-namespaces with `c` and `lean_and_mean`:  ```zig const win32 = @import('win32'); _ = win32.c.messageboxa(...); ```  or import one of the sub-namespaces directly:  ```zig const win32 = @import('win32').lean_and_mean; _ = win32.messageboxa(...); ```  ## macros not available in the ffi files  `makeintresource{a,w}` is not available in the generated files, but is available in the top namespace:  ```zig const win32 = @import('win32'); const resource: windows.lpstr = win32.makeintresourcea(32512); ``` ","zigster64/zts":"Zig Templates made Simple # zts  ## other zig template management tools to check out  - https://github.com/jetzig-framework/zmpl - https://github.com/batiati/mustache-zig - https://github.com/haze/etch  also:  - https://github.com/kristoff-it/ziggy ... static site generator that has some interesting templating possibilities  # zig templates made simple (zts)  ![zts](https://github.com/zigster64/zts/blob/main/docs/zts.jpg?raw=true)  zts is a minimalist zig module that helps you use text templates in a way that is simple, maintainable, and efficient.  simple: - uses zig like field tags in your template - uses zig `fmt.print` for formatting data  - no funky new templating syntax, no dsl, no new formatting conventions to learn - outputs to zig `writer` interface. use it in web server apps !  maintainable: - control of the template logic is done in your zig code, not delegated to the template engine - data passed through the template must be explicitly defined - there is no magic expansion of data structs that works fine today, and breaks tomorrow as your data model evolves - mismatches between your code, your data, and the template are caught at compile time, not runtime  efficient: - all template parsing is performed at comptime, no runtime overhead - minimal codebase - there is just _less_ going on compared to full-featured templating engines  lets have a look ...   ## zts - very basic example  lets say you have a template file `foobar.txt` that looks like this :  ``` .foo i prefer daytime .bar i like the nighttime ```  note the sections `.foo` and `.bar`.  zts uses a 'zig like' field syntax for defining the section breaks in the text.   then in your zig code, just embed that file, and then use the `zts.s(template, section_name)` function to return the appropriate section out of the data.  ```zig const zts = @import('zts');  const out = std.io.getstdout().writer();  const tmpl = @embedfile('foobar.txt'); try out.print('foo says - {s}╲n', zts.s(tmpl, 'foo')); try out.print('bar says - {s}╲n', zts.s(tmpl, 'bar'));  ```  produces the output  ``` foo says - i prefer daytime  bar says - i like the nighttime  ```  thats really all there is to it. its basically splitting the input into sections delimited by named tags in the input text.  ## the contents of data sections are comptime known  the data returned from `s(template, section_name)` is comptime known ... which means that it can in turn be passed to zig standard print functions  as a formatting string.  ``` .foo i like {s} .bar i prefer {s} ```  ```zig  const tmpl = @embedfile('foobar.txt');  try out.print(zts.s(tmpl, 'foo'), .{'daytime'}); try out.print(zts.s(tmpl, 'bar'), .{'nighttime'});  ```  ## zts print helper functions  use of the `s(tmpl, section_name)` function is provided as a low-level utility.  putting `zts.s(tmpl, section_name)` everywhere is a bit verbose, and gets a bit messy very quickly.   zts provides helper functions that make it easier to print.  `zts.print(tmpl, section_name, args, writer)` works like `print()` in zig.  `zts.write(tmpl, section_name, writer)` works like `write()` in zig.   ``` .foo i like {s} .bar i prefer {s} ```  ```zig  const tmpl = @embedfile('foobar.txt');  try zts.print(tmpl, 'foo', .{'daytime'}, out); try zts.print(tmpl, 'bar', .{'nighttime'}, out);  ```  because everything is happening at comptime, if your template file and your zig code get out of sync due to ongoing changes, nothing to fear ... zig will pick that up at compile time, and throw an error about missing sections in your templates, as  well as the standard compile errors about parameters not matching the expected fields in the template.  for example, if you add this to the code above :  ```zig try zts.print(tmpl, 'other', .{}, out); ```  this will throw a compile error saying that there is no section labelled `other` in the template.  if the template gets modified - say change the label `.foo` to `.fooz` in the text file ... then that will also cause a compile error in the zig code, saying that 'foo' doesnt exist in the template anymore.  if the template changes again, say ... change the `.foo` contents to `i like {d}` ... then this will also cause a compile error in the zig code, saying that the string parameter 'daytime' does not match format '{d}' in the template.  there is no great magic here, its just the power of zig comptime, as it is actively parsing the text templates at compile time, and using the built in zig `print` formatting which also evaluates at compile time.  ## zts runtime / non-comptime helper functions  if you want to pass data through template segments using the built in zig `print` functions on the writer, then everything must be comptime.  there are no exceptions to this, its just the way that zig `print` works.  if your template segments do not have print formatting, do not need argument processing, and are just blocks of text, then you can use the `write` variant helper functions that zts provides.  ```zig try zts.writeheader(template, out); try zts.write(template, section, out); ```  when using `write(template, section, out)` ... if the section is null, or cannot be found in the data, then write() will print nothing.   there is also a `lookup()` function that takes runtime / dynamic labels, and returns a non-comptime string of the section ... or `null` if not found. its a runtime version of the `s()` function, that can be used with dynamic labels.  you can only use the return data from `lookup()` in a non-comptime context though, such as using the data in a `writeall()` statement.   example: ```zig  // you can do some fancy dynamic processing here const dynamic_template_section = zts.lookup(tmpl, os.getenv('planet').?); if (dynamic_template_section == null) {    std.debug.print('sorry, cannot find a section for the planet you are on');    return; } try out.writeall(dynamic_template_section);  // or you can do this using the write helper functions // note that if there is no planet env, then nothing is printed try zts.write(tmpl, os.getenv('planet'), out);    // but you cant do this, because print needs comptime values only, and lookup is a runtime variant try out.print(dynamic_template_section, .{customer_details});  // <<-- compile error ! dynamic_template_section is not comptime known  // and you cant do this either, because s() demands comptime params too const printable_dynamic_section = zts.s(tmpl, os.getenv('planet').?);  // <<-- compile error !  unable to resovle comptime value ```  comptime restrictions can be a pain.  zts `lookup()`, `writeheader()`, and `write()` might be able to help you out if you need to do some dynamic processing .. or it might not,  depending on how deep a hole of meta programming you are in.   ## a more common html templating example  lets define a typical html file, with template segments defined, and add some places where we can print structured data that we pass through the template.  the html template looks like this :  ```html <div>   <h1>financial statement page</h1>      .customer_details     <h1>customer</h1>     <p>name:           {[name]:s}</p>     <p>address:        {[address]:s}</p>     <p>credit limit: $ {[credit]:.2}</p>      .invoice_table     <h2>invoices</h2>     <table>         <tr>             <th>date</th>             <th>details</th>             <th>amount</th>         </tr>          .invoice_row         <tr>             <td>  {[date]:s}</td>             <td>  {[details]:s}</td>             <td>$ {[amount]:.2}</td>         </tr>          .invoice_table_total         <tr>             <td></td>             <td>total due:</td>             <td>$ {[total]:.2}</td>         </tr>      </table> </div>  ```  and the zig code to print data through that template looks like this : ```zig fn printcustomerdetails(out: anytype, cust: *customerdetails) !void {    var tmpl = @embedfile('html/financial_statement.html');        try zts.writeheader(tmpl, out);    try zts.print(tmpl, 'customer_details', .{         .name = cust.name,         .address = cust.address,         .credit = cust.credit,    });     try zts.print(tmpl, 'invoice_table', .{}, out);     for (cust.invoices) |invoice|  {       try zts.print(tmpl, 'invoice_row', .{           .date = invoice.date,           .details = invoice.details,           .amount = invoice.amount,         },       out);       total += invoice.amount;     }      try zts.print(tmpl, 'invoice_total', .{.total = total}, out); } ```  so thats all pretty explicit.  note that we cant do this :  ```zig    var tmpl = @embedfile('html/financial_statement.html');        try zts.writeheader(tmpl, out);        // explicit parameters defined here    // try zts.print(tmpl, 'customer_details', .{         // .name = cust.name,         // .address = cust.address,         // .credit = cust.credit,    // });     // this alternative will be a compile error instead    try zts.print(tmpl, 'customer_details', cust); ```  because the struct `customerdetails` is not an exact match for the parameters that the 'customer_details' section of the template expects, this will be a compile error.  yes, its more verbose, but its explicit in the zen of zig, and easier to maintain.  by looking at this code only, you can see what parameters the template expects (without reading the template), and you can see what fields of the customerdetails struct are applied to which template field.  you cant accidentally miss anything, and any future changes to customerdetails struct will not  create any new regressions against the template.   ## zts templates rely on your zig code to drive the logic  you will notice that the pattern used here is that the zig code is completely driving the flow of logic, and the 'template' only serves  to provide a repository of static strings that can be looked up, and delivered at comptime.  as far as 'template engines' go - zts is just like a fancy table of strings that you have to drive yourself manually.  this is an inversion of how templating libraries usually work ... where your code passes data to the template engine, which then drives the flow of the logic to produce the output.  the traditional approach tends to get messy when you want to inject additional logic into the template generation, over and above simple range statements.  other approaches, such as jsx, employ a variety of character codes enabling you to jump in and out of javascript inside the template.  or go templates, which have their own go-like dsl, and the ability to pass a map of function pointers that the template can callback into.  see https://pkg.go.dev/html/template for details of go html templating.  there is also the mustache standard, which offers an array iterator, and lambdas, and rendering of partials amongst other things.  these are all great of course, but they also delegate the control away from your program, and into a dsl like environment that inevitably employs some magic to get the job done.  in some instances, it may be more powerful (as well as simpler), to just drive all the logic directly and imperatively from your own code instead. in my subjective opinion, this direct and imperative approach is more in keeping with the zen of zig. ymmv.  if you want the traditional approach, whilst using zig, have a look at   https://github.com/batiati/mustache-zig  with examples of mustache-zig used in the zap (web server) project here :  https://github.com/zigzap/zap/blob/master/examples/mustache/mustache.zig  there is also etch : https://github.com/haze/etch  there are some examples of zts used with the http.zig library here :  https://github.com/zigster64/zig-zag-zoe/blob/master/src/game.zig#l416  ... in this case, its rendering a game board for a multi-player web game  ## selectively print sections from the template  in the traditional template-driven approach, this is normally done by adding syntax to the template such as ``` hey there {{customer_title}}   you owe us some money !    here is the proof ...  {{if language .eq 'de'}}   geschäftsbedingungen   zahlung 7 tagen netto {{elseif language .eq 'es'}}   términos y condiciones   pago neto 7 días {{elseif }}   .... etc etc {{else}}   terms and conditons   payment nett 7 days {{endif}} ```  but we dont need to add any control flow inside the template in some non-zig templating language ... we can just do it from the zig code because the whole 'template' is nothing more than a map of section tags to blocks of text.  you dont even need to print them all !  example: ``` hey there {s}   you owe us some money !    here is the proof ...  .terms_en   terms and conditons   payment nett 7 days .terms_de   geschäftsbedingungen   zahlung 7 tagen netto .terms_es   términos y condiciones   pago neto 7 días .terms_pt   termos e condições   pagamento líquido em 7 dias .terms_fr   termes et conditions   paiement net 7 jours .terms_hi   नियम और शर्तें   भुगतान नेट 7 दिन .terms_jp   利用規約   次の7日でお支払い ```  looks a bit cleaner, easier to read, and more ziggy than the previous example.  code to process this :  ```zig  // dynamically create the label at runtime, based on the lang env var // restriction here is that because the section label is dynamic, it cant be comptime // ... and therefore cant be used with the print variants  try terms_section = std.fmt.allocprint(allocator, 'terms_{s}', std.os.getenv('lang').?[0..2]); defer allocator.free(section);  try zts.printheader(tmpl, 'dear customer', out); try zts.write(tmpl, terms_section, out); } ```  (see example in test cases inside the code in zts.zig)  or we can even mix up the order of sections in the output depending on some variable :  ```zig if (is_northern_hemisphere) try zts.printheader(tmpl, 'dear customer', out); try zts.write(tmpl, terms_section, out); if (is_southern_hemisphere) try zts.printheader(tmpl, 'mate', out); ```  so for our us and eu customers, they get the notice header followed by the terms and conditions.  for our au, nz, and sth american customers, because they are upside down, they get the terms and conditions first followed by the notice header.  doing the same thing using a traditional template flow would be possible, but likely to be quite ugly, or involve duplicating sections of  the template in the original data, wrapped in if statements.   so again, its not for everyone, but there are definitely some cases where its just simpler and more powerful to keep the control inside your zig code rather than a templating engine.   ## content that occurs before the first directive  all content that occurs before the first directive is considered to be the 'header' of the document.  example: ```html <div>    everything in here is leading content     .details    <div>... some details in here</div>    .end_details     ... more content </div> ```  you can use the `printheader(template, args, out)` to access and print out this header segment. ```zig const tmpl = @embedfile('foobar.txt'); try zts.printheader(tmpl, .{}, out);  // or the write variant with no extra parameters  try zts.writeheader(tmpl, out); ```  you can access this header section using the `s()` function, and passing `null` as the section name.  ```zig const tmpl = @embedfile('foobar.txt'); const header_content = zts.s(tmpl, null);  // or use lookup for the runtime variant const header_content = zts.lookp(tmpl, null);  ```  # section declaration syntax  in the template examples above, sections in the template are simply denoted by a line that has a `.directive` and nothing else.  the syntax for a `.directive` looks a lot like a zig field declaration  syntactically, the `.directive` in the template must obey these rules :  - can start with any amount of leading whitespace - begins with a `.` character - contains just the directive word with no whitespace, and no templated content - directive name cannot contain special characters [] {} - : ╲t - is a complete line, terminated by a `╲n`   any lines that do not obey all of the above rules are considered as content, and not a directive.  example: ``` things i need to buy this week;     - milk     - eggs     - potatoes .car_stuff    - indicator fluid    - parking meter detector .computer_stuff     - more ram     - more disk     - more compilers .notes    some general notes about things     .that need to be purchased    by the end of the week ```  so that gives us the following sections: - header (everything from the start up to car_stuff) - car_stuff - computer_stuff - notes  the line in notes beginning with `.that` is not seen as a section, rather its part of the notes content  # future addition  as of version 0.12.x of the compiler, zig comptime can handle getting substrings out of comptime string inputs, but it cant handle returning these slices as comptime values.  its a bit more complicated than it looks - bascially, comptime strings do not have a usable address until very late  in the compilation pipeline. this should be addressed in future releases of zig.  when we get there, zts will get these shiny new functions :  ``` --- foobar.txt --- .foo i like daytime {s} .bar i prefer nighttime {s}  ```  ```zig  const mytemplate = zts.template('templates/foobar.txt');  // mytemplate is a comptime generated type declaration that is equivalent to this :  const mytemplate = struct {   foo: []const u8 = 'i like daytime {s}',   bar: []const u8 = 'i prefer nighttime {s}', }; ```  which you can use in your code like this : ``` // note the {} to create an instance of the dynamic type  const foobar = zts.template('templates/foobar.txt'){};  zts.print(foobar.foo, ',yes i do !'); zts.print(foobar.bar, 'because its quieter'); ```  to produce the output :  ``` i like daytime, yes i do ! i prefer nighttime because its quieter ``` ","tr1ckydev/zoop":"A benchmarking library for zig. ![](res/output.png)  # zoop  a benchmarking library for zig.  - uses built in monotonic, high performance timer. - warms up to remove function call overhead time. - supports lifecycle hooks like *beforeall*, *aftereach*, etc. - can export raw benchmark data to json. - vibrant terminal output with easy to read data. - highly customizable.    ## installation  > zig master version is required to use zoop.  to install zoop in your own project,  1. add the dependency to the `build.zig.zon` of your project.     ```zig    .dependencies = .{        .zoop = .{            .url = 'https://github.com/tr1ckydev/zoop/archive/0ce2e985206e28fe13ed3c6dcb6b88650688238e.tar.gz',            .hash = '1220bad2ffae51552957e6255289dd452ee1a5e687d9f4c8c9427008edb0a802d874',        },    },    ```  2. add the dependency and module to your `build.zig`.     ```zig    const zoop_dep = b.dependency('zoop', .{});    const zoop_mod = zoop_dep.module('zoop');    exe.addmodule('zoop', zoop_mod);    ```  3. import it inside your project.     ```zig    const benchmark = @import('zoop').benchmark;    ```  or, if you just want to try out the benchmark from the above image, clone this repository and run `zig build run`.    ## documentation  > *callbackfn* refers to the type `*const fn () anyerror!void`.  - ### benchmark.init(allocator, config)    create a new benchmark instance with the provided `config` options. (provide `.{}` to use the default configuration.)    ```zig   var bench = benchmark.init(allocator, .{});   ```    - `allocator`*(allocator)*: the allocator to use inside the benchmark.   - `config`*(struct)*: configuration for the benchmark.     - `show_cpu_name`*(bool)*: if true, shows the name of host device cpu. (default is true)     - `show_zig_version`*(bool)*: if true, shows the version of zig currently used to run the benchmark. (default is true)     - `show_summary`*(bool)*: if true, shows the summary after the entire benchmark is finished, i.e. the fastest test and comparison with other tests. (default is true)     - `show_summary_comparison`*(bool)*: if true, shows the comparison of the fastest test with the other tests else summary only displays the fastest test. (default is true)     - `show_output`*(bool)*: if false, no output is printed to stdout. (default is true)     - `enable_warmup`*(bool)*: if true, measures a [noop](https://en.wikipedia.org/wiki/nop_(code)#javascript) function to calculate function call overhead which will be subtracted from results for more accurate data. (default is true)     - `iterations`*(u16)*: the maximum number of iterations to perform if the budget expires. (default is 10)     - `budget`*(u64)*: the maximum time (in nanoseconds) allotted to measure if the maximum iterations expire. (default is 2 secs)     - `hooks`*(struct)*: hooks to execute during the benchmark lifecycle. (defaults are noop)       - `beforeall`*(callbackfn)*: runs once before starting the benchmark.       - `afterall`*(callbackfn)*: runs once after finishing the benchmark.       - `beforeeach`*(callbackfn)*: runs before measuring each test.       - `aftereach`*(callbackfn)*: runs after measuring each test.     - `export_json`*(?[]const u8)*: exports the raw benchmark data in nanoseconds to the provided json file path. (default is null)  - ### benchmark.deinit()    release all allocated memory.    ```zig   defer bench.deinit();   ```  - ### benchmark.add(name: `[]const u8`, function: `callbackfn`)    add a function to the test suite.    ```zig   try bench.add('my function', myfunction);   // ...   // ...   fn myfunction() !void {       // some code here to be measured   }   ```  - ### benchmark.run()    after adding all the tests, start the benchmark. (after finishing, results are sorted from fastest to slowest.)    ```zig   try bench.run();   ```    some of the internal functions are exposed for user's convenience.  - ### getcpuname(allocator)    returns the name of the host device cpu, such as `12th gen intel(r) core(tm) i7-12700h`, `apple m1 max`, etc.  - ### fmtintu32(u32_int)    returns a formatter which can convert u32 integers to short forms like 26.312k, 2.906m.    if you have any questions, feel free to join the discord server [here](https://discord.com/invite/tfba2z8mbq).    ## credits  zoop is inspired from [hyperfine](https://github.com/sharkdp/hyperfine) and [mitata](https://github.com/evanwashere/mitata).    ## license  this repository uses mit license. see [license](https://github.com/tr1ckydev/zoop/blob/main/license) for full license text. ","zigcc/zig-msgpack":"zig messagpack implementation / msgpack.org[zig]  # messagepack for zig this is an implementation of [messagepack](https://msgpack.org/index.html) for [zig](https://ziglang.org/).  an article introducing it: [zig msgpack](https://nvimer.org/blog/zig-msgpack/)  ## features  - supports all messagepack types(except timestamp) - efficient encoding and decoding - simple and easy-to-use api  ## note  the current protocol implementation has been completed, but it has not been fully tested. only limited unit testing has been conducted, which does not cover everything.  ## getting started  ### `0.11`  1. add to `build.zig.zon`  ```zig .@'zig-msgpack' = .{         // it is recommended to replace the following branch with commit id         .url = 'https://github.com/zigcc/zig-msgpack/archive/{commit or branch}.tar.gz',         .hash = <hash value>,     }, ```  2. config `build.zig`  ```zig const msgpack = b.dependency('zig-msgpack', .{     .target = target,     .optimize = optimize, });  // add module exe.addmodule('msgpack', msgpack.module('msgpack')); ```  ### `0.12` ╲ `0.13`  ╲ `nightly`  1. add to `build.zig.zon`  ```sh zig fetch --save https://github.com/zigcc/zig-msgpack/archive/{commit or branch}.tar.gz # of course, you can also use git+https to fetch this package! ```  2. config `build.zig`  ```zig // to standardize development, maybe you should use `lazydependency()` instead of `dependency()` const msgpack = b.dependency('zig-msgpack', .{     .target = target,     .optimize = optimize, });  // add module exe.root_module.addimport('msgpack', msgpack.module('msgpack')); ```  ## related projects  - [znvim](https://github.com/jinzhongjia/znvim) ","travisstaloch/flatbufferz":"a flatbuffers codegen library in zig :warning: this project is in its early early stages. beware of bugs and missing features. :warning:  # about  generate zig code from flatbuffer schema files which can de/serialize flatbuffer messages. depends on packaged flatc to parse .fbs files.  ci tested weekly with latest zig version.  this project depends on packaged `flatc` compiler @v23.3.3, built with zig using [a fork of google/flatbuffers](https://github.com/travisstaloch/flatbuffers).  # usage  ## fetch to generate code from a flatbuffers file in your build.zig:  ```console $ zig fetch --save git+https://github.com/travisstaloch/flatbufferz ```  ## gen step ```zig // build.zig const std = @import('std');  pub fn build(b: *std.build) !void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});     const exe = b.addexecutable(.{         .name = 'my-app',         .root_source_file = b.path('src/main.zig'),         .target = target,         .optimize = optimize,     });     const fbz_dep = b.dependency('flatbufferz', .{         .target = target,         .optimize = optimize,     });     const gen_step = try @import('flatbufferz').genstep.create(         b,         fbz_dep.artifact('flatc-zig'),         &.{'src/myschema.fbs'},         &.{},         'flatc-zig',     );     exe.root_module.addimport('generated', gen_step.module);     exe.root_module.addimport('flatbufferz', fbz_dep.module('flatbufferz')); }  ```   ## manual generation  run packaged flatc ```console zig build flatc -- <flatc args> ```  ### compile from .fbs files use `flatc-zig` to generate zig files from schema (.fbs) files: ```console zig-out/bin/flatc-zig -o gen -i examples/includes examples/test.fbs ```  ### compile from .bfbs files optionally use packaged `flatc` to generate a binary schema (.bfbs) from a schema (.fbs) files: ```console zig build flatc -- -b --schema --bfbs-comments --bfbs-builtins --bfbs-gen-embed -i examples/includes -o gen/examples examples/test.fbs ``` use `flatc-zig` to generate zig files from binary schema (.bfbs) files: ``` zig-out/bin/flatc-zig -o gen gen/examples/test.bfbs ```  ### use compiled zig files either of these create the following in gen/ ```console $ find gen/ -name '*.fb.zig' gen/race.fb.zig gen/people/x.fb.zig gen/people/foo.fb.zig gen/people/person.fb.zig ```  you can now import these files into your zig application as in [gen-step](#gen-step).  the compiled .fb.zig files depend on the same 'flatbufferz' module.  ```zig // build.zig const flatbufferz_dep = b.dependency('flatbufferz', .{     .target = target,     .optimize = optimize, }); exe.root_module.addimport('generated', b.createmodule(.{     .root_source_file = b.path('src/my_generated.fb.zig'),     .imports = &.{.{ .name = 'flatbufferz', .module = flatbufferz_dep.module('flatbufferz') }}, })); ```   # tools convert .bfbs to .fbs. ```console zig-out/bin/flatc-zig gen/test.bfbs --bfbs-to-fbs ``` :warning: warning: --bfbs-to-fbs doesn't produce valid .fbs files. in its current state, it is more of a binary schema debugging tool. ","sbancuz/OpenMP-zig":"An implementation of the OpenMP directives for Zig # openmp-zig  this wrapper implements (almost all) the openmp directives up-to version 3.1 and some newer stuff. all of this is (mostly, see below) without any allocation from the zig part.  this is implemented using the `libomp' library of llvm. (gomp support is not planned) **disclaimer** this project is not affiliated with llvm in any capacity.  ```zig const std = @import('std'); const omp = @import('omp');  fn main() void {     omp.parallel(.{})         .run(.{}, struct {         fn f() void {             std.debug.print('hello world {}!', .{omp.get_thread_num()});         }     }.f); } ```  ## build  ```sh zig fetch --save git+https://github.com/sbancuz/openmp-zig ```  ```zig // build.zig const openmp_zig_dep = b.dependency('openmp-zig', .{       .target = target,       .optimize = optimize, }); exe.root_module.addimport('omp', openmp_zig_dep.module('omp')); ```  ## features - [x] `#pragma omp parallel` - [x] `all reductions` - [x] `#pragma omp for` - [x] `#pragma omp sections` - [x] `#pragma omp single` - [x] `#pragma omp master/masked` - [x] `#pragma omp critical` - [x] `#pragma omp barrier` - [x] `#pragma omp task` - [ ] `#pragma omp atomic` not possible to implement - [ ] `#pragma omp simd` not possible to implement  to see some other examples of the library check the tests folder.  ## extensions  ```zig fn test_omp_task_error() !bool {     // the ret reduction parameter tells the directive how it should reduce the return value     const result = omp.parallel(.{ .ret_reduction = .plus })         .run(.{}, struct {         // you can return whatever you want!         fn f() !usize {             const maybe = omp.single()                 .run(.{}, struct {                 // only for tasks, you have to put the explicit error type in the promise,                 // otherwise it won't be able to infer the type                 fn f() *omp.promise(error{wompwomp}!usize) {                     return omp.task(.{})                         .run(.{}, struct {                         // same deal here                         fn f() error{wompwomp}!usize {                             return error.wompwomp;                         }                     }.f);                 }             }.f);             if (maybe) |pro| {                 defer pro.deinit();                 return pro.get();             }             return 0;         }     }.f) catch |err| switch (err) {         error.wompwomp => std.debug.print('caught an error :^(', .{});     };      std.debug.print('no errors here!'. /{}); } ```  ### return  all of the directives can return values. to return something you may need to specify the `ret_reduction` parameter.  > [!warning] > the promises that are returned from the `task` directive will be heap allocated. so make sure to deinit() them!  ### errors  all of the directive can return error types. > [!warning] > returning more than one type of error from a directive it's clearly a race condition!  ## goal  the goal of this library is to provide at least openmp 4.5 to zig and be production ready, along with the mentioned extensions. ","SasLuca/zig-nanoid":"A tiny, secure, URL-friendly, unique string ID generator. Now available in pure Zig. # nano id in zig  [![license](https://img.shields.io/badge/license-mit%20license-blue.svg)](https://github.com/sasluca/nanoid-zig/master/license) [![cross build tests](https://github.com/sasluca/zig-nanoid/actions/workflows/cross-build.yml/badge.svg)](https://github.com/sasluca/zig-nanoid/actions/workflows/cross-build.yml) ![maintenance intention for this crate](https://img.shields.io/badge/maintenance-actively--developed-brightgreen.svg)  <img src='https://raw.githubusercontent.com/sasluca/zig-nanoid/main/logo.svg' align='right' alt='nano id x zig logo by anton lovchikov, adapted by luca sas' width='180' height='94'>  a battle-tested, tiny, secure, url-friendly, unique string id generator. now available in pure zig.  * **freestanding.** zig-nanoid is entirely freestanding. * **fast.** the algorithm is very fast and relies just on basic math, speed will mostly depend on your choice of rng. * **safe.** it can use any random generator you want and the library has no errors to handle. * **short ids.** it uses a larger alphabet than uuid (`a-za-z0-9_-`). so id length was reduced from 36 to 21 symbols and it is url friendly. * **battle tested.** original implementation has over 18 million weekly downloads on [npm](https://www.npmjs.com/package/nanoid). * **portable.** nano id was ported to [20+ programming languages](https://github.com/ai/nanoid#other-programming-languages).  ## example  basic usage with `std.crypto.random`: ```zig const std = @import('std'); const nanoid = @import('nanoid');  pub fn main() !void {        const result = nanoid.generate(std.crypto.random);      std.log.info('nanoid: {s}', .{result}); } ```  ## comparison to uuid  nano id is quite comparable to uuid v4 (random-based).  it has a similar number of random bits in the id (126 in nano id and 122 in uuid), so it has a similar collision probability.  it also uses a bigger alphabet, so a similar number of random bits are packed in just 21 symbols instead of 36.  for there to be a one in a billion chance of duplication, 103 trillion version 4 ids must be generated.  ## how to use  ### generating an id with the default size  the simplest way to generate an id with the default alphabet and length is by using the function `generate` like so:  ```zig const result = nanoid.generate(std.crypto.random); ```  if you want a custom alphabet you can use `generatewithalphabet` and pass either a custom alphabet or one from `nanoid.alphabets`: ```zig const result = nanoid.generatewithalphabet(std.crypto.random, nanoid.alphabets.numbers); // this id will only contain numbers ```  you can find a variety of other useful alphabets inside of `nanoid.alphabets`.  the result is an array of size `default_id_len` which happens to be 21 which is returned by value.  there are no errors to handle, assuming your rng object is valid everything will work. the default alphabet includes the symbols '-_', numbers and english lowercase and uppercase letters.  ### generating an id with a custom size  if you want a custom alphabet and length use `generateex` or `generateexwithiterativerng`.  the function `generateex` takes an rng, an `alphabet`, a `result_buffer` that it will write the id to, and a `step_buffer`. the `step_buffer` is used by the algorithm to store a random bytes so it has to do less calls to the rng and `step_buffer.len` must be at  least `computerngstepbufferlength(computemask(@truncate(u8, alphabet.len)), result_buffer.len, alphabet.len)`.  the function `generateexwithiterativerng` is the same as `generateex` except it doesn't need a `step_buffer`. it will use `random.int(u8)`  instead of `random.bytes()` to get a random byte at a time thus avoiding the need for a rng step buffer. normally this will be slower but  depending on your rng algorithm or other requirements it might not be, so the option is there in case you need but normally it is  recommended you use `generateex` which requires a temporary buffer that will be filled using `random.bytes()` in order to get the best performance.  additionally you can precompute a sufficient length for the `step_buffer` and pre-allocate it as an optimization using  `computesufficientrngstepbufferlengthfor` which simply asks for the largest possible id length you want to generate.  if you intend to use the `default_id_len`, you can use the constant `nanoid.rng_step_buffer_len_sufficient_for_default_length_ids`.  ### regarding rngs  you will need to provide an random number generator (rng) yourself. you can use the zig standard library ones, either `std.rand.defaultprng` or if you have stricter security requirements use `std.rand.defaultcsprng` or `std.crypto.random`.  when you initialize them you need to provide a seed, providing the same one every time will result in the same ids being generated every  time you run the program, except for `std.crypto.random`.  if you want a good secure seed you can generate one using `std.crypto.random.bytes`.   here is an example of how you would initialize and seed `std.rand.defaultcsprng` and use it:  ```zig // generate seed var seed: [std.rand.defaultcsprng.secret_seed_length]u8 = undefined; std.crypto.random.bytes(&seed);  // initialize the rng and allocator var rng = std.rand.defaultcsprng.init(seed);  // generate id var id = nanoid.generate(rng.random()); ```  ## add zig-nanoid to your project  ### manually  to add the library as a package to your zig project: 1. download the repo and put it in a folder (eg: `thirdparty`) in your project. 2. import the library's `build.zig` in your build script (eg: `const nanoid = @import('thirdparty/nanoid-zig/build.zig');`) 3. add the library as a package to your steps (eg: `exe.addpackage(nanoid.getpackage('nanoid'));`)  full example: ```zig // build.zig const std = @import('std'); const nanoid = @import('thirdparty/zig-nanoid/build.zig');  pub fn build(b: *std.build.builder) void  {     const target = b.standardtargetoptions(.{});     const mode = b.standardreleaseoptions();      const exe = b.addexecutable('zig-nanoid-test', 'src/main.zig');     exe.settarget(target);     exe.setbuildmode(mode);     exe.addpackage(nanoid.getpackage('nanoid'));     exe.install(); } ```  ### using the gyro package manager  we support the zig [gyro package manager](https://github.com/mattnite/gyro). here is how to use it:  1. from your terminal initialize a gyro project and add the package `sasluca/nanoid`.     ```     gyro init     gyro add sasluca/nanoid     ```  2. in your `build.zig` do an import like so `const pkgs = @import('deps.zig').pkgs;` and call `pkgs.addallto(exe);` to add all libraries to your executable (or some other target).  3. import `const nanoid = @import('nanoid');` in your `main.zig` and use it.  4. invoke `gyro build run` which will generate `deps.zig` and other files as well as building and running your project.  ## useful links  - original implementation: https://github.com/ai/nanoid  - online tool: https://zelark.github.io/nano-id-cc/ ","pwbh/ymlz":"Small and convenient YAML parser for Zig <h1 align='center'>   <img src='https://raw.githubusercontent.com/pwbh/ymlz/414cc4ad1a0cdfb59e1d7b62753a5330833d0b77/imgs/logo.svg?token=a6ppckm5ygwibjm4wfm3vcdgytmve' alt='ymlz' width='1007'> </h1>  <h4 align='center'>small and convenient <a href='https://en.wikipedia.org/wiki/yaml' target='_blank'>yaml</a> parser</h4>  <p align='center'>   <a href='#key-features'>key features</a> •   <a href='#how-to-use'>how to use</a> •   <a href='#support'>support</a> •   <a href='#contribution'>contribution</a> •   <a href='#license'>license</a> </p>  ## key features  - simple and straightforward to use thanks to built-in [reflections](https://ziglang.org/documentation/master/#function-reflection). - just define a struct, load a yml into it, and access your fields. - supports recursive struct. - deinitialization is handled for you, just call `deinit()` and you are done. - fields are automatically parsed based on field type. - ability to parse fields optionally.  ## how to use  easiest way to use ymlz is to fetch it via `zig fetch`, **make sure to provide it the url of latest released version as the argument**.  see an example below.  ```bash zig fetch --save https://github.com/pwbh/ymlz/archive/refs/tags/0.1.0.tar.gz ```  now in your `build.zig` we need to import ymlz as a module the following way:  ```zig pub fn build(b: *std.build) void {     const exe = b.addexecutable(.{ ... });      const ymlz = b.dependency('ymlz', .{});     exe.root_module.addimport('ymlz', ymlz.module('root')); } ```  ### parsing yaml from file  we can utilize `loadfile` which expects the absolute path to your yaml file, i will be loading the following yaml file located in the root of my project under the name `file.yml`:  ```yml first: 500 second: -3 name: just testing strings overhere fourth: 142.241 foods:   - apple   - orange   - strawberry   - mango inner:   sd: 12   k: 2   l: hello world   another:     new: 1     stringed: its just a string ```  main.zig:  ```zig /// usage /// zig build run -- ./file.yml const std = @import('std');  const ymlz = @import('ymlz').ymlz;  // notice how simple it is to define a struct that is one-to-one // to the yaml file structure const tester = struct {     first: i32,     second: i64,     name: []const u8,     fourth: f32,     foods: [][]const u8,     inner: struct {         sd: i32,         k: u8,         l: []const u8,         another: struct {             new: f32,             stringed: []const u8,         },     }, };  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     const allocator = gpa.allocator();     defer _ = gpa.deinit();      const args = try std.process.argsalloc(allocator);     defer std.process.argsfree(allocator, args);      if (args.len < 2) {         return error.nopathargument;     }       const yml_location = args[1];      const yml_path = try std.fs.cwd().realpathalloc(         allocator,         yml_location,     );     defer allocator.free(yml_path);      var ymlz = try ymlz(tester).init(allocator);     const result = try ymlz.loadfile(yml_path);     defer ymlz.deinit(result);      // we can print and see that all the fields have been loaded     std.debug.print('tester: {any}╲n', .{result});     // lets try accessing the first field and printing it     std.debug.print('first: {}╲n', .{result.first});     // same goes for the array that we've defined `foods`     for (result.foods) |food| {         std.debug.print('{s}', .{food});     } } ```  ### parsing yaml from bytes  parsing yaml file using generic `u8` slice for the sake of our example, lets parse a small yaml inlined in to some variable that contains our yaml in `[]const u8`.  ```zig const std = @import('std');  const ymlz = @import('root.zig').ymlz;  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     const allocator = gpa.allocator();     defer _ = gpa.deinit();      const yaml_content =         ╲╲first: 500         ╲╲second: -3         ╲╲name: just testing strings overhere # just a comment         ╲╲fourth: 142.241         ╲╲# comment in between lines         ╲╲foods:         ╲╲  - apple         ╲╲  - orange         ╲╲  - strawberry         ╲╲  - mango         ╲╲inner:         ╲╲  abcd: 12         ╲╲  k: 2         ╲╲  l: hello world                 # comment somewhere         ╲╲  another:         ╲╲    new: 1         ╲╲    stringed: its just a string     ;      const experiment = struct {         first: i32,         second: i64,         name: []const u8,         fourth: f32,         foods: [][]const u8,         inner: struct {             abcd: i32,             k: u8,             l: []const u8,             another: struct {                 new: f32,                 stringed: []const u8,             },         },     };      var ymlz = try ymlz(experiment).init(allocator);     const result = try ymlz.loadraw(yaml_content);     defer ymlz.deinit(result);      std.debug.print('experiment.first: {}╲n', .{result.first}); }  ```  ### parsing by providing a custom std.io.anyreader  it's possible to pass your own implementation of the std.io.anyreader interface to ymlz using `loadreader` which is used internally for both `loadfile` and `loadraw`. see [internal implementation](https://github.com/pwbh/ymlz/blob/master/src/root.zig#l64) for reference.  ## contribution  you are more then welcomed to submit a pr, ymlz codebase is still pretty small and it should be relatively simple to get into it, if you have any questions regarding the project or you just need assist starting out, open an issue.  ## support  if you find a bug please [submit new issue](https://github.com/pwbh/ymlz/issues/new) and i will try to address it in my free time. i do however want to note that this project is used in my bigger project, so any bugs i find, i fix without reporting them as an issue, so some issues that may have been reported have beeen fixed without me seeing them.  ## license  apache license 2.0. can be found under the [license](https://github.com/pwbh/ymlz/blob/master/license). ","ziglibs/ini":"A teeny tiny ini parser # ini parser library  this is a very simple ini-parser library that provides: - raw record reading - leading/trailing whitespace removal - comments based on `;` and `#` - zig api - c api  ## usage example  ### zig   ```zig const std = @import('std'); const ini = @import('ini');  pub fn main() !void {     const file = try std.fs.cwd().openfile('example.ini', .{});     defer file.close();      var parser = ini.parse(std.testing.allocator, file.reader());     defer parser.deinit();      var writer = std.io.getstdout().writer();      while (try parser.next()) |record| {         switch (record) {             .section => |heading| try writer.print('[{s}]╲n', .{heading}),             .property => |kv| try writer.print('{s} = {s}╲n', .{ kv.key, kv.value }),             .enumeration => |value| try writer.print('{s}╲n', .{value}),         }     } } ```  ### c  ```c #include <ini.h>  #include <stdio.h> #include <stdbool.h>  int main() {   file * f = fopen('example.ini', 'rb');   if(!f)     return 1;      struct ini_parser parser;   ini_create_file(&parser, f);    struct ini_record record;   while(true)   {     enum ini_error error = ini_next(&parser, &record);     if(error != ini_success)       goto cleanup;          switch(record.type) {       case ini_record_nul: goto done;       case ini_record_section:         printf('[%s]╲n', record.section);         break;       case ini_record_property:         printf('%s = %s╲n', record.property.key, record.property.value);         break;       case ini_record_enumeration:         printf('%s╲n', record.enumeration);         break;     }    } done:  cleanup:   ini_destroy(&parser);   fclose(f);   return 0; } ```","akarpovskii/build.crab":"Use Rust libraries in Zig # build.crab  thin wrapper around cargo which integrates it with zig's build system. <br> cross-compilation is supported.  ## requirements  * zig >= 0.13.0  ## usage  ```sh zig fetch --save https://github.com/akarpovskii/build.crab/archive/refs/tags/v0.1.7.tar.gz ```  in `build.zig` (replace `crate` with the name of your crate): ```zig const build_crab = @import('build.crab'); const crate_artifacts = build_crab.addcargobuild(     b,     .{         .manifest_path = b.path('path/to/cargo.toml'),         // you can pass additional arguments to cargo         .cargo_args = &.{             '--release',             '--quiet',         },     },     .{         // set to .debug to see debug logs,         // defaults to the same optimization level as your package.         .optimize = .releasesafe,     }, );  module.addlibrarypath(crate_artifacts); module.linksystemlibrary('crate', .{}); ```  see [`example`](./example/build.zig) for the other examples.  ## cross-compilation  use `target` argument to specify the cross-compilation target:  ```zig const target = b.standardtargetoptions(.{}); const build_crab = @import('build.crab'); const crate_artifacts = build_crab.addcargobuild(     b,     .{         // cargo params     },     .{         .target = target,     }, ); ```  `build.crab` binaries will still be built for the native target, but it will try its best to convert zig's target triple to rust and call `cargo build` with the appropriate `--target` argument.  see [`rust.zig`](src/rust.zig) and the tests at the bottom to know how the conversion is done.  ## windows  ![hydra meme with windows as the weird head!](./images/windows%20is%20the%20weird%20one.jpeg)  windows, as always, is the weird one.  by default, rust on windows targets msvc toolchain. this creates additional problems as you have to link against msvcrt, etc.  if you want to avoid that, you can target windows-gnu. this is the default behavior of `build.crab`.  but that has its own problems since both rust and zig provide `compiler_rt.lib` with most of the symbols having weak linking, but not `___chkstk` and `___chkstk_ms`.  so if you want to link against a rust library that needs these intrinsics, you should somehow resolve the conflict (though i'm not completely sure that it is safe to do).  for this purpose, `build.crab` provides an additional artifact called `strip_symbols` that repacks `.a` archive removing `.o` files containing conflicting functions (provided by the user).  ```zig const crate_lib_path = @import('build.crab').addstripsymbols(b, .{     .name = 'libcrate.a',     .archive = b.path('path/to/libcrate.a'),     .symbols = &.{         '___chkstk_ms',     }, });  module.addlibrarypath(crate_lib_path.dirname()); module.linksystemlibrary('crate', .{}); ```  if you use `addruststaticlib`, this is already taken care of for you. see the [`buid.zig`](./example/build.zig) for a complete example.  on top of that, i recommend adding the following parameters to `cargo.toml`:  ```toml [profile.release] opt-level = 'z'  # optimize for size. strip = true lto = true ```  otherwise, you again will have to link some obscure windows libraries even if you don't use them.  and it also makes the size of the rust library smaller. ","zigtools/zig-lsp-codegen":"LSP codegen based on the MetaModel [![ci](https://github.com/zigtools/zig-lsp-codegen/actions/workflows/main.yml/badge.svg)](https://github.com/zigtools/zig-lsp-codegen/actions) [![codecov](https://codecov.io/gh/zigtools/zig-lsp-codegen/graph/badge.svg?token=c3hcn59e4c)](https://codecov.io/gh/zigtools/zig-lsp-codegen) [![documentation](https://badgen.net/badge/icon/docs?icon=wiki&label)](https://zigtools.github.io/zig-lsp-codegen) [![license: mit](https://img.shields.io/badge/license-mit-yellow.svg)](https://opensource.org/licenses/mit)  # zig lsp codegen  generates `std.json` compatible zig code based on the official [lsp metamodel](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#metamodel)  ## installation  ```bash # initialize a `zig build` project if you haven't already zig init # add the `lsp-codegen` package to your `build.zig.zon` zig fetch --save git+https://github.com/zigtools/zig-lsp-codegen.git ```  you can then import `lsp-codegen` in your `build.zig` with:  ```zig const lsp_codegen = b.dependency('lsp-codegen', .{}); const exe = b.addexecutable(...); exe.root_module.addimport('lsp', lsp_codegen.module('lsp')); ``` ","karlseguin/mqttz":"MQTT client for Zig 404: not found","andrewrk/xml":"Tokenize XML # xml  a library for tokenizing xml.  ## building  ``` zig build ```  ## testing  ``` zig build test ``` ","BitlyTwiser/snek":"Snek - A simple CLI parser to build CLI applications in Zig <div align='center'>   <img src='/assets/logo.png' width='450' height='500'>   # 🐍snek🐍 a simple cli parser building cli applications in zig  # contents [usage](#usage) | [building the cli](#build-your-cli) | [examples](#examples) | [optionals](#optionals) | [default values](#default-values) | [help menu](#help-menu) | [what is not supported](#what-is-not-supported)  </div>   ### usage add snek to your zig project with zon: ``` zig fetch --save https://github.com/bitlytwiser/snek/archive/refs/tags/v0.1.0.tar.gz ```  add the following to build.zig file: ```     const snek = b.dependency('snek', .{});     exe.root_module.addimport('snek', snek.module('snek')); ```  ### build your cli snek builds dynamic (yet simple) cli's using zigs meta programming to infer the struct fields, the expected types, then insert the incoming data from the stdin arguments and serialize that data into the given struct mapping the data values to the given fields and marshalling the data into the proper type.  ```     const t = struct {         bool_test: bool,         word: []const u8,         test_opt: ?u32,         test_default: []const u8 = 'i am static if not set by user',     };     var snek = try snek(t).init(std.heap.page_allocator);     const parsed = try snek.parse();      // do stuff with the fields of the struct after parsing     std.debug.print('{any}', .{parsed}); ```  when the user goes to interact with the application, they can now utilize the flags you have established to run specific commands.  see the [completed](#example---full-execution) and functional example below or checkout the [main file](./src/main.zig) in the repo for a full working example as well.  #### items to note: 1. if the user does not supply a value and the field is *not* otional, that is a failure case and a message is displayed to the user 2. if there is a default value on the field of the struct and a vale is not passed for that field, it is treated as an *optional* case and will use the static value (i.e. no error message and value is set) 3. simple structs only for now, no recursive struct fields at the moment. (i.e. no embeded structs) 4. if the users passed the wrong *type* which differes from what is expeected (i.e. the type of the struct field), this is an error case and a message will be displayed to the user. 5. if you want to handle the errors yourself, the clierror struct is public, so you can catch errors on the `parse()` call ```     const t = struct {         bool_test: bool,         word: []const u8,         test_opt: ?u32,         test_default: []const u8 = 'i am static if not set by user',     };     var snek = try snek(t).init(std.heap.page_allocator);     // adjust to actually use value of course     _ = snek.parse() catch |err| {         switch(e) {             ... do stuff with the errors         }     }  ```   #### examples  using the above struct as a  reference, here are a few examples of calling the cli: ##### example - help command ``` ./<yourappname> -help  # or  ./<yourappname> -h ```  note: as you can see, the optionals are just that, *optional*. they are not required by your users and can be checked in the calling code in the standard ways that zig handles optionals. this is a design decisions allowing flexibility over the cli to not lock users into using every flag etc.. ##### example - optionals ```` ./<yourappname> -bool_test=true -word='i am a word!' ````  ##### example - defaults: ``` ./<yourappname> -bool_test=true -word='i am a word!'  # or to override the default field   ./<yourappname> -bool_test=true -word='i am a word!' -test_defaults='i am a different word!' ```   ##### example - full execution ``` const std = @import('std'); const snek = @import('lib.zig').snek;  // binary is also compiled for showcasing how to use the api const t = struct {     name: []const u8,     location: u32,     exists: bool,     necessary: ?bool,     filled_optional: ?[]const u8,     default_name: []const u8 = 'test default name', };  // example command after compilation: // ./zig-out/bin/snek -name='test mctest' -location=420 -exists=true pub fn main() !void {     var cli = try snek(t).init(std.heap.page_allocator);     const parsed_cli = try cli.parse();      // necessary is skipped here to showcase optional values being ignored     std.debug.print('name: {s}╲n location: {d}╲n exists: {any}╲n defualt value: {s}╲n filled optional: {s}╲n', .{ parsed_cli.name, parsed_cli.location, parsed_cli.exists, parsed_cli.default_name, parsed_cli.filled_optional orelse 'badvalue' }); } ``` compile with `zig build` then run the cli command: ``` ./zig-out/bin/snek -name='test mctest' -location=420 -exists=true ```  #### optionals using zig optionals, you can set selected flags to be ignored on the cli, thus giving flexibilitiy on the behalf of the cli creator to use or not use selected flags at their whimsy  #### default values you can use struct defaut values to set a static value if one is not parsed. this can be useful for certain flags for conditional logic branching later in program execution.  ### help menu snek dynaically builds the help menu for your users. by calling the `help()` function, you can display how to use your cli: ```     const t = struct {         bool_test: bool,         word: []const u8,         test_opt: ?u32,     };     var snek = try snek(t).init(std.heap.page_allocator);     const parsed = try snek.help();  ``` output: ``` cli flags help menu --------- -bool_test=bool (optional: false) -word=pointer (optional: false) -test_opt=optional (optional: true) --------- ```   alternatively, if users call -help as the *first* arguments in the cli, it will also display the help menu. ``` ./<yourappname> -help  # or  ./<yourappname> -h ```  this will display the help menu and skip *all other parsing*. so its important to note that this is effectively an exit case for the parser and your program.  you should build your application to support this.   ### what is *not* supported  ##### recursive struct types for sub-command fields at this time, no recursive flags are supported, i.e. you cannot use a slice of structs as a field in the primary cli interface struct and have those fields parsed as sub-command fields. perhaps, if this is requested, we could work that into the application. it seemed slightly messy and unecessray for a simple cli builder, but perhaps expansion will be necessary there if its requested :)  [top](#usage) ","flyfish30/zig-cats":"A category and functional programing library for Zig language # zig-cats a category and functional programing library for zig: monoid, functor, applicative, monad, compose, product, coproduct, generic, etc. the monoid/functor/applicative/monad has support pure data type.  ## current supported feature list - [ ] semigroup - [ ] monoid  - [x] functor - [x] natural transformation - [x] applicative functor - [x] monad  - [x] compose - [x] product - [x] coproduct  - [ ] foldable - [ ] traversable ","ymndoseijin/zilliam":"A Geometric Algebra library for Zig # zilliam  zilliam is a geometric algebra library that generates a simd optimized library for any given cl(p,q,r) algebra. it can be used for:  * pga (projective geometric algebra, for which zilliam has a special for generating all needed mask types) where you can easily construct points, lines and planes in any dimension and do projection, rotations, intersections and more between all of them under the same syntax. it has many uses for computer graphics and physics. it can also model conformal transformations using cga. * modelling complex numbers, quaternions, dual numbers and many more other clifford algebras under a single interface, generating simd optimized code for all of them. this makes it possible to use zilliam for automatic differentiation, complex analysis * calculate lorentz boosts and more using an sta (spacetime algebra) which also provides a very useful model for doing electrodynamics work.  for all these applications, zilliam gives you access to useful functions such as the trigonometric functions, the exponential and also useful concepts such as the poincare dual and wedge operations. it also provides a sort of operation overloading through a [comath](https://github.com/inkryption/comath) interface, which allows you to evaluate complex expressions more easily and without much compile time cost.  it currently has the following operations (syntax for the eval function): - a*b: geo - ~a: reverse - a^b: wedge - a&b: regressive - *a: dual - a|b: inner product - #a: grade involution - a$k: grade projection - %a: undual  it generates simd operations for any generic clifford algebra for all these operations, and for any generic type as well:  ```zig const alg = algebra(i32, 2, 1, 1);  try std.testing.expectequalslices(     i32,     &(try alg.eval('(14*e1) - (21*e2) - (7*e12) - 24', .{})).val,     &(try alg.eval('(2*e1+3*e2+5*e12) * (11*e1+13*e2+17*e12)', .{})).val, );  try std.testing.expectequalslices(     i32,     &(try alg.eval('109 + 654*e0 + 129*e1 + 127*e2 + 214*e12', .{})).val,     &(try alg.eval('(23*e0+2*e1+3*e2+5*e12+7) | (31*e0+11*e1+13*e2+17*e12+19)', .{})).val, ); ```  as you can see, it also uses the amazing [comath](https://github.com/inkryption/comath) library to overload operations.  in the case where you know the grade of the multivectors you are working with (which is most practical cases), zilliam generates types for like k-vector plus the even subalgebra and dispatches among them. ```zig const alg = algebra(f32, 3, 0, 1); const blades = getblades(alg); const types = blades.types;  const vector = types[1]; const bivector = types[2]; const trivector = types[3];  pub fn main() !void {     const bivectorbatch = bivector.getbatchtype(2);     const vectorbatch = vector.getbatchtype(2);      for (0..bivector.count) |a_i| {         for (0..vector.count) |b_i| {             var a = bivectorbatch{};             var b = vectorbatch{};             a.val[a_i] = .{ 1, 2 };             b.val[b_i] = .{ 1, 2 };             var buf: [2048]u8 = undefined;              // this is a trivector, it gets properly dispatched             const res = a.wedge(b);              for (0..2) |i| {                 const r_w = res.get(i);                  var r_s = try a.get(i).print(&buf);                 std.debug.print('{s} ^ ', .{r_s});                 r_s = try b.get(i).print(&buf);                 std.debug.print('{s} = ', .{r_s});                 r_s = try r_w.print(&buf);                 std.debug.print('{s}╲n', .{r_s});             }             std.debug.print('╲n', .{});         }     } }  // ... // 1.0000e13 ^ 1.0000e0 = 1.0000e013 // 2.0000e13 ^ 2.0000e0 = 4.0000e013 // ... ```  for more examples and a guide for using zilliam on your project, check the [wiki](https://github.com/ymndoseijin/zilliam/wiki/examples).  # todo - add more general utilities beyond just the pga one and improve the calculation of functions - eventually, hook it up to my graphics library to start doing visualizations (maybe something on par with ganja.js)  # references - thanks to [klein](https://github.com/jeremyong/klein) specially, who gave me the idea to generate simd operations and something to compare the generated code to. - also thanks to the people at [bivector.net](https://bivector.net/index.html) and specially their [/tools](https://bivector.net/tools.html) page, whose tables and calculators helped me verifying the correctness of my own code. ","nektro/zig-inquirer":"A collection of utilities for prompting information from the user on the CLI # zig-inquirer  a collection of utilities for prompting information from the user on the cli  adapted from https://github.com/sboudrias/inquirer.js  ## add me ``` zigmod aq add 1/nektro/inquirer ```  ## run example ``` zig build run ```  ## screenshots ![image](https://user-images.githubusercontent.com/5464072/127479686-fda8f860-a705-4fd6-9768-a3e1f53a6bc7.png)  ## usage - `pub fn answer(writer, reader, comptime prompt: []const u8, value: []const u8) []const u8`     - prints just the done string. - `pub fn forenum(writer, reader, comptime prompt: []const u8, alloc: *std.mem.allocator, comptime options: enum, default: ?options) !options`     - accepts an enum and prompts the user to pick on of the fields. - `pub fn forstring(writer, reader, comptime prompt: []const u8, alloc: *std.mem.allocator, default: ?[]const u8) ![]const u8`     - base function, asks prompt and returns non-empty answer. - `pub fn forconfirm(writer, reader, comptime prompt: []const u8, alloc: *std.mem.allocator) !bool`     - calls `forenum` with `y/n`  ## todo - number (current implementation causes compiler crash) - list with strings - string password - long list with autocomplete - date - time  ## license mit ","nektro/zig-ulid":"A binary implementation of ULID in Zig. # zig-ulid ![loc](https://sloc.xyz/github/nektro/zig-ulid) [![license](https://img.shields.io/github/license/nektro/zig-ulid.svg)](https://github.com/nektro/zig-ulid/blob/master/license)  a binary implementation of ulid in zig.  https://github.com/ulid/spec  ## license mit ","kubkon/zelf":"Zig's ELF parser utility # zelf  zig's elf parsing utility - a replacement (maybe someday) utility for `readelf` written in zig.  ## usage  ``` usage: zelf [options] file  general options: -a, --all                        equivalent of having all flags on -g, --section-groups             display the section groups -h, --file-header                display elf file header -l, --program-headers            display program headers (if present) -s, --section-headers            display section headers -s, --symbols                    display symbol table     --dyn-syms                   display the dynamic symbol table -r, --relocs                     display relocations (if present) -d, --dynamic                    display the dynamic section (if present) --initializers                   display table(s) of initializers/finalizers (if present) -p, --string-dump=<number|name>  dump the contents of section <number|name> as strings -v, --version-info               display the version sections (if present) -w, --wide                       do not shorten the names if too wide -x, --hex-dump=<number|name>     dump the contents of section <number|name> as bytes --help                           display this help and exit ```  currently supported flags. more to come.  typical output will look something like this.  ``` > zelf -a main.o elf header:   magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00   class:                             elf64   data:                              2's complement, little endian   version:                           1 (current)   os/abi:                            unix - system v   abi version:                       0   type:                              rel (relocatable file)   machine:                           advanced micro devices x86-64   version:                           0x1   entry point address:               0x0   start of program headers:          0 (bytes into file)   start of section headers:          28208 (bytes into file)   flags:                             0x0   size of this header:               64 (bytes)   size of program headers:           0 (bytes)   number of program headers:         0   size of section headers:           64 (bytes)   number of section headers:         23   section header string table index: 22  there are 23 section headers, starting at offset 0x6e30:  section headers:   [nr]  name              type              address           offset         size              entsize           flags  link  info  align   [ 0]                    null              0000000000000000  0000000000000000         0000000000000000  0000000000000000            0     0     0   [ 1]  .note.gnu.pr[..]  note              0000000000000000  0000000000000040         0000000000000040  0000000000000000  a         0     0     8   [ 2]  .note.abi-tag     note              0000000000000000  0000000000000080         0000000000000020  0000000000000000  a         0     0     4   [ 3]  .text             progbits          0000000000000000  00000000000000a0         0000000000000031  0000000000000000  ax        0     0    16   [ 4]  .rela.text        rela              0000000000000000  0000000000000480         0000000000000030  0000000000000018  i        20     3     8   [ 5]  .rodata.cst4      progbits          0000000000000000  00000000000000d4         0000000000000004  0000000000000004  am        0     0     4   [ 6]  .eh_frame         progbits          0000000000000000  00000000000000d8         000000000000005c  0000000000000000  a         0     0     8   [ 7]  .rela.eh_frame    rela              0000000000000000  00000000000004b0         0000000000000030  0000000000000018  i        20     6     8   [ 8]  .data             progbits          0000000000000000  0000000000000134         0000000000000004  0000000000000000  wa        0     0     1   [ 9]  .bss              nobits            0000000000000000  0000000000000138         0000000000000000  0000000000000000  wa        0     0     1   [10]  .comment          progbits          0000000000000000  0000000000000138         0000000000000036  0000000000000001  ms        0     0     1   [11]  .note.gnu-stack   progbits          0000000000000000  000000000000016e         0000000000000000  0000000000000000            0     0     1   [12]  .debug_aranges    progbits          0000000000000000  00000000000004e0         000000000000003b  0000000000000000  c         0     0     8   [13]  .rela.debug_[..]  rela              0000000000000000  0000000000000520         0000000000000090  0000000000000018  i        20    12     8   [14]  .debug_info       progbits          0000000000000000  00000000000005b0         00000000000013c4  0000000000000000  c         0     0     8   [15]  .rela.debug_info  rela              0000000000000000  0000000000001978         00000000000041d0  0000000000000018  i        20    14     8   [16]  .debug_abbrev     progbits          0000000000000000  0000000000005b48         00000000000001ac  0000000000000000  c         0     0     8   [17]  .debug_line       progbits          0000000000000000  0000000000005cf8         0000000000000313  0000000000000000  c         0     0     8   [18]  .rela.debug_line  rela              0000000000000000  0000000000006010         0000000000000030  0000000000000018  i        20    17     8   [19]  .debug_str        progbits          0000000000000000  0000000000006040         0000000000000d1a  0000000000000001  msc       0     0     8   [20]  .symtab           symtab            0000000000000000  0000000000000170         0000000000000288  0000000000000018           21    19     8   [21]  .strtab           strtab            0000000000000000  00000000000003f8         0000000000000088  0000000000000000            0     0     1   [22]  .shstrtab         strtab            0000000000000000  0000000000006d5a         00000000000000d6  0000000000000000            0     0     1 key to flags:   w (write), a (alloc), x (execute), m (merge), s (strings), i (info),   l (link order), o (extra os processing required), g (group), t (tls),   c (compressed), x (unknown), o (os specific), e (exclude),   d (mbind), l (large), p (processor specific)  there are no program headers in this file.  relocation section '.rela.text' at offset 0x480 contains 2 entries:   offset        info            type                    sym. value  sym. name + addend 000000000017 00150000002a r_x86_64_rex_gotpcrelx   0000000000000000 main - 4 00000000001d 001900000029 r_x86_64_gotpcrelx       0000000000000000 __libc_start_main - 4  relocation section '.rela.eh_frame' at offset 0x4b0 contains 2 entries:   offset        info            type                    sym. value  sym. name + addend 000000000020 000300000002 r_x86_64_pc32            0000000000000000 .text + 0 000000000050 000300000002 r_x86_64_pc32            0000000000000000 .text + 30  relocation section '.rela.debug_aranges' at offset 0x520 contains 6 entries:   offset        info            type                    sym. value  sym. name + addend 000000000006 000b0000000a r_x86_64_32              0000000000000000 .debug_info + 0 000000000010 000300000001 r_x86_64_64              0000000000000000 .text + 0 000000000036 000b0000000a r_x86_64_32              0000000000000000 .debug_info + 2e 000000000056 000b0000000a r_x86_64_32              0000000000000000 .debug_info + af4 000000000076 000b0000000a r_x86_64_32              0000000000000000 .debug_info + b34 000000000080 000300000001 r_x86_64_64              0000000000000000 .text + 30  symbol table '.symtab' contains 27 entries:   num:            value  size type    bind   vis      ndx   name     0: 0000000000000000     0 notype  local  default  und        1: 0000000000000000     0 section local  default  1          2: 0000000000000000     0 section local  default  2          3: 0000000000000000     0 section local  default  3          4: 0000000000000000     0 section local  default  5          5: 0000000000000000     0 section local  default  6          6: 0000000000000000     0 section local  default  8          7: 0000000000000000     0 section local  default  9          8: 0000000000000000     0 section local  default  10         9: 0000000000000000     0 section local  default  11        10: 0000000000000000     0 section local  default  12        11: 0000000000000000     0 section local  default  14        12: 0000000000000000     0 section local  default  16        13: 0000000000000000     0 section local  default  17        14: 0000000000000000     0 section local  default  19        15: 0000000000000000     0 file    local  default  abs   abi-note.c    16: 0000000000000000    32 object  local  default  2     __abi_tag    17: 0000000000000000     0 file    local  default  abs   init.c    18: 0000000000000000     0 file    local  default  abs   static-reloc.c    19: 0000000000000030     1 func    global unknown  3     _dl_relocate_static_pie    20: 0000000000000000    34 func    global default  3     _start    21: 0000000000000000     0 notype  global default  und   main    22: 0000000000000000     0 notype  weak   default  8     data_start    23: 0000000000000000     0 notype  global default  und   _global_offset_table_    24: 0000000000000000     4 object  global default  5     _io_stdin_used    25: 0000000000000000     0 notype  global default  und   __libc_start_main    26: 0000000000000000     0 notype  global default  8     __data_start  ```  ","mattnite/zig-zlib":"compile zlib in your build.zig # zlib build package  [![build](https://github.com/mattnite/zig-zlib/actions/workflows/build.yml/badge.svg)](https://github.com/mattnite/zig-zlib/actions/workflows/build.yml)  ## like this project?  if you like this project or other works of mine, please consider [donating to or sponsoring me](https://github.com/sponsors/mattnite) on github [:heart:](https://github.com/sponsors/mattnite)  ## how to use  this repo contains code for your `build.zig` that can statically compile zlib, as well as some idiomatic zig bindings for zlib that you can use in your application. in either case below you will be able to include zlibs header with:  ```zig const c = @cimport({     @cinclude('zlib.h'); }); ```  ### link and add bindings to your application  in order to statically link zlib into your application and access the bindings with a configurable import string:  ```zig const zlib = @import('path/to/zlib.zig');  pub fn build(b: *std.build.builder) void {     // ...      const lib = zlib.create(b, target, mode);      const exe = b.addexecutable('my-program', 'src/main.zig');     lib.link(exe, .{ .import_name = 'zlib' }); } ```  now code that is part of the `my-program` executable can import the zlib bindings with `@import('zlib')`.  ### only link to your application  in order to just link to the application, all you need to do is omit the `.import_name = 'zlib'` argument to zlib's link options:  ```zig     lib.link(exe, .{}); ``` ","ikskuh/zig-mqtt":"A build package for mqtt-c. # zig-mqtt  a build package for the awesome [mqtt-c](https://github.com/liambindle/mqtt-c) project by [liam bindle](https://github.com/liambindle).  right now only provides a build script api in `sdk.zig`, but might contain a zig frontend in the future.  ## usage  ```zig const std = @import('std'); const sdk = @import('sdk.zig');  pub fn build(b: *std.build.builder) void {     const mode = b.standardreleaseoptions();     const target = b.standardtargetoptions(.{});      const lib = sdk.createlibrary(b);     lib.setbuildmode(mode);     lib.settarget(target);     lib.install();      const exe = b.addexecutable(…);     exe.linklibary(lib);     exe.addincludepath(sdk.include_path);     … } ``` ","allyourcodebase/cpython":"A port of the CPython implementation of the Python programming language to the zig build system # cpython zig package  this is a fork of [cpython](https://www.python.org/), packaged for zig.  unnecessary files have been deleted, and the build system has been replaced with `build.zig`. there are no system dependencies; the only thing required to build this package is [zig](https://ziglang.org/download/).  this builds a static executable, which can be then executed like this: ``` pythonpath=lib zig-out/bin/cpython ```  ## project status  my personal use case is to run the latest [ytdlp](https://github.com/yt-dlp/yt-dlp) releases. this package is capable of doing that, however, there may be missing features beyond what is required for this use case, such as missing c modules.  i have tested on x86_64-linux-gnu and x86_64-linux-musl but not any other targets yet. probably, other targets will need some work before they are additionally supported.  contributions to broaden the support status are welcome. ","ziglibs/painterz":"Low-level implementation of different painting primitives (lines, rectangles, ...) without specialization on a certain draw target # painterz  the idea of this library is to provide platform-independent, embedded-feasible implementations of several drawing primitives.  the library exports a generic `canvas` type which is specialized on a `setpixel` function that will put pixels of type `color` onto a `framebuffer`. it's currently not possible or planned to do blending, but alpha test could be implemented by ignoring certain color values in the `setpixel` function.  ## usage example  ![usage example rendering](docs/example.png)  see [`src/example.zig`](src/example.zig) for a full usage example.  ```zig const pixel = packed struct {     r: u8, g: u8, b: u8, a: u8 };  const framebuffer = struct {     buffer: []pixel,      fn setpixel(fb: @this(), x: isize, y: isize, c: pixel) void {         if (x < 0 or y < 0) return;         if (x >= 100 or y >= 100) return;         fb.buffer[100 * std.math.abscast(y) + std.math.abscast(x)] = c;     } };  var canvas = painterz.canvas(framebuffer, pixel, framebuffer.setpixel).init(framebuffer{     .buffer = …, });  canvas.drawline(100, 120, 110, 90, pixel{     .r = 0xff,     .g = 0x00,     .b = 0xff,     .a = 0xff, }); ``` ","zhuyadong/zoop":"A Zig OOP solution # [中文](readme.cn.md) | [english](readme.md) # zoop is an oop solution for zig  ## install in the project root directory: ```shell zig fetch 'git+https://github.com/zhuyadong/zoop.git' --save=zoop ``` if you want to install a specific version: ```shell zig fetch 'git+https://github.com/zhuyadong/zoop.git#<ref id>' --save=zoop ```  ## define the class ```zig // define a class human pub const human = struct {     // the first field of the zoop class must be aligned to `zoop.alignment`     name: []const u8 align(zoop.alignment),     age: u8 = 30,      // if there is no cleanup work, can skip define `deinit`     pub fn deinit(self: *human) void {         self.name = '';     }      pub fn getname(self: *const human) []const u8 {         return self.name;     }      pub fn setname(self: *human, name: []const u8) void {         self.name = name;     } }; ```  ## creating and destroying class objects ```zig const t = std.testing;  // create a `human` on the heap var phuman = try zoop.new(t.allocator, human, null); // if the class field has a default value, the object field will be initialized to the default value try t.expect(phuman.age == 30); // destroy the object and release the memory. // if the class defines `deinit`, it will be called first and then release the memory. zoop.destroy(phuman);  // create a `human` on the stack var human = zoop.make(human, null); // access object fields through `ptr()` try t.expect(human.ptr().age == 30); // clean up the object (call `deinit` if any). // if there is no work to clean up, you don't need to call `zoop.destroy` zoop.destroy(human.ptr());  // both `zoop.new` and `zoop.make` support creation-time initialization phuman = try zoop.new(t.allocator, human, .{.name = 'heapobj', .age = 1}); human = zoop.make(human, .{.name = 'stackobj', .age = 2}); try t.expect(phuman.age == 1); try t.expect(human.ptr().age == 2); ``` note about `deinit`: `zoop.destroy` will sequentially call the `deinit` method of the class and all its parent classes  ## inheritance ```zig // define `superman`, inherit from `human`,  // the parent class must be the first field and the alignment is `zoop.alignment`, // the field name is arbitrary and does not have to be `super`, but it is recommended to use `super` pub const superman = struct {     super: human align(zoop.alignment),     // superman can live a long time, u8 can't satisfy it, we use u16     age: u16 = 9999,      pub fn getage(self: *superman) u16 {         return self.age;     }      pub fn setage(self: *superman, age: u16) void {         self.age = age;     } };  // first create a `superman` object var psuperman = try zoop.new(t.allocator, superman, null); //call parent class method psuperman.super.setname('super'); // or call the parent class method like this. this method is suitable for situations where the // inheritance hierarchy is too deep and you don't know which parent class implements the `setname` method. // in addition, since it is called `upcall`, it means that even if `superman` implements `setname`, // the following call will still call the `setname` method of the nearest parent class zoop.upcall(psuperman, .setname, .{'super'}); // you can also flexibly access all fields in the class inheritance tree. for example, // if you want to access the `human.age` field, you can do this: var phuman_age = zoop.getfield(psuperman, 'age', u8); try t.expect(phuman_age.* == 30); // access `superman.age`, you can do this: var psuper_age = zoop.getfield(psuperman, 'age', u16); try t.expect(psuper_age.* == 9999); // note that if two `age` are of the same type and both are called 'age', // the above `zoop.getfield` call will cause a compilation error to avoid bugs ```  ## class type conversion ```zig // first create a human and a superman var phuman = try zoop.new(t.allocator, human, null); var psuper = try zoop.new(t.allocator, superman, null);  // subclasses can be converted to parent classes t.expect(zoop.as(psuper, human) != null); t.expect(zoop.cast(psuper, human).age == 30); // the parent class cannot be converted to a subclass (if `zoop.cast` is used, a compilation error will occur) t.expect(zoop.as(phuman, superman) == null); // a parent class pointer to a subclass can be converted to a subclass phuman = zoop.cast(psuper, human); try t.expect(zoop.as(phuman, superman) != null); ```  ## define the interface ```zig // define an interface `iname` for accessing names pub const iname = struct {     // the interface can only define two fields, `ptr` and `vptr`,     // and the names and types must be the same as below     ptr: *anyopaque,     vptr: *anyopaque,      // define the `getname` interface method     pub fn getname(self: ihuman) []const u8 {         return zoop.icall(self, .getname, .{});     }     // define the `setname` interface method     pub fn setname(self: ihuman, name: []const u8) void {         zoop.icall(self, .setname, .{name});     }     // don't worry about what `zoop.icall` is, just follow it };  // define another interface `iage` for accessing age pub const iage = struct {     ptr: *anyopaque,     vptr: *anyopaque,      pub fn getage(self: ihuman) u16 {         return zoop.icall(self, .getage, .{});     }     pub fn setage(self: ihuman, age: u16) void {         zoop.icall(self, .setage, .{age});     } }  // interfaces can also be inherited pub const inameandage struct {     pub const extends = .{iname, iage};      ptr: *anyopaque,     vptr: *anyopaque, }  // can specify exclude apis. // only methods defined in this interface can be specified, // and inherited methods will not be affected. pub const inameandage struct {     pub const extends = .{iname, iage};     // exclude “eql' method     pub const excludes = .{'eql'};      ptr: *anyopaque,     vptr: *anyopaque,      pub fn eql(self: inameandage, other: inameandage) bool {         return self.ptr == other.ptr;     } }  // interfaces can also provide default implementations of methods, // so that classes that declare to implement interfaces can still // compile and work correctly without implementing these methods // (the interface becomes an abstract class) pub const iname = struct {     ...// same as above code      pub fn default(comptime class: type) type {         return struct {             pub fn getname(_: *class) []const u8 {                 return 'default name';             }         }     } } ```  ## implementing the interface ```zig // we let `human` implement the `iname` interface pub const human = struct {     pub const extends = .{iname};     ...// same as above code };  // let `superman` implement the `iage` interface pub const superman = struct {     pub const extends = .{iage};     ...//same as above code } // the interface implemented by the parent class is automatically implemented by the class, // so `superman` also implements `iname`, although it only declares that it implements `iage`. // a subclass can repeatedly declare that it implements an interface that has already been implemented  // by its parent class. this will not cause any problems and will not affect the results. // for example, the following code is equivalent to the above: pub const superman = struct {     pub const extends = .{iage, iname};     ... } ```  ## converting between classes and interfaces ```zig // first create a human and a superman var phuman = try zoop.new(t.allocator, human, .{.name = 'human'}); var psuper = try zoop.new(t.allocator, superman, .{.super = .{.name = 'super'}});  // human implements iname, so it can be converted var iname = zoop.cast(phuman, iname); // superman implements iage, so it can be transferred var iage = zoop.cast(psuper, iage); try t.expect(iage.getage() == psuper.age); try t.expectequalstrings(iname.getname(), phuman.name); // human does not implement iage, so the conversion will fail. // (note that now `iname` points to `phuman`, and `iage` points to `psuper`) try t.expect(zoop.as(phuman, iage) == null); try t.expect(zoop.as(iname, iage) == null); // now let iname point to psuper iname = zoop.cast(psuper, iname); // or you can write it like this, but the performance is a little affected // (`cast` is o(1), while `as` is o(n) in the worst case n=the number of interfaces implemented by superman) iname = zoop.as(psuper, iname).?; // now iname can be converted to iage try t.expect(zoop.as(iname, iage) != null); try t.expectequalstrings(iname.getname(), 'super'); // everything can be converted to zoop.iobject try t.expect(zoop.as(phuman, zoop.iobject) != null); try t.expect(zoop.as(psuper, zoop.iobject) != null); // can also be converted back from iobject var iobj = zoop.cast(psuper, zoop.iobject); try t.expect(zoop.as(iobj, superman).? == psuper); ``` to summarize `cast` and `as`: - `cast` is applicable     - subclass -> parent class     - sub-interface -> parent interface     - class -> interfaces implemented by the class and its parent class - `as` is applicable     - all the cases where `cast` is applicable and not applicable (everything can be `as`)  ## method overriding and virtual method calls ```zig // if superman overrides the getname method pub const superman = struct {     ...//same as above      pub fn getname(_: *superman) []const u8 {         return 'override';     } }  // now iname.getname will call superman.getname instead of human.getname var psuper = try zoop.new(t.allocator, superman, .{.super = .{.name = 'human'}}); var iname = zoop.cast(psuper, iname); try t.expectequalstrings(iname.getname(), 'override'); // another style of calling interface methods try t.expectequalstrings(zoop.vcall(psuper, iname.getname, .{}), 'override'); // virtual method calls are also useful for converted classes var phuman = zoop.cast(psuper, human); iname = zoop.cast(phuman, iname); try t.expectequalstrings(iname.getname(), 'override'); try t.expectequalstrings(zoop.vcall(phuman, iname.getname, .{}), 'override'); ``` performance notes for `vcall`: `vcall` will use `cast` when possible, and `as` otherwise  ## `zoop.iobject.formatany` for print `zoop.iobject` can conveniently output the string content of the object through the `format(...)` mechanism of `std.fmt`. ```zig // define a class that implemented `zoop.iobject.formatany` pub const someclass = struct {     name:[]const u8 align(zoop.alignment) = 'some';      pub fn formatany(self: *someclass, writer: std.io.anywriter) anyerror!void {         try writer.print('someclass.name = {s}', .{self.name});     } }  // print string from `someclass.formatany`  const psome = try zoop.new(t.allocator, someclass, null); std.debug.print('{}╲n', .{zoop.cast(psome, zoop.iobject)}); // output: someclass.name = some ```","zigster64/zig-zag-zoe":"Multiplayer TicTacToe - in Zig - using HTMX for that zero-javascript experience # zig-zag-zoe multiplayer tictactoe - in zig - using htmx for that zero-javascript experience  online demo here http://zig-zag-zoe.com  .. (running on a t4g-nano instance on aws - linux arm64, using less than 2mb memory for the whole container)  ** uses latest zig 0.12.0 official release **   ![screenshot](https://github.com/zigster64/zig-zag-zoe/blob/main/src/images/zzz-screenshot.jpg)  # install  get zig - https://ziglang.org/download/  zigzagzoe now tracks : - zig 0.12.dev from nightly builds  last successful build / test using 0.12.0-dev.2139+e025ad7b4  - http.zig #blocking branch with .hash = '1220b9cb100296f9ecbea1d5d335a074884e978c2f4fa9781cdeec47e2d222119b65',   is not currently working with the non-blocking / async branch of http.zig   ``` git clone https://github.com/zigster64/zig-zag-zoe.git cd zig-zag-zoe zig build ```  # build and run  ``` zig build  .. or  zig build run ```  now point your browsers at http://localhost:3000  .. or the equivalent address on the local network  on boot, the system will print a list of valid urls that should be able to find the game.  note that for multi-user play, you must bring up multiple browser tabs. works best if you  spawn a couple of new windows from the browser, and shrink them so they can sit side by side.   # how to play  please visit teh wiki / user manual at  https://github.com/zigster64/zig-zag-zoe/wiki/zig-zag-zoe-%e2%80%90-zero-wing-edition   ## bugs  there are a few lingering bugs that i havent got around to fixing yet.  audio support on ios + safari is a lost cause - can fix it, but it requires a lot of js code, and i figure that is outside the scope of a nice clean zig application that im trying to build here.  also appreciate any other thrashing / trying to break the application, as it all helps make the zig http ecosystem much  more robust.  thanks.  ## contributions  yep, thats cool.  just go through the regular channels  - raise an issue - post a pr  if you have questions or rfcs - you can either post them as an issue here, or discuss on zig discord.  dont be too sad if it takes > 48hr for me to respond though ... will do my best.  ## more modes and gameplay ideas  thinking up some new random modes to add to make the game harder - ideas most welcome.  - poison square ... make the grid square permanently unusable - skip ... skip the next player's turn, they miss out - reverso ... like uno reverso, reverses the order in which players take turns - team play ... allow multiple users to collab as a team - exotic victory conditions ... not just lines, but other shapes to allow victory   # whats interesting, from a code point of view ?  this code is interesting, and worth a read for the following reasons :  - its all written in zig. http://ziglang.org.  fast / safe / easy to read  - pick all 3 - it uses the excellent http.zig library https://github.com/karlseguin/http.zig to do all the web stuff. i have had exactly zero issues using this lib. - single file binary, which includes the game, a web server, all assets such as html, images and audio.  1 file - no litter on your filesystem - generated docker image = 770kb (compressed) all it has is the compiled executable (2.5mb), which includes only a single binary, nothing else. - run stats - in releasefast mode running a 2 player game, uses less than 2mb ram to run, and hardly any cpu. its pretty resource efficient. - its about as simple as doing the same thing in go, there is really nothing too nasty required in the code.   - the router, and all the html contents is part of the game object ... the implications of this are that it is possible to create 'web components' using this zig/htmx approach that are all self contained, and can be imported into other projects, without having to know about connecting up routes, or pulling in content. interesting. - uses sse / event streams to keep it all realtime with pub/sub updates for multiple players. is simple, and it works, and requires only a trivial amount of code to do. - demonstrates how to do threading, thread conditions / signalling, and using mutexes to make object updates thread safe. its a bit tricky to do cleanly still, but i guess that concurrency was never meant to be easy. its certainly no harder than doing the some concurrency in go - no websockets needed - there is pretty much no javascript on the frontend. it uses htmx https://htmx.org ... which is an alternative approach to web clients, where the frontend is pure hypertext, and everything is done on the backend - there is a tiny bit of js, to play some audio, and to update the session id, but im still thinking up a way of getting rid of that as well. - uses std.fmt.print() as the templating engine.  i didnt know before, but you can use named tags inside the comptime format string, and use those to reference fields in the args param.    actually makes for a half decent templating tool, without having to find and import a templating lib.  ie ``` response.print('i can use {[name]s} and {[address]s} in a fmt.print statement, and it references fields from the struct passed ', .{   .name = 'johnny ziggy',   .address = '22 zig street, zigville, 90210' }); ```  thats pretty good - dont really need a templating engine to do most things like that then, can just use std.fmt.print.  in fact, this is better than using a template engine, because you can store the html in actual `.html` files ... which means your editor goes into full html mode!  otherwise, need to come up with yet another jsx like thing, and then write a bunch of editor tooling to understand it.  yuk !  keep it simple i reckon, just use std.fmt, and just use `.html` files.   not sure if its worth adding a templating lib - at least to do loops and some basic flow control, because its often much much better to take the full power of a real language instead, and just emit formatted fragments.  go has a pretty comprehensive and well done text templating tool in the stdlib, but its quite a pain to use and impossible to debug when thing do go wrong, compared to doing the hard stuff in a real language.   ## htmx thoughts  yeah, its pretty cool, worth adding to your toolbelt. not sure its really a 'replacement' for spa type apps - i think it might be painful for larger apps. not sure, havnt tried yet.  what it is 100% excellent for though is for doing apps where there is a lot of shared state between users. (like a turn based game !) in that case, doing everything on the server, and not having any state at all on the frontend to sync, is really ideal.  its a good fit to this sort of problem.  its super robust. you can do horrible things like reboot the backend, or hard refresh the front end(s) ... and it maintains state without a hiccup, and without needing any exception handling code at all.  very nice. it would be a nightmare doing this in react.  there are some very complex things you could do with a turn-based-multiplayer-game type of model though (doesnt have to be a game even) and being able to do that without touching js, or writing a tonne of code to synch state on the frontends is really nice.  its also a reasonable model for doing shared state between gui frontends, just using the http/sse protocol too. its just http requests, so the networking is totally portable. ","rdunnington/zig-stable-array":"Address-stable array with a max size that allocates directly from virtual memory. # zig-stable-array address-stable array with a max size that allocates directly from virtual memory. memory is only committed when actually used, and virtual page table mappings are relatively cheap, so you only pay for the memory that you're actually using. additionally, since all memory remains inplace, and new memory is committed incrementally at the end of the array, there are no additional recopies of data made when the array is enlarged.  ideal use cases are for large arrays that potentially grow over time. when reallocating a dynamic array with a high upper bound would be a waste of memory, and depending on dynamic resizing may incur high recopy costs due to the size of the array, consider using this array type. another good use case is when stable pointers or slices to the array contents are desired; since the memory is never moved, pointers to the contents of the array will not be invalidated when growing. not recommended for small arrays, since the minimum allocation size is the platform's minimum page size. also not for use with platforms that don't support virtual memory, such as wasm.  typical usage is to specify a large size up-front that the array should not encounter, such as 2gb+. then use the array as usual. if freeing memory is desired, `shrinkandfree()` will decommit memory at the end of the array. total memory usage can be calculated with `calctotalusedbytes()`. the interface is very similar to arraylist, except for the allocator semantics. since typical heap semantics don't apply to this array, the memory is manually managed using mmap/munmap and virtualalloc/virtualfree on nix and windows platforms, respectively.  usage: ```zig var array = stablearray(u8).init(1024 * 1024 * 1024 * 128); // virtual address reservation of 128 gb try array.appendslice(&[_]u8{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); assert(array.calctotalusedbytes() == mem.page_size); for (array.items) |v, i| {     assert(v == i); } array.shrinkandfree(5); assert(array.calctotalusedbytes() == mem.page_size); array.deinit(); ``` ","scemino/z_impact":"A 2d game engine written in ZIG [![build](https://github.com/scemino/z_impact/actions/workflows/main.yml/badge.svg)](https://github.com/scemino/z_impact/actions/workflows/main.yml)      ███████╗    ██╗███╗   ███╗██████╗  █████╗  ██████╗████████╗     ╚══▓▓▓╔╝    ▓▓║▓▓▓▓╗ ▓▓▓▓║▓▓╔══▓▓╗▓▓╔══▓▓╗▓▓╔════╝╚══▓▓╔══╝       ▒▒▒╔╝     ▒▒║▒▒╔▒▒▒▒╔▒▒║▒▒▒▒▒▒╔╝▒▒▒▒▒▒▒║▒▒║        ▒▒║         ░░░╔╝      ░░║░░║╚░░╔╝░░║░░╔═══╝ ░░╔══░░║░░║        ░░║        ░░░░░░░╗    ░░║░░║ ╚═╝ ░░║░░║     ░░║  ░░║╚░░░░░░╗   ░░║        ╚══════╝    ╚═╝╚═╝     ╚═╝╚═╝     ╚═╝  ╚═╝ ╚═════╝   ╚═╝         ░░░░▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓██████████████▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒░░░░╗     ╚═════════════════════════════════════════════════════════╝                                                             z impact is a zig game engine for creating 2d action games. it's well suited for jump'n'runs, twin stick shooters, top-down dungeon crawlers and others with  a focus on pixel art.  this is not a general purpose game engine akin to godot, unreal or unity. at this stage, it is also quite experimental and lacking documentation. expect problems.  z impact is more a framework than it is a library, meaning that you have to adhere to a structure, in code and file layout, that is prescribed by the  engine. you do not call z impact, z impact _calls you_.  games made with z impact can be compiled for linux, macos, windows (through the usual hoops) and for the web with wasm. there are currently two 'platform backends': sdl2 & sokol and different renderers: for sdl2 platform: opengl and for sokol: one renderer by os: opengl (linux), metal (mac os), direct-x (windows).  z impact is a port of the orginal game engine [high_impact](https://github.com/phoboslab/high_impact/tree/master) made by phoboslab.  ## examples  - [biolab disaster](https://github.com/scemino/z_biolab): a jump'n'gun  platformer, displaying many of z impacts capabilities. - [drop](https://github.com/scemino/z_impact/tree/main/samples/zdrop): a minimal arcade game with randomly generated levels   ## compiling  to compile and run the sample game drop  ### linux - windows - macos  sdl2 platform + opengl renderer  ```shell zig build run ```  sdl2 platform + software renderer  ```shell zig build -dplatform=sdl_soft run ```  sokol platform ```shell zig build -dplatform=sokol run ```  ### web  ```shell zig build -dtarget=wasm32-emscripten run  ```  ## documentation  there's not much at the moment. most of z impact's functionality is  documented in the header files with this readme giving a general overview. it's best to read [the blog post](https://phoboslab.org/log/2024/08/high_impact) for an overview and the source for all the details.   ## assets  at this time, z impact can only load images in qoi format and sounds & music  in qoa format. the tools to convert png to qoi and wav to qoa are bundled in  this repository and can be integrated in your build step.  game levels can be loaded from .json files. a tile editor to create these levels is part of z impact: `weltmeister.html` which can be launched with a simple double click from your local copy.  ## libraries used  - sokol app, audio and time: https://github.com/floooh/sokol-zig - stb_image.h and stb_image_write.h https://github.com/nothings/stb - qoi image format: https://github.com/phoboslab/qoi - qoa audio format: https://github.com/phoboslab/qoa - sdl.zig: https://github.com/ikskuh/sdl.zig  ## license  all z impact code is mit licensed, though some of the libraries  come with their own (permissive) license. check the header files. ","nektro/zig-ansi":"ANSI utilities for CLI usage in Zig. # zig-ansi ![loc](https://sloc.xyz/github/nektro/zig-ansi) [![license](https://img.shields.io/github/license/nektro/zig-ansi.svg)](https://github.com/nektro/zig-ansi/blob/master/license) [![discord](https://img.shields.io/discord/551971034593755159.svg?logo=discord)](https://discord.gg/p6y4zqc)  ansi utilities for cli usage in zig.  ## zig - https://ziglang.org/ - https://github.com/ziglang/zig - https://github.com/ziglang/zig/wiki/community  ## getting started using https://github.com/nektro/zigmod, add a `git` type with a path of `https://github.com/nektro/zig-ansi`.  ## usage see `src/main.zig` or do `zig build run` to see examples.  see `src/lib.zig` for source code.  ## built with - zig 0.7.0  ## contact - hello@nektro.net - https://twitter.com/nektro  ## license mit ","mattnite/zig-libcurl":"compile libcurl in your build.zig # libcurl build package  [![ci](https://github.com/mattnite/zig-libcurl/actions/workflows/ci.yml/badge.svg)](https://github.com/mattnite/zig-libcurl/actions/workflows/ci.yml)  ## like this project?  if you like this project or other works of mine, please consider [donating to or sponsoring me](https://github.com/sponsors/mattnite) on github [:heart:](https://github.com/sponsors/mattnite)  ## how to use  this repo contains code for your `build.zig` that can statically compile libcurl, as well as some idiomatic zig bindings for libcurl that you can use in your application. in either case below you will be able to include libcurls header with:  ```zig const c = @cimport({     @cinclude('curl/curl.h'); }); ```  ### link and add bindings to your application  in order to statically link libcurl into your application and access the bindings with a configurable import string:  ```zig const libcurl = @import('path/to/libcurl.zig');  pub fn build(b: *std.build.builder) void {     // ...      const lib = libcurl.create(b, target, optimize);      const exe = b.addexecutable(.{         .name = 'my-program',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     const exe = b.addexecutable('my-program', 'src/main.zig');     lib.link(exe, .{ .import_name = 'curl' }); } ```  now code that is part of the `my-program` executable can import the libcurl bindings with `@import('curl')`.  ### only link to your application  in order to just link to the application, all you need to do is omit the `.import_name = 'curl'` argument to libcurl's link options:  ```zig     lib.link(exe, .{}); ``` ","Vexu/comptime_hash_map":"A statically initiated HashMap # comptime hashmap  a statically initiated hashmap, originally a pull request to the zig std lib [#5359](https://github.com/ziglang/zig/pull/5359).  ## installation  build for zig `0.13.0`.  ```sh zig fetch --save git+https://github.com/vexu/comptime_hash_map ```  in your `build.zig`: ```zig const chm = b.dependency('comptime_hash_map', .{}); exe.root_module.addimport('comptime_hash_map', chm.module('comptime_hash_map')); ```  in your `exe` module: ```zig const chm = @import('comptime_hash_map'); ``` ","ziglibs/string-searching":"String(not limited to []const u8)-searching algorithms in zig # string-searching  ![ci](https://github.com/ziglibs/zig-string-searching/workflows/ci/badge.svg)  implementation of some string-search algorithms in [zig](https://ziglang.org). compatible with zig 0.13.0.  ### boyer-moore string searching  ported from the implementation in the go standard library: [strings/search.go](https://golang.org/src/strings/search.go).  ### bitap algorithm  inspired by the code on the [wikipedia article](https://en.wikipedia.org/wiki/bitap_algorithm). ","jedisct1/zig-rocca-s":"An implementation of the ROCCA-S encryption scheme. # rocca-s: an efficient aes-based encryption scheme  this is an implementation of [rocca-s: an efficient aes-based encryption scheme for beyond 5g](https://www.ietf.org/archive/id/draft-nakano-rocca-s-05.html), a very fast authenticated encryption scheme optimized for platforms with aes-ni or arm crypto extensions.  rocca-s has a 256 bit key size, a 128 bit nonce, processes 256 bit message blocks and outputs a 256 bit authentication tag.  **warning:** this implementation is for benchmarking and testing purposes only. ","nektro/zig-tracer":"Generic tracing library for Zig, supports multiple backends. # zig-tracer  generic tracing library for zig, supports multiple backends.  ## install  - supports zigmod - supports zig package manager  ## usage  in your program:  ```zig const std = @import('std'); const tracer = @import('tracer'); pub const build_options = @import('build_options');  pub const tracer_impl = tracer.spall; // see 'backends' section below  pub fn main() !void {     try tracer.init();     defer tracer.deinit();      // main loop     while (true) {         try tracer.init_thread();         defer tracer.deinit_thread();          handler();     } }  fn handler() void {     const t = tracer.trace(@src());     defer t.end(); } ```  `@src()` values are sometimes absolute paths so backends may use this value to trim it to only log relative paths  ```zig exe_options.addoption(usize, 'src_file_trimlen', std.fs.path.dirname(std.fs.path.dirname(@src().file).?).?.len); ```  ## backends  - `none` this is the default and causes tracing calls to become a no-op so that `tracer` can be added to libraries transparently - `log` uses `std.log` to print on function entrance. - `chrome` writes a json file in the `chrome://tracing` format described [here](https://docs.google.com/document/d/1cvaclvffya5r-phyumn5ooqtymh4h6i0nsskchnaysu/preview) and [here](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/). - `spall` writes a binary file compatible with the [spall](https://gravitymoth.com/spall/) profiler. - more? feel free to open an issue with requests!  any custom backend may also be used that defines the following functions:  - `pub fn init() !void` - `pub fn deinit() void` - `pub fn init_thread(dir: std.fs.dir) !void` - `pub fn deinit_thread() void` - `pub inline fn trace_begin(ctx: tracer.ctx, comptime ifmt: []const u8, iargs: anytype) void` - `pub inline fn trace_end(ctx: tracer.ctx) void`  ## license  mit ","dweiller/zubench":"Micro benchmarking in zig # zubench  a micro-benchmarking package for [zig](https://ziglang.org).  ## goals  the primary goals of **zubench** are to:    - be simple to use - there should be no need to wrap a function just to benchmark it   - provide standard machine-readable output for archiving or post-processing   - given the user the choice of which system clock(s) to use   - provide statistically relevant and accurate results   - integrate with the zig build system  not all these goals are currently met, and its always possible to debate how well they are met; feel free to open an issue (if one doesn't exist) or pull request if you would like to see improvement in one of these areas.  ## features    - [x] human-readable terminal-style output   - [x] machine-readable json output   - [x] wall, process, and thread time   - [ ] kernel/user mode times   - [x] declarative `zig test` style benchmark runner   - [x] option to define benchmarks as zig tests   - [ ] adaptive sample sizes   - [x] [mad](https://en.wikipedia.org/wiki/median_absolute_deviation)-based outlier rejection  ## platforms  some attempt has been made to work on the below platforms; those with a '️️️️️⚠️' in the table below haven't been tested, but _should_ work for all implemented clocks. windows currently only has the wall time clock implemented. if you find a non-linux platform either works or has issues please raise an issue.  | platform | status | | :------: | :----: | |   linux  |   ✅   | |  windows |   ❗   | |  darwin  |   ⚠️    | |    bsd   |   ⚠️    | |   wasi   |   ⚠️    |  ## usage  the *main* branch follows zig's master branch, for zig 0.12 use the *zig-0.12* branch.  the simplest way to create and run benchmarks is using one of the zig build system integrations. there are currently two integrations, one utilising the zig test system, and one utilising public declarations.  both integrations will compile an executable that takes a collection of functions to benchmark, runs them repeatedly and reports timing statistics. the differences between the two integrations are how you define benchmarks in your source files, and how benchmarking options are determined.  ### test integration the simplest way to define and run benchmarks is utilising the zig test system. **zubench** will use a custom test runner to run the benchmarks. this means that benchmarks are simply zig tests, i.e. `test { // code to benchmark }`. in order to avoid benchmarking regular tests when using this system, you should consider the way that zig analyses test declarations and either give the names of benchmark tests a unique substring that can be used as a test filter or organise your tests so that when the compiller analyses the root file for benchmark tests, it will not analyse regular tests.  the following snippets show how you can use this integration. ```zig const addtestbench = @import('zubench/build.zig').addtestbench;  pub fn build(b: *std.build.builder) void {     // existing build function     // ...      // benchmark all tests analysed by the compiler rooted in 'src/file.zig', compiled in releasesafe mode     const benchmark_exe = zubench.addtestbench(b, 'src/file.zig', .releasesafe);     // use a test filter to only benchmark tests whose name include the substring 'bench'     // note that this is not required if the compiler will not analyse tests that you don't want to benchmark     benchmark_exe.settestfilter('bench');      const bench_step = b.step('bench', 'run the benchmarks');     bench_step.dependon(&benchmark_exe.run().step); } ``` this will make `zig build bench` benchmark tests the compiler analyses by starting at `src/file.zig`. `addtestbench()` returns a `*libexeobjstep` for an executable that runs the benchmarks; you can integrate it into your `build.zig` however you wish. benchmarks are `test` declarations the compiler analyses staring from `src/file.zig`: ```zig // src/file.zig  test 'bench 1' {     // this will be benchmarked     // ... }  test 'also a benchmark' {     // this will be benchmarked     // ... }  test {     // this will be benchmarked     // the test filter is ignored for unnamed tests     // ... }  test 'regular test' {     // this will not be benchmarked     return error.notabenchmark; } ```  ### public decl integration this integration allows for fine-grained control over the execution of benchmarks, allowing you to specify various options as well as benchmark functions that take parameters.  the following snippets shows how you can use this integration. ```zig // build.zig  const addbench = @import('zubench/build.zig').addbench;  pub fn build(b: *std.build.builder) void {     // existing build function     // ...      // benchmarks in 'src/file.zig', compiled in releasesafe mode     const benchmark_exe = addbench(b, 'src/file.zig', .releasesafe);      const bench_step = b.step('bench', 'run the benchmarks');     bench_step.dependon(&benchmark_exe.run().step); } ``` this will make `zig build bench` run the benchmarks in `src/file.zig`, and print the results. `addbench()` returns a `*libexeobjstep` for an executable that runs the benchmarks; you can integrate it into your `build.zig` however you wish. benchmarks are specified in `src/file.zig` by creating a `pub const benchmarks` declaration: ```zig // add to src/file.zig  // the zubench package const bench = @import('src/bench.zig'); pub const benchmarks = .{     .@'benchmark func1' = bench.spec(func1){ .args = .{ arg1, arg2 }, .max_samples = 100 },     .@'benchmark func2' = bench.spec(func2){         .args = .{ arg1, arg2, arg3 },         .max_samples = 1000,         .opts = .{ .outlier_detection = .none }}, // disable outlier detection } ```  the above snippet would cause two benchmarks to be run called 'benchmark func1' and 'benchmark func2' for functions `func1` and `func2` respectively. the `.args` field of a `spec` is a `std.meta.argstuple` for the corresponding function, and `.max_samples` determines the maximum number of times the function is run during benchmarking. a complete example can be found in `examples/fib_build.zig`.  it is also relatively straightforward to write a standalone executable to perform benchmarks without using the build system integration. to create a benchmark for a function `func`, run it (measuring process and wall time) and obtain a report, all that is needed is  ```zig var progress = std.progress.start(.{}); var bm = try benchmark(func).init(allocator, 'benchmark name', .{ func_arg_1, … }, .{}, max_samples, progress); const report = bm.run(); bm.deinit(); ```  the `report` then holds a statistical summary of the benchmark and can used with `std.io.writer.print` (for terminal-style readable output) or `std.json.stringify` (for json output). see `examples/` for complete examples.  ### custom exectuable  it is also possible to write a custom benchmarking executable using **zubench** as a dependency. there is a simple example of this in `examples/fib2.zig` or, you can examine `src/bench_runner.zig`.  ## examples  examples showing some ways of producing and running benchmarks can be found the `examples/` directory. each of these files are built using the root `build.zig` file. all examples can be built using `zig build examples` and they can be run using `zig build run`.  ## status  **zubench** is in early development—the api is not stable at the moment and experiments with the api are planned, so feel free to make suggestions for the api or features you would find useful. ","karlseguin/smtp_client.zig":"SMTP client for Zig 404: not found","kassane/libvlc-zig":"Zig bindings for libVLC media framework. <h1 align='center'>   <div>     <img src='.github/logo.png' alt='libvlc-zig logo'/>   </div> </h1> <p align='center'>     <a href='https://github.com/kassane/libvlc-zig/actions/workflows/linux.yml'>         <img alt='build linux status' src='https://github.com/kassane/libvlc-zig/actions/workflows/linux.yml/badge.svg'>     </a>     <a href='https://github.com/kassane/libvlc-zig/actions/workflows/darwin.yml'>         <img alt='build macos status' src='https://github.com/kassane/libvlc-zig/actions/workflows/darwin.yml/badge.svg'>     </a>     <a href='https://github.com/kassane/libvlc-zig/actions/workflows/mingw.yml'>         <img alt='build mingw status' src='https://github.com/kassane/libvlc-zig/actions/workflows/mingw.yml/badge.svg'>     </a>     <a href='https://opensource.org/licenses/bsd-2-clause' rel='nofollow'>         <img alt='bsd 2 clause license' src='https://img.shields.io/github/license/kassane/libvlc-zig'/>     </a>     <a href='https://github.com/kassane/libvlc-zig/graphs/contributors'>         <img alt='github contributors' src='https://img.shields.io/github/contributors/kassane/libvlc-zig' />     </a> </p>  # libvlc-zig  zig bindings for libvlc media framework. some of the features provided by libvlc include the ability to play local files and network streams, as well as to transcode media content into different formats. it also provides support for a wide range of codecs, including popular formats like h.264, mpeg-4, and aac.  ## requirements  - [zig v0.11.0 or higher](https://ziglang.org/download) - [vlc](https://code.videolan.org/videolan/vlc)  ## how to use  ### example  ```bash $> zig build run -doptimize=releasesafe # print-version (default) $> zig build run -dexample='cliplayer-{c,cpp,zig}' -doptimize=releasesafe -- -i /path/multimedia_file ```  ## how to contribute to the libvlc-zig project?  read [contributing](contributing.md).   ## faq   ### q: why isn't libvlc-zig licensed under **lgplv2.1**?   a: the decision to license `libvlc-zig` under the **bsd-2 clause** was made by the author of the project. this license was chosen because it allows for more permissive use and distribution of the code, while still ensuring that the original author receives credit for their work.  `libvlc-zig` respects the original **lgplv2.1** (lesser general public license) license of the vlc project.   ### q: are you connected to the developers of the original project?   a: no, the author of `libvlc-zig` is not part of the **videolan development team**. they are simply interested in being part of the vlc community and contributing to its development.   ### q: what is the main goal of this project?   a: the main goal of `libvlc-zig` is to provide a set of bindings for the **vlc media player's** libvlc library that are written in the **zig programming language**. the project aims to provide a more modern and safe way to interface with the library, while maintaining compatibility with existing code written in **c** and **c++**.   ### q: does libvlc-zig aim to replace libvlc?   a: no, `libvlc-zig` does not aim to replace libvlc. instead, it provides an alternative way to interface with the library that may be more suitable for zig developers.   ### q: can i use libvlc-zig in my project?   a: yes, you can use `libvlc-zig` in your project as long as you comply with the terms of the **bsd-2 clause** license. this includes giving credit to the original author of the code.   ### q: does libvlc-zig support all of the features of libvlc?   a: `libvlc-zig` aims to provide bindings for all of the features of libvlc, but it may not be complete or up-to-date with the latest version of the library. if you encounter any missing features or bugs, please report them to the project's github issues page.   ### q: what programming languages are compatible with libvlc-zig?   a: `libvlc-zig` provides bindings for the **zig programming language**, but it can also be used with **c** and **c++** projects that use the libvlc library.    ## license  ``` bsd 2-clause license  copyright (c) 2022, matheus catarino frança  redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  1. redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.  2. redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution. ``` ","tiawl/cimgui.zig":"dear imgui packaged for @ziglang # cimgui.zig  this is a fork of [ocornut/imgui][1] packaged for [zig][2]  ## why this fork ?  the intention under this fork is to package [ocornut/imgui][1] for [zig][2]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`, * [dearimgui/dear_bindings][3] generates the c binding, * a cron runs every day to check [ocornut/imgui][2] and [dearimgui/dear_bindings][3]. then it updates this repository if a new release is available.  ## how to use it  the goal of this repository is not to provide a [zig][2] binding for [ocornut/imgui][1]. there are at least as many legit ways as possible to make a binding as there are active accounts on github. so you are not going to find an answer for this question here. the point of this repository is to abstract the [ocornut/imgui][1] compilation process with [zig][2] (which is not new comers friendly and not easy to maintain) to let you focus on your application. so you can use **cimgui.zig**: - as raw (see the [examples directory](https://github.com/tiawl/cimgui.zig/blob/trunk/examples)), - as a daily updated interface for your [zig][2] binding of [ocornut/imgui][1] (see [here][13] for a private usage).  ## backends  currently only [glfw][4] and [vulkan][5] backends are supported. there will be no other backends **if you are not ready to maintain backends you want to use**. the team is not interested to maintain backends nobody uses. if you want to see a new backend available on this repository and you are ready for this, open an issue: we will be happy to talk with you and how we could manage this together.  ## dependencies  the [zig][2] part of this package is relying on the latest [zig][2] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [ocornut/imgui](https://github.com/tiawl/cimgui.zig/blob/trunk/.references/imgui)  currently there are no tags/release for [dearimgui/dear_bindings][3] so **cimgui.zig** is relying on the last commit.  for backends see [the build.zig.zon](https://github.com/tiawl/cimgui.zig/blob/trunk/build.zig.zon)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/spaceporn][6]  this repository is automatically updated when a new release is available from these repositories: * [ocornut/imgui][1] * [dearimgui/dear_bindings][3] * [tiawl/toolbox][7] * [tiawl/glfw.zig][8] * [tiawl/spaceporn-action-bot][9] * [tiawl/spaceporn-action-ci][10] * [tiawl/spaceporn-action-cd-ping][11] * [tiawl/spaceporn-action-cd-pong][12]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch     update .references folder and build.zig.zon then stop execution   -dupdate    update binding   -drenderer  specify the renderer backend                 supported values:                   vulkan   -dplatform  specify the platform backend                 supported values:                   glfw ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/ocornut/imgui [2]:https://github.com/ziglang/zig [3]:https://github.com/dearimgui/dear_bindings [4]:https://github.com/glfw/glfw [5]:https://github.com/khronosgroup/vulkan-headers [6]:https://github.com/tiawl/spaceporn [7]:https://github.com/tiawl/toolbox [8]:https://github.com/tiawl/glfw.zig [9]:https://github.com/tiawl/spaceporn-action-bot [10]:https://github.com/tiawl/spaceporn-action-ci [11]:https://github.com/tiawl/spaceporn-action-cd-ping [12]:https://github.com/tiawl/spaceporn-action-cd-pong [13]:https://github.com/tiawl/spaceporn/blob/trunk/src/spaceporn/bindings/imgui/imgui.zig ","jdknezek/uuid6-zig":"UUIDv6 implemented in Zig # uuid6-zig    this is a prototype [uuidv6](https://github.com/uuid6/uuid6-ietf-draft) draft 03 implementation in [zig](https://github.com/ziglang/zig). it also includes versions 1 & 3-5 for comparison.    ## installation    the library is contained entirely in `src/uuid.zig`. feel free to copy and customize or clone it as a submodule.    it targets zig `master` and may not work on the latest release.    ### adding to your build.zig    ```zig  liborexe.addpackagepath('uuid6', 'path/to/uuid6-zig/src/uuid.zig');  ```    ## usage    there are namespaces for the various uuid versions, `v1`, `v3` - `v7`. each has a `create(...)` method to create a single uuid, or a `source` that can be used to create many with shared parameters and/or state.    sources are not thread-safe and should be protected with a mutex.    ### example    ```zig  const std = @import('std');  const uuid = @import('uuid6');    pub fn main() anyerror!void {      var rng = std.rand.defaultprng.init(0);      const source = uuid.v4.source.init(&rng.random);        var i: usize = 0;      while (i < 10) : (i += 1) {          const uuid = source.create();          std.debug.print('{}╲n', .{uuid});      }  }  ```    see also `examples/bench`.    ## performance    the following tables were generated by [hyperfine](https://github.com/sharkdp/hyperfine) running `examples/bench`.    note that the times are for 1e7 uuids, so for example each v4 takes ~12ns, and each v3 takes ~99ns.    ### thread-safe    | command | mean [ms] | min [ms] | max [ms] | relative |  |:---|---:|---:|---:|---:|  | `bench -n 10000000 -v 1` | 232.4 ± 1.5 | 230.6 | 235.7 | 1.83 ± 0.02 |  | `bench -n 10000000 -v 3` | 998.9 ± 2.9 | 995.7 | 1004.7 | 7.88 ± 0.09 |  | `bench -n 10000000 -v 4` | 126.8 ± 1.3 | 123.7 | 129.7 | 1.00 |  | `bench -n 10000000 -v 5` | 740.7 ± 2.6 | 736.6 | 743.9 | 5.84 ± 0.06 |  | `bench -n 10000000 -v 6` | 189.1 ± 1.1 | 187.3 | 191.6 | 1.49 ± 0.02 |  | `bench -n 10000000 -v 7` | 206.7 ± 1.6 | 204.3 | 209.7 | 1.63 ± 0.02 |    ### single-threaded    | command | mean [ms] | min [ms] | max [ms] | relative |  |:---|---:|---:|---:|---:|  | `bench -n 10000000 -v 1` | 229.7 ± 0.9 | 228.3 | 231.3 | 1.89 ± 0.02 |  | `bench -n 10000000 -v 3` | 1005.7 ± 17.4 | 998.5 | 1054.9 | 8.27 ± 0.17 |  | `bench -n 10000000 -v 4` | 121.7 ± 1.3 | 119.8 | 125.7 | 1.00 |  | `bench -n 10000000 -v 5` | 747.8 ± 8.9 | 737.0 | 760.2 | 6.15 ± 0.10 |  | `bench -n 10000000 -v 6` | 151.6 ± 1.0 | 150.0 | 153.9 | 1.25 ± 0.02 |  | `bench -n 10000000 -v 7` | 203.4 ± 1.4 | 201.4 | 206.4 | 1.67 ± 0.02 |    environment:  - os: windows 10  - cpu: amd ryzen 5 5600x  - build mode: `release-fast`  ","deckarep/zigualizer":"Zigualizer: A music visualizer built with Zig, powered by the FFT algorithm. # zigualizer zigualizer: a music visualizer built with zig, powered by the fft algorithm. [click here](https://youtu.be/6h9bty-wdma) for a demo on youtube!  ![](screenshot.png)  ## details this implementation was originally based on the [musializer project by @tsoding](https://github.com/tsoding/musializer/blob/master/src/plug.c). this version as it stands has been tested to work with raylib 5.0. i have modified this version to be backed by a generic circular buffer over a  fixed size array. additionally, i am leveraging comptime in a few spots to generate some static windowing functions.  ## raylib integration for a more thorough example see raylib.zig in the examples/ folder. integration is a 4-step process (aside from music stream code).  ```zig // 1. import const fft = @import('zigualizer');  // 2. init fft.fft_analyzer.reset();  // after loading up a raylib music stream. track = c.loadmusicstream(pathtotrack); defer c.unloadmusicstream(track);  // 3. attach c.attachaudiostreamprocessor(track.stream, fft.fft_analyzer.fft_process_callback); c.playmusicstream(track);  // in your update loop fn update() void {     c.updatemusicstream(track);     // 4. analyze     frames = fft.fft_analyzer.analyze(c.getframetime()); }  // in your draw loop render the fft however you like! fn draw() void {     c.begindrawing();     defer c.enddrawing();     c.clearbackground(c.black);          // 5. draw     renderfft(400, 200); } ```  ## building the examples ```sh # run the raylib demo. zig build -dexample-name=raylib.zig && zig-out/example/raylib ``` ","jedisct1/zig-eddsa-key-blinding":"A Zig implementation of EdDSA signatures with blind keys. # eddsa signatures with blind keys  a zig implementation of the [eddsa key blinding](https://chris-wood.github.io/draft-wood-cfrg-eddsa-blinding/draft-wood-cfrg-eddsa-blinding.html) proposal.  ```zig     // create a standard ed25519 key pair     const kp = try ed25519.keypair.create(null);      // create a random blinding seed     var blind: [32]u8 = undefined;     crypto.random.bytes(&blind);      // blind the key pair     const blind_kp = try blinded25519.blind(kp, blind);      // sign a message and check that it can be verified with the blind public key     const msg = 'test';     const sig = try blinded25519.sign(msg, blind_kp, null);     try ed25519.verify(sig, msg, blind_kp.blind_public_key);      // unblind the public key     const pk = try blinded25519.unblind_public_key(blind_kp.blind_public_key, blind);     try std.testing.expectequalslices(u8, &pk, &kp.public_key); ``` ","allyourcodebase/pipewire":"pipewire ported to the zig build system # pipewire  pipewire client library, ported to the zig build system.  ## motivation  i want a static executable that can play audio. i have this working already with libsoundio, however, it is via the pulseaudio client library. i thought it would be nice to use pipewire directly on systems that use it.  ## status  i got the audio-src example compiling and running, however, it turns out the pipewire protocol only works via `dlopen`, making it a non-starter for static executables.  therefore, i will not be pursuing this project any further. ","lawrence-laz/zig-enumerable":"Iterator tools for functional data processing. # zig enumerable ⚡  functional vibes for data processing as sequences.  ```zig const std = @import('std'); const enumerable = @import('enumerable');  test 'example' {     try expectequaliter(         '(1,2,3)',         enumerable.from(std.mem.tokenizeany(u8, 'foo=1;bar=2;baz=3', '=;').buffer)             .where(std.ascii.isdigit)             .intersperse(',')             .prepend('(')             .append(')'),     ); } ```  ## 📦 get started  ```bash zig fetch --save https://github.com/lawrence-laz/zig-enumerable/archive/master.tar.gz ```  ```zig // build.zig const enumerable = b.dependency('enumerable', .{     .target = target,     .optimize = optimize, });  exe.root_module.addimport('enumerable', enumerable.module('enumerable')); ```  ","nektro/gimme":"A yummy collection of useful Allocators. # gimme  `gimme` is a yummy collection of useful `allocator`s.  check out [`src/lib.zig`](src/lib.zig) for more. ","ATTron/astroz":"Astrodynamics and Spacecraft Toolkit Written in Zig! Features orbit prop, celestial precession, CCSDS parsing, RF parsing, fits image parsing, and more! # astroz  [![ci][ci-shd]][ci-url] [![cd][cd-shd]][cd-url] [![dc][dc-shd]][dc-url]  <img src='https://repository-images.githubusercontent.com/819657891/291c28ef-4c03-4d0e-bb0c-41d4662867c3' width='100' height='100'/>  ## astronomical and spacecraft toolkit written in zig for zig!  ### features / plans  #### spacecraft  - [x] ccsds packets   - [x] ccsds stream parser - [x] vita49 packets   - [x] vita49 stream parser - [x] tle support   - [x] orbital propagation     - [x] rk4   - [x] orbital maneuvers     - [x] impulse maneuvers     - [x] phase maneuvers     - [x] plane change maneuvers - [x] orientation determination  #### astronomical  - [x] astronomical references   - [x] j2000 and jd   - [x] celestial bodies     - [x] mass     - [x] radius     - [x] orbital details - [x] astronomical coordinates   - [x] equatorial coordinate system   - [x] world coordinate system - [x] astronomical computation   - [x] precession - [x] celestial bodies - [ ] orbital mechanics   - [ ] interplanetary maneuvers - [ ] fits file parsing - broken due to zigimg dependency breaking on main   - [x] image generation     - [ ] multi image parsing/generation   - [x] table parsing  ### feature not listed ?  to request a feature, please create an issue for this project and i will try my best to be responsive.  ### usage  - add `astroz` as a dependency in your `build.zig.zon`.  ```sh zig fetch --save https://github.com/attron/astroz/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `astroz` as a module in your `build.zig`.  ```zig const astroz_dep = b.dependency('astroz', .{     .target = target,     .optimize = optimize, }); const astroz_mod = astroz_dep.module('astroz'); exe.root_module.addimport('astroz', astroz_mod); ```  ### examples  - #### [parse tle](examples/parse_tle.zig)  - #### [orbit prop for next 3 days](examples/orbit_prop.zig)  <img src='assets/orbit_prop.gif' width='450' height='400' alt='visualization of orbit prop'/>  - #### [orbit prop for next 3 days with impulse maneuvers](examples/orbit_prop_impulse_manuevers.zig)  <img src='assets/orbit_prop_impulse.gif' width='450' height='400' alt='visualization of orbit prop with impulse'/>  - #### [orbit plane change](examples/orbit_plane_change.zig)  - #### [orbit phase change](examples/orbit_phase_change.zig)  - #### [orbit orientation determination](examples/simple_spacecraft_orientation.zig)  - #### [parse vita49](examples/parse_vita49.zig)  - #### [parse vita49 with callback](examples/parse_vita49_callback.zig)  - #### [parse ccsds from file](examples/parse_ccsds.zig)  - #### [parse ccsds from file with file sync](examples/parse_ccsds_file_sync.zig)  - #### [create ccsds packet](examples/create_ccsds_packet.zig)  - #### [create ccsds packet with config](examples/create_ccsds_packet_config.zig)  **note this is currently broken due to zigimg dependency breaking on the main branch**  - #### [generate image from fits file](examples/parse_fits_file.zig)  <img src='test/test.png' width='450' height='400' alt='sample fits image as png'/>  - #### [precess star to july 30, 2005](examples/precess_star.zig)  - #### [calculate wcs values from a tle](examples/wcs.zig)  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/attron/astroz/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/attron/astroz/blob/main/.github/workflows/ci.yaml [cd-shd]: https://img.shields.io/github/actions/workflow/status/attron/astroz/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/attron/astroz/blob/main/.github/workflows/cd.yaml [dc-shd]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=doc&labelcolor=black [dc-url]: https://attron.github.io/astroz ","dmgk/zig-uuid":"Fast, allocation-free v4 UUIDs in Zig # fast, allocation-free v4 uuids in zig  ## example  ```zig const std = @import('std'); const uuid = @import('uuid.zig').uuid;  pub fn main() !void {     // generate     const uuid1 = uuid.init();     std.debug.print('{}╲n', .{uuid1});      // parse     const uuid2 = try uuid.parse('3df6f0e4-f9b1-4e34-ad70-33206069b995');     std.debug.print('{}╲n', .{uuid2}); } ```  ``` $ zig run example.zig  78c33481-4c67-4202-ba8d-11ee1dfaad24 3df6f0e4-f9b1-4e34-ad70-33206069b995 ```  ### tests ```bash zig test uuid.zig ``` ```bash test [3/3] test.check to_string works...  first  call to_string 851d0256-c62c-43b0-bf15-71da00bafb30  second call to_string 851d0256-c62c-43b0-bf15-71da00bafb30  all 3 tests passed. ```","ikskuh/zig-assimp":"Open Asset Importer Library built with Zig # openassetimporter library binding for zig  this repo is a build sdk for [assimp](https://github.com/assimp/assimp) to be used with the zig build system:  ```zig const std = @import('std');  // import the sdk const assimp = @import('sdk.zig');  pub fn build(b: *std.build.builder) void {     const mode = b.standardreleaseoptions();      const exe = b.addexecutable('static-example', null);     exe.setbuildmode(mode);     exe.addcsourcefile('src/example.cpp', &[_][]const u8{'-std=c++17'});     exe.linklibc();     exe.linklibcpp();     exe.install();          // create a new instance     var sdk = assimp.init(b);      // and link assimp statically to our exe and enable a default set of     // formats.     sdk.addto(exe, .static, assimp.formatset.default); } ```","freakmangd/zentig_ecs":"Zig ECS library # zentig_ecs a zig ecs library.   zentig is designed for scalability and ease of use, while staying out of your way. it's heavily inspired by everything that makes [bevy_ecs](https://github.com/bevyengine/bevy) so great and [unity](https://unity.com/) so approachable.  ##### warning: it is not recommended to use zentig for anything major in it's current state. while it is functional and i use it frequently, it is far from battle tested.  that being said, if you encounter any problems please feel free to open an issue!  ## installation fetching for zig master: ``` zig fetch --save git+https://github.com/freakmangd/zentig_ecs ```  fetching for zig 0.13.0: ``` zig fetch --save https://github.com/freakmangd/zentig_ecs/archive/refs/tags/0.13.0.tar.gz ```  in both cases, place this in your `build.zig`: ```zig const zentig = b.dependency('zentig-ecs', .{}); exe.root_module.addimport('ztg', zentig.module('zentig')); ```  and import it in your project: ```zig const ztg = @import('ztg'); ```  ## overview an entity is just a `usize`: ```zig pub const entity = usize; ```  a basic component: ```zig pub const player = struct {   name: []const u8, }; ```  a basic system: ```zig pub fn playerspeak(q: ztg.query(.{player})) !void {   for (q.items(0)) |plr| {     std.debug.print('my name is {s}╲n', .{self.name});   } } ```  registering systems/components into a world: ```zig const myworld = blk: {   var wb = ztg.worldbuilder.init(&.{});   wb.addcomponents(&.{player});   wb.addsystemstostage(.update, playerspeak);   break :blk wb.build(); }; ```  calling systems is easily integratable into your game framework: ```zig test 'running systems' {   var world = myworld.init(testing.allocator);   defer world.deinit();    try world.runstage(.load);   try world.runupdatestages();   try world.runstage(.draw);      // support for user defined stages   try world.runstagelist(&.{ .post_process, .pre_reset, .post_mortem }); } ```  ## scalability the `.include()` function in `worldbuilder` makes it easy to compartmentalize your game systems. as well as integrate third party libraries with only one extra line!  `main.zig`: ```zig // .include() looks for a `pub fn include(comptime *worldbuilder) (!)void` def  // in each struct. if the function errors it's a compile error, // but the signature can return either `!void` or `void` wb.include(&.{   ztg.base,   @import('player.zig'),   @import('my_library'), }); ```  `player.zig`: ```zig pub fn include(comptime wb: *ztg.worldbuilder) void {   wb.addcomponents(.{ player, playergun, playerhud });   wb.addsystemstostage(.update, .{ update_player, update_gun, update_hud }); } ```  `my_library/init.zig`: ```zig pub fn include(comptime wb: *ztg.worldbuilder) void {   wb.include(&.{       // namespaces can be included more than once to 'ensure'        // they are included if you depend on them       ztg.base,        //...   }); } ```  ## getting started see this short tutorial on creating systems and components [here](https://github.com/freakmangd/zentig_ecs/tree/main/docs/hello_world.md)  ## full examples see full examples in the [examples folder](https://github.com/freakmangd/zentig_ecs/tree/main/examples)  ## framework support zentig is framework agnostic, it doesn't include any drawing capabilities. for that you need something like raylib, i've created a library that wraps common raylib components and provides systems that act on those components [here](https://github.com/freakmangd/zentig_raylib).  that page provides installation instructions and usage examples. ","dmgk/zig-getopt":"POSIX-compatible getopt(3) implementation in Zig # minimal posix getopt(3) implementation in zig  this is a minimal, allocation-free getopt(3) implementation with [posix-conforming](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getopt.html) argument parsing semantics.  ## example  ```zig const std = @import('std'); const debug = std.debug; const getopt = @import('getopt.zig');  pub fn main() void {     var arg: []const u8 = undefined;     var verbose: bool = false;      var opts = getopt.getopt('a:vh');      while (opts.next()) |maybe_opt| {         if (maybe_opt) |opt| {             switch (opt.opt) {                 'a' => {                     arg = opt.arg.?;                     debug.print('arg = {s}╲n', .{arg});                 },                 'v' => {                     verbose = true;                     debug.print('verbose = {}╲n', .{verbose});                 },                 'h' => debug.print(                     ╲╲usage: example [-a arg] [-hv]                     ╲╲                 , .{}),                 else => unreachable,             }         } else break;     } else |err| {         switch (err) {             getopt.error.invalidoption => debug.print('invalid option: {c}╲n', .{opts.optopt}),             getopt.error.missingargument => debug.print('option requires an argument: {c}╲n', .{opts.optopt}),         }     }      debug.print('remaining args: {?s}╲n', .{opts.args()}); } ```  ``` $ zig run example.zig -- -hv -a42 foo bar usage: example [-a arg] [-hv] verbose = true arg = 42 remaining args: { foo, bar } ``` ","alexnask/PeerType":"Zig peer type resolution at comptime, ported from the compiler source code # peertype  ## api ```zig /// types must be an iterable of types (tuple, slice, ptr to array) pub fn peertype(comptime types: anytype) ?type; pub fn coercesto(comptime dst: type, comptime src: type) bool; pub fn requirescomptime(comptime t: type) bool; ```  ## license mit ","zetaframe/zetaframe":"lightweight zig game framework. # zetaframe  ![github workflow status](https://img.shields.io/github/workflow/status/zetaframe/zetaframe/tests?style=for-the-badge)  a `wip` lightweight zig game framework.  ## modules  ### core  the core of all zetaframe applications.  zetaframe is based around a entity component system (ecs).  ### math  a glsl compatible linear algebra library. `wip`  ### render  an powerful vulkan render api. `wip`.  will later include a system that can be added directly into `core`.  ---  ## building  use zig master.  ---  ## license  see [license.md](../master/license.md) ","jnordwick/tempus":"fast, minimal clocks, TSC, dates, and timestamps for zig 404: not found","jedisct1/zig-hpke":"HPKE implementation for Zig. # hpke for zig  `zig-hpke` is an implementation of the [hybrid public key encryption](https://www.rfc-editor.org/rfc/rfc9180.html) (hpke) scheme.  ## usage  ### bounded arrays  this code heavily relies on the `std.boundedarray` type: a type to store small, variable-sized slices whose maximum size is known.  keys are typically represented using that type, whose raw slice can be accessed with the `constslice()` function (for a constant slice), or `slice()` (for a mutable slice).  ### suite instantiation  ```zig const suite = try suite.init(     primitives.kem.x25519hkdfsha256.id,     primitives.kdf.hkdfsha256.id,     primitives.aead.aes128gcm.id, ); ```  ### key pair creation  ```zig const kp = try suite.generatekeypair(); ```  ### client: creation and encapsulation of the shared secret  a _client_ initiates a connexion by sending an encrypted secret; a _server_ accepts an encrypted secret from a client, and decrypts it, so that both parties can eventually agree on a shared secret.  ```zig var client_ctx_and_encapsulated_secret =     try suite.createclientcontext(server_kp.public_key.slice(), 'info', null, null);  var client_ctx = client_ctx_and_encapsulated_secret.client_ctx;  var encapsulated_secret = client_ctx_and_encapsulated_secret.encapsulated_secret; ```  * `encapsulated_secret.encapsulated` needs to be sent to the server. `encapsulated_secret.encapsulated.secret` must remain secret. * `client_ctx` can be used to encrypt/decrypt messages exchanged with the server.  to improve misuse resistance, this implementation uses distinct types for the client and the server context: `clientcontext` for the client, and `servercontext` for the server.  ### server: decapsulation of the shared secret  ```zig var server_ctx =     try suite.createservercontext(encapsulated_secret.encapsulated.constslice(), server_kp, 'info', null); ```  * `server_ctx` can be used to encrypt/decrypt messages exchanged with the client * the last parameter is an optional pre-shared key.  ### encryption of a message from the client to the server  a message can be encrypted by the client for the server:  ```zig client_ctx.encrypttoserver(&ciphertext, message, ad); ```  nonces are automatically incremented, so it is safe to call this function multiple times within the same context.  last parameter is optional associated data.  the ciphertext is `client_ctx.taglength()` bytes larger than the message.  ### decryption of a ciphertext received by the server  the server can decrypt a ciphertext sent by the client:  ```zig var message2: [message.len]u8 = undefined; try server_ctx.decryptfromclient(&message2, &ciphertext, ad); ```  last parameter is optional associated data. the message length is `server_ctx.taglength()` bytes shorter than the ciphertext.  ### encryption of a message from the server to the client  a message can also be encrypted by the server for the client:  ```zig server_ctx.encrypttoclient(&ciphertext, message, ad); ```  nonces are automatically incremented, so it is safe to call this function multiple times within the same context.  last parameter is optional associated data.  ### decryption of a ciphertext received by the client  the client can decrypt an encrypted response from the server:  ```zig try client_ctx.decryptfromserver(&message2, &ciphertext, ad); ```  last parameter is optional associated data.  ## authenticated modes  authenticated modes, with or without a psk are supported.  see `createauthenticatedclientcontext` and `createauthenticatedservercontext`.  ### exporter secret  the exporter secret can be obtained with the `exportedsecret()` function available both in the `servercontext` and `clientcontext` structures:  ```zig const exporter = client_ctx.exportersecret().constslice(); ```  ### key derivation  ```zig const secret1 = try client_ctx.exportsecret('description 1') const secret2 = try server_ctx.exportsecret('description 2'); ```  ### access the raw cipher interface  ```zig const aead = suite.aead; ```  ## that's it! ","leecannon/zig-x86_64":"Support for x86_64 specific instructions (e.g. TLB flush), registers (e.g. control registers), and structures (e.g. page tables) # zig-x86_64  [![ci](https://github.com/leecannon/zig-x86_64/actions/workflows/main.yml/badge.svg?branch=master)](https://github.com/leecannon/zig-x86_64/actions/workflows/main.yml)  **i don't use this library anymore. i made this as a port of the rust crate but over time i have come to dislike the api.**  **as written it does not support self-hosted so will probably be deleted with the release of zig 0.11**  this repo contains various functionality required to make an x86_64 kernel (following [writing an os in rust](https://os.phil-opp.com/))  it is mainly a zig reimplementation of the rust crate [x86_64](https://github.com/rust-osdev/x86_64).  it includes a few additonal types in the `x86_64.additional` namespace:  - `serialport` - serial port type, mainly for debug output - `simplepic` - reimplementation of [pic8259_simple](https://docs.rs/pic8259_simple)  ## how to get  ### gyro  `gyro add leecannon/x86_64`  ### zigmod  `zigmod aq add 1/leecannon/x86_64`  ### git  #### submodule  `git submodule add https://github.com/leecannon/zig-x86_64 zig-x86_64`  #### clone  `git clone https://github.com/leecannon/zig-x86_64` ","jedisct1/zig-blind-rsa-signatures":"Blind RSA signatures implementation for Zig. # blind rsa signatures  author-blinded rsassa-pss rsae signatures.  this is an implementation of the [rsa blind signatures](https://www.rfc-editor.org/rfc/rfc9474.html) rfc.  also includes a preliminary implementation of the [partially blind rsa signatures](https://datatracker.ietf.org/doc/draft-amjad-cfrg-partially-blind-rsa/) draft.  ## protocol overview  a client asks a server to sign a message. the server receives the message, and returns the signature.  using that `(message, signature)` pair, the client can locally compute a second, valid `(message', signature')` pair.  anyone can verify that `(message', signature')` is valid for the server's public key, even though the server didn't see that pair before. but no one besides the client can link `(message', signature')` to `(message, signature)`.  using that scheme, a server can issue a token and verify that a client has a valid token, without being able to link both actions to the same client.  1. the client creates a random message, optionally prefixes it with noise, and blinds it with a random, secret factor. 2. the server receives the blind message, signs it and returns a blind signature. 3. from the blind signature, and knowing the secret factor, the client can locally compute a `(message, signature)` pair that can be verified using the server's public key. 4. anyone, including the server, can thus later verify that `(message, signature)` is valid, without knowing when step 2 occurred.  the scheme was designed by david chaum, and was originally implemented for anonymizing digicash transactions.  ## dependencies  this implementation requires openssl or boringssl.  ## usage  ```zig     // [server]: generate a rsa-2048 key pair     const kp = try blindrsa(2048).keypair.generate();     defer kp.deinit();     const pk = kp.pk;     const sk = kp.sk;      // [client]: create a random message and blind it for the server whose public key is `pk`.     // the second parameter determines whether noise should be added to the message.     // `true` adds noise, and returns it as `blinding_result.msg_randomizer`     // `false` doesn't prefix the message with noise.     // the client must store the message, the optional noise, and the secret.     const msg = 'msg';     var blinding_result = try pk.blind(msg, true);      // [server]: compute a signature for a blind message, to be sent to the client.     // the client secret should not be sent to the server.     const blind_sig = try sk.blindsign(blinding_result.blind_message);      // [client]: later, when the client wants to redeem a signed blind message,     // using the blinding secret, it can locally compute the signature of the     // original message.     // the client then owns a new valid (message, signature) pair, and the     // server cannot link it to a previous(blinded message, blind signature) pair.     // note that the finalization function also verifies that the new signature     // is correct for the server public key.     // the noise parameter can be set to `null` if the message wasn't prefixed with noise.     const sig = try pk.finalize(blind_sig, blinding_result.secret,                                 blinding_result.msg_randomizer, msg);      // [server]: a non-blind signature can be verified using the server's public key.     try pk.verify(sig, blinding_result.msg_randomizer, msg); ```  deterministic padding is also supported with the `blindrsadeterministic` type:  ```zig const brsa = blindrsadeterministic(2048); const kp = brsa.keypair.generate(); ... ```  for specific use cases, custom hash functions and salt lengths are also accessible via the `blindrsacustom` type.  ```zig const brsa = blindrsacustom(2048, .sha256, 48); const kp = brsa.keypair.generate(); ... ```  some helper functions are also included for key serialization and deserialization.  ## for other languages  * [rust](https://github.com/jedisct1/rust-blind-rsa-signatures) * [c](https://github.com/jedisct1/blind-rsa-signatures) * [go](https://github.com/cloudflare/circl/tree/master/blindsign) ","allyourcodebase/openssl":"openssl zig package # openssl zig package  this is openssl ported to the zig build system.  ## status  i was able to use this to build [cpython](https://github.com/thejoshwolfe/cpython) for x86_64-linux.  adding support for other operating systems and cpu architectures is straightforward and will require fiddling with the build script to take into account the target.  ## anti-endorsement  i do not endorse openssl. i think it is a pile of trash. my motivation for this project is because it is a dependency of cpython, which is a dependency of the most active youtube downloader, [ytdlp](https://github.com/yt-dlp/yt-dlp). ","leecannon/zig-bitjuggle":"Various 'bit juggling' helpers and functionality # zig-bitjuggle  [![ci](https://github.com/leecannon/zig-bitjuggle/actions/workflows/main.yml/badge.svg?branch=master)](https://github.com/leecannon/zig-bitjuggle/actions/workflows/main.yml)  this package contains various 'bit juggling' helpers and functionality:  - `isbitset` - check if a bit is set - `getbit` - get the value of a bit - `getbits` - get a range of bits - `setbit` - set a specific bit - `setbits` - set a range of bits - `bitfield` - used along with `extern union` to represent arbitrary bit fields - `bit` - used along with `extern union` to represent bit fields - `boolean` - used along with `extern union` to represent boolean bit fields  the `bitfield`, `bit` & `boolean` types are taken pretty much verbatim from [florence](https://github.com/florenceos/florence/blob/master/lib/util/bitfields.zig) (see license-florence for original license)  ## how to get  #### submodule  `git submodule add https://github.com/leecannon/zig-bitjuggle zig-bitjuggle`  #### clone  `git clone https://github.com/leecannon/zig-bitjuggle` ","nektro/zig-range":"A range function to loop over an index without an extra variable. # zig-range ![loc](https://sloc.xyz/github/nektro/zig-range) [![license](https://img.shields.io/github/license/nektro/zig-range.svg)](https://github.com/nektro/zig-range/blob/master/license) [![discord](https://img.shields.io/discord/551971034593755159.svg?logo=discord)](https://discord.gg/p6y4zqc)  a range function to loop over an index without an extra variable  ## usage ```zig for (range(10)) |_, i| {     // 'i' will increment from 0 -> 9 } ```  ## building example program ``` $ zigmod fetch $ zig build ```  ## built with - zig master & [zigmod package manager](https://github.com/nektro/zigmod)  ## license mit ","ziglibs/lscolors":"A zig library for colorizing paths according to LS_COLORS # lscolors  ![ci](https://github.com/ziglibs/zig-lscolors/workflows/ci/badge.svg)  a zig library for colorizing paths according to the `ls_colors` environment variable. designed to work with zig 0.13.0.  ## quick example  ```zig const std = @import('std');  const lscolors = @import('lscolors').lscolors;  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();     const allocator = gpa.allocator();      var lsc = try lscolors.fromenv(allocator);     defer lsc.deinit();      var dir = try std.fs.cwd().openiterabledir('.', .{});     defer dir.close();      var iterator = dir.iterate();     while (try iterator.next()) |itm| {         std.log.info('{}', .{try lsc.styled(itm.name)});     } } ``` ","ttytm/osdialog-zig":"Cross-platform utility module for Zig to open native dialogs for the filesystem, message boxes, color-picking. # osdialog-zig  [badge__build-status]: https://img.shields.io/github/actions/workflow/status/ttytm/osdialog-zig/ci.yml?branch=main&logo=github&logocolor=c0caf5&labelcolor=333 [badge__version-lib]: https://img.shields.io/github/v/tag/ttytm/osdialog-zig?logo=task&logocolor=c0caf5&labelcolor=333&color= [badge__version-zig]: https://img.shields.io/badge/zig-0.13.0-cc742f?logo=zig&logocolor=c0caf5&labelcolor=333  [![][badge__build-status]](https://github.com/ttytm/osdialog-zig/actions?query=branch%3amain) [![][badge__version-lib]](https://github.com/ttytm/osdialog-zig/releases/latest) [![][badge__version-zig]](https://github.com/ttytm/osdialog-zig/releases/latest)  cross-platform utility module for zig to open native dialogs for the filesystem, message boxes, color-picking.  ## quickstart  - [installation](#installation) - [usage](#usage)   - [example](#example) - [credits](#credits)  ## showcase  <table align='center'>   <tr>     <th>linux</th>     <th>windows</th>     <th>macos</th>   </tr>   <tr>     <td width='400'>       <img alt='linux file dialog' src='https://github.com/ttytm/dialog/assets/34311583/6ba6e96b-3581-4382-8074-79918a99dcbd'>     </td>     <td width='400'>       <img alt='windows file dialog' src='https://github.com/ttytm/dialog/assets/34311583/911e8c71-0cc1-4426-a62c-04714b6b071f'>     </td>     <td width='400'>       <img alt='macos file dialog' src='https://github.com/ttytm/dialog/assets/34311583/f7c4375e-d2e4-4121-ad34-db0473d8fabe'>     </td>   </tr> </table>  <details open> <summary><b>more examples</b> <sub><sup>toggle visibility...</sup></sub></summary><br>  <table align='center'>   <tr>     <th>linux</th>     <th>windows</th>     <th>macos</th>   </tr>   <tr>     <td width='400'>       <img alt='linux color picker gtk3' src='https://github.com/ttytm/dialog/assets/34311583/8e587c8c-2f12-41ee-9a10-4c3f92e72885'>       <img alt='linux message' src='https://github.com/ttytm/dialog/assets/34311583/42e1081b-ee52-4286-abfd-ad9eda63d282'>       <img alt='linux message with yes and no buttons' src='https://github.com/ttytm/dialog/assets/34311583/07aa26bd-f887-417b-9c1a-56724ceb2589'>       <img alt='linux input prompt' src='https://github.com/ttytm/dialog/assets/34311583/bc5e3ec1-88b5-4e1a-b46e-381b322b8a6c'>       <img alt='linux color picker gtk2' src='https://github.com/ttytm/dialog/assets/34311583/37619ed0-8fe2-4e5c-af11-70d7f2304b2b'>     </td>     <td width='400'>       <img alt='windows color picker' src='https://github.com/ttytm/dialog/assets/34311583/966b1395-55ac-45b8-aa1b-516f673b64e8'>       <img alt='windows message' src='https://github.com/ttytm/dialog/assets/34311583/a73e0eaf-e56b-44e6-bcc5-31bb381c6e37'>       <img alt='windows message with yes and no buttons' src='https://github.com/ttytm/dialog/assets/34311583/16a1ad65-571e-4183-8c0b-119cbf126aec'>       <img alt='windows input prompt' src='https://github.com/ttytm/dialog/assets/34311583/54e4a708-de38-44ea-ae61-be39c1bdbff9'>     </td>     <td width='400'>       <img alt='macos color picker' src='https://github.com/user-attachments/assets/551ac8d6-406d-4b01-9095-d0a357cc8250'>       <!-- <img alt='macos message' src='https://github.com/ttytm/dialog/assets/34311583/15920c46-e529-405f-9731-3ac57ce46449'> -->       <img alt='macos message with yes and no buttons' src='https://github.com/ttytm/dialog/assets/34311583/11cba10b-3190-4114-b1ad-e49e56d4498c'>       <img alt='macos input prompt' src='https://github.com/ttytm/dialog/assets/34311583/e6d496b4-3c20-4ece-8808-0eba99a59a45'>     </td>   </tr> </table>  </details>  ## installation  ```sh # ~/<projectspath>/your-awesome-projct zig fetch --save https://github.com/ttytm/osdialog-zig/archive/main.tar.gz ```  ```zig // your-awesome-projct/build.zig const std = @import('std');  pub fn build(b: *std.build) void {   // ..   const osdialog_dep = b.dependency('osdialog', .{});   const exe = b.addexecutable(.{     .name = 'your-awesome-projct',     // ..   });   exe.root_module.addimport('osdialog', osdialog_dep.module('osdialog'));   // ... } ```  ## usage  ref.: [`osdialog-zig/src/lib.zig`](https://github.com/ttytm/osdialog-zig/blob/main/src/lib.zig) ```zig /// opens a message box and returns `true` if `ok` or `yes` was pressed. pub fn message(text: [*:0]const u8, opts: messageoptions) bool  /// opens an input prompt with an 'ok' and 'cancel' button. pub fn prompt(allocator: std.mem.allocator, text: [*:0]const u8, opts: promptoptions) ?[:0]u8  /// opens an rgba color picker and returns the selected `color` or `null` if the selection was canceled. pub fn color(options: colorpickeroptions) ?color  /// opens a file dialog and returns the selected path or `null` if the selection was canceled. pub fn path(allocator: std.mem.allocator, action: pathaction, options: pathoptions) ?[:0]u8 ```  ### example  ref.: [`osdialog-zig/examples/src/main.zig`](https://github.com/ttytm/osdialog-zig/blob/main/examples/src/main.zig)  ```zig const std = @import('std'); const osd = @import('osdialog');  pub fn main() void {   var gpa = std.heap.generalpurposeallocator(.{}){};   const allocator = gpa.allocator();   defer _ = gpa.deinit();    _ = osd.message('hello, world!', .{});   if (!osd.message('do you want to continue?', .{ .buttons = .yes_no })) {     std.process.exit(0);   }   if (osd.prompt(allocator, 'give me some input', .{})) |input| {     defer allocator.free(input);     std.debug.print('input: {s}╲n', .{input});   }   if (osd.color(.{ .color = .{ .r = 247, .g = 163, .b = 29, .a = 255 } })) |selected| {     std.debug.print('color rrr,ggg,bbb,aaa: {d},{d},{d},{d}╲n', .{ selected.r, selected.g, selected.b, selected.a });   }   if (osd.path(allocator, .open, .{})) |path| {     defer allocator.free(path);     std.debug.print('selected file: {s}╲n', .{path});   }   if (osd.path(allocator, .open_dir, .{})) |path| {     defer allocator.free(path);   }   if (osd.path(allocator, .save, .{ .path = '.', .filename = 'myfile.txt' })) |path| {     defer allocator.free(path);     std.debug.print('save location: {s}╲n', .{path});   } } ```  ```sh # osdialog/examples zig build run ```  ## credits  - [andrewbelt/osdialog](https://github.com/andrewbelt/osdialog) - the c project this library is leveraging ","GoNZooo/zig-windows-process":"Toolset for interacting with Windows processes in Zig # zig-windows-process  this repo is meant to hold tools for tinkering with windows processes (though i might extend it in the future) to allow for a higher-level interface for injecting dlls and such.  the primary motivation is that i'd like to have a basic toolkit for dealing with things that usually come up in game hacking and exploration.  ## the library code  the library code is primarily in `main.zig` so if you were to add the package it would be from that file, as follows:  ```zig exe.addpackagepath('windows-process', 'dependencies/windows-process/src/main.zig'); ```  ## example usage  ### dll injection  `inject_dll.zig` contains a main file for a program that will take a dll path and inject it into a given process. one needs to make sure that the process has the same bitness as the dll.  ### finding/enumerating processes  `find_process.zig` uses the process enumeration api to find processes matching a given executable name.  ## more stuff and more ways to do these things  i'm not an expert on any of these things and there are way more things to add here. i'd love suggestions for tools to add, techniques to facilitate through this package. having a general module that allows interaction with windows processes in general is the point, after all. ","nektro/zig-tls":"[WIP] A pure-Zig TLS 1.3 client implementation. # zig-tls  a pure-zig [rfc8446 tls 1.3](https://tools.ietf.org/html/rfc8446) client implementation.  crypto is hard, please feel free to view the source and open issues for any improvements.  indebted to https://tls13.xargs.org/ and multiple readings of the rfc.  ## license  mit ","nektro/zig-unicode-ucd":"Zig bindings for the Unicode Character Database # zig-unicode-ucd  zig bindings for the unicode character database  last updated as of unicode 16.0.0  http://www.unicode.org/reports/tr44/  https://www.unicode.org/versions/latest/  ## development  ``` zig build run -dstep=generate zig build run -dstep=run ```  ## license  code here is mit  source data files are https://www.unicode.org/license.html ","jinzhongjia/znvim":"neovim remote rpc client implementation with zig # znvim  _znvim_ is a [neovim remote rpc](https://neovim.io/doc/user/api.html#rpc-connecting) client implementation with [`zig`](https://ziglang.org/).  > this package is under developing!  ## document  [https://jinzhongjia.github.io/znvim/](https://jinzhongjia.github.io/znvim/)  ## features  - implementation of multiple remote calling methods - support all neovim rpc [channels](https://neovim.io/doc/user/channel.html#channel-intro) - completely thread safe - asynchronous  ## getting started  ### `0.12.0` / `0.13.0`  1. add to `build.zig.zon`  ```sh zig fetch --save https://github.com/jinzhongjia/znvim/archive/{commit or branch}.tar.gz ```  2. config `build.zig`  ```zig const znvim = b.dependency('znvim', .{     .target = target,     .optimize = optimize, });  // add module exe.root_module.addimport('znvim', znvim.module('znvim')); ```  ## to use this lib  you can find example on `test` fold!  recommend to learn about what [msgpack](https://github.com/msgpack/msgpack/blob/master/spec.md) is (this lib uses [zig-msgpack](https://github.com/zigcc/zig-msgpack)) and read neovim's api [documentation](https://neovim.io/doc/user/api.html). ","leecannon/zig-sbi":"Zig wrapper around the RISC-V SBI specification # zig-sbi  zig wrapper around the risc-v sbi specification  implements sbi specification v1.0.0  ## how to get  ### gyro  `gyro add leecannon/sbi`  ### zigmod  `zigmod aq add 1/leecannon/sbi`  ### git  #### submodule  `git submodule add https://github.com/leecannon/zig-sbi zig-sbi`  #### clone  `git clone https://github.com/leecannon/zig-sbi` ","jedisct1/zig-aes-gem":"AES-GEM (AES Galois Extended Mode) implementation. 404: not found","nektro/zig-json":"A JSON library for inspecting arbitrary values # zig-json ![loc](https://sloc.xyz/github/nektro/zig-json) [![license](https://img.shields.io/github/license/nektro/zig-json.svg)](https://github.com/nektro/zig-json/blob/master/license)  a json library for inspecting arbitrary values. optionally accepts trailing commas.  fully passes https://github.com/nst/jsontestsuite.  ## usage  see `test.zig` for examples.  ## building example program  ``` $ zigmod fetch $ zig build test ```  ## license mit ","AdjectiveAllison/zai":"Zig AI! # zai - a zig ai library!  ## installation  1. declare zai as a project dependency with `zig fetch`:      ```sh     # latest version     zig fetch --save git+https://github.com/adjectiveallison/zai.git#main      # specific commit     zig fetch --save git+https://github.com/adjectiveallison/zai.git#commit     ```  2. expose zai as a module in your project's `build.zig`:      ```zig     pub fn build(b: *std.build) void {         const target = b.standardtargetoptions(.{});         const optimize = b.standardoptimizeoption(.{});          const opts = .{ .target = target, .optimize = optimize };   // 👈         const zai = b.dependency('zai', opts).module('zai'); // 👈          const exe = b.addexecutable(.{             .name = 'my-project',             .root_source_file = b.path('src/main.zig'),             .target = target,             .optimize = optimize,         });          exe.root_module.addimport('zai', zai); // 👈          // ...     }     ```  3. import zig ai into your code:      ```zig     const zai = @import('zai');     ```  ## features  - support for chat completions and embeddings - streaming capabilities for real-time responses - easy integration with zig projects - configurable model selection - automatic provider-specific api handling (in the works)  ## usage  ### chat completion  here's a basic example of using zai for chat completion:  ```zig const std = @import('std'); const zai = @import('zai');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();     const allocator = gpa.allocator();      var ai: zai.ai = undefined;     try ai.init(allocator, zai.provider.octoai);     defer ai.deinit();      var messages = [_]zai.message{         .{             .role = 'system',             .content = 'you are a helpful ai assistant.',         },         .{             .role = 'user',             .content = 'write one sentence about how cool it would be to use zig to call language models.',         },     };      const payload = zai.completionpayload{         .model = 'meta-llama-3.1-8b-instruct',         .messages = &messages,         .temperature = 0.1,         .stream = true,     };      var chat_completion: zai.chatcompletion = undefined;     chat_completion.init(allocator);     defer chat_completion.deinit();      try chat_completion.streamandprint(&ai, payload); } ```  ### embeddings  here's how to use zai for generating embeddings:  ```zig const std = @import('std'); const zai = @import('zai');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();     const allocator = gpa.allocator();      var ai: zai.ai = undefined;     try ai.init(allocator, zai.provider.octoai);     defer ai.deinit();      const input_text = 'zig is a general-purpose programming language and toolchain for maintaining robust, optimal, and reusable software.';      const payload = zai.embeddings.embeddingspayload{         .input = input_text,         .model = 'thenlper/gte-large',     };      var embeddings: zai.embeddings = undefined;     embeddings.init(allocator);     defer embeddings.deinit();      try embeddings.request(&ai, payload);      std.debug.print('embedding vector length: {d}╲n', .{embeddings.embedding.len}); } ```  ## examples  you can find more detailed examples in the `examples/` directory:  1. [chat completion](examples/chat_completion.zig) 2. [embeddings](examples/embeddings.zig)  to run an example, use:  ```sh zig build chat-completion # or zig build embeddings ```  ## configuration  zai uses environment variables for api keys (right now). set the appropriate environment variable for your chosen provider:  - openai: `openai_api_key` - octoai: `octoai_token` - togetherai: `together_api_key` - openrouter: `openrouter_api_key`  ## license  zai is released under the mit license. see the [license](license) file for details. ","ominitay/zigvale":"A Zig implementation of the stivale2 boot protocol # zigvale  zigvale is a zig implementation of the stivale2 boot protocol to be used both in kernels and bootloaders. the specification, along with c header files, may be found [here](https://github.com/stivale/stivale).  ## example  visit [zigvale-barebones](https://github.com/ominitay/zigvale-barebones) for a bare-bones kernel demonstrating how to use zigvale.  ## add to your project  zigvale is available on [aquila](https://aquila.red/1/ominitay/zigvale), [zpm](https://zig.pm/#/package/zigvale), and [astrolabe](https://astrolabe.pm/#/package/ominitay/zigvale/0.7.3).  ### gyro  `gyro add ominitay/zigvale`  ### zigmod ###### aquila `zigmod aq add 1/ominitay/zigvale`  ###### zpm `zigmod zpm add zigvale`  ### zkg  `zkg add zigvale`  ### git ###### submodule `git submodule add https://github.com/ominitay/zigvale zigvale`  ###### clone `git clone https://github.com/ominitay/zigvale`  ## documentation  to generate documentation, run `zig build docs`  zig's documentation generator is experimental and incomplete. when documentation generation has improved somewhat, i will host the documentation. in the meantime, you may both read the comments made manually, and read the documentation in the [stivale repository](https://github.com/stivale/stivale). ","ikskuh/zig-gemtext":"A zig library to manipulate gemini text files # gemini text processor  this is a library and a tool to manipulate [gemini text files](https://gemini.circumlunar.space/docs/specification.html).  it provides both an easy-to-use api as well as a streaming parser with minimal allocation requirements and a proper separation between temporary allocations required for parsing and allocations for returned text fragments.  the library is thoroughly tested with a lot of gemini text edge cases and all (tested) cases are handled reasonably.  ## features  - fully spec-compliant gemini text parsing - non-blocking streaming parser - provides both a convenient [zig](src/gemtext.zig) and [c](include/gemtext.h) api - rendering to several formats   - gemini text   - html   - markdown   - rtf  ## example  this is a simple example that parses a gemini file and converts it into a html file.  ```zig pub fn main() !void {     var document = try gemtext.document.parse(       std.heap.page_allocator,       std.io.getstdin().reader(),     );     defer document.deinit();      try gemtext.renderer.html(       document.fragments.items,        std.io.getstdout().writer(),     ); } ```  more examples can be found the the examples folder: - `gem2html` ([c](examples/gem2html.c), [zig](examples/gem2html.zig)) - `gem2md` ([c](examples/gem2md.c), [zig](examples/gem2md.zig)) - `streaming-parser` ([c](examples/streaming-parser.c), [zig](examples/streaming-parser.zig))","paoda/bit-string":"This repository has no description. # bit string   a library to check and extract values from integers based on a 'bit string'. primarily intended for (my) emulator instruction decoding, but maybe someone else can find a use for it?  ## example   ```zig  const std = @import('std');   test 'doc test' {     const value: u8 = 0b10001011;      try std.testing.expectequal(true, match('1000_1011', value));     try std.testing.expectequal(false, match('11111011', value));     try std.testing.expectequal(true, match('1---1011', value));      {         const ret = extract('1000aaaa', value);         try std.testing.expectequal(@as(u4, 0b1011), ret.a);     }     {         const ret = extract('1aaa1aaa', value);         try std.testing.expectequal(@as(u6, 0b000011), ret.a);     }     {         const ret = extract('1---abcd', value);         try std.testing.expectequal(@as(u3, 0b1), ret.a);         try std.testing.expectequal(@as(u3, 0b0), ret.b);         try std.testing.expectequal(@as(u3, 0b1), ret.c);         try std.testing.expectequal(@as(u3, 0b1), ret.d);     }  }  ```  ## syntax   |  token  |  meaning  | description  | ------- | --------- | -----------  | `0`     | clear bit | in the equivalent position, the value's bit must be cleared.  | `1`     | set bit   | in the equivalent position, the value's bit must be set.  | `a..=z` | variable  | given the 4-bit bit string, `'1aa0'`, the value `0b1010` would produce the variable `a` with the value `0b01`  | `-`     | ignored   | in the equivalent position, the value's bit does not matter.  | `_`     | ignored*  | underscores are completely ignored during parsing, use to make bit strings easier to read e.g. `1111_1111`  ## notes  - this library does the majority of it's work at `comptime`. due to this, you cannot create strings to match against at runtime. - variables do not have to be 'sequential'. this means the 5-bit bit string `'1aa0a'` with the value `0b10101` will produce the variable `a` with the value `0b011`. ","FObersteiner/zdt":"Timezoned Datetime in Zig <!-- -*- coding: utf-8 -*- -->  [![zig](https://img.shields.io/badge/-zig-f7a41d?style=flat&logo=zig&logocolor=white)](https://ziglang.org/) ⚡ [![tests](https://github.com/fobersteiner/zdt/actions/workflows/zdt-tests.yml/badge.svg)](https://github.com/fobersteiner/zdt/actions/workflows/zdt-tests.yml)  [![github release](https://img.shields.io/github/v/release/fobersteiner/zdt)](https://github.com/fobersteiner/zdt/releases)  [![tzdata](https://img.shields.io/badge/tzdata-2024b-blue)](https://www.iana.org/time-zones)  [![license: mpl 2.0](https://img.shields.io/badge/license-mpl_2.0-brightgreen.svg)](https://github.com/fobersteiner/zdt/blob/master/license)  # zdt  **timezoned datetime in zig.** opinionated, and mostly for learning purposes.  - [api overview](https://github.com/fobersteiner/zdt/wiki/api-overview) - [examples](https://github.com/fobersteiner/zdt/tree/master/examples) (build step: `zig build examples`) - [roadmap](https://github.com/fobersteiner/zdt/wiki/roadmap) - contributions: welcome!  ### [demo](https://github.com/fobersteiner/zdt/blob/master/examples/demo.zig)  ```zig // need an allocator for the time zones since the size of the rule-files varies. var gpa = std.heap.generalpurposeallocator(.{}){}; defer _ = gpa.deinit(); const allocator = gpa.allocator();  // zdt embeds the iana tz database: var tz_la = try zdt.timezone.fromtzdata('america/los_angeles', allocator); defer tz_la.deinit();  // you can also use your system's tz data at runtime; // this will very likely not work on windows, so we use the embedded version here as well. var tz_paris = switch (builtin.os.tag) {     .windows => try zdt.timezone.fromtzdata('europe/paris', allocator),     else => try zdt.timezone.fromsystemtzdata('europe/paris', zdt.timezone.tzdb_prefix, allocator), }; defer tz_paris.deinit();  // iso8601 parser on-board, accepts wide variety of compatible formats const a_datetime = try zdt.datetime.fromiso8601('2022-03-07'); const this_time_la = try a_datetime.tzlocalize(.{ .tz = &tz_la });  // string output also requires allocation... var buf = std.arraylist(u8).init(allocator); defer buf.deinit(); try this_time_la.tostring('%i %p, %z', buf.writer());  const this_time_paris = try this_time_la.tzconvert(.{ .tz = &tz_paris });  // '{s}' directive gives iso8601 format by default; std.debug.print(     'time, la : {s} ({s})╲n... that's {s} in paris ({s})╲n╲n',     .{ this_time_la, buf.items, this_time_paris, this_time_paris.tzabbreviation() }, ); // time, la : 2022-03-07t00:00:00-08:00 (12 am, pst) // ... that's 2022-03-07t09:00:00+01:00 in paris  const wall_diff = try this_time_paris.diffwall(this_time_la); const abs_diff = this_time_paris.diff(this_time_la);  std.debug.print(     'wall clock time difference: {s}╲nabsolute time difference: {s}╲n',     .{ wall_diff, abs_diff }, ); // wall clock time difference: pt9h // absolute time difference: pt0s ```  more examples in the `./examples` directory.   ## documentation  see [wiki](https://github.com/fobersteiner/zdt/wiki)  ## development  see [changelog](https://github.com/fobersteiner/zdt/blob/master/changelog.md)  ## zig version  this library is developed with zig `0.14.0-dev` aka 'master', might not compile with older versions. as of 2024-11-10, zig-0.13 stable or higher should work.  ## iana timezone database version  - `v0.2.2+` (current): `2024b` - `>= v0.2.1`: `2024a`  ## dependencies, development and time zone database  - no dependencies on other libraries. - time zone database: `zdt` comes with [eggert/tz](https://github.com/eggert/tz). the database is compiled and shipped with `zdt` (as-is; not tar-balled or compressed). - if you wish to use your own version of the [iana time zone db](https://www.iana.org/time-zones), you can set a path to it using the `-dprefix-tzdb='path/to/your/tzdb'` option. see also `zig build --help`. - for development: to update the time zone database and the version info, run the following build steps: `zig build update-tzdb`. some of the code generation is done with python scripts, which require python >= 3.9 but no third party packages, i.e. a system installation will do.  ## license  mpl. see the license file in the root directory of the repository. ","kassane/openssl-zig":"TLS/SSL and crypto library (uses Zig Build) welcome to the openssl project ==============================  [![openssl logo]][www.openssl.org]  [![github actions ci badge]][github actions ci] ![nightly os zoo ci badge](https://github.com/openssl/openssl/actions/workflows/os-zoo.yml/badge.svg) ![provider compatibility](https://github.com/openssl/openssl/actions/workflows/provider-compatibility.yml/badge.svg) ![quic interop](https://github.com/openssl/openssl/actions/workflows/run_quic_interop.yml/badge.svg) ![daily checks](https://github.com/openssl/openssl/actions/workflows/run-checker-daily.yml/badge.svg)  openssl is a robust, commercial-grade, full-featured open source toolkit for the tls (formerly ssl), dtls and quic (currently client side only) protocols.  the protocol implementations are based on a full-strength general purpose cryptographic library, which can also be used stand-alone. also included is a cryptographic module validated to conform with fips standards.  openssl is descended from the ssleay library developed by eric a. young and tim j. hudson.  the official home page of the openssl project is [www.openssl.org].  table of contents =================   - [overview](#overview)  - [download](#download)  - [build and install](#build-and-install)  - [documentation](#documentation)  - [license](#license)  - [support](#support)  - [contributing](#contributing)  - [legalities](#legalities)  overview ========  the openssl toolkit includes:  - **libssl**   an implementation of all tls protocol versions up to tlsv1.3 ([rfc 8446]),   dtls protocol versions up to dtlsv1.2 ([rfc 6347]) and   the quic (currently client side only) version 1 protocol ([rfc 9000]).  - **libcrypto**   a full-strength general purpose cryptographic library. it constitutes the   basis of the tls implementation, but can also be used independently.  - **openssl**   the openssl command line tool, a swiss army knife for cryptographic tasks,   testing and analyzing. it can be used for   - creation of key parameters   - creation of x.509 certificates, csrs and crls   - calculation of message digests   - encryption and decryption   - ssl/tls/dtls and client and server tests   - quic client tests   - handling of s/mime signed or encrypted mail   - and more...  download ========  for production use ------------------  source code tarballs of the official releases can be downloaded from [www.openssl.org/source](https://www.openssl.org/source). the openssl project does not distribute the toolkit in binary form.  however, for a large variety of operating systems precompiled versions of the openssl toolkit are available. in particular, on linux and other unix operating systems, it is normally recommended to link against the precompiled shared libraries provided by the distributor or vendor.  we also maintain a list of third parties that produce openssl binaries for various operating systems (including windows) on the [binaries] page on our wiki.  for testing and development ---------------------------  although testing and development could in theory also be done using the source tarballs, having a local copy of the git repository with the entire project history gives you much more insight into the code base.  the official openssl git repository is located at [git.openssl.org]. there is a github mirror of the repository at [github.com/openssl/openssl], which is updated automatically from the former on every commit.  a local copy of the git repository can be obtained by cloning it from the original openssl repository using      git clone git://git.openssl.org/openssl.git  or from the github mirror using      git clone https://github.com/openssl/openssl.git  if you intend to contribute to openssl, either to fix bugs or contribute new features, you need to fork the openssl repository openssl/openssl on github and clone your public fork instead.      git clone https://github.com/yourname/openssl.git  this is necessary because all development of openssl nowadays is done via github pull requests. for more details, see [contributing](#contributing).  build and install =================  after obtaining the source, have a look at the [install](install.md) file for detailed instructions about building and installing openssl. for some platforms, the installation instructions are amended by a platform specific document.   * [notes for unix-like platforms](notes-unix.md)  * [notes for android platforms](notes-android.md)  * [notes for windows platforms](notes-windows.md)  * [notes for the dos platform with djgpp](notes-djgpp.md)  * [notes for the openvms platform](notes-vms.md)  * [notes on perl](notes-perl.md)  * [notes on valgrind](notes-valgrind.md)  specific notes on upgrading to openssl 3.x from previous versions can be found in the [ossl-guide-migration(7ossl)] manual page.  documentation =============  readme files ------------  there are some readme.md files in the top level of the source distribution containing additional information on specific topics.   * [information about the openssl quic protocol implementation](readme-quic.md)  * [information about the openssl provider architecture](readme-providers.md)  * [information about using the openssl fips validated module](readme-fips.md)  * [information about the legacy openssl engine architecture](readme-engines.md)  the openssl guide -----------------  there are some tutorial and introductory pages on some important openssl topics within the [openssl guide].  manual pages ------------  the manual pages for the master branch and all current stable releases are available online.  - [openssl master](https://www.openssl.org/docs/manmaster) - [openssl 3.0](https://www.openssl.org/docs/man3.0) - [openssl 3.1](https://www.openssl.org/docs/man3.1) - [openssl 3.2](https://www.openssl.org/docs/man3.2)  demos -----  the are numerous source code demos for using various openssl capabilities in the [demos subfolder](./demos).  wiki ----  there is a wiki at [wiki.openssl.org] which is currently not very active. it contains a lot of useful information, not all of which is up-to-date.  license =======  openssl is licensed under the apache license 2.0, which means that you are free to get and use it for commercial and non-commercial purposes as long as you fulfill its conditions.  see the [license.txt](license.txt) file for more details.  support =======  there are various ways to get in touch. the correct channel depends on your requirement. see the [support](support.md) file for more details.  contributing ============  if you are interested and willing to contribute to the openssl project, please take a look at the [contributing](contributing.md) file.  legalities ==========  a number of nations restrict the use or export of cryptography. if you are potentially subject to such restrictions, you should seek legal advice before attempting to develop or distribute cryptographic code.  copyright =========  copyright (c) 1998-2024 the openssl project authors  copyright (c) 1995-1998 eric a. young, tim j. hudson  all rights reserved.  <!-- links  -->  [www.openssl.org]:     <https://www.openssl.org>     'openssl homepage'  [git.openssl.org]:     <https://git.openssl.org>     'openssl git repository'  [git.openssl.org]:     <https://git.openssl.org>     'openssl git repository'  [github.com/openssl/openssl]:     <https://github.com/openssl/openssl>     'openssl github mirror'  [wiki.openssl.org]:     <https://wiki.openssl.org>     'openssl wiki'  [ossl-guide-migration(7ossl)]:     <https://www.openssl.org/docs/manmaster/man7/ossl-guide-migration.html>     'openssl migration guide'  [rfc 8446]:      <https://tools.ietf.org/html/rfc8446>  [rfc 6347]:      <https://tools.ietf.org/html/rfc6347>  [rfc 9000]:      <https://tools.ietf.org/html/rfc9000>  [binaries]:     <https://wiki.openssl.org/index.php/binaries>     'list of third party openssl binaries'  [openssl guide]:     <https://www.openssl.org/docs/manmaster/man7/ossl-guide-introduction.html>     'an introduction to openssl'  <!-- logos and badges -->  [openssl logo]:     doc/images/openssl.svg     'openssl logo'  [github actions ci badge]:     <https://github.com/openssl/openssl/workflows/github%20ci/badge.svg>     'github actions ci status'  [github actions ci]:     <https://github.com/openssl/openssl/actions?query=workflow%3a%22github+ci%22>     'github actions ci'  [appveyor badge]:     <https://ci.appveyor.com/api/projects/status/8e10o7xfrg73v98f/branch/master?svg=true>     'appveyor build status'  [appveyor jobs]:     <https://ci.appveyor.com/project/openssl/openssl/branch/master>     'appveyor jobs' ","jetzig-framework/zmd":"Zmd is a Markdown library written in Zig # zmd  _zmd_ is a [markdown](https://en.wikipedia.org/wiki/markdown) parser and _html_ translator written in 100% pure [zig](https://ziglang.org/) with zero dependencies.  _zmd_ is used by the [jetzig web framework](https://www.jetzig.dev/).  ## supported syntax  * headers (h1->h6) * **bold** * _italic_ * `code` * links * images * fenced code blocks (with info string) * ordered lists * unordered lists  ## usage  ```zig const std = @import('std');  const zmd = @import('zmd').zmd; const fragments = @import('zmd').html.defaultfragments;  pub fn main() !void {     var zmd = zmd.init(std.testing.allocator);     defer zmd.deinit();      try zmd.parse(         ╲╲# header         ╲╲## sub-header         ╲╲### sub-sub-header         ╲╲         ╲╲some text in **bold** and _italic_         ╲╲         ╲╲a paragraph         ╲╲         ╲╲```zig         ╲╲some code         ╲╲```         ╲╲some more text with a `code` fragment     );      const html = try zmd.tohtml(fragments);     defer std.testing.allocator.free(html); } ```  ### customization  the default _html_ formatter provides a set of fragments that can be overridden. fragments can be either:  * a two-element tuple containing an open and close tag (e.g. `.{ '<div>', </div>' }`); * a function that receives `std.mem.allocator` and `zmd.node`, returning `![]const u8`.  simply define a struct with the appropriate declarations of either type and _zmd_ will use the provided fragments, falling back to defaults for anything that is not defined.  some node types provie special attributes such as:  * `meta` - provided on `block` elements. this is the language specifier (`zig`) in this example: ```` ```zig if (true) std.debug.print('some zig code'); ``` ```` * `href`, `title` - provided on `image` and `link` elements.  ```zig const myfragments = struct {     pub const h1 = .{ '<h1 class='text-xl font-bold'>', '</h1>╲n' };      pub fn block(allocator: std.mem.allocator, node: node) ![]const u8 {         const style = 'font-family: monospace;';          return if (node.meta) |meta|             std.fmt.allocprint(allocator,                 ╲╲<pre class='language-{s}' style='{s}'><code>{s}</code></pre>             , .{ meta, style, node.content })         else             std.fmt.allocprint(allocator,                 ╲╲<pre style='{s}'><code>{s}</code></pre>             , .{ style, node.content });     } } ```  and then:  ```zig const html = try zmd.tohtml(myfragments); ```  see [src/zmd/html.zig](src/zmd/html.zig) for the full reference.  ## license  _zmd_ is [mit](license)-licensed. ","kassane/winpthreads-zigbuild":"The Winpthreads Library for Zig toolchain the winpthreads library for zig -----------------------  [![build](https://github.com/kassane/winpthreads-zigbuild/actions/workflows/build.yml/badge.svg)](https://github.com/kassane/winpthreads-zigbuild/actions/workflows/build.yml)  based on: https://github.com/ziglang/zig/issues/10989  zig toolchain/mingw don't includes `winpthreads`.  this library provides posix threading apis for mingw-w64.  for maximum compatibility, winpthreads headers expose apis without the `dllimport` attribute by default. if your program is linked against the dll, you may define the `winpthreads_use_dllimport` macro to add the `dllimport` attribute to all apis, which makes function calls to them a bit more efficient.   how to use ---------  **requires:** zig v0.12.0 or higher   * make a project:  ```bash mkdir your-project-folder cd your-project-folder  # generate both (exe and lib template w/ build.zig & build.zig.zon) zig init # get latest version (commit-tag or branch) zig fetch git+https://github.com/kassane/winpthreads-zigbuild#main ```  * add on current project:  ```bash # (w/ build.zig & build.zig.zon) cd your-project-folder # get latest version zig fetch git+https://github.com/kassane/winpthreads-zigbuild#main # or #commit-tag ```  **warn:** `main` branch changes commit hashes. ","better-zig/learn-zig":"zig quick learn # learn-zig  - learning zig language  > related:  - ✅ https://github.com/better-zig/ziglings-solutions     - zig 语法练习  ## features:  - [basic](./packages/basic/): zig basic example - [toolbox](./packages/toolbox/) : zig toolbox - [zig-utils](./packages/zig-utils/) : zig utils  > 与 c 语言互操作性:  - ✅ [c](./packages/c/src/main.c): 使用 zig 作为 c 编译器, 直接编译 c 代码   - `cd packages/c; task run`   - or `task c:run` - ✅ [zig-use-c](./packages/zig-use-c/src/main.zig): zig 调用 c 代码 - ✅ [zig-to-c](./packages/zig-to-c/readme.md): zig 编译成 c lib(c abi), 基于 `ffi`, 被其他语言(如 dart)调用  ## quickstart:  > requirements:  - zig: `0.10.0-dev.2617+47c4d4450` - zigmod: `zigmod r80 macos aarch64 none`  > install:  ```ruby  # install zig: task install:zig:dev  -> % zig version 0.10.0-dev.2617+47c4d4450  # macos + m1 cpu: task install:zigmod:m1 # or macos + intel cpu task install:zigmod:intel   ```  > run:  ```ruby task basic:run ```  > test:  ```ruby task basic:test ```  ## structure:  ```ruby   -> % tree ./packages/ -l 2 ./packages/ ├── basic │   ├── taskfile.yml │   ├── build.zig │   ├── src │   ├── zig-cache │   ├── zig-out │   └── zigmod.yml ├── toolbox │   ├── taskfile.yml │   ├── build.zig │   ├── src │   └── zigmod.yml └── zig-utils     ├── taskfile.yml     ├── build.zig     ├── src     ├── zig-cache     └── zigmod.yml    ``` ","ziglana/gRPC-zig":"blazigly fast gRPC client & server implementation in zig # 🚀 grpc-zig  a blazingly fast grpc client & server implementation in zig, designed for maximum performance and minimal overhead.  [![license: unlicense](https://img.shields.io/badge/license-unlicense-blue.svg)](http://unlicense.org/) [![zig](https://img.shields.io/badge/zig-%23f7a41d.svg?style=flat&logo=zig&logocolor=white)](https://ziglang.org/) [![http/2](https://img.shields.io/badge/http%2f2-supported-success)](https://http2.github.io/)  ## ⚡️ features  - 🔥 **blazingly fast**: built from ground up in zig for maximum performance - 🔐 **full security**: built-in jwt authentication and tls support - 🗜️ **compression**: support for gzip and deflate compression - 🌊 **streaming**: efficient bi-directional streaming - 💪 **http/2**: full http/2 support with proper flow control - 🏥 **health checks**: built-in health checking system - 🎯 **zero dependencies**: pure zig implementation - 🔍 **type safety**: leverages zig's comptime for compile-time checks  ## 🚀 quick start  ```zig // server const server = try grpcserver.init(allocator, 50051, 'secret-key'); try server.handlers.append(.{     .name = 'sayhello',     .handler_fn = sayhello, }); try server.start();  // client var client = try grpcclient.init(allocator, 'localhost', 50051); const response = try client.call('sayhello', 'world', .none); ```  ## 📚 examples  ### basic server  ```zig const std = @import('std'); const grpcserver = @import('server.zig').grpcserver;  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();      var server = try grpcserver.init(gpa.allocator(), 50051, 'secret-key');     defer server.deinit();      try server.start(); } ```  ### streaming  ```zig var stream = streaming.messagestream.init(allocator, 5); try stream.push('first message', false); try stream.push('final message', true); ```  ## 🔧 installation  1. add to your `build.zig.zon`:  ```zig .dependencies = .{     .grpc_zig = .{         .url = 'https://github.com/ziglana/grpc-zig/archive/refs/tags/v0.1.0.tar.gz',     }, }, ```  2. add to your `build.zig`:  ```zig const grpc_zig = b.dependency('grpc_zig', .{}); exe.addmodule('grpc', grpc_zig.module('grpc')); ```  ## 🏃 performance  benchmarked against other grpc implementations (ops/sec, lower is better):  ``` grpc-zig    │████████░░░░░░░░░░│  2.1ms grpc go     │██████████████░░░░│  3.8ms grpc c++    │████████████████░░│  4.2ms ```  ## 🤝 contributing  contributions are welcome! please feel free to submit a pull request. for major changes, please open an issue first to discuss what you would like to change.  ## 📜 license  this project is licensed under the unlicense - see the [license](license) file for details.  ## ⭐️ support  if you find this project useful, please consider giving it a star on github to show your support!  ## 🙏 acknowledgments  - [spice](https://github.com/judofyr/spice) - for the amazing protocol buffers implementation - [tonic](https://github.com/hyperium/tonic) - for inspiration on api design - the zig community for their invaluable feedback and support  ---  made with ❤️ in zig ","jedisct1/zig-morus":"MORUS-1280-128 implementation in Zig. # morus cipher for zig  this is a zig implementation of [morus](https://competitions.cr.yp.to/round3/morusv2.pdf) (morus-1280-128)  morus is a fast authenticated cipher for platforms without hardware aes acceleration.  it performs especially well on webassembly compared to alternatives.  its performance is comparable to aes-ocb, without using aes instructions.  benchmark results on x86_64 (macbook pro, 2,4 ghz core i9, single core):  ```text             morus:       5890 mib/s        aes128-ocb:       5824 mib/s ```  benchmark results for webassembly (wavm)  ```text        aes128-gcm:        176 mib/s        aes128-ocb:        300 mib/s  xchacha8poly1305:        319 mib/s        aegis-128l:        807 mib/s             rocca:        854 mib/s             morus:       3505 mib/s ```  morus is the fastest cipher on raspberry pi 4, and possibly other arm devices without crypto extensions:  ```text        aes128-gcm:         41 mib/s        aes128-ocb:         81 mib/s  xchacha8poly1305:        159 mib/s        aegis-128l:        168 mib/s             rocca:        221 mib/s             morus:        713 mib/s ```  on platforms with aes acceleration, [aegis](https://jedisct1.github.io/draft-aegis-aead/draft-irtf-cfrg-aegis-aead.html)(available in the standard library as `std.crypto.aead.aegis.aegis128l`) and [rocca](https://github.com/jedisct1/zig-rocca) have higher performance.  benchmark on rocket lake (xeon e-2386g):  ```text        aes128-ocb:      10173 mib/s        aes256-ocb:       7792 mib/s             morus:      11069 mib/s             rocca:      16274 mib/s        aegis-128l:      21206 mib/s (170 gb/s) ```  warning: morus doesn't provide 128-bit confidentiality even though [the best know attacks](https://eprint.iacr.org/2019/172.pdf) are impractical. ","ikskuh/zig-uri":"A small URI parser that parses URIs after RFC3986 # zig uri parser  a small uri parser that parses uris after [rfc3986](https://tools.ietf.org/html/rfc3986).  > **notice: this library is deprecated!**   > this library is now part of zig `std` library, available as `std.uri` since [87b2234](https://github.com/ziglang/zig/commit/87b223428a8953b6af9bea61ff4cc905821c0557). >   ## usage example  ```zig var link = try uri.parse('https://github.com/masterq32/zig-uri'); // link.scheme == 'https' // link.host   == 'github.com' // link.path   == '/masterq32/zig-uri' ``` ","guidorice/libgeos.zig":"Zig bindings for the GEOS C library; compile libgeos in your build.zig. # libgeos.zig  [zig](https://ziglang.org) bindings for the [geos c library (libgeos)](https://libgeos.org/)  > geos (geometry engine, open source) is a c/c++ library for spatial computational geometry of the sort generally used by “geographic information systems” software. geos is a core dependency of postgis, qgis, gdal, and shapely.  ## geos version  `3.10.2-capi-1.16.0`  ## zig version  * `0.9.1`, `0.10.0-dev`  ## build  requires only `zig`. don't forget to clone/init the submodule!  ```shell git clone --recurse-submodules https://github.com/guidorice/libgeos.zig.git cd libgeos.zig/ zig build ```  ## tests  ```shell zig build test ```  ## examples  ```shell $ zig build --help $ zig build run-ex1 geometry a:         polygon((0 0, 10 0, 10 10, 0 10, 0 0)) geometry b:         polygon((5 5, 15 5, 15 15, 5 15, 5 5)) intersection(a, b): polygon ((10 10, 10 5, 5 5, 5 10, 10 10)) ```  ## known issues  * blocker: the libgeos library uses c++ `std::runtime_error`, which is not currently captured by the zig wrapper code. as a result, there is no way to recover from some error conditions, for example, failing to parse some wkt formatted string. [see issue #9](https://github.com/guidorice/libgeos.zig/issues/9)  ## roadmap  * [x] minimal build.zig. builds libgeos entirely using zig compiler and build system. * [x] create example exe using this package as a zig library. * [x] port libgeos c examples to zig (from src/geos/examples)   * [x] [ex 1](src/examples/ex1.zig) reads two wkt representations and calculates the intersection, prints it out, and cleans up.   * [x] [ex 1 (threadsafe)](src/examples/ex1_threadsafe.zig)   * [x] [ex 2](src/examples/ex2.zig) reads one geometry and does high-performance prepared geometry operations to place 'random' points inside it.   * [x] [ex 3](src/examples/ex3.zig) build a spatial index and search it for a nearest pair. * [ ] solution for `std:runtime_error` conditions (see known issues) * [ ] new zig idiomatic wrapper for libgeos c api? alternatively: port to zig-native. * [ ] new geojson reader/writer which speaks libgeos types and full support for feature properties. reference: [geos geojson support notes here.](https://libgeos.org/specifications/geojson/) * [ ] new zig projects which utilize these geospatial or geometric primitives.  ## notes  see also [vendor/geos/readme](src/vendor/geos/readme.md) for how libgeos is updated within this repo. ","Jeevananthan-23/ziglang-caches":"In-memory cache implementation with commonly used LRU, W-LFU and S3-FIFO as the eviction policy # ziglang-caches  this is a modern cache implementation, inspired by the following papers, provides high efficiency.  - sieve | [sieve is simpler than lru: an efficient turn-key eviction algorithm for web caches (nsdi'24)](https://junchengyang.com/publication/nsdi24-sieve.pdf) - s3-fifo | [fifo queues are all you need for cache eviction (sosp'23)](https://dl.acm.org/doi/10.1145/3600006.3613147) - w-tinylfu | [tinylfu: a highly efficient cache admission policy](https://arxiv.org/abs/1512.00727)  this offers state-of-the-art efficiency and scalability compared to other lru-based cache algorithms.  ## basic usage  > [!lru_cache]  > least recents used cache eviction policy for cache your data in-memory for fast access.    ```zig const std = @import('std'); const lru = @import('lru');  const cache = lru.lrucache(.locking, u8, []const u8);  pub fn main() !void {      // create a cache backed by dram     var lrucache = try cache.init(std.heap.page_allocator, 4);     defer lrucache.deinit();      // add an object to the cache     try lrucache.insert(1, 'one');     try lrucache.insert(2, 'two');     try lrucache.insert(3, 'three');     try lrucache.insert(4, 'four');      // most recently used cache     std.debug.print('mru: {s} ╲n', .{lrucache.mru().?.value});      // least recently used cache     std.debug.print('lru: {s} ╲n', .{lrucache.lru().?.value});      // remove from cache     _ = lrucache.remove(1);      // check if an object is in the cache o/p: false     std.debug.print('key: 1 exists: {} ╲n', .{lrucache.contains(1)}); } ```  ### :rocket: usage  1. add `ziglang-caches` as a dependency in your `build.zig.zon`.      <details>      <summary><code>build.zig.zon</code> example</summary>      ```zig     .{         .name = '<name_of_your_package>',         .version = '<version_of_your_package>',         .dependencies = .{             .caches = .{                 .url = 'https://github.com/jeevananthan-23/ziglang-caches/archive/<git_tag_or_commit_hash>.tar.gz',                 .hash = '<package_hash>',             },         },     }     ```      set `<package_hash>` to `12200000000000000000000000000000000000000000000000000000000000000000`, and zig will provide the correct found value in an error message.      </details>  2. add `lrucache` as a module in your `build.zig`.      <details>      <summary><code>build.zig</code> example</summary>      ```zig     const lrucache = b.dependency('caches', .{});     exe.addmodule('lrucache', lrucache.module('lrucache'));     ```      </details> ","knadh/zig-releaser":"A simple hack to use GoReleaser to build, release, and publish Zig projects. # zig-releaser  zig-releaser is a hack that allows zig programs to be built, packaged, and released with [goreleaser](https://goreleaser.com), a tool for publishing go programs.  [here is an example](https://github.com/knadh/csv2json/releases) for a zig program published to github with goreleaser. the changelog and artefacts are all automatically generated by goreleaser. this hack has only been tested with github but should work with other release targets goreleaser supports.  ### how to use  - install [goreleaser](https://goreleaser.com/install/). - setup the [github token](https://github.com/settings/tokens/new) with `repo` perms.   - copy `.goreleaser/`, and `.goreleaser.yml` from this repo to the root of the zig project. - edit `.goreleaser.yml` for the project (generally the `binary`, `goos`, `files` fields). - edit `build.sh` script to tweak the zig build flags.  once the project is ready for release, add a semver tag (`git tag -a v0.1.0 -m v0.1.0`)  ### dry run  ```sh goreleaser --snapshot --skip=publish --clean ```  the releases will appear in the `dist` directory.  ### publish  ```sh goreleaser --snapshot --skip=publish --clean ``` ","tensorush/zig-sieve":"Zig implementation of SIEVE cache eviction algorithm. # zig-sieve  [![ci][ci-shd]][ci-url] [![cd][cd-shd]][cd-url] [![dc][dc-shd]][dc-url] [![lc][lc-shd]][lc-url]  ## zig implementation of [sieve cache eviction algorithm](https://cachemon.github.io/sieve-website/).  ### :rocket: usage  - add `sieve` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-sieve/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `sieve` dependency in `build.zig`.  ```zig const sieve_dep = b.dependency('sieve', .{     .target = target,     .optimize = optimize, }); const sieve_mod = sieve_dep.module('sieve'); <compile>.root_module.addimport('sieve', sieve_mod); ```  ### :bar_chart: benchmarks  - sequence: the time to cache and retrieve integer values.      ```sh     $ zig build bench -- -s     sequence: 28.833us     ```  - composite: the time to cache and retrieve composite values.      ```sh     $ zig build bench -- -c     composite: 45.291us     ```  - composite (normal): the time to cache and retrieve normally-distributed composite values.      ```sh     $ zig build bench -- -n     composite normal: 135.25us     ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-sieve/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-sieve/blob/main/.github/workflows/ci.yaml [cd-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-sieve/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/tensorush/zig-sieve/blob/main/.github/workflows/cd.yaml [dc-shd]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=docs&labelcolor=black [dc-url]: https://tensorush.github.io/zig-sieve [lc-shd]: https://img.shields.io/github/license/tensorush/zig-sieve.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-sieve/blob/main/license ","Durobot/zon_get_fields":"Utility functions to get field values from the abstract syntax tree generated from ZON (Zig Object Notation) text using Zig stdlib # zon_get_fields  several functions to facilitate the process of walking abstract syntax trees (asts) generated from [zon](https://github.com/ziglang/zig/issues/14290) text, and fetch the values of the fields from the ast.   but first you have to call `std.zig.ast.parse` to tokenize and parse your zon, creating the ast.  tested with zig **0.14.0-dev.1421+f87dd43c1**.  support for older versions, like zig **0.12.0**, **0.12.1**, **0.13.0**, and **0.14.0-dev.91+a154d8da8** was dropped because of [this breaking change in the standard library](https://github.com/ziglang/zig/commit/0fe3fd01ddc2cd49c6a2b939577d16b9d2c65ea9).  if you need a version of zon_get_fields that works with older zig versions, [get this release](https://github.com/durobot/zon_get_fields/releases/tag/v0.1-beta). it still probably won't work with zig 0.11, but you're welcome to try it and report back, although i'm not too keen on backporting.  **zon_get_fields** is licensed under the [the mit license](https://en.wikipedia.org/w/index.php?title=mit_license&useskin=vector). you are more than welcome to drop `zon_get_fields.zig` into your project (don't forget to `const zgf = @import('zon_get_fields.zig');`), or you can use the zig package manager:  1. in your project's `build.zig.zon`, in `.dependencies`, add     ```zig    .zon_get_fields =    .{        .url = 'https://github.com/durobot/zon_get_fields/archive/<git commit hash, 40 hex digits>.tar.gz',        .hash = '<zig package hash, 68 hex digits>' // use arbitrary hash, get correct hash from the error     }    ```  2. in your project's `build.zig`, in `pub fn build`, before `b.installartifact(exe);`, add     ```zig    const zgf = b.dependency('zon_get_fields',    .{        .target = target,        .optimize = optimize,    });    exe.root_module.addimport('zon_get_fields', zgf.module('zon_get_fields'));    ```  3. add `const zgf = @import('zon_get_fields');`in your source file(s).  3. build your project with `zig build`, as you normally do.  things i like:  1. hey, it works! at least it looks like it does, and since nothing like this exists in the standard library, i consider it a success; 2. you can throw your struct and an ast at a function (`pub fn zontostruct`), and have your struct filled with data. the fields that have matching values in the provided ast, that is, and you get to know what was filled and what was not - look and the returned struct; 3. or you can fetch the values of the fields you need using string paths to indicate them, calling `pub fn getfieldval`. it's fine if all you need is a couple of fields; 3. all the basics are covered - signed and unsigned integers and floats, strings, single characters, booleans, nested structs, arrays, arrays of arrays, arrays of structs (in fact, any combination of structs and arrays should work).  things i don't really like:  1. no ast validity verification. thinking about zon schemas or similar in the future, maybe? 2. if you use the second approach, `pub fn getfieldval`, for every field you want to read you've got to specify the path. the path is split, the ast is walked, and if you have rather large structures to fetch, a lot of this work is repeated for each field. not the best approach performance-wise. but you can switch to `pub fn zontostruct`, which fills all the fields it can it one go; 3. an ugly hack that i had to use in order to get negative values from the fields, both integers and floating point. see `fn fullltokenslice`.  i can't be sure my approach works correctly in all situations, or will continue to work in the future, so i feel really uneasy about using it;  for examples of how to use them, turn to the test sections in `zon_parse.zig`:  1. find `zontostruct tests` [comment](https://github.com/durobot/zon_get_fields/blob/cd1524a1e30b1375524a48b491d845f27a3b4594/src/zon_get_fields.zig#l1490) for `pub fn zontostruct` approach - filling your struct all at once; 2. find `getfieldval tests` [comment](https://github.com/durobot/zon_get_fields/blob/cd1524a1e30b1375524a48b491d845f27a3b4594/src/zon_get_fields.zig#l428) for `pub fn getfieldval`approach - fetching field values one by one, as you provide string paths to each field.  or check out the short examples below (you can compile and run them with `zig build example_zon_to_struct` and `zig build example_get_field_val` commands).  say you've got this zon file (`my.zon`):  ```zon .{     .database =     .{         .host = '127.0.0.1',         .port = 5432,         .user = 'superadmin',         .password = 'supersecret',     },     .decimal_separator = '.',     .months_in_year = 12,     .newline_char = '╲n',     .pi = 3.14159265359,     .hello = 'こんにちは',     .unicode_char = '⚡',     .primes = .{ 2, 3, 5, 7, 11 },     .factorials = .{ 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800 },     .slc_of_structs = .{ .{ .ham = 10, .eggs = 2 }, .{ .ham = 5 } },     .slc_of_arrays = .{ .{ 10, 20, 30 }, .{ 40, 50, }, },     .slc_of_slices = .{ .{ 1, 2, 3 }, .{ 4, 5 }, .{ 6 } } } ``` then you can either: 1. define a struct, pass a pointer to it together with ast built from `my.zon` to pub `fn zontostruct`, get your struct filled, and get a report struct which mirrors the fields of your struct, indicating whether they were filled or not (see [this table](#report-struct-field-types) for report struct field types):  ```zig const std = @import('std'); const zgf = @import('zon_get_fields.zig');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();     const allocr = gpa.allocator();      // `ast.parse` requires a sentinel (0) terminated slice, so we pass 0 as the sentinel value (last arg)     const zon_txt = try std.fs.cwd().readfileallocoptions(allocr, 'my.zon', std.math.maxint(usize),                                                           null, @alignof(u8), 0);     defer allocr.free(zon_txt);      var ast = try std.zig.ast.parse(allocr, zon_txt, .zon);     defer ast.deinit(allocr);      const mystruct = struct // field order is not important     {         const databasesettings = struct         {             host: []const u8 = &.{}, // since this is a slice of _const_ u8,                                      // it will be addressing the string in ast.source             port: u16 = 0,             user: []u8 = &.{}, // having a slice field requires passing a non-null allocator                                // to zontostruct, and freeing `user` when we're done             password: [20]u8 = [_]u8 {33} ** 20, // this array is filled with string/array elements up                                                  // to this field's capacity, or padded with 0 bytes,                                                  // if zon string/array hasn't got enough elements         };         const mystruct = struct { ham: u32 = 0, eggs: u32 = 0 };         database: databasesettings = .{},         decimal_separator: u8 = 0,         months_in_year: u8 = 0,         newline_char: u8 = 0,         pi: f64 = 0.0,         hello: []const u8 = &.{}, // same as hello: []const u8 = undefined; hello.len = 0;         unicode_char: u21 = 0,         primes: [10]u8 = [_]u8 { 0 } ** 10,         factorials: [10]u32 = [_]u32 { 0 } ** 10,         slc_of_structs: []mystruct = &.{},         slc_of_arrays: [][3]u32 = &.{},         slc_of_slices: [][]u32 = &.{},     };     var ms = mystruct {};     // we must provide `allocr` if there are slices in ms, otherwise a null is fine.     const report = try zgf.zontostruct(&ms, ast, allocr);     defer allocr.free(ms.database.user); // must free `user` since it's a slice of non-const u8's.     defer allocr.free(ms.slc_of_structs);     defer allocr.free(report.slc_of_structs); // must also free the slice of structs in `report`     defer allocr.free(ms.slc_of_arrays);     defer allocr.free(report.slc_of_arrays);     defer     {         for (ms.slc_of_slices) |s| allocr.free(s); // deallocate nested slices first         allocr.free(ms.slc_of_slices); // then deallocate the outer slice         allocr.free(report.slc_of_slices); // `report` contains a slice of `zonfieldresult` enums     }      std.debug.print('field = database.host      value = {s}╲n', .{ ms.database.host });     std.debug.print('field = database.port      value = {d}╲n', .{ ms.database.port });     std.debug.print('field = database.user      value = {s}╲n', .{ ms.database.user });     std.debug.print('field = database.password  value = {s}╲n', .{ ms.database.password });     std.debug.print('field = decimal_separator  value = {c}╲n', .{ ms.decimal_separator });     std.debug.print('field = months_in_year     value = {d}╲n', .{ ms.months_in_year });     std.debug.print('field = newline_char       value = 0x{x:0>2}╲n', .{ ms.newline_char });     std.debug.print('field = pi                 value = {d}╲n', .{ ms.pi });     std.debug.print('field = hello              value = {s}╲n', .{ ms.hello });     std.debug.print('field = unicode_char       value = {u}╲n', .{ ms.unicode_char });     std.debug.print('field = primes             value = [ ', .{});     for (ms.primes) |p| std.debug.print('{}, ', .{ p });     std.debug.print(']╲n', .{});     std.debug.print('field = factorials         value = [ ', .{});     for (ms.factorials) |f| std.debug.print('{}, ', .{ f });     std.debug.print(']╲n', .{});     std.debug.print('field = slc_of_structs     value = [ ', .{});     for (ms.slc_of_structs) |s| std.debug.print('{{ ham = {}, eggs = {} }}, ', .{ s.ham, s.eggs });     std.debug.print(']╲n', .{});     std.debug.print('field = slc_of_arrays      value = [ ', .{});     for (ms.slc_of_arrays) |a|     {         std.debug.print('[ ', .{});         for (a) |e| std.debug.print('{}, ', .{ e });         std.debug.print('], ', .{});     }     std.debug.print(']╲n', .{});     std.debug.print('field = slc_of_slices      value = [ ', .{});     for (ms.slc_of_slices) |s|     {         std.debug.print('[ ', .{});         for (s) |e| std.debug.print('{}, ', .{ e });         std.debug.print('], ', .{});     }     std.debug.print(']╲n╲n', .{});      // `report` describes the state of corresponding fields in `ms`     std.debug.print('report =╲n{s}╲n', .{ std.json.fmt(report, .{ .whitespace = .indent_4 }) }); } ```  2. or you can fetch the values one by one using `pub fn getfieldval`:  ```zig const std = @import('std'); const zgf = @import('zon_get_fields.zig');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();     const allocr = gpa.allocator();      // `ast.parse` requires a sentinel (0) terminated slice, so we pass 0 as the sentinel value (last arg)     const zon_txt = try std.fs.cwd().readfileallocoptions(allocr, 'my.zon', std.math.maxint(usize),                                                           null, @alignof(u8), 0);     defer allocr.free(zon_txt);      var ast = try std.zig.ast.parse(allocr, zon_txt, .zon);     defer ast.deinit(allocr);      var fld_name: []const u8 = 'database.host';     const dbhost_str = try zgf.getfieldval([]const u8, ast, fld_name);     std.debug.print('field = {s}      value = {s}╲n', .{ fld_name, dbhost_str });      fld_name = 'database.port';     const dbport_u16 = try zgf.getfieldval(u16, ast, fld_name);     std.debug.print('field = {s}      value = {d}╲n', .{ fld_name, dbport_u16 });      fld_name = 'database.user';     const dbhost_user = try zgf.getfieldval([]const u8, ast, fld_name);     std.debug.print('field = {s}      value = {s}╲n', .{ fld_name, dbhost_user });      fld_name = 'database.password';     const dbhost_password = try zgf.getfieldval([]const u8, ast, fld_name);     std.debug.print('field = {s}  value = {s}╲n', .{ fld_name, dbhost_password });      fld_name = 'decimal_separator';     const dec_separ_u8 = try zgf.getfieldval(u8, ast, fld_name);     std.debug.print('field = {s}  value = {c}╲n', .{ fld_name, dec_separ_u8 });      fld_name = 'months_in_year';     const months_in_year_u8 = try zgf.getfieldval(u8, ast, fld_name);     std.debug.print('field = {s}     value = {d}╲n', .{ fld_name, months_in_year_u8 });      fld_name = 'newline_char';     const newline_char_u8 = try zgf.getfieldval(u8, ast, fld_name);     std.debug.print('field = {s}       value = 0x{x:0>2}╲n', .{ fld_name, newline_char_u8 });      fld_name = 'pi';     const pi_f64 = try zgf.getfieldval(f64, ast, fld_name);     std.debug.print('field = {s}                 value = {d}╲n', .{ fld_name, pi_f64 });      fld_name = 'hello';     const hello_unicode_str = try zgf.getfieldval([]const u8, ast, fld_name);     std.debug.print('field = {s}              value = {s}╲n', .{ fld_name, hello_unicode_str });      fld_name = 'unicode_char';     const unicode_char_u21 = try zgf.getfieldval(u21, ast, fld_name);     std.debug.print('field = {s}       value = {u}╲n', .{ fld_name, unicode_char_u21 });      std.debug.print('field = primes             value = [ ', .{});     var buf = [_]u8 { 0 } ** 22;     for (0..5) |i|     {         const buf_slice = try std.fmt.bufprint(&buf, 'primes[{d}]', .{i});         const int_u8 = try zgf.getfieldval(u8, ast, buf_slice);         std.debug.print('{d}, ', .{ int_u8 });     }     std.debug.print(']╲n', .{});      std.debug.print('field = factorials         value = [ ', .{});     for (0..12) |i|     {         const buf_slice = try std.fmt.bufprint(&buf, 'factorials[{d}]', .{i});         const int_u32 = try zgf.getfieldval(u32, ast, buf_slice);         std.debug.print('{d}, ', .{ int_u32 });     }     std.debug.print(']╲n', .{});      std.debug.print('field = slc_of_structs     value = [ ', .{});     for (0..2) |i|     {         const ham_buf_slice = try std.fmt.bufprint(&buf, 'slc_of_structs[{d}].ham', .{i});         const ham_int_u32 = try zgf.getfieldval(u32, ast, ham_buf_slice);         const eggs_buf_slice = try std.fmt.bufprint(&buf, 'slc_of_structs[{d}].eggs', .{i});         const eggs_int_u32 = zgf.getfieldval(u32, ast, eggs_buf_slice) catch |err|         {   // we actually must check these things for all fields             std.debug.print('{{ ham = {d}, eggs = {} }}, ', .{ ham_int_u32, err });             continue;         };         std.debug.print('{{ ham = {d}, eggs = {d} }}, ', .{ ham_int_u32, eggs_int_u32 });     }     std.debug.print(']╲n', .{});      std.debug.print('field = slc_of_arrays      value = [ ', .{});     for (0..2) |i|     {         std.debug.print('[ ', .{});         for (0..(3 - i)) |j|         {             const buf_slice = try std.fmt.bufprint(&buf, 'slc_of_arrays[{d}].[{d}]', .{i, j});             const int_u32 = try zgf.getfieldval(u32, ast, buf_slice);             std.debug.print('{d}, ', .{ int_u32 });         }         std.debug.print('], ', .{});     }     std.debug.print(']╲n', .{});      std.debug.print('field = slc_of_slices      value = [ ', .{});     for (0..3) |i|     {         std.debug.print('[ ', .{});         for (0..(3 - i)) |j|         {             const buf_slice = try std.fmt.bufprint(&buf, 'slc_of_slices[{d}].[{d}]', .{i, j});             const int_u32 = try zgf.getfieldval(u32, ast, buf_slice);             std.debug.print('{d}, ', .{ int_u32 });         }         std.debug.print('], ', .{});     }     std.debug.print(']╲n', .{}); } ```    ##### report struct field types  | target struct field                      | report struct field                                          | | ---------------------------------------- | ------------------------------------------------------------ | | primitive types (integers, floats, etc.) | zonfieldresult enum.                                         | | array of elements of a primitive type    | array of zonfieldresult enum elements.                       | | array of arrays, structs or slices       | array of arrays, structs, slices, or zonfieldresult enums (for target array of slices of primitive elements).<br />the type of report array element depends on the type of target array elements. | | struct                                   | struct. field types depend on target struct field types.     | | slice of elements of a primitive type    | zonfieldresult enum.                                         | | slice of arrays                          | slice of arrays. report array element type depends on the target array element type.<br />**note**: (1) allocator must be provided (not null), since report slice has to be allocated; (2) caller owns the report struct and must deallocate this report slice. | | slice of structs                         | slice of structs. report struct field types depend on the target struct field types.<br />**note**: (1) allocator must be provided (not null), since report slice has to be allocated; (2) caller owns the report struct and must deallocate this report slice. | | slice of slices                          | if target nested slices contain primitive type elements (integers, floats, etc.), then the report will contain a slice of zonfieldresult enum elements.<br />if target nested slices contain structs, arrays or slices, then the report will contain a slice of matching structs, arrays or slices. see target struct field types 'struct', 'array' or 'slice' above.<br />**note**: (1) allocator must be provided (not null), since report slice has to be allocated; (2) caller owns the report struct and must deallocate this report slice. |","tensorush/liza":"Zig codebase initializer. # liza  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## zig codebase initializer.  ### :rocket: usage  ```sh git clone https://github.com/tensorush/liza.git cd liza/ zig build exe -- -h ```  ### :sparkles: features  - #### [zig executable template](src/templates/exe/):     - dependency package usage.     - custom `build.zig.zon`.     - readme with badges.  - #### [zig library template](src/templates/lib/):     - examples' directory setup.     - custom `build.zig.zon`.     - readme with badges.  - #### [zig port template](src/templates/prt/):     - c/c++/objc codebase compilation.     - custom `build.zig.zon`.     - readme with badges.  - #### [github ci template](src/templates/.github/workflows/ci.yaml):     - `exe`/`example`/`install` (`?`): executable's run, library's example suite execution, or port's installation.     - `test`: test suite execution and code coverage publication to [codecov](https://docs.codecov.com/docs/github-2-getting-a-codecov-account-and-uploading-coverage#install-the-github-app-integration).     - `fmt`: formatting checks execution.  - #### [github cd workflow](src/templates/.github/workflows/cd.yaml):     - `emit` -> `deploy`: documentation emission and deployment to [github pages](https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow).  - #### [mit license template](src/templates/license).  - #### [`.gitattributes`](src/templates/.gitattributes).  - #### [`.gitignore`](src/templates/.gitignore).  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/liza/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/liza/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/tensorush/liza.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/liza/blob/main/license ","allyourcodebase/nasm":"nasm with the build system replaced by zig this is a fork of [nasm](https://nasm.us/), packaged for zig. unnecessary files have been deleted, and the build system has been replaced with `build.zig`.  original readme follows:  ----------------------------------------------------------------------------  nasm, the netwide assembler ===========================  [![master](https://travis-ci.org/netwide-assembler/nasm.svg?branch=master)](https://travis-ci.org/netwide-assembler/nasm)  many many developers all over the net respect nasm for what it is: a widespread (thus netwide), portable (thus netwide!), very flexible and mature assembler tool with support for many output formats (thus netwide!!).  now we have good news for you: nasm is licensed under the 'simplified' [(2-clause) bsd license](https://opensource.org/licenses/bsd-2-clause). this means its development is open to even wider society of programmers wishing to improve their lovely assembler.  visit our [nasm.us](https://www.nasm.us/) website for more details.  with best regards, the nasm crew. ","nektro/zig-mime":"This repository has no description. # zig-mime ","hendriknielaender/http2.zig":"🌐 HTTP/2 server for zig > [!warning]   > still work in progress.  <h1 align='center'>    <img src='docs/images/logo.png' width='40%' height='40%' alt='http2.zig logo' title='http2.zig logo'> </h1>  <div align='center'>a http/2 zig library according to the http/2 rfcs.</div> <div align='center'>     [![mit license](https://img.shields.io/badge/license-mit-blue.svg)](https://github.com/hendriknielaender/http2.zig/blob/head/license) ![github code size in bytes](https://img.shields.io/github/languages/code-size/hendriknielaender/http2.zig) [![prs welcome](https://img.shields.io/badge/prs-welcome-brightgreen.svg)](https://github.com/hendriknielaender/http2.zig/blob/head/contributing.md) ![h2spec conformance](https://img.shields.io/badge/h2spec-71%2f74%20tests%20passing-red)  </div>  ## features  - connection management - stream handling - frame parsing and serialization - compliance with http/2 specifications  ## installation  you can use `zig fetch` to conveniently set the hash in the `build.zig.zon` file and update an existing dependency.  run the following command to fetch the http2.zig package: ```shell zig fetch https://github.com/hendriknielaender/http2.zig/archive/<commit>.tar.gz --save ``` using `zig fetch` simplifies managing dependencies by automatically handling the package hash, ensuring your `build.zig.zon` file is up to date.  ### option 1 (build.zig.zon)  1. declare http2.zig as a dependency in `build.zig.zon`:     ```diff    .{        .name = 'my-project',        .version = '1.0.0',        .paths = .{''},        .dependencies = .{    +       .http2 = .{    +           .url = 'https://github.com/hendriknielaender/http2.zig/archive/<commit>.tar.gz',    +       },        },    }    ```  2. add the module in `build.zig`:     ```diff    const std = @import('std');     pub fn build(b: *std.build) void {        const target = b.standardtargetoptions(.{});        const optimize = b.standardoptimizeoption(.{});     +   const opts = .{ .target = target, .optimize = optimize };    +   const http2_module = b.dependency('http2', opts).module('http2');         const exe = b.addexecutable(.{            .name = 'test',            .root_source_file = b.path('src/main.zig'),            .target = target,            .optimize = optimize,        });    +   exe.root_module.addimport('http2', http2_module);        exe.install();         ...    }    ```  3. get the package hash:     ```shell    $ zig build    my-project/build.zig.zon:6:20: error: url field is missing corresponding hash field            .url = 'https://github.com/hendriknielaender/http2.zig/archive/<commit>.tar.gz',                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    note: expected .hash = '<hash>',    ```  4. update `build.zig.zon` package hash value:     ```diff    .{        .name = 'my-project',        .version = '1.0.0',        .paths = .{''},        .dependencies = .{            .http2 = .{                .url = 'https://github.com/hendriknielaender/http2.zig/archive/<commit>.tar.gz',    +           .hash = '<hash>',            },        },    }    ```  ## usage  ### connection  to create an http/2 connection, use the `connection` struct. this struct handles the initialization, sending of the http/2 preface, settings, and managing streams.  ```zig const std = @import('std'); const http2 = @import('http2');  const connection = http2.connection(std.io.anyreader, std.io.anywriter);  pub fn main() !void {     const address = try std.net.address.resolveip('0.0.0.0', 8081);     var listener = try address.listen(.{ .reuse_address = true });     defer listener.deinit();      std.debug.print('listening on 127.0.0.1:8081...╲n', .{});      while (true) {         var conn = try listener.accept();         defer conn.stream.close();           std.debug.print('accepted connection from: {any}╲n', .{conn.address});          var server_conn = connection.init(@constcast(&std.heap.page_allocator), conn.stream.reader().any(), conn.stream.writer().any(), true) catch |err| {             std.debug.print('failed to initialize connection: {}╲n', .{err});             continue;         };         defer server_conn.deinit();          // handle connection and errors during the process         server_conn.handleconnection() catch |err| {             std.debug.print('error handling connection: {}╲n', .{err});         };          std.debug.print('connection from {any} closed╲n', .{conn.address});     } } ``` ","eldesh/iter-zig":"A basic iterator library written in Zig # iter-zig  **iter-zig** is a lazy style generic iterator combinator library written in zig. where the *iterator* means that the types enumrating all element of a set of values.   ## support  this library is developped with:  - debian (x86_64) 10.4 - zig 0.10.0 and zigmod r80 - zig 0.9.1 and zigmod r79   ## build  ```sh zig build ```   ## unit test  to performs unit tests of iter-zig:   ```sh zig build test ```   ## example  an example program using iter-zig is provided. the program can be performed with:  ```sh zig build example ```  source code of this program is `src/main.zig`.   ## generate docs  to generate documentations:   ```sh zig build doc ```  a html documents would be generated under the `./docs` directory.   ## iterator concept  **iterator** is a generic concept that objects that enumrating a set of values. especially, in this library, iterator is a value of a kind of types that satisfies follow constraints.  the constraints are: - have `self` type - have `item` type - have `next` method takes `*self` and returns `?item`.  where the `self` type specifies the type itself (equals to `@this()`), the `item` type represents the type of elements returns from the iterator, and the `next` method returns a 'next' value of the container. if the next value is not exists, 'null' must be returned. the order of occurence of values are implementation defined. however, all values must occur exactly once before 'null' is returned.   ## features  ### meta function  [the type constraints required as an iterator](#iterator-concept) is able to be checked by `isiterator` function statically.  ```zig comptime assert(isiterator(sliceiter(u32))); comptime assert(!isiterator(u32)); ```  when you implement a new type to be an iterator, it must ensure that `isiterator` returns `true`.   ### container iterators  **iter-zig** provides several basic iterators that wraps standard containers.  - arrayiter - sliceiter - arraylistiter - singlylinkedlistiter - boundedarrayiter - tailqueueiter  for example, an iterator on a slice is able to be used as follows:  ```zig var arr = [_]u32{ 1, 2, 3 }; var iter = sliceiter(u32).new(arr[0..]); try expectequal(@as(u32, 1), iter.next().?.*); try expectequal(@as(u32, 2), iter.next().?.*); try expectequal(@as(u32, 3), iter.next().?.*); try expectequal(@as(?*u32, null), iter.next()); ```  further, `const` variations are defined for each containers. these iterators behaves as same to non-const variations except for returns const pointers.  - arrayconstiter - sliceconstiter - arraylistconstiter - singlylinkedlistconstiter - boundedarrayconstiter - tailqueueconstiter  ```zig var arr = [_]u32{ 1, 2, 3 }; var iter = sliceconstiter(u32).new(arr[0..]); iter.next().?.* += 1; // error: cannot assign to constant ```  note that, these iterators not own container values into it. the user must release the memory holding the container if necessary.   ### iterators to containers  iterator to container converters are defined for some std containers.  - slice_from_iter - array_list_from_iter - bounded_array_from_iter - singly_linked_list_from_iter  these converters consume the input iterator and build a container. the constructed container contains all the elements of the iterator and no other elements.   ### range iterator  `range` creates a range value such that it represents a range of numbers. for example, `range(0, 10)` means that the numbers from `0` to `10`, which is mathematics is denoted as `[0,10)`.  in particular, range instantiated with integral type to be iterator.  ```zig var rng = range(@as(u32, 0), 3); try expectequal(@as(u32, 0), rng.next().?); try expectequal(@as(u32, 1), rng.next().?); try expectequal(@as(u32, 2), rng.next().?); try expectequal(@as(?u32, null), rng.next()); ```   similarly, `range_from` creates an instance of `rangefrom` to represents an endless sequence of numbers. e.g. `range_from(@as(u32, 0))` creates an endless sequence of natural numbers `0,1,2,...`.  ```zig var rng = range_from(@as(u32, 0)); try expectequal(@as(u32, 0), rng.next().?); try expectequal(@as(u32, 1), rng.next().?); try expectequal(@as(u32, 2), rng.next().?); .. ```   when `range` or `rangefrom` is instantiated with a type of floating numbers, it would not be an iterator. it is just a range of values.  ```zig comptime assert(!concept.isiterator(range.range(f64))); comptime assert(!concept.isiterator(range.rangefrom(f64))); comptime assert( range.range(@as(f64, 2.0), 3.0).contains(2.5)) comptime assert(!range.range(@as(f64, 2.0), 3.0).contains(1.5)) ```   ### iterator operators  all iterators defined in this library provide iterator functions below.  - peekable - position - cycle - copied - cloned - nth - last - flat_map - flatten - partial_cmp - cmp - le - ge - lt - gt - sum - product - eq - ne - max - max_by - max_by_key - min - min_by - min_by_key - reduce - skip - scan - step_by - fold - try_fold - try_foreach - for_each - take_while - skip_while - map - map_while - filter - filter_map - chain - enumerate - all - any - take - count - find - find_map - inspect - fuse - zip   these functions are almost same to [functions on iterator trait of rust](https://doc.rust-lang.org/std/iter/trait.iterator.html) except for experimental api.  #### adaptor style iterator  some functions above return an iterator from the iterator itself. for that case, the functions are implemented in adaptor style. for example, the `map` function returns a new iterator object `map` rather than apply a function to each elements from the iterator.  ```zig var arr = [_]u32{ 1, 2, 3 }; var iter = sliceiter(u32).new(arr[0..]); fn incr(x:u32) u32 { return x+1; } // calculations have not yet been performed. var map: map(sliceiter(u32), fn (u32) u32) = iter.map(incr);  try expectequal(@as(u32, 2), map.next().?.*); // incr is performed try expectequal(@as(u32, 3), map.next().?.*); // incr is performed try expectequal(@as(u32, 4), map.next().?.*); // incr is performed try expectequal(@as(?*u32, null), map.next()); ```   ### implementing iterator  **iter-zig** allows library users to implement a new iterator type by their self. further, it is easy to implement all functions showed in [iterator operators](#iterator-operators) to your new iterator type using `deriveiterator`.  for example, let's make an iterator `counter` which counts from `1` to `5`.  ```zig const counter = struct {   pub const self = @this();   pub const item = u32;   count: u32,   pub fn new() self { return .{ .count = 0 }; }   pub fn next(self: *self) ?item {     self.count += 1;     if (self.count < 6)       return self.count;     return null;   } }; ```  now we can use it as an iterator.  ```zig comptime assert(isiterator(counter)); var counter = counter.new(); try expectequal(@as(u32, 1), counter.next().?); try expectequal(@as(u32, 2), counter.next().?); try expectequal(@as(u32, 3), counter.next().?); try expectequal(@as(u32, 4), counter.next().?); try expectequal(@as(u32, 5), counter.next().?); try expectequal(@as(?u32, null), counter.next()); ```  however, `counter` not implement utility functions like `map` or `count` etc ... to implement these functions, use `deriveiterator` meta function like below.  ```zig const counterext = struct {   pub const self = @this();   pub const item = u32;   pub usingnamespace deriveiterator(@this()); // add    count: u32,   pub fn new() self { return .{ .count = 0 }; }   pub fn next(self: *self) ?item {     self.count += 1;     if (self.count < 6)       return self.count;     return null;   } }; ```  in above code, `counterext` difference from `counter` is only the `deriveiterator(@this())` line. now, you can use all functions showed in [iterator operators](#iterator-operators).  ```zig fn incr(x:u32) u32 { return x+1; } fn even(x:u32) bool { return x % 2 == 0; } fn sum(st:*u32, v:u32) ?u32 {   st.* += v;   return st.*; } var counter = counterext.new(); var iter = counter              .map(incr)     // 2,3,4,5,6              .filter(even)  // 2,4,6              .scan(@as(u32, 0), sum); // 2,6,12 try expectequal(@as(u32, 2), iter.next().?); try expectequal(@as(u32, 6), iter.next().?); try expectequal(@as(u32, 12), iter.next().?); try expectequal(@as(?u32, null), iter.next()); ```  if you can implement some method efficiently rather than using `next` method, just implement that method (in `counterext` in the above). `deriveiterator` suppresses the generation of that function.   #### convention  **iter-zig** adopts naming conventions for implementing iterators. first, when defining a new iterator type, the type constructor must be named `maket` where type `t` is a name of the type. and the constructor should take a `derive` function like below.  ```zig pub fn makecounter(comptime derive: fn (type) type) type {   return struct {     pub const self = @this();     pub const item = u32;     pub usingnamespace derive(@this());     count: u32,     pub fn next(self: *self) ?item {       ...     }   }; } ```  this allows users to switch the function used for deriving.   second, a type constructor should be named `t`. and the constructor should forward `deriveiterator` to `maket`.  ```zig pub fn counter() type {   return makecounter(deriveiterator); } ```  ","ZigEmbeddedGroup/zfat":"Generic purpose platform-independent FAT driver for Zig # zfat  bindings for the [fatfs](http://elm-chan.org/fsw/ff/00index_e.html) library ","liyu1981/zcmd.zig":"zcmd is a single file lib to replace zig's std.childProcess.run with the ability of running pipeline like bash.. # zcmd.zig  `zcmd` is a single file lib (`zcmd.zig`) to replace zig's `std.childprocess.run`. it has almost identical api like `std.childprocess.run`, but with the ability of running pipeline like `bash`.  example like execution of single command (replacement of zig's `std.childprocess.run`)  ```zig const result = try zcmd.run(.{     .allocator = allocator,     .commands = &[_][]const []const u8{         &.{ 'uname', '-a' },     }, }); ```  the differences to `std.childprocess.run` is it will take `commands` instead of single `command`.  it can run a `bash` like pipeline like follows (_to recursively find and list the latest modified files in a directory with subdirectories and times_)  ```zig const result = try zcmd.run(.{     .allocator = allocator,     .commands = &[_][]const []const u8{         &.{ 'find', '.', '-type', 'f', '-exec', 'stat', '-f', ''%m %n'', '{}', ';' },         &.{ 'sort', '-nr' },         &.{ 'head', '-1' },     }, }); ```  it can also accept an input from outside as stdin to command or command pipeline, like follows  ```zig const f = try std.fs.cwd().openfile('tests/big_input.txt', .{}); defer f.close(); const content = try f.readtoendalloc(allocator, max_output); defer allocator.free(content); const result = try zcmd.run(.{     .allocator = allocator,     .commands = &[_][]const []const u8{         &.{'cat'},         &.{ 'wc', '-lw' },     },     .stdin_input = content, }); ```  when there is something failed inside pipeline, we will report back `stdout` and `stderr` just like `bash`, like below example  ```zig const result = try zcmd.run(.{     .allocator = allocator,     .commands = &[_][]const []const u8{         &.{ 'find', 'nonexist' },         &.{ 'wc', '-lw' },     }, }); defer result.deinit(); try testing.expectequalslices(     u8,     result.stdout.?,     '       0       0╲n', ); try testing.expectequalslices(     u8,     result.stderr.?,     'find: nonexist: no such file or directory╲n', ); ```  please check [example/zcmd_app](https://github.com/liyu1981/zcmd.zig/tree/main/example/zcmd_app) for an example on how to use `zcmd.zig`.  ### use `zcmd.zig` in `build.zig`  originally `zcmd.zig` is functions i wrote in `build.zig` to auto generating files with commands, so it is important that can use this in `build.zig`. so `zcmd.zig` exposed itself for `build.zig` too.  to use that we will need to normally introduce `zcmd.zig` to `build.zig.zon` (see usage below). then in your `build.zig`, do following to use it  ```zig // when import in build.zig, the zcmd is exposed in nested const zcmd const zcmd = @import('zcmd').zcmd; // then next can use zcmd.run as above ```  please check [example/zcmd_build_app](https://github.com/liyu1981/zcmd.zig/tree/main/example/zcmd_build_app) for detail version how to use in this way.  ## usage  ### through zig package manager  use following bash in your project folder (with `build.zig.zon`)  ``` zig fetch --save https://github.com/liyu1981/zcmd.zig/archive/refs/tags/v0.2.2.tar.gz ```  you can change the version `v0.1.0` to other version if there are in [release](https://github.com/liyu1981/zcmd.zig/releases) page.  ### or simply just copy `zcmd.zig` file to your project  it is a single file lib with no dependencies!  ## zig docs  zig docs is hosted in github pages at: [https://liyu1981.github.io/zcmd.zig/](https://liyu1981.github.io/zcmd.zig/), please go there to find what apis `zcmd.zig` provides.  ## coverage  `zcmd.zig` is rigorously tested. run unit tests at repo checkout root folder with `zig test src/zcmd.zig`.  for coverage test, as `kcov` is working in a way of 'debug every line and record', it can not work with `zcmd` tests. `zcmd` tests will fork many sub processes and if one of them be stopped the whole pipeline hangs. i am still in searching of what's the best method to cover. ","neurocyte/thespian":"thespian: an actor library for Zig, C & C++ applications # thespian fast & flexible actors for zig, c & c++ applications  to build: ``` ./zig build ```  see `tests/*` for many interesting examples. ","edqx/dishwasher":"A non-spec-compliant, but probably pretty fast, XML parser for Zig. # dishwasher  a fairly fast xml parser for [zig](https://ziglang.org).  note that this parser isn't strictly spec-compliant, however it will probably work with most well-formed xml documents.  ## features - [x] pretty speedy - [x] reader api-friendly - [x] can populate structs - [x] can populate dynamic values - [x] compile-time parsing - [x] diagnostics for malformed documents - [ ] stringification (coming soon)  ### benchmarks  here are the results from the given benchmarks on my pc (i9-14900kf) in different optimisation modes, when parsing the [opengl xml spec document](https://github.com/khronosgroup/opengl-registry/blob/main/xml/gl.xml) fully.  | mode | min | max | avg | |------|-----|-----|-----| | `debug` | `100ms` | `280ms` | `131ms` | | `releasesafe` | `13ms` | `25ms` | `15ms` |  | `releasesmall` | `18ms` | `50ms` | `30ms` | | `releasefast` | `7ms` | `27ms` | `13ms` |  _all times are averaged over 100 runs, rounded to the nearest 2sf._  ## usage  dishwasher has 4 apis, 3 of which will be most useful.  - [parsing api](#parsing-api) - for parsing an entire xml document at runtime. - [populate api](#populate-api) - for mapping an xml document to a given struct. - [comptime parsing and populate api](#comptime-parsing-and-populate-api) - for parsing an entire xml document at compile time. - [scanner api](#scanner-api) - for iterating through xml symbols from a slice or reader.  ### parsing api dishwasher lets you parse an xml document from either an entire slice or a reader into a tree-like structure that represents all nodes.  all of the parse methods create an arena which is returned back to you so that you can deinitialise it when you no longer need the data.  #### parse from a slice ```zig const owned_tree = dishwasher.parse.fromslice(allocator, xml_text); defer owned_tree.deinit(); // all strings and lists will be free'd  std.debug.assert(owned_tree.tree.children[0] == .elem); ```  #### parse from a reader ```zig const owned_tree = dishwasher.parse.fromreader(allocator, file.reader()); defer owned_tree.deinit();  std.debug.assert(owned_tree.tree.children[0] == .elem); ```  #### diagnostics you can also get basic information about invalid documents using the parse diagnostics struct, and passing it into either `parse.fromslicediagnostics` or `parse.fromreaderdiagnostics`. ```zig var diagnostics = dishwasher.parse.diagnostics.init(allocator); defer diagnostics.deinit();  const parsed = try dishwasher.parse.fromreaderdiagnostics(allocator, file.reader(), &diagnostics); defer parsed.deinit();  for (diagnostics.defects.items) |defect| {   std.debug.print('{} from {}..{}', .{ defect.kind, defect.range.start, defect.range.end }); } ```  #### tree api the returned tree has the following signature: ```zig const tree = struct {     pub const node = union(enum) {         pub const elem = struct {             pub const attr = struct {                 name: []const u8,                 value: ?[]const u8,             };              tag_name: []const u8,             attributes: []const attr,             tree: ?tree,              // get an attribute given its name.             pub fn attributebyname(self: elem, needle: []const u8) ?attr;             pub fn attr(self: elem, needle: []const u8) ?attr;              // get the value of an attribute given its name. note that if the             // attribute has no value, e.g., <button disabled> this will             // still return null. use attr or attributebyname in those             // cases.             pub fn attributevaluebyname(self: elem, needle: []const u8) ?[]const u8;             pub fn attrvalue(self: elem, needle: []const u8) ?[]const u8;         };          pub const text = struct {             contents: []const u8,              // return the text without any whitespace at the beginning or end.             pub fn trimmed(self: text) []const u8;         }          pub const comment = struct {             contents: []const u8,         };          elem: elem,         text: text,         comment: comment,     };      children: []const node,      // find an element child by its tag name     pub fn elementbytagname(self: tree, needle: []const u8) ?node.elem;     pub fn elem(self: tree, needle: []const u8) ?node.elem;          // allocate a slice for all of the element children of a given tag name     // to free the returned slice, you can just call allocator.free(elements)     // where 'elements' is the returned slice.     pub fn elementsbytagnamealloc(self: tree, allocator: std.mem.allocator, needle: []const u8) ![]node.elem;     pub fn elemsalloc(self: tree, allocator: std.mem.allocator, needle: []const u8) ![]node.elem;      // get an element by the value of one of its attributes     pub fn elementbyattributevalue(self: tree, needle_name: []const u8, needle_value: []const u8) ?node.elem;     pub fn elembyattr(self: tree, needle_name: []const u8, needle_value: []const u8) ?node.elem;      // return the inner text (not including the elements) of the tree. note that the     // result will be entirely unformatted.     pub fn concattextalloc(self: tree, allocator: std.mem.allocator) ![]const u8;     // return the inner text (not including the elements) of the tree but without     // any whitespace at the start or end.     pub fn concattexttrimmedalloc(self: tree, allocator: std.mem.allocator) ![]const u8; } ```  ### populate api often, it's useful to be able to populate a given struct with values from an xml document. that is, 'reading' the document into the struct.  dishwasher comes with a shaping api so you can dictate how the document should be read into the struct. simply declare an `xml_shape` on the struct:  ```zig const job = struct {   title: []const u8,   start_date: []const u8,   end_date: []const u8, }  const person = struct {     pub const xml_shape = .{         .name = .content_trimmed,         .age = .{ .attribute, 'age' },         .jobs = .{ .elements, 'job', .{             .start_date = .{ .attribute, 'start_date' },             .end_date = .{ .attribute, 'end_date' },             .title = .content_trimmed,             .fired = .attribute_exists,         } },         .location = .{             .one_of,             .{ .element, 'house', .content },             .{ .element, 'work', .content },             .none,         },         .apprentice = .{ .maybe, .{ .element, 'apprentice', person } },         .children = .{ .elements, 'child', person },     };      name: []const u8,     age: []const u8,     jobs: []struct {         start_date: []const u8,         end_date: []const u8,         title: []const u8,         fired: bool,     },     location: union(enum) {         house: []const u8,         work: []const u8,         none: void,     },     apprentice: ?*person,     children: []person, };  pub const register = struct {     pub const xml_shape = .{         .people = .{ .elements, 'person', person },     };      people: []person, };  const register = try diswasher.populate(register).initfromslice(allocator, xml_text); defer register.deinit();  // register.value: register ```  alternatively, you can populate an existing struct: ```zig var register: register = undefined; const arena = try dishwasher.populate(register).fromslice(allocator, xml_text, &register); defer arena.deinit(); ```  if you want to own all of your values yourself, use: ```zig const owned_tree = dishwasher.parse.fromreader(allocator, file.reader()); defer owned_tree.deinit();  const register = try dishwasher.populate(register).initfromtreeowned(allocator, owned_tree.tree); // free 'register' values yourself.. ```  #### dynamic values if some field accepts any sort of xml document shape, you can instruct it to accept a `parse.tree`:  ```zig const register = struct {   pub const xml_shape = .{     .people = .{ .elements, 'person', dishwasher.parse.tree },   };    people: []dishwasher.parse.tree, }; ```  > [!note] > note that the tree is not duplicated for you, so if you use the `initfromtreeowned` method, the values in the tree > will still belong to the arena that was initialised for the tree.  #### free struct if you use the `initfromtreeowned` population method, you can free all of the values in an arena-friendly way with: ```zig dishwasher.populate(register).deinit(allocator, register); ```  ### comptime parsing and populate api it could be useful to parse an xml document at compile time, for example for some inline code generation. while comptime doesn't have allocators, there's a custom api for this:  ```zig const tree = dishwasher.parse.fromslicecomptime(xml_text); ```  check out the [tree api](#tree-api) to know what to do with the returned value.  #### comptime populate api if you want to populate a struct at compile time, you can use the `*comptime` methods on the `populate` struct: ```zig const register = dishwasher.populate(register).initfromslicecomptime(xml_text); ```  > [!note] > remember that for the target struct, all pointers need to be `*const t` or > `[]const t`.  ### scanner api if you want low-level access to the iterator for lexing an xml document, you can use the scanner api, which accepts a slice buffer: ```zig var xmlscanner = scanner.fromslice(xml_text); while (try xmlscanner.next()) |token| {   std.debug.print('token kind: ', .{ token.kind }); } ```  if you have a reader and no access to the entire slice, the reader api can connect any reader to the scanner api so you can lex from a reader: ```zig var xmlreader = scanner.staticbufferreader(file.reader()); while (try xmlscanner.next()) |token| {   std.debug.print('token kind: ', .{ token.kind }); } ```  > [!note] > if you're given an error about running out of buffer space, try increase > the reader buffer size with > ```zig > const buffer_size = 4096; > const xmlfilereader = zigscanner.staticbufferreader(@typeof(file.reader()), buffer_size); > const xmlreader = xmlfilereader.init(file.reader()); > ```  #### comptime scanner the scanner works during compile time without any modification.  ## license all dishwasher code is under the mit license. ","nektro/zig-oauth2":"HTTP handler functions to allow you to easily add OAuth2 login support to your Zig application # zig-oauth2  http handler functions to allow you to easily add oauth2 login support to your zig application.  ## built with - zig master     - https://github.com/ziglang/zig - zigmod package manager     - https://github.com/nektro/zigmod  ## install ``` zigmod aq add 1/nektro/oauth2 ```  ## license mit ","Chriscbr/zig-fractions":"Simplify, convert, and do math with fractions in Zig # zig-fractions  a zig library for performing math with fractions, where each fraction is represented by a pair of integers.  compatible with zig 0.13 stable.  supported apis:  - convertion from floats, or numerator/denominator pairs (`fromfloat()`, `init()`) - convertion to floats and integers (`to(t)`) - formatting (`tostring()`, `tostringalloc()`, `format()`) - negation, absolute value (`negate()`, `abs()`) - addition, subtraction, multiplication, division (`add()`, `sub()`, `mul()`, `div()`) - comparison (`eql()`, `eqlabs()`, `eqlzero()`, `order()`, `orderabs()`) - simplifying (`simplify()`)  ## installation  first, run the following:  ``` zig fetch --save git+https://github.com/chriscbr/zig-fractions ```  then add the following to build.zig:  ```zig const zig_fractions = b.dependency('zig-fractions', .{}); exe.root_module.addimport('zig-fractions', zig_fractions.module('zig-fractions')); ```  then you can use the library in your zig project:  ```zig const fraction = @import('zig-fractions').fraction;  var f1 = try fraction.fromfloat(@as(f32, 2.5)); const f2 = try fraction.init(1, 5, false); try f1.mul(&f2); // 2.5 * 1/5 = 1/2 std.debug.print('{}╲n', .{f1}); // '1/2' ```  ## contributing  pull requests are welcome. ","by-nir/aws-sdk-zig":"🟧 AWS SDK for the Zig programming language # aws sdk for zig  ![zig v0.14 (dev)](https://img.shields.io/badge/zig-v0.14_(dev)_-black?logo=zig&logocolor=f7a41d 'zig v0.14 – master branch') [![mit license](https://img.shields.io/github/license/by-nir/aws-sdk-zig)](/license)  **the _aws sdk for zig_ provides an interface for _amazon web services (aws)_.**  > [!caution] > this project is in early development, do not use in production! > > support for the remaining services and features will be added as the project > matures and stabilize. **breaking changes are imminent!**  _pure zig implementation,_ from code generation to runtime sdks. building upon the language’s strong foundation, this project provides a **performant** and fully functioning sdks, while **minimizing dependencies** and increased **platform portability**.  > [!tip] > use the [aws lambda runtime for zig](https://github.com/by-nir/aws-lambda-zig) > to deploy lambda functions written in zig.  ## supported features  ### authentication  | status | method | runs locally | |:------:|:-------|:------------:| |        | [iam identity center authentication](https://docs.aws.amazon.com/sdkref/latest/guide/access-sso.html) | ✓ | |        | [iam roles anywhere](https://docs.aws.amazon.com/sdkref/latest/guide/access-rolesanywhere.html) | ✓ | |        | [assume a role](https://docs.aws.amazon.com/sdkref/latest/guide/access-assume-role.html) | ✓ | | ✓      | [aws access keys](https://docs.aws.amazon.com/sdkref/latest/guide/access-users.html) | ✓ | |        | [iam roles for ec2 instances](https://docs.aws.amazon.com/sdkref/latest/guide/access-iam-roles-for-ec2.html) |   |  ### settings  | status | feature | notes | |:------:|:--------|:------| |        | [application id](https://docs.aws.amazon.com/sdkref/latest/guide/feature-appid.html) | | |        | [amazon ec2 instance metadata](https://docs.aws.amazon.com/sdkref/latest/guide/feature-ec2-instance-metadata.html) | | |        | [amazon s3 access points](https://docs.aws.amazon.com/sdkref/latest/guide/feature-s3-access-point.html) | | |        | [amazon s3 multi-region access points](https://docs.aws.amazon.com/sdkref/latest/guide/feature-s3-mrap.html) | | | ✓      | [aws region](https://docs.aws.amazon.com/sdkref/latest/guide/feature-region.html) | | |        | [aws sts regionalized endpoints](https://docs.aws.amazon.com/sdkref/latest/guide/feature-sts-regionalized-endpoints.html) | | | ✓      | [dual-stack and fips endpoints](https://docs.aws.amazon.com/sdkref/latest/guide/feature-endpoints.html) | | |        | [endpoint discovery](https://docs.aws.amazon.com/sdkref/latest/guide/feature-endpoint-discovery.html) | | |        | [general configuration](https://docs.aws.amazon.com/sdkref/latest/guide/feature-gen-config.html) | | |        | [imds client](https://docs.aws.amazon.com/sdkref/latest/guide/feature-imds-client.html) | | |        | [retry behavior](https://docs.aws.amazon.com/sdkref/latest/guide/feature-retry-behavior.html) | | |        | [request compression](https://docs.aws.amazon.com/sdkref/latest/guide/feature-compression.html) | | |        | [service-specific endpoints](https://docs.aws.amazon.com/sdkref/latest/guide/feature-ss-endpoints.html) | | |        | [smart configuration defaults](https://docs.aws.amazon.com/sdkref/latest/guide/feature-smart-config-defaults.html) | |  ## contributing  > [!important] > at this point, the project serves as environment for developing other experimental sub-projects. > this initiative is in an exploratory phase and is **not yet ready for contributions**.  | 📁                                | description                                                     | |:----------------------------------|:----------------------------------------------------------------| | [sdk](sdk/)                       | aws sdks for zig<br />_auto-generated, do not modify manually!_ | | [aws/runtime](aws/runtime/)       | sdk runtime shared by all the services                          | | [aws/codegen](aws/codegen/)       | aws-specific source generation pipeline                         | | [smithy/runtime](smithy/runtime/) | [smithy 2.0](https://smithy.io/2.0) client runtime              | | [smithy/codegen](smithy/codegen/) | [smithy 2.0](https://smithy.io/2.0) source generation pipeline  |  ### cli commands  - `zig build --build-file build.codegen.zig` generate the aws sdks source code.     - optionally specify one or more `-dfilter=sdk_codename` to select specific services. - `zig build test:<service>` run generated sdk service’s unit tests.  ## license  the author and contributors are not responsible for any issues or damages caused by the use of this software, part of it, or its derivatives. see [license](/license) for the complete terms of use.  > [!note] > _aws sdk for zig_ is not an official _amazon web services_ software, nor is it > affiliated with _amazon web services, inc_.  the sdks code is generated based on a dataset of _smithy models_ created by _amazon web services_. the models are extracted from the official [aws sdk for rust](https://github.com/awslabs/aws-sdk-rust) and [licensed](https://github.com/awslabs/aws-sdk-rust/blob/main/license) as  declared by amazon web services, inc. at the source repository. this codebase, including the generated code, are covered by a [standalone license](/license).  ## references  ### smithy  - [smithy spec](https://smithy.io/2.0/index.html) - [smithy reference implementation](https://github.com/smithy-lang/smithy) - [smithy rust](https://github.com/smithy-lang/smithy-rs)  ### aws sdks  - [aws sdks and tools reference guide](https://docs.aws.amazon.com/sdkref/latest/guide/overview.html) - [aws common runtime (crt) libraries](https://docs.aws.amazon.com/sdkref/latest/guide/common-runtime.html) - [aws sdk for c++](https://github.com/aws/aws-sdk-cpp) - [aws sdk for rust](https://github.com/awslabs/aws-sdk-rust)","freref/fzwatch":"A lightweight and cross-platform file watcher for your Zig projects # fzwatch a lightweight and cross-platform file watcher for your zig projects. > [!note]   > this project exists to support [fancy-cat](https://github.com/freref/fancy-cat) and has limited features.  ## instructions ### run example you can run the [examples](./examples/) like so: ```sh zig build run-<filename> ``` ### usage a basic example can be found under [examples](./examples/basic.zig). the api is defined as follows: ```zig pub const event = enum { modified }; pub const callback = fn (context: *anyopaque, event: event) void; pub const opts = struct { latency: f16 = 1.0 };   pub fn init(allocator: std.mem.allocator) !watcher; pub fn deinit(self: *watcher) void; pub fn addfile(self: *watcher, path: []const u8) !void; pub fn removefile(self: *watcher, path: []const u8) !void; pub fn setcallback(self: *watcher, callback: callback) void; pub fn start(self: *watcher, opts: opts) !void; pub fn stop(self: *watcher) !void; ```` ","lawrence-laz/jaysan":"A fast json serializer <h1 align='center'>   <img src='https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/json_vector_logo.svg/160px-json_vector_logo.svg.png' width='64'><br>   jayさん   <br> </h1>  jaysan is a fast json library written in zig. currently supports serialization only.  ```zig var gpa = std.heap.generalpurposeallocator(.{}){};  const foo = struct {     foo: i32,     bar: []const u8, };  const string = try json.stringifyalloc(     gpa.allocator(),     foo{         .foo = 123,         .bar = 'hello, world!',     }, );  // {'foo':123,'bar':'hello, world!'} ```  ```md benchmark 1: zig-stdjson   time (mean ± σ):     141.9 ms ±   1.1 ms    [user: 140.4 ms, system: 1.0 ms]   range (min … max):   140.1 ms … 144.1 ms    20 runs  benchmark 2: zig-jaysan   time (mean ± σ):      46.8 ms ±   1.3 ms    [user: 46.2 ms, system: 0.4 ms]   range (min … max):    43.1 ms …  49.2 ms    61 runs  benchmark 3: rust-serde   time (mean ± σ):      46.9 ms ±   0.9 ms    [user: 45.8 ms, system: 0.9 ms]   range (min … max):    45.9 ms …  50.9 ms    62 runs  summary   zig-jaysan     1.00 ± 0.03 times faster than rust-serde     3.03 ± 0.09 times faster than zig-stdjson ``` ","hexops-graveyard/mach-system-sdk":"DirectX 12 headers for MinGW/Zig, cross-compile DX12/Metal/etc with Zig, etc. # mach/system-sdk, more libraries for cross-compilation with zig <a href='https://hexops.com'><img align='right' alt='hexops logo' src='https://raw.githubusercontent.com/hexops/media/master/readme.svg'></img></a>  * updated directx 12 headers for use with mingw/zig * cross-compile directx apps targetting windows * cross compile metal apps targetting macos/ios intel or apple silicon. * cross compile opengl/vulkan apps targetting linux (not other oss, sorry)  ## what is this?  one thing i care about extremely with [mach engine](https://github.com/hexops/mach) is that you're able to cross compile for any os with nothing more than `zig` and `git`. and while we can build most things from source (glfw, and even the directx shader compiler!) there are a few system headers / libraries where, really, we just need a copy of them.  `mach/system-sdk` is how mach engine gets a copy of them via the zig build system.  although it was intended for mach specifically, and i wouldn't be surprised if one day zig provides better options out of the box, i realize others might benefit from this and so i've made it easy for anyone to use!  ## what does it provide?  depending on the target os, `system_sdk.zig` will automatically `git clone` the relevant system sdk for you and include it:  * `sdk-windows-x86_64` (~7mb):   * updated directx 12 headers (and prior versions) for use with zig/mingw when specifying a `-dtarget=x86_64-windows-gnu` target.   * directx libraries such as `dxgi.lib` and `dxguid.lib` * `sdk-linux-x86_64` (~40mb):   * x11/xcb/wayland libraries/headers (as static as possible)   * opengl and vulkan headers   * generated wayland protocol sources * `sdk-macos-11.3` (~198mb) and `sdk-macos-12.0` (~149mb)   * a nearly full copy of the macos 11.3 and 12.0 xcode sdks, with just a few particularly large frameworks excluded.   * pretty much every framework, header, etc. that you need to develop macos and ios applications for intel and apple silicon.   * symlinks mostly eliminated for ease of use on windows  the build script will `git clone` these sdks for you, pin them to a specific git revision denoted in the `system_sdk.zig` file so they are versioned, and even prompt for xcode license agreement in the case of macos sdks.  into the appdata directory   ``` /users/slimsag/library/application support/hexops ```  ## single file & one-liner to use  get [system_sdk.zig](https://github.com/hexops/mach/blob/main/glfw/system_sdk.zig) into your codebase however you prefer. i suggest just copying it for now, it's a single file.  in your `build.zig`:  ``` const system_sdk = @import('system_sdk.zig'); ... system_sdk.include(b, step, .{}); ```  where `step` is the exe / lib you're building.  ## shared between zig projects  the sdks are cloned into your `<appdata>/hexops` directory to ensure they are shared across projects and you don't end up with multiple copies. prior to use the build script will `git reset` to the target revision.  ## customization  if you don't like what is provided in the sdk repositories, i've tried to make it as easy as possible to switch to your own sdk repos. just pass `options`:  ```zig system_sdk.include(b, step, .{     .github_org = 'myorg',     .linux_x86_64_revision = 'ab7fa8f3a05b06e0b06f4277b484e27004bfb20f',     .windows_x86_64_revision = '5acba990efd112ea0ced364f0428e6ef6e7a5541', }); ```  and set the revisions to the git revisions of your forks of [the sdk repositories.](https://github.com/hexops?q=mach-sdk&type=all&language=&sort=)  ## is this the right way to do this? should i be using this?  to be clear, i don't think this is the perfect way or 100% ideal way to handle this. i am positive that the zig community will eventually land on better solutions here.  for example, generating updated directx 12 headers for mingw/zig requires patching microsoft's idl files, running them through the wine widl compiler, and then some. storing even a few binaries in git is not ideal, even if we do clone with `--depth 1`.  but, if you care about that developer experience as immensely as i do i hope you'll see a bit of reason behind the madness.  use at your own peril!  ## issues  please file issues/complaints in the [main mach repository](https://github.com/hexops/mach/issues). ","mnemnion/runeset":"Fast UTF-8 codepoint sets for Zig. # runeset: sets of utf-8 characters  this library offers a compact data structure for 'generalized'[^1] utf-8 encoded codepoints.  the design is based on an [implicit data structure](https://en.wikipedia.org/wiki/implicit_data_structure)[^2], which uses `@popcount` and bit masking to check membership quickly, with minimal branching, and without having to decode the utf-8 into another format (for instance, a codepoint).  this design is original, in the sense that i invented it.  there may be prior art, it's remarkably difficult to search for 'utf-8 character sets' and find papers on set data structures, so i can't say with high confidence that it's truly novel; in a sense, it's an obvious extension of the widespread practice of using a pair of `u64` bitmasks to detect a set of ascii values.  what i can say is: it's effective.  the `runeset` struct is just a slice of `u64`, offering a few variations on set membership tests, depending on how confident you are that the string it's testing is valid utf-8, and what you would like the test to do in the event that it isn't.  also supported are the fundamental set operations: equality, subset, union, intersection, and difference.  all of the three combining forms produce a new `runeset`, and must be given an `allocator`.  the `runeset` is immutable by design, and as such, doesn't support adding or removing codepoints to an already-created set.  this would be possible to implement in principle, but i don't happen to have a use for mutable adds and removes, and therefore didn't write them.  you can create a `runeset` containing a single character, and via union or difference, either add or subtract that character, if you would like: this would create a new `runeset` with just that character added or removed.  the data structure is very fast.  the test suite, with extensions, contains 5mb of sample data, with a 20mb extra collection, and performs a multitude of operations on that data, on the order of a dozen per string.  in releasefast mode, the main suite of 5mb concludes in roughly a second on an m1.  with the annex, including fuzzing the creation function 2^24 times, a complete run is over in six seconds, give or take a few milli.  about 2/3rds of that is the fuzzing.  while i have yet to set up definitive benchmarks, it's clear that membership testing using `runeset` has a throughput over 100 mb/sec on modern machines, potentially substantially higher than this.  i'll update this with better numbers when i get around to benchmarking it; the focus has been on implementing the library, and assuring good test coverage.  for real character sets, it is also quite sparing of memory.  the cjk ideographs block of unicode, consisting of 22,992 codepoints, is represented as a `runeset` in 338 words.  dense ranges such as that block can of course be tested by decoding the tested sequence into a codepoint and checking if it's in that range, but the combination of generality, compactness, and speed, offered by the `runeset`, is unique.  speaking of test coverage, the library has 100% line coverage, which you may verify by running `zig build cov`, provided you have [kcov](https://github.com/simonkagstrom/kcov) installed.  to run the extended suite, including the fuzzer, use `zig build -dtest-more test`.  this will take an appreciable amount of time in the default debug-mode builds, as it will trigger the 244 assertions which gird the library.  ## roadmap  i intend to add some ability to write out the data structure, whether as binary data, zig source code, or potentially both. as an allocating data structure, it isn't currently possible to generate a runeset at comptime, and many applications of them will use character sets known in advance, which may as well be built into the `.rodata` of programs, rather than constructed at runtime from strings.  i also plan to wrap all of the major functionality in c-compatible data structures and functions, for use wherever the c abi is spoken.  other than that, i consider the library fully implemented and feature-complete.  odds are good, however, that more open-source code, which makes use of the runeset as a foundation, will be forthcoming.  [^1]: generalized, here, has a similar meaning to its use in [wtf-8](https://simonsapin.github.io/wtf-8/), except that `runeset` can also encode so-called 'overlong' encodings, as well as surrogates (paired vs. unpaired is a meaningless distinction for a codepoint set).  this falls out of the design: it's capable of encoding those sequences, and i saw no reason to impose a performance burden in order to prevent it.  on the contrary, should you want to represent the set of all overlong encodings, perhaps to detect them and raise an error, a `runeset` is a fine way to do it.  a set which does not contain overlong encodings or surrogates will never match against them, so this seeming laxity comes with no disadvantages.  the five- and six-byte sequences from pike and thompson's original fss utf-8 of 1993 are not supported.  as such, what would constitute lead bytes for those sequences are rejected as invalid.  it would be possible to extend the `runeset` data structure to include these, if there were ever any point in so doing.  [^2]: that the `runeset` is 'implicit' doesn't make it the smallest possible encoding for every subset of utf-8.  for example, the cjk unified ideographs block could be represented as two numbers, and for some crafted inputs, such as one in 64 characters throughout the unicode range, a bitmask of one bit per character would be smaller as well.  it means that the structure is implicit to the data, without indirection, and that in full generality it isn't possible to represent utf-8 sequences more compactly, compared to the information theoretic lower-bound.  our overhead is limited to one word, used to store one of the offsets as an important optimization. ","jedisct1/zig-bounded-array":"BoundedArray module for Zig. # boundedarray for zig  a `boundedarray` is a structure containing a fixed-size array, as well as the length currently being used.  it can be used as a variable-length array that can be freely resized up to the size of the backing array.  if you're looking for a zig equivalent to rust's super useful `arrayvec`, this is it.  it is useful to pass around small arrays whose exact size is only known at runtime, but whose maximum size is known at comptime, without requiring an `allocator`.  bounded arrays are easier and safer to use than maintaining buffers and active lengths separately, or involving structures that include pointers.  they can also be safely copied like any value, as they don't use any internal pointers.  ```zig var actual_size = 32; var a = try boundedarray(u8, 64).init(actual_size); var slice = a.slice(); // a slice of the 64-byte array var a_clone = a; // creates a copy - the structure doesn't use any internal pointers ``` ","laohanlinux/boltdb-zig":"This repository has no description. # boltdb-zig","alichraghi/jigar":"Case convertion library for ziguanas # jigar ![logo](/media/logo.png)  case convertion library for ziguanas  supports: `lower case`, `upper case`, `macro_case`, `train-case`, `snake_case`, `snake_camel`, `snake_pascal`, `kebab-case`, `kebab-pascal`, `camelcase` and `pascalcase`  ### usage  ```zig const jigar = @import('jigar');  pub fn main() void {   var my_hello = 'hello world'.*;   jigar.snakecase(&my_hello); // results: hello_world } ``` ","ikskuh/SLF":"The Simple Linking Format # ⛓ simple linking format  slf is a very simple object file format that can be used to link programs that don't require distinct sections for code and data.  ## documentation  - [binary format](docs/module-format.md)  ## available tools  - `slf-ld` is the standalone linker that can be used to link object files into a flat binary - `slf-objdump` is a dumper for slf files. it can list all sections as well as dump the raw binary data.  ## available apis  `src/slf.zig` is a package that exports several apis:  - `slf.view` allows introspection of in-memory slf files. - `slf.linker` allows linking slf files together. - `slf.builder` allows the creation of new slf files.  ## project status  [![build](https://github.com/masterq32/slf/actions/workflows/cross-build.yml/badge.svg)](https://github.com/masterq32/slf/actions/workflows/cross-build.yml)  **disclaimer: feature complete, but still highly experimental.**  ### todo  - [ ] add better diagnostics   - [ ] add support for object/file names - [ ] support exporting other file types   - [x] flat binary   - [ ] intel hex ","liyu1981/jstring.zig":"a reusable string lib for myself with all familiar methods methods can find in javascript string # `jstring.zig`  ## target: create a reusable string lib for myself with all familiar methods methods can find in javascript string.  ## reason:  1.  string is important we all know, so a good string lib will be very useful. 2.  javascript string is (in my opinion) the most battle tested string library out there, strike a good balance     between features and complexity.  the javascript string specs and methods this file use as reference can be found at https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/string  all methods except those marked as deprecated (such as anchor, big, blink etc) are implemented, in zig way.  # integration with pcre2 regex  one highlight of `jstring.zig` is that it integrates with [pcre2](https://www.pcre.org/) to provide `match`, `match_all` and more just like the familar feeling of javascript string.  here are some examples of how regex can be used  ```zig var str1 = try jstringunmanaged.newfromslice(arena.allocator(), 'hello,hello,world'); var results = try str1.splitbyregex(arena.allocator(), 'l+', 0, 0); try testing.expectequal(results.len, 1); try testing.expect(results[0].eqlslice('hello,hello,world')); results = try str1.splitbyregex(arena.allocator(), 'l+', 0, -1); try testing.expectequal(results.len, 4); try testing.expect(results[0].eqlslice('he')); try testing.expect(results[1].eqlslice('o,he')); try testing.expect(results[2].eqlslice('o,wor')); try testing.expect(results[3].eqlslice('d')); ```  # usage  ```bash zig fetch --save https://github.com/liyu1981/jstring.zig/archive/refs/tags/0.1.1.tar.gz ```  check `example` folder for a sample project  ```zig const std = @import('std'); const jstring = @import('jstring');  pub fn main() !u8 {     var your_name = brk: {         var jstr = try jstring.jstring.newfromslice(std.heap.page_allocator, 'name is: zig');         defer jstr.deinit();         const m = try jstr.match('name is: (?<name>.+)', 0, true, 0, 0);         if (m.matchsucceed()) {             const r = m.getgroupresultbyname('name');             break :brk try jstr.slice(                 @as(isize, @intcast(r.?.start)),                 @as(isize, @intcast(r.?.start + r.?.len)),             );         }         unreachable;     };     defer your_name.deinit();      try std.io.getstdout().writer().print('╲nhello, {s}╲n', .{your_name});     return 0; } ```  in order to run this example from the `git clone` repo, you will need  ```bash cd <jstirng_repo>/examples zig fetch --save ../ # to update your local zig cache about jstring zig build run ```  # `build.zig`  when use `jstring.zig` in your project, as it integrates with `pcre2`, will need to link your project to `libpcre-8`. `jstring.zig` provide a build time function to easy this process.  ```zig // in your build.zig const jstring_build = @import('jstring'); ... const jstring_dep = b.dependency('jstring', .{}); exe.addmodule('jstring', jstring_dep.module('jstring')); jstring_build.linkpcre(exe, jstring_dep); ```  again, check `example` folder for the usage  # performance  `jstring.zig` is built with performance in mind. though `benchmark` is still in developing, but the initial result of allocate/free 1m random size of strings shows a _~70%_ advantage comparing to c++/20's `std::string`.  ```bash benchmark % ./zig-out/bin/benchmark |zig create/release: | [ooooo] | avg=    16464000ns | min=    14400000ns | max=    20975000ns | |cpp create/release: | [ooooo] | avg=    56735400ns | min=    56137000ns | max=    57090000ns | ```  (`jstring.zig` is built with `-doptimize=releasefast`, and `cpp` is built with `-std=c++20 -o2`)  check current benchmark method [here](https://github.com/liyu1981/jstring.zig/blob/main/tools/benchmark/main.zig)  # docs  check the auto generated zig docs [here](https://liyu1981.github.io/jstring.zig)  # tests  `jstring` is rigorously tested.  ```bash ./script/pcre_test.sh src/jstring.zig ```  to run all tests.  or check kcov report [here](https://liyu1981.github.io/jstring.zig/cov/index.html): the current level is 100%.  # license  mit license :) ","jnordwick/zig-string":"Zig string library that includes small string optimization on the stack 404: not found","nektro/zig-zorm":"An ORM-ish library for Zig. # zorm  the orm library for zig.  wip  ## example usage [src/main.zig](src/main.zig)  ## built with - [zig](https://github.com/ziglang/zig) master - [zigmod](https://github.com/nektro/zigmod) package manager - https://github.com/vrischmann/zig-sqlite  ## add me ``` $ zigmod aq add 1/nektro/zorm ```  ## license agpl-3.0 ","Ratakor/axe":"A logging library # axe 🪓  a fully customizable, drop-in replacement for `std.options.logfn` with support for multiple file logging (custom writer supported), buffering, json, time, custom format, colors (automatic tty detection, windows support, no╲_color support, clicolor╲_force support), source location, and thread safety (multiple mutex interface available)!  ![](screenshot.png)  ## usage  add it to an existing project with this command: ```sh zig fetch --save git+https://github.com/ratakor/axe ``` then add the module your build.zig. ```zig const axe = b.dependency('axe', .{}).module('axe'); exe.root_module.addimport('axe', axe); ```  check [example.zig](example/example.zig) for how to use it!  [api documentation](https://ratakor.github.io/axe)  <!-- ## todo - add a way to combine multiple loggers into one. --> ","cryptocode/stitch":"Append resources to your executables <img align='right' height='120' src='https://user-images.githubusercontent.com/34946442/232327201-294224c2-8502-423b-b2cb-663ca88ccfc1.png'>  <img src='https://user-images.githubusercontent.com/34946442/230613201-60de5adc-6304-4f18-84d9-d36bb46fdc1f.svg' width='24' height='24'>&nbsp; <img src='https://user-images.githubusercontent.com/34946442/230613198-ca5c938a-613b-412f-8d97-8ce8f19aeb1f.svg' width='24' height='24'>&nbsp; <img src='https://user-images.githubusercontent.com/34946442/230613203-858cb471-2859-4e6e-8ef9-61b03c36c085.svg' width='24' height='24'>  stitch is a tool and library for zig and c for adding and retrieving resources to and from executables.  why not just use `@embedfile` / `#embed`? stitch serves a different purpose, namely to let build systems, and *users* of your software, create self-contained executables.  for example, instead of requiring users to install an interpreter and execute `mylisp fib.lisp`, they can simply run `./fib` or `fib.exe`  resoures can be anything, such as scripts, images, text, templates config files and other executables.  ## some use cases * self extracting tools, like an installer * create executables for scripts written in your interpreted programming language * include a sample config file, which is extracted on first run. the user can then edit this. * an image in your own format that's able to display itself when executed  ## building the project to build with zig 0.13, use the `zig-<version>` tag/release. to build with zig master, use the main branch (last tested with zig 0.14.0-dev.130+cb308ba3a)  `zig build` will put a `bin` and `lib` directory in your output folder (e.g. zig-out)  * bin/stitch is a standalone tool for attaching resources to executables. this can also be done programmatically using the library * lib/libstitch is a library for reading attached resources from the current executable, and for adding resources to executables (like the standalone tool)  ## using the tool  this example adds two scripts to a lisp interpreter that supports, through the stitch library, reading embedded scripts:  ```bash stitch ./mylisp std.lisp fib.lisp --output fib  ./fib 8 21 ```  resources can be named explicitly  ```bash stitch ./mylisp std=std.lisp fibonacci=fib.lisp --output fib ```  if a name is not given, the filename (without path) is used. the stitch library supports finding resources by name or index.  the `--output` flag is optional. by default, resources are added to the original executable (first argument) ## stitching programmatically let's say you want your interpreted programming language to support producing binaries.  an easy way to do this is to create an interpreter executable that reads scripts attached to itself using stitch.  you can provide interpreter binaries for all the os'es you wanna support, or have the zig build file do this if your user is building the interpreter.  in the example below, a lisp interpreter uses the stitch library to support creating self-contained executables:  ```bash ./mylisp --create-exe sql-client.lisp --output sql-client ``` the resulting binary can now be executed:  ``` ./sql-client ```  you can make the `mylisp` binary understand stitch attachments and then make a copy of it and stitch it with the scripts. alternatively, you can have separate interpreter binaries specifically for reading stitched scripts. ## using the library from c  include the `stitch.h` header and link to the library. here's an example, using the included c test program:  ```bash zig build-exe c-api/test/c-test.c -lzig-out/lib -lstitch -ic-api/include ./c-test ```  ## binary layout  the binary layout specification can be used by other tools that wants to parse files produced by stitch, without using the stitch library.  [specification](spec/readme.md) ","neurocyte/notcurses-zig":"Zig bindings and packaging for notcurses # zig bindings and package for notcurses  this package provides build scripts and basic (wip) bindings for building notcurses applications in zig.  see `src/ncinputtest.zig` for a basic example application.  should generally build with zig nightly. ","jedisct1/zig-alzette":"Implementation of the Alzette box and the CRAX block cipher in Zig. # zig-alzette  implementation of the alzette box and crax block cipher in zig.  ## references  * [alzette: a 64-bit arx-box](https://eprint.iacr.org/2019/1378.pdf) ","DISTREAT/zig-csv":"A library for parsing, creating, and manipulating CSV data. # zig-csv  a library for parsing, creating, and manipulating csv data.  _build using zig version: `0.12.0`_  ## features  - avoiding memory leaks - flexible and simplistic api  ## example  ```zig const std = @import('std'); const csv = @import('zig-csv'); const allocator = std.heap.allocator;  // parse csv data var table = csv.table.init(allocator, csv.settings.default()); defer table.deinit();  try table.parse(     ╲╲id,animal,shorthand     ╲╲0,dog,d     ╲╲1,cat,c     ╲╲2,pig,p );  // print all animals const column_indexes_animal = try table.findcolumnindexesbykey(allocator, 'animal'); defer allocator.free(column_indexes_animal);  var animals = table.getcolumnbyindex(column_indexes_animal[0]);  while (animals.next()) |animal| {     std.debug.print('{s}', .{animal.value}); }  // replace a value const column_indexes_id = try table.findcolumnindexesbykey(allocator, 'id'); defer allocator.free(column_indexes_id);  const row_indexes_id_2 = try table.findrowindexesbyvalue(allocator, column_indexes_id[0], '2'); defer allocator.free(row_indexes_id_2);  try table.replacevalue(row_indexes_id_2[0], column_indexes_animal[0], 'porcupine');  // delete a column try table.deletecolumnbyindex(column_indexes_id[0]);  // export back to csv const exported = try table.exportcsv(allocator); defer allocator.free(exported);  ```  _more examples can be found in `src/tests.zig`._  ## docs  the documentation is created in the directory `docs/` when running `zig build`.  [documentation](https://distreat.github.io/zig-csv/) ","mattnite/glob":"small library for globing file paths # glob small library for globing file paths ","softprops/zig-retry":"♻️ Retry faillible zig functions <h1 align='center'>     ♻️ zig retry </h1>  <div align='center'>     a retry library for fault tolerant zig applications </div>  ---  [![main](https://github.com/softprops/zig-retry/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/zig-retry/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/zig-retry) ![release](https://img.shields.io/github/v/release/softprops/zig-retry) [![zig support](https://img.shields.io/badge/zig-0.13.0-black?logo=zig)](https://ziglang.org/documentation/0.13.0/)  a goal of any operation should be a successful outcome. this package gives operations a better chance at achieving that.  ## 📼 installing  create a new exec project with `zig init`. copy an example from the examples directory into your into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/softprops/zig-retry/archive/refs/tags/v0.1.0.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +       // 👇 declare dep properties +        .jwt = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-retry/archive/refs/tags/v0.1.0.tar.gz', +            // 👇 hash verification +            .hash = '...', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-retry/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-retry/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference dep from build.zig.zon +    const retry = b.dependency('retry', .{ +        .target = target, +        .optimize = optimize, +    }).module('retry');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the module to executable +    exe.root_mode.addimport('retry', retry);      b.installartifact(exe); } ```  ## examples  see examples directory  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)   ╲- softprops 2024 ","octopus-foundation/uuid.zig":"UUID v4 implementation in pure Zig. No allocations # uuid v4  rfc 4122 compliant uuid v4 implementation in zig.  ## features - zero dependencies - generate random uuids (v4) - parse from string/bytes - format to string/bytes - no allocations - supports cryptographic rng - tested on zig 0.14.0-dev  ## install  ```bash zig fetch --save https://github.com/octopus-foundation/uuid.zig/archive/refs/tags/0.0.0.tar.gz ```  in your `build.zig`: ```zig const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const uuid = b.dependency('uuid', .{         .target = target,         .optimize = optimize,     });      const exe = b.addexecutable(.{         .name = 'example',         .root_source_file = b.path('src/main.zig'),         .target = target,         .optimize = optimize,     });      exe.root_module.addimport('uuid', uuid.module('uuid'));     b.installartifact(exe); } ```  ## usage  ```zig const uuid = @import('uuid').v4;  // generate random uuid var prng = std.random.defaultprng.init(0); const id = uuid.random(prng.random());  // format as string var buf: [36]u8 = undefined; uuid.tostring(id, &buf); // '550e8400-e29b-41d4-a716-446655440000'  // parse from string  const parsed = try uuid.fromstring('550e8400-e29b-41d4-a716-446655440000');  // convert to/from bytes var bytes: [16]u8 = undefined; uuid.tobytes(id, &bytes); const frombytes = try uuid.frombytes(&bytes);  // with crypto random const crypto_id = uuid.random(std.crypto.random); ```","fig-eater/zig-function-overloading":"Explicit function overloading for the Zig programming language # explicit function overloading for zig  simple one-file, no-dependency, explicit function overloading for zig. this all runs during compile time so running overloaded functions shouldn't have any runtime overhead.  ## install  ### using zig package manager  run `zig fetch --save https://github.com/fig-eater/zig-function-overloading/archive/refs/heads/main.tar.gz` within your project directory. run this again if you ever want to update the dependency.  then add an import to the module which needs overloading to your `build.zig`  this code is an example of how you might do this:  ```zig  const overloading_dependency = b.dependency('overloading', .{     .target = target,     .optimize = optimize, });  // in a default project `compile_step` might be `lib` or `exe`. // replace the first 'overloading' here to avoid namespace conflicts or to change the name of the import for your project. compile_step.root_module.addimport('overloading', overloading_dependency.module('overloading'));  ```  ### manually  download [src/overloading.zig](./src/overloading.zig) and save in your project.  import directly using `@import('path/to/overloading.zig')`  *or*  see [build.zig](./build.zig) for an example of how to use this as a local module.  ## usage  - import the `overloading` module or `overloading.zig` if saved locally. - call `overloading.make` with a tuple of functions, `make` will return a function which when called will call a function in the tuple with corresponding argument types. - all functions passed in the tuple must have the same return type. - functions in the tuple cannot have the same arguments as others in the tuple. - if a function takes no arguments, pass `{}` into the overloaded function to call it. - if a function takes multiple arguments pass the arguments in a tuple. - if a function takes void as it's only argument pass in `.{{}}` into the overloaded function to call it  example: ```zig const std = @import('std'); const overloading = @import('overloading');  fn addnoargs() u32 {     return 0; } fn addu32(a: u32) u32 {     return a; } fn addu8slice(as: []const u8) u32 {     var total: u32 = 0;     for (as) |a| total +|= a;     return total; } fn addoptionalu32(a: ?u32) u32 {     return if (a) |a_val| return a_val else 0; } fn addptru32(a_ptr: *u32) u32 {     return a_ptr.*; } fn addu32i32(a: u32, b: i32) u32 {     return a + @as(u32, @intcast(b)); }  fn printnoargs() void {     std.debug.print('no args╲n', .{}); } fn printvoid(_: void) void {     std.debug.print('void╲n', .{}); } fn printu32(a: u32) void {     std.debug.print('{d}╲n', .{a}); } fn printu8slice(a: []const u8) void {     std.debug.print('{s}╲n', .{a}); } fn printu32u32(a: u32, b: u32) void {     std.debug.print('{d} {d}╲n', .{ a, b }); }  const myadd = overloading.make(.{     addnoargs,     addu32,     addu8slice,     addoptionalu32,     addptru32,     addu32i32, });  const myprint = overloading.make(.{     printnoargs,     printvoid,     printu32,     printu8slice,     printu32u32, });  pub fn main() void {     const optional_with_val: ?u32 = 555;     const optional_with_null: ?u32 = null;     var a: u32 = 5;     _ = myadd({}); // returns 0     _ = myadd(2); // returns 2     _ = myadd('abc'); // returns 294     _ = myadd(optional_with_val); // returns 555     _ = myadd(optional_with_null); // returns 0     _ = myadd(&a); // returns 5     _ = myadd(.{ 5, 20 }); // returns 25      myprint({}); // prints 'no args'     myprint(.{{}}); // prints 'void'     myprint(2); // prints '2'     myprint('hello'); // prints 'hello'     myprint(.{ 3, 4 }); // prints '3 4' } ``` see [example.zig](src/example.zig) for another example.  ## license  licensed under the unlicense see included [license](./license) file or https://unlicense.org attribution to fig / fig-eater / groakgames is appreciated but not required. ","allyourcodebase/libmp3lame":"libmp3lame with the build system replaced by zig 404: not found","kassane/asio":"Asio C++ Library (uses zig build-system) 404: not found","dimdin/zig-recover":"zig panic recover zig panic recover =================  recover calls a function and regains control of the calling thread when the function panics or behaves undefined. recover is licensed under the terms of the [mit license](license).  how to use ----------  recover `call`, calls `function` with `args`, if the function does not panic, will return the called function's return value. if the function panics, will return `error.panic`. ``` const recover = @import('recover');  try recover.call(function, args); ```  prerequisites -------------  1. enabled runtime safety checks, such as unreachable, index out of bounds, overflow, division by zero, incorrect pointer alignment, etc.  2. in the root source file define panic as recover.panic or override the default panic handler and call recover `panicked`. ``` pub const panic = recover.panic; ``` 3. excluding windows, linking to c standard library is required.  example -------  returns error.panic because function division panics with runtime error 'division by zero'. ``` fn division(num: u32, den: u32) u32 {     return num / den; }  try recover.call(division, .{1, 0}); ```  testing -------  for recover to work for testing, you need a custom test runner with a panic handler: ``` pub const panic = @import('recover').panic; ```  to test that `foo(0)` panics: ``` test 'foo(0) panics' {      const err = recover.call(foo, .{0});      std.testing.expecterror(error.panic, err). }     ```  proper usage ------------  - recover is useful for testing panic and undefined behavior runtime safety checks. - it is **not** recommended to use recover as a general exception mechanism. ","paoda/hamt":"Hash Array Mapped Trie as defined in Phil Bagwell (2001). Ideal Hash Tries   # hash array mapped trie  a barebones implementation of [this paper](https://infoscience.epfl.ch/record/64398) by phil bagwell.   ### usage  as an example:  ```zig const std = @import('std'); const expectequal = std.testing.expectequal; const hasharraymappedtrie = @import('hamt').hasharraymappedtrie;  const stringtrie = hasharraymappedtrie([]const u8, void, stringcontext);  const stringcontext = struct {     // note: this definition is *required*     // todo: i could just grab the @typeinfo(hashfn).fn.return_type right?     pub const digest = u64;      pub inline fn hash(key: []const u8) digest {         return std.hash.wyhash.hash(0, key);     }      pub inline fn eql(left: []const u8, right: []const u8) bool {         return std.mem.eql(u8, left, right);     } };  test {     const pair = stringtrie.pair;     const allocator = std.testing.allocator;      var trie = try stringtrie.init(allocator);     defer trie.deinit(allocator);      try trie.insert(allocator, 'hello', {});      try expectequal(@as(?pair, .{ .key = 'hello', .value = {} }), trie.search('hello'));     try expectequal(@as(?pair, null), trie.search('world')); } ```  ### building   build in release mode with `zig build -doptimzie=releasesafe`;  ","nektro/zig-leven":"Measure the difference between two slices using the Levenshtein distance algorithm # zig-leven  measure the difference between two slices using the levenshtein distance algorithm  adapted from https://github.com/sindresorhus/leven  ## built with - zig master     - https://github.com/ziglang/zig - zigmod package manager     - https://github.com/nektro/zigmod  ## install ``` zigmod aq add 1/nektro/leven ```  ## usage `pub fn leven(comptime t: type, alloc: *std.mem.allocator, a: []const t, b: []const t, max: ?usize) !usize`  ## future todo unicode support for strings  ## license mit ","hendriknielaender/zlog":"🪵 structured logging library for zig > [!warning]   > still work in progress.  # zlog - high-performance logging in zig [![mit license](https://img.shields.io/badge/license-mit-blue.svg)](https://github.com/hendriknielaender/zlog/blob/head/license) ![github code size in bytes](https://img.shields.io/github/languages/code-size/hendriknielaender/zlog) [![prs welcome](https://img.shields.io/badge/prs-welcome-brightgreen.svg)](https://github.com/hendriknielaender/zlog/blob/head/contributing.md) <img src='logo.png' alt='zlog logo' align='right' width='20%'/>  zlog is a high-performance, extensible logging library for zig, designed to offer both simplicity and power in logging for system-level applications. inspired by the best features of modern loggers and tailored for the zig ecosystem, `zlog` brings structured, efficient, and flexible logging to your development toolkit.  ## key features  - **high performance**: minimizes overhead, ensuring logging doesn't slow down your application. - **asynchronous logging**: non-blocking logging to maintain application performance. - **structured logging**: supports json and other structured formats for clear, queryable logs. - **customizable log levels**: tailor log levels to fit your application's needs. - **redaction capabilities**: securely redact sensitive information from your logs. - **extensible architecture**: plug in additional handlers for specialized logging (e.g., file, network). - **cross-platform compatibility**: consistent functionality across different platforms. - **intuitive api**: a simple, clear api that aligns with zig's philosophy.  ## getting started  ### installation  1. declare zlog as a dependency in `build.zig.zon`:      ```diff     .{         .name = 'my-project',         .version = '1.0.0',         .paths = .{''},         .dependencies = .{     +       .zlog = .{     +           .url = 'https://github.com/hendriknielaender/zlog/archive/<commit>.tar.gz',     +       },         },     }     ```  2. add it to your `build.zig`:      ```diff     const std = @import('std');      pub fn build(b: *std.build) void {         const target = b.standardtargetoptions(.{});         const optimize = b.standardoptimizeoption(.{});      +   const opts = .{ .target = target, .optimize = optimize };     +   const zlog_module = b.dependency('zlog', opts).module('zlog');          const exe = b.addexecutable(.{             .name = 'test',             .root_source_file = .{ .path = 'src/main.zig' },             .target = target,             .optimize = optimize,         });     +   exe.addmodule('zlog', zlog_module);         exe.install();          ...     }     ```  3. get zlog package hash:      ```     $ zig build     my-project/build.zig.zon:6:20: error: url field is missing corresponding hash field             .url = 'https://github.com/hendriknielaender/zlog/archive/<commit>.tar.gz',                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     note: expected .hash = '<hash>',     ```  4. update `build.zig.zon` package hash value:      ```diff     .{         .name = 'my-project',         .version = '1.0.0',         .paths = .{''},         .dependencies = .{             .zlog = .{                 .url = 'https://github.com/hendriknielaender/zlog/archive/<commit>.tar.gz',     +           .hash = '<hash>',             },         },     }     ```  ### basic usage  ```zig const zlog = @import('zlog');  // set up your logger var logger = zlog.logger.init(allocator, zlog.level.info, zlog.outputformat.json, handler); ```  here is a basic usage example of zlog: ```zig // simple logging logger.log('this is an info log message');  // asynchronous logging logger.asynclog('this is an error log message'); ```  ### structured logging ```zig // log with structured data logger.info('test message', &[_]kv.keyvalue{     kv.keyvalue{ .key = 'key1', .value = kv.value{ .string = 'value1' } },     kv.keyvalue{ .key = 'key2', .value = kv.value{ .int = 42 } },     kv.keyvalue{ .key = 'key3', .value = kv.value{ .float = 3.14 } }, }); ```  ## contributing  the main purpose of this repository is to continue to evolve zlog, making it faster and more efficient. we are grateful to the community for contributing bugfixes and improvements. read below to learn how you can take part in improving zbench.  ### contributing guide  read our [contributing guide](contributing.md) to learn about our development process, how to propose bugfixes and improvements, and how to build and test your changes to zlog.  ### license  zlog is [mit licensed](./license). ","karlseguin/otp.zig":"An TOTP library for Zig 404: not found","travisstaloch/clarp":"A command line argument parsing library in zig # why was this project archived?  complexity, bloat and long compile times.  # recommended alternatives  * https://github.com/games-by-mason/structopt * https://github.com/travisstaloch/flagset   # about  derive command line parsers from union and struct types.  provides nested, context aware usage text similar to the zig compiler.  works with existing data structures you may not control.  # features  * field types   * int, bool, enum, float, optional, array, slice     * integer fields may be parsed as utf8 by setting `clarp_options.fields.<field_name>.utf8`   * nested unions and structs * help / usage   * automatically printed on parsing errors   * very customizable   * nested and context aware, showing only one level of help info at once   * written to `parse_options.err_writer` (default `std.io.null_writer`)   * accessible from any print() method: `std.debug.print('{help}', .{parse_result});` * diagnostics which clearly point to parsing errors * easily dump parse results   * from any print() method: `std.debug.print('{}', .{parse_result});` * derive short names by setting `clarp_options.derive_short_names` and override them with `fieldoption.short` * apply `clarp_options` to types you don't control with `parsewithoptions()` * rename long names with `fieldoption.long` * long and short options can be parsed with any of these forms:      | long          | short      |    | ------------- | ---------- |    | `--foo value` | `-f value` |    | `--foo=value` | `-f=value` |    | `--foovalue`  | `-fvalue`  |  # overview union types create alternative commands.  commands match field names exactly.  struct types create sequences of options.  options match field names with leading dashes such as `--text_color` for field `text_color`.  named options can be parsed out of order.  unnamed, positional parsing may be enabled by setting `clarp_options.fields.<field_name>.positional`.  tuple types create unnamed sequences and are parsed strictly by position.  bool fields create 'flags' and may be specified as `--flag` or `true`/`false` when unnamed.  they are always optional and default to false.  slice fields require an allocator and consume input until an argument is found which starts with '-' or end of arguments. `clarp_options.end_marker` may also be used to mark the end of field's arguments.  this may be necessary with unnamed, positional fields.  an allocator can be passed as `parseoptions.allocator`.  ## zig version this package is developed with zig master branch.  there are also [tagged releases](https://github.com/travisstaloch/clarp/tags) for previous compiler versions.  # usage you can find many examples in the [tests](src/tests.zig).  ## add clarp dependency  #### fetch ```console # 0.12.0 $ zig fetch --save https://github.com/travisstaloch/clarp/archive/refs/tags/0.12.0.tar.gz  # 0.13 / nightly $ zig fetch --save https://github.com/travisstaloch/clarp/archive/<commit hash>.tar.gz ``` this will add the following ```zig // build.zig.zon .dependencies = .{     .clarp = .{         .url = 'https://github.com/travisstaloch/clarp/archive/<commit-hash>.tar.gz',         .hash = ...,     }, }, ```  #### modify build.zig  ```zig // build.zig pub fn build(b: *std.build) void {     const exe = b.addexecutable(.{...});     const clarp = b.dependency('clarp', .{}).module('clarp');     exe.root_module.addimport('clarp', clarp); } ```  ## full example this program creates a parser and dumps the result to stderr.  it is available [here](src/test-demo.zig) and can be run with `$ zig build test-demo -- args`. ```zig const std = @import('std'); const clarp = @import('clarp');  pub fn main() !void {     var arena = std.heap.arenaallocator.init(std.heap.page_allocator);     defer arena.deinit();     const allocator = arena.allocator();      const argparser = clarp.parser(union(enum) {         cmd1: struct {             foo: []const u8,             pub const clarp_options = clarp.options(@this()){                 .fields = .{                     .foo = .{ .desc = 'foo description.' },                 },             };         },         cmd2: struct { enum { a, b } = .a },         pub const clarp_options = clarp.options(@this()){             .fields = .{                 .cmd1 = .{ .desc = 'cmd1 description.', .short = 'c1' },                 .cmd2 = .{ .desc = 'cmd2 description.', .short = 'c2' },             },         };     }, .{});      const args = try std.process.argsalloc(allocator);     const parsed = argparser.parse(args, .{         .err_writer = std.io.getstderr().writer().any(),     }) catch |e| switch (e) {         error.helpshown => return,         else => return e,     };     std.debug.print('{}╲n', .{parsed});      // access parse result     switch (parsed.result) {         .cmd1 => {},         .cmd2 => {},     } } ```  ## [clarp_options](src/clarp.zig#l29) when a struct or union contains a `pub const clarp_options` declaration, it changes parsing behavior.  nested structs and unions may declare their own `clarp_options`.  ## [parseoptions](src/clarp.zig#l59) runtime parsing options. the second argument to `clarp.parser(t).parse()`.  ## [parseroptions](src/clarp.zig#l66) comptime global parsing options. the second argument to `clarp.parser()`.  ### help flags by default, if an arg is `help`, `--help` or `-h` context aware usage is displayed.  you may change the help flags by passing an enum type for `parseroptions.help_type`.  ```console $ zig-out/bin/testexe help usage: testexe [command]  commands:    cmd1, c1            cmd1 description.   cmd2, c2            cmd2 description.  general options:    help, --help, -h    print command specific usage. ```  notice how this message is derived from the `union(enum)` passed to `clarp.parser()` above and that its `clarp_options` declaration affects the output, adding the `c1` and `c2` shorts and descriptions.  ### command specific help  ```console $ zig-out/bin/testexe cmd1 help usage: testexe cmd1 [options]    cmd1 description.  options:    --foo: string       foo description.  general options:    help, --help, -h    print command specific usage. ```  ## command line examples here are some results from the `argparser` we defined above in [full example](#full-example).  #### long names ```console $ zig-out/bin/testexe cmd1 --foo 'opt1 value'  cmd1:    foo: 'opt1 value' ```  #### short names ```console $ zig-out/bin/testexe c1 --foo 'opt1 value'  cmd1:    foo: 'opt1 value'  $ zig-out/bin/testexe c2 b  cmd2:    0: b ``` #### diagnostics ```console $ zig-out/bin/testexe foo usage: testexe [command]  commands:    cmd1, c1            cmd1 description.   cmd2, c2            cmd2 description.  general options:    help, --help, -h    print command specific usage.  error at argument 1: foo                      ^~~ error: unknowncommand #... stack trace omitted ``` ","dweiller/zig-wfc":"An implementation of the wave function collapse algorithm in Zig # zig-wfc an implementation of the wave function collapse algorithm in zig  a generic library implementing the *wave function collapse* algorithm. this library exposes a generic core algorithm which produces tilings given a collection of tiles and associated adjacency constraints, as well a tile generator for implementing the _overlapping_ mode. see the [original implementation](https://github.com/mxgmn/wavefunctioncollapse) for an overview of the algorithm and links to other resources.  ## using zig-wfc  you can use `zig-wfc` in a zig project with the zig build system. include a dependency in your `build.zig.zon`, e.g.: ``` .dependencies = .{     .zig_wfc = .{         .url = 'https://github.com/dweiller/zig-wfc/archive/[[commit_hash]].tar.gz',         .hash = '[[zig_package_hash]]',     }, } ```  then retrieve the `wfc` module from the dependency in your `build.zig`: ``` pub fn build(b: *std.build) !void {      // -- snip --      const wfc = b.dependency('zig_wfc', .{}).module('wfc');      // assuming you have a `std.build.step.compile` called 'exe' that wants to do wfc     exe.addmodule('zig-wfc', wfc); } ```  you can ascertain the correct value for `[[zig_package_hash]]` by leaving that field out initially; this make zig report the correct hash value.  ## wfc core  wfc is sometimes considered as having two different modes: overlapping and tiled. i think is description is a little misleading: i would rather say the wfc is a tiling generator (or maybe even more generally a graph colouring algorithm) and the overlapping mode merely one of several processing pipelines that can be used to achieve various effects. a good explanation how the core tiling algorithm relates to the overlapping mode can be found [here](https://www.gridbugs.org/wave-function-collapse/). another processing pipeline of particular interest i haven't yet seen talked about is what could be called the 'iterative mode' (if we want to keep the nomenclature of modes), which allows for generating [large-scale structure](#large-scale-structure), which are usually considered outside the scope of wfc.  the most common situation is generating a 2d or 3d cubic tiling and this library is currently restricted to 2-dimensional rectangular tilings.  ## features (and todos)    - [x] generic core algorithm you can use with any set of (2d) tiles/edge constraints forming a rectangular grid   - [x] generate tiles from image (overlapping mode)   - [x] seeded generation   - generation constraints     - [x] maximum tile count (i.e. max number of times a tile can be used)     - [ ] minimum tile count (i.e. min number of times a tile can be used)     - [ ] connectivity constraints (i.e. forces tiles to be part of the same region/path)     - [ ] distance constraints (distance between particular tiles and of paths)   - [ ] tile symmetry groups   - [ ] iterative pipeline   - [ ] _n_-dimensional rectangular tilings   - [ ] hexagonal grid  ## iterative pipeline  helper utilities for the iterative pipeline is not yet implemented, but are planned for the future. this pipeline is a fairly general idea that produces intermediate tilings that are used to seed the next stage.  ### large-scale structure  wfc does not generally produce large-scale structures as the constraints it considers are all local. however, the core tiling algorithm can be used to generate large-scale structure fairly easily using an iterative strategy. the basic idea is to first generate a low resolution tiling which is used to seed subsequent tile generation. the increase in resolution naturally leads to the initial tiling producing large-scale structure.  for example, say you wanted to generate a 2d tiling with some larger-scale structure that includes houses, roads and grass, including more specialised tiles for the boundary regions between the road and a front lawn (like a footpath). you could start by generating a 'seed' tiling at a lower resolution that has the tiles 'property' and 'road'. you then expand this tiling into a higher resolution one initially seeded with 'house', 'footpath' and 'grass' tiles in the regions associated to 'property' tiles and 'road' tiles seeded where the 'road' tiles were. the adjacency constraints for 'footpath' can then require that they border 'road' tiles and 'grass' tiles surround 'house' tiles. this guarantees a minimum size for each large-scale 'property' which are grassy regions (possibly) with house tiles inside them. more passes/sub-tile types could be added for improved internal structure of a 'property' (e.g. to make 'house' tiles form a connected region or to add a driveway).   ## contributing  contributions are welcome, as are issues requesting/suggesting better documentation or api and new features; feel free to open issues and send prs. ","mattnite/zig-libssh2":"compile libssh2 in your build.zig # libssh2 build package  [![ci](https://github.com/mattnite/zig-libssh2/actions/workflows/ci.yml/badge.svg)](https://github.com/mattnite/zig-libssh2/actions/workflows/ci.yml)  ## like this project?  if you like this project or other works of mine, please consider [donating to or sponsoring me](https://github.com/sponsors/mattnite) on github [:heart:](https://github.com/sponsors/mattnite)  ## how to use  this repo contains code for your `build.zig` that can statically compile libssh2.  ### link to your application  in order to statically link libssh2 into your application:  ```zig const libssh2 = @import('path/to/libssh2.zig');  pub fn build(b: *std.build.builder) void {     // ...      const lib = libssh2.create(b, target, optimize);      const exe = b.addexecutable(.{         .name = 'my-program',         .root_source_file = .{ .path = 'src/main.zig' },     });     lib.link(exe); } ``` ","nektro/zig-iana-tlds":"List of official IANA Top Level Domain Names # zig-iana-tlds  list of official iana top level domain names.  https://data.iana.org/tld/tlds-alpha-by-domain.txt  ## license  mit ","kassane/anotherBuildStep":"zig build add-on (add more toolchains [LLVM-based] support) # anotherbuildstep (a.k.a abs)  ## overview  `anotherbuildstep` is a project designed to leverage the zig build system (`build.zig`) for building projects with various other toolchains. this allows developers to use zig as a unified build system across different environments and toolsets.  ## todo  - [x] ldc2 support - [x] flang-new support - [x] rustc (no cargo) support - [ ] ~~rustc (cargo) support~~ (need to figure out how to get the cargo build system to work) - [x] swiftc-6 support  ## required  - [zig](https://ziglang.org/download) v0.13.0 or master   ## supported  - [ldc2](https://ldc-developers.github.io/) v1.38.0 or latest-ci - [flang](https://flang.llvm.org) (a.k.a flang-new) llvm-18.1.3 or master - [rustc](https://www.rust-lang.org/tools/install) stable or nightly - [swift](https://swift.org/download/) v6.0 or main-snapshots   ## usage  make new project or add to existing project:  in project folder, add this package as dependency on your `build.zig.zon`  ```bash $ zig fetch --save=abs git+https://github.com/kassane/anotherbuildstep ``` - add `const abs = @import('abs')` in `build.zig`  ```zig const std = @import('std'); // get build.zig from pkg to extend your build.zig project (only pub content module) const abs = @import('abs'); // dlang const ldc2 = abs.ldc2; // fortran const flang = abs.flang; // rust const rustc = abs.rust; // swift const swiftc = abs.swift; // zig-cc wrapper const zcc = abs.zcc;  pub fn build(b: *std.build) !void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});          const exedlang = try ldc2.buildstep(b, .{         .name = 'd_example',         .target = target,         .optimize = optimize,         .sources = &.{             'src/main.d',         },         .dflags = &.{             '-w',         },     });     b.default_step.dependon(&exedlang.step);      // or          const exefortran = try flang.buildstep(b, .{         .name = 'fortran_example',         .target = target,         .optimize = optimize,         .sources = &.{             'src/main.f90',         },         .use_zigcc = true,         .zcc_options = try zcc.buildoptions(b, target),     });     b.default_step.dependon(&exefortran.step);      // or      const exerust = try rustc.buildstep(b, .{         .name = 'rust_example',         .target = target,         .optimize = optimize,         .source = b.path('src/main.rs'),         .rflags = &.{             '-c',             'panic=abort',         },     });     b.default_step.dependon(&exerust.step);      // or      const exeswift = try swift.buildstep(b, .{         .name = 'swift_example',         .target = target,         .optimize = optimize,         .sources = &.{             'examples/main.swift',         },         .use_zigcc = true,         .zcc_options = try zcc.buildoptions(b, target),     });     b.default_step.dependon(&exeswift.step); } ``` ","softprops/zig-iter":"iterators for zig <h1 align='center'>     zig iter </h1>  <div align='center'>     iterators (for zig) </div>  ---  [![main](https://github.com/softprops/zig-iter/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/zig-iter/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/zig-iter) ![release](https://img.shields.io/github/v/release/softprops/zig-iter) [![zig support](https://img.shields.io/badge/zig-0.13.0-black?logo=zig)](https://ziglang.org/documentation/0.13.0/)  ## what's next()?  if you are coming to zig from any variety of other languages (we welcome you) you might be asking the questions like: how can i transform this zig collection?, how can i filter out elements?, and other perfectly valid questions based on what you might be used to from where you are coming from. the answer in zig is 'it depends', but you'll likely be using a for loop and allocating a copy of the collection you have on hand.  let's use a very simple example: doubling the value of an array of elems that you may do something later with. i'll just print it out for simplicity, but you'll likely be doing something more useful.  ```zig const elems = [_]i32{ 1, 2, 3 }; // 👇 conjure an allocator for the list below var gpa = std.heap.generalpurposeallocator(.{}){}; defer _ = gpa.deinit(); const allocator = gpa.allocator(); // 👇 allocate a new list to hold the data of the transformation, dont forget to deallocate it var buf = try std.arraylist(i32).initcapacity(allocator, elems.len); defer buf.deinit(); for (elems) |elem| {     buf.appendassumecapacity(elem * 2); } // 👇 capture a ref to the slice of data you want, dont forget to deallocate it const doubled = try buf.toownedslice(); defer allocator.free(doubled); // 👇 do something with it for (doubled) |elem| {     std.debug.print('{d}', .{elem}); } ```  the simple example above quickly becomes much more complicated as additional transformations and filtering is required.  if you are coming to zig from another language you are probably used to expressing this with something like `elems.map(...)`  with this library you can _almost_ have that too. below is an equivalent program but  sans required additional allocations and zig's required memory deallocation.   ```zig var elems = [_]i32 { 1, 2, 3 }; // 👇 create an interator and apply a transformation var doubled = iter.from(elems)     .then().map(i32, struct { fn func(n: i32) i32 { return n * 2; } }.func); // 👇 do something with it while (doubled.next()) |elem| {     std.debug.print('{d}', .{elem}); } ```  i say _almost_ because   * zig does not support closures, but it does support functions as arguments so we can emulate these to a certain degree with struct fn references * some [changes to `usingnamespace`](https://github.com/softprops/zig-iter/issues/1) facilitate the need for an itermediatory method, we use `then()`, to access and chain iterator methods. if zig brings that back in a different form this library's `then()` will no longer been nessessary.   the following functions create iterators  * `from(zigtype)` - create an iterator for a native zig type, we're expanding the list of types supported * `fromfn(returntype, init, func)` - create an iterator from a generator func * `once(value)` - create an iterator that only repeats once * `repeat(value)` - create an iterator that repeats a given value indefinitely  the following methods are available when calling `then()` on iterator types  * `chain(other)` - extends one iterator with another * `cycle()` - repeats an iterator indefinitely * `filter(func)` - filters an iterator by testing a `func` predicate * `fold(returntype, init, func)` - reduces an iterator down to a single value * `map(returntype, func)` - transforms an iterator by applying `func` * `skip(n)` - skip the first `n` elems of an iterator * `take(n)` - take only the first `n` elems of an iterator * `zip(iter)` - create an iterator yielding a tuple of iterator values  likely more to come   note, nothing is allocated behind the scenes. if you do need to take the results and  store the result in an allocatoed type simply do what you would do with any iterator: feed  it values of `next()`  ```zig var elems = [_]i32 { 1, 2, 3 }; var doubled = iter.from(elems)     .then().map(i32, struct { fn func(n: i32) i32 { return n * 2; } }.func);  // now go ahead feed the result into a list  // 👇 conjure an allocator for the list below var gpa = std.heap.generalpurposeallocator(.{}){}; defer _ = gpa.deinit(); const allocator = gpa.allocator(); // 👇 allocate a new list to hold the data of the transformation, dont forget to deallocate it var buf = try std.arraylist(i32).initcapacity(allocator, elems.len); defer buf.deinit(); while (doubled.next()) |elem| {     buf.appendassumecapacity(elem * 2); } // 👇 capture a ref to the slice of data you want, dont forget to deallocate it const copied = try buf.toownedslice(); defer allocator.free(copied); ```  ## examples  for more examples see the `examples` directory  ## 📼 installing  create a new exec project with `zig init`. copy an example from the examples directory into your into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/softprops/zig-iter/archive/refs/tags/v0.1.0.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +       // 👇 declare dep properties +        .iter = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-iter/archive/refs/tags/v0.1.0.tar.gz', +            // 👇 hash verification +            .hash = '...', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-iter/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-iter/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference dep from build.zig.zon` +    const iter = b.dependency('iter', .{ +        .target = target, +        .optimize = optimize, +    }).module('iter');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the module to executable +    exe.root_mode.addimport('iter', iter);      b.installartifact(exe); } ```  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)   ╲- softprops 2024","ziglibs/zig-windows-console":"Zig Windows Console stuff # zig-windows-console    tools for all your zig + windows console needs!    ## usage    add this to your `build.zig` and check out `examples/events.zig` for a quick, 5 minute primer.    ## try it!    ```bash  # build it!  zig build demo  ```  ","seyhajin/webgpu-wasm-zig":"🚀 A minimal WebGPU example written in Zig, compiled to WebAssembly (wasm). 🛠️ Ideal for experimenting and preparing for native development without install dependencies (dawn, wgpu-rs). 404: not found","travisstaloch/diff-zimilar":"a port of the dtolnay/dissimilar text diffing library to zig.  based on google's diff-match-patch  # diff-zimilar  a port of [dtolnay/dissimilar](https://github.com/dtolnay/dissimilar/) text diffing library to [zig](https://ziglang.org/). includes semantic cleanups.  based on google's diff match patch.   # goals  * reduced memory footprint, limited allocations * fast diffing, maybe for use in [zls](https://github.com/zigtools/zls)  # tools ### diffit a simple diffing utility that can be run from the command line: ```console $ zig build run -- <file_a> <file_b> ``` ```console $ zig build && zig-out/bin/diffit <file_a> <file_b> ``` this shows ansi colored diffs.  ### benchmark ```console $ zig run -lc -oreleasefast src/bench.zig -- <file_a> <file_b> <iterations> ``` ```console $ zig  run -lc -oreleasefast src/bench.zig -- /tmp/dissimilar/benches/document1.txt /tmp/dissimilar/benches/document2.txt 10 took 1.363s for 10 diffs ```  # usage ```zig test {     const diff = @import('lib.zig');     var arena = std.heap.arenaallocator.init(std.heap.page_allocator);     const aalloc = arena.allocator();     // 'catch return' just allows test to pass     const file_a = std.fs.cwd().openfile('/path/to/file_a', .{}) catch return;      const file_b = std.fs.cwd().openfile('/path/to/file_b', .{}) catch return;     const doc_a = try file_a.readtoendalloc(aalloc, std.math.maxint(u32));     const doc_b = try file_b.readtoendalloc(aalloc, std.math.maxint(u32));     var chunks = try diff.diff(aalloc, doc_a, doc_b);     defer chunks.deinit(aalloc); } ```  # references * inspired by [tomhoule/zig-diff](https://github.com/tomhoule/zig-diff/) * ported from [dtolnay/dissimilar](https://github.com/dtolnay/dissimilar/) * [google diff match patch](https://github.com/google/diff-match-patch) * [myers' diff algorithm](https://neil.fraser.name/writing/diff/myers.pdf) * [semantic cleanups](https://neil.fraser.name/writing/diff/) ","nektro/zig-tokenize":"A data-oriented-design built tokenizer # zig-tokenize a data-oriented-design built tokenizer ","softprops/zig-envy":"parse env variables into zig structs <h1 align='center'>     envy </h1>  <div align='center'>     deserialize environment variables into typesafe structs </div>  ---  [![main](https://github.com/softprops/zig-envy/actions/workflows/main.yml/badge.svg)](https://github.com/softprops/zig-envy/actions/workflows/main.yml) ![license info](https://img.shields.io/github/license/softprops/zig-envy) ![release](https://img.shields.io/github/v/release/softprops/zig-envy) [![zig support](https://img.shields.io/badge/zig-0.12.0-black?logo=zig)](https://ziglang.org/documentation/0.12.0/)  ## 🍬 features  - fail fast on faulty application configuration - supports parsable std lib types out of the box - fail at compile time for unsupported field types  ## examples  ```zig const std = @import('std'); const envy = @import('envy');  const config = struct {     foo: u16,     bar: bool,     baz: []const u8,     boom: ?u64 };  pub fn main() !void {     var arena = std.heap.arenaallocator.init(std.heap.page_allocator);     defer arena.deinit();     const allocator = arena.allocator();      const config = envy.parse(config, allocator, .{}) catch |err| {         std.debug.print('error parsing config from env: {any}', err);         return;     };     std.debug.println('config {any}', .{ config }); } ```  ## 📼 installing  create a new exec project with `zig init-exe`. copy the echo handler example above into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig `0.12.0`, you can use  ```sh zig fetch --save https://github.com/softprops/zig-envy/archive/refs/tags/v0.2.1.tar.gz ```  to manually add it as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +        // 👇 declare dep properties +        .envy = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-envy/archive/refs/tags/v0.2.1.tar.gz', +            // 👇 hash verification +            .hash = '{current-hash}', +        },     },     .paths = .{''}, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-envy/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-envy/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{}); +    // 👇 de-reference envy dep from build.zig.zon +    const envy = b.dependency('envy', .{ +        .target = target, +        .optimize = optimize, +    }).module('envy');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = b.path('src/main.zig'),         .target = target,         .optimize = optimize,     }); +    // 👇 add the envy module to executable +    exe.root_module.addimport('envy', envy);      b.installartifact(exe); } ```  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)  ╲- softprops 2023 ","tensorush/zig-uuid":"Zig implementation of all seven UUID versions. # zig-uuid  [![ci][ci-shd]][ci-url] [![cd][cd-shd]][cd-url] [![dc][dc-shd]][dc-url] [![lc][lc-shd]][lc-url]  ## zig implementation of [all seven uuid versions](https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-04.html).  ### :rocket: usage  - add `uuid` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-uuid/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `uuid` dependency in `build.zig`.  ```zig const uuid_dep = b.dependency('uuid', .{     .target = target,     .optimize = optimize, }); const uuid_mod = uuid_dep.module('uuid'); <compile>.root_module.addimport('uuid', uuid_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-uuid/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-uuid/blob/main/.github/workflows/ci.yaml [cd-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-uuid/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/tensorush/zig-uuid/blob/main/.github/workflows/cd.yaml [dc-shd]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=doc&labelcolor=black [dc-url]: https://tensorush.github.io/zig-uuid [lc-shd]: https://img.shields.io/github/license/tensorush/zig-uuid.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-uuid/blob/main/license ","mnemnion/ztap":"ZTAP: TAP producer for zig build test # ztap  the [test anything protocol](https://testanything.org/) is a simple, venerable, and widely-used format for reporting the output of tests.  ztap is a zig library for running and reporting tests in the tap 14 format.  ## use  this can be used as the main unit testing step, or as a custom step. instructions will assume the latter, but are easily adapted for the former case.  add to `build.zig.zon` in the usual fashion:  ```sh zig fetch --save 'https://github.com/mnemnion/ztap/archive/refs/tags/v0.8.1.tar.gz' ``` you'll need a test runner à la `src/ztap-runner.zig`:  ```zig const std = @import('std'); const builtin = @import('builtin'); const ztap = @import('ztap');  // this gives tap-compatible panic handling pub const panic = ztap.ztap_panic;  pub fn main() !void {     ztap.ztap_test(builtin);     std.process.exit(0); } ```  do be sure to exit with `0`, since the protocol interprets non-zero as a test failure.  add something of this nature to `build.zig`:  ```zig     // ztap test runner step.     const ztap_unit_tests = b.addtest(.{         .name = 'ztap-run',         .root_source_file = b.path('src/test-root-file.zig'),         .target = target,         .optimize = optimize,         .test_runner = b.path('src/ztap-runner.zig'),     });      // to put the runner in zig-out etc.     b.installartifact(ztap_unit_tests);      const run_ztap_tests = b.addrunartifact(ztap_unit_tests);      // to unilaterally run tests, add this:     run_ztap_tests.has_side_effects = true;      if (b.lazydependency('ztap', .{         .target = target,         .optimize = optimize,     })) |ztap_dep| {         ztap_unit_tests.root_module.addimport('ztap', ztap_dep.module('ztap'));     }      const ztap_step = b.step('ztap', 'run tests with ztap');     ztap_step.dependon(&run_ztap_tests.step); ``` that should do the trick.  see the first link for an example of what to expect in the way of output.  ## use notes  ztap is simply an output format for zig's test system, and no changes should be necessary to use it as such.  if `error.skipzigtest` is returned, ztap will issue the `# skip` directive.  zig doesn't support a todo for tests (not that it should necessarily), but tap does, so if `error.ztaptodo` is returned, ztap will issue `# todo`.  zig's test runner will treat the latter as any other error.  in the event that zig adds a todo error to the test system, ztap will support that also.  the `ztap_panic` function will add a comment to the tap output naming the test, and issue the `bail out!` directive which is proper for a fatal error.  it then calls the default panic handler, which does the accustomed things using `stderr`.  ## roadmap  ztap does what it needs to.  my intention is to use it (use by others is encouraged as well) until i'm fairly convinced it does nothing weird or untoward, or until six months have passed, whichever is longer.  it will then be declared 1.0 and will not change further unless tap, or zig, require it to.  no changes to the interface at any of these points are likely.  ### why though?  everything speaks tap.  ci speaks tap, distros speak tap, your editor speaks tap.  if you find yourself wanting to integrate with some or all of these things, ztap will tap your zig.  also, if you print to `stdout`, ztap will not hang your unit tests.  that doesn't make it a good idea, tap harnesses ignore what they don't grok, but it can't help things, and it can screw them up.  it does mean that tests will complete in the event that `stdout` is printed to. ","PauloCampana/random_variable":"RNG, density, probability, survival and quantile functions for various distributions.  ![](image.png)  for over 30 probability distributions, this library provides:  * random variable generation * density, probability, survival and quantile functions  mathematical functions are tested for high precision and rng tested to correctly fit the distribution  # installation builds static library with header file, optionally run tests ```bash $ zig build -doptimize=releasefast $ zig build test $ zig build correctness -doptimize=releasefast ```  # [documentation](https://paulocampana.github.io/random_variable)  # importing zig module ```bash $ zig fetch --save git+https://github.com/paulocampana/random_variable ```  ```zig // build.zig const rv_dep = b.dependency('random_variable', .{     .target = target,     .optimize = optimize, }); const rv_mod = rv_dep.module('random_variable');  exe.root_module.addimport('random_variable', rv_mod); ```  ```zig // main.zig const rv = @import('random_variable'); ``` ","BrookJeynes/progress":"A simple thread safe progress bar and spinner library # progress  a simple thread safe progress bar and spinner library.  ![recording](https://github.com/user-attachments/assets/227297c4-15a5-4c68-a8bc-49d7e1505a79)  ## adding to your program 1. fetch the package.       `zig fetch --save git+https://github.com/brookjeynes/progress` 2. add to your `build.zig`.     ```zig     const progress = b.dependency('progress', .{}).module('progress');     exe.root_module.addimport('progress', progress);     ```  ## minimal example ```zig const std = @import('std'); const progressbar = @import('progress').bar; const progressspinner = @import('progress').spinner;  pub fn bar() !void {     const stdout = std.io.getstdout().writer();     var pb = progressbar.init(10, stdout.any(), .{});      while (!pb.isfinished()) {         pb.add(1);         try pb.render();          std.time.sleep(std.time.ns_per_ms * 150);     } }  pub fn spinner() !void {     const stdout = std.io.getstdout().writer();     var ps = progressspinner.init(stdout.any(), .{         .symbols = progressspinner.predefinedsymbols.default,     });      var iterations: usize = 0;     while (!ps.isfinished()) {         iterations += 1;         try ps.render();          if (iterations == 20) try ps.finish();          std.time.sleep(std.time.ns_per_ms * 150);     } } ```  you can find more examples in the `examples/` folder.   for more information, see the source code or documentation (`zig build docs`).  ## contributing contributions, issues, and feature requests are always welcome! this project is  using the latest stable release of zig (0.13.0). ","neurocyte/flow-themes":"Themes compiler for Flow Control, the text editor # flow-themes themes compiler for flow-control, the text editor  ## requirements   - zig 0.13  - hjson (installed in your path)  ## build  `zig build`  this will download and compile all the themes and create a zig module in `zig-out` that can be referenced as a dependency from another project's `build.zig.zon`. ","ethanthoma/zensor":"Zig tensor library <h3 align='center'>     zensor, a zig tensor library </h3>  a zig tensor library. correctness first, speed second.  this library promises compile-time type and shape checking.  **very wip**  ## example usage: ```zig  const std = @import('std');  const t = u32; const tensor = @import('zensor').tensor(t);  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     const allocator = gpa.allocator();      var compiler = zensor.compiler.init(allocator);     defer compiler.deinit();      const filename = './examples/numpy.npy';      const a = try zensor.tensor(.int64, .{3}).from_numpy(&compiler, filename);      const b = try zensor.tensor(.int64, .{3}).full(&compiler, 4);      const c = try a.mul(b);      const d = try c.sum(0);      std.debug.print('{}╲n', .{d}); } ```  results in: ``` ❯ zig build run tensor(         type: dtypes.int64,         shape: [1],         length: 1,         data: [56, ] ) ```  ## install  fetch the library: ```bash zig fetch --save git+https://github.com/ethanthoma/zensor.git#main ```  add to your `build.zig`: ```zig     const zensor = b.dependency('zensor', .{         .target = target,         .optimize = optimize,     }).module('zensor');     exe.root_module.addimport('zensor', zensor); ```  ## examples  examples can be found in `./examples`. you can run these via: ```bash zig build name_of_example ``` assuming you have cloned the source.  ## tests  if you want to run the tests after cloning the source. simply run: ```bash zig build test ```  ## design  this library conversts all your tensor operations into an ast: ``` 0 store runtimebuffer(ptr=@140052063859008, dtype=dtypes.int64, shape={ 3 }) 1 ┗━mul 2   ┣━load runtimebuffer(ptr=@140052063858688, dtype=dtypes.int64, shape={ 3 }) 3   ┗━const 4 ```  when you want to execute your operations, it first gets split into schedules: ``` schedule{         status: notrun         topological sort: [4]ast.nodes{load, const, mul, store},         global buffers: [(0, true), (1, false)],         dependencies count: 0,         ast:         0 store runtimebuffer(ptr=@140052063859008, dtype=dtypes.int64, shape={ 3 })         1 ┗━mul         2   ┣━load runtimebuffer(ptr=@140052063858688, dtype=dtypes.int64, shape={ 3 })         3   ┗━const 4 } ```  and then ir code: ``` step op name          type             input            arg    0 define_global    pointer          []               (0, true)    1 define_global    pointer          []               (1, false)    2 const            int              []               0    3 const            int              []               3    4 define_acc       int              [5]              0    5 loop             int              [2, 3]           none    6 load             int              [1, 5]           none    7 alu              int              [4, 6]           alu.add    8 update           int              [4, 7]           none    9 endloop                           [5]              none   10 const            int              []               0   11 store                             [0, 10, 4]       none ```  and finally, executed: ``` pc:   0 pc:   1 pc:   2 const: 0 pc:   3 const: 3 pc:   4 acc: 0 pc:   5 loop: from 0 to 3 pc:   6 load: 4 from buffer 1 at 0 pc:   7 alu: add(0, 4) = 4e0 pc:   8 update: value stored in step 4 to 4e0 pc:   6 load: 16 from buffer 1 at 1 pc:   7 alu: add(4e0, 16) = 2e1 pc:   8 update: value stored in step 4 to 2e1 pc:   6 load: 36 from buffer 1 at 2 pc:   7 alu: add(2e1, 36) = 5.6e1 pc:   8 update: value stored in step 4 to 5.6e1 pc:   9 pc:  10 const: 0 pc:  11 store: 5.6e1 into 0 at 0 ``` ","Calder-Ty/multihash":"Zig Multihash implementation # multihash a library for creating, serializing and deserializing [multihashes](https://multiformats.io/multihash/).  # contents:  ## multihash  `multihash` is the package for creating, serializing and deserializing multihashes. exposes two structs: `multihash`, and `unsignedvarint`.  ### examples: ```zig // bytes for multihash const input = [_]u8{     0x12, 0x20, 0x41, 0xdd, 0x7b, 0x64, 0x43, 0x54, 0x2e, 0x75, 0x70,     0x1a, 0xa9, 0x8a, 0x0c, 0x23, 0x59, 0x51, 0xa2, 0x8a, 0x0d, 0x85,     0x1b, 0x11, 0x56, 0x4d, 0x20, 0x02, 0x2a, 0xb1, 0x1d, 0x25, 0x89,     0xa8, };  const result = try multihash.deserialize(&input, testing.allocator); defer result.deinit(); ```  ## pkghash  `pkghash` is a tool for generating hashes for zig packages. it is forked from the pkghash utility in [zap](https://github.com/zigzap/zap). the main purpose of forking was to add the ability to specify the exact files that would be included in the hash.  ### usage ``` usage: pkghash [options]  options:    -h --help           print this help and exit.   -g --git            use git ls-files   -f --file <file list>           list files to include in hash. directories are included recursively. does not work with `-g`  sub-options:    --allow-directory : calc hash even if no build.zig is present                       applies in no-git mode only  sub-options for --git:    --tag=<tag>          : specify git tag to use in template                          defaults to tag pointing to head   --template=<file.md> : specify markdown template to render ```  ### example: ```bash pkghash -f license src/* readme.md build.zig build.zig.zon ```  # acknowledgments portion of this code use code licensed by others:  main.zig: copyright (c) 2023 rene schallner, mit license  ","karlseguin/localize.zig":"ICU Message Parser and Renderer 404: not found","Marco-Christiani/zigrad":"A deep learning framework built on an autograd engine with high level abstractions and low level control. <p align='center'>   <img src='./docs/zg-logo.svg' width=350> </p>  <p align='center'>   <img src='https://img.shields.io/github/license/marco-christiani/zigrad?style=flat&logo=opensourceinitiative' alt='license'>   <img src='https://img.shields.io/github/last-commit/marco-christiani/zigrad?style=flat&logo=git&logocolor=white' alt='last-commit'>   <img src='https://img.shields.io/github/languages/count/marco-christiani/zigrad?style=flat' alt='repo-language-count'>   <img src='https://img.shields.io/github/languages/top/marco-christiani/zigrad?style=flat&color=f7a41d' alt='repo-top-language'>   <!-- <img src='https://img.shields.io/badge/zig-f7a41d.svg?style=flat&logo=zig&logocolor=white' alt='zig'> --> </p> <br>  # zigrad #### a deep learning framework built on an autograd engine with high level abstractions and low level control.   https://github.com/user-attachments/assets/3842aa72-9b16-4c25-8789-eac7159e3768    **fast** <!-- benchmarks -->  2.5x+ speedup over a compiled pytorch model on apple silicon, 1.5x on x86. expect similar performance gains across more architectures and platforms as mkl/cuda support improves and zigrad's ml graph compiler is operational.* <!-- link to a benchmarking page --> <!-- only need one of the bm plots, probably fast vs fast since that requires the least explanation -->  <picture>   <source media='(prefers-color-scheme: light)' srcset='docs/zg_mnist_zg_torch_perf.svg'>   <source media='(prefers-color-scheme: dark)' srcset='docs/zg_mnist_zg_torch_perf_dark.svg' >   <img alt='description of the image' src='docs/zg_mnist_zg_torch_perf.svg'> </picture> <!-- ![](./docs/zg_mnist_zg_torch_perf_0_speedupzigrad_pytorch_plotly.svg) -->  <sub>*tensorflow excluded for scaling purposes (too slow). a hermetic, reproducible benchmarking pipeline built on bazel will allow testing across more platforms (in progress, testers needed).</sub>  **built for specialized optimization**  zigrad's design enables deep control and customization  - fine-grained control over memory management - flexible tradeoffs between performance characteristics like latency vs throughput - optimize for your specific hardware, use case, and system requirements - no abstraction layers or build systems that make aggressive optimizations challenging or complex  but wait, there's more..  - tiny binaries: binaries for the mnist tests shown are under 400kb in `releasefast` mode and under 200kb in `releasesmall`. - graph tracing - tensorboard integration* - cross platform - statically linked executables - minimal and transparent heap allocations <!-- scalar api -->  <sub>*not yet merged</sub>  ## features  ### trace the computation graph  ![](./docs/comp_graph_mnist_simple_noag.svg)  an example of tracing the computation graph generated by a fully connected neural network for mnist.  - *input:* batch of images 28x28 pixel samples. - **flatten:** `28x28 -> 784` - **fc1**: linear layer `784 -> 128` - **relu** - **fc2:** linear layer `128 -> 64` - **relu** - **fc3:** linear layer `64 -> 10` - *output:* value for each of the 10 classes   we did not have to use zigrad's modules to write this network at all, as zigrad is backed by a capable autograd engine. even when using the autograd backend to dynamically construct the same neural network zigrad can still trace the graph and render it.    > note: since the graph is generated from the autograd information, we set the labels for the nodes by naming the tensors for the sake of the diagram.  ![](./docs/comp_graph_mnist_simple_ag.svg)  ## getting started  only dependency is a blas library.  ### linux  on linux (or intel mac) you have some options,  - mkl (recommended for best performance)   - see https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-download.html   - reccommend a system installation for simplicity although this can work with `conda` for example, just make sure you adjust the library paths as necessary. - openblas   - see https://github.com/openmathlib/openblas/wiki/precompiled-installation-packages   - likely available through your package manager as `libopenblas-dev` or `openblas-devel`  ### apple silicon  - nothing :)  ### examples  the `examples/` directory has some standalone templates you can take and modify, the zon files are pinned to commit hashes.  hello world example shows how to run a backward pass using the `graphmanager.` note that in this very simple example, we do not need the `graphmanager` and the script could be simplified but this is designed to get you familiar with the workflow.  ```shell git clone https://github.com/marco-christiani/zigrad/ cd zigrad/examples/hello-world zig build run ```  run the mnist demo  ```shell cd zigrad/examples/mnist make help make ```  ## roadmap  a lot is planned and hoping for support from the zig community so we can accomplish some of the more ambitious goals.  - more comprehensive mkl support - more parallelization (e.g. activation functions) - cuda support - lazy tensors - static graph optimization - dynamic graph compiler - mlir - support for popular formats like onnx and ggml. - zml translation for inference  ## known issues and limitations  - lack of gpu support for now - effort has been directed towards performant primitives, not many layer types have been implemented   - e.g. conv, pooling, etc are test implementations for verification, they are slow and unoptimized, i would not use them   -   ## contributing  - in addition to the above list, anything in in [docs/roadmap.norg](docs/roadmap.norg) is planned - any open issue is available for development, just leave a comment mentioning your interest and i can provide support to help get you started if necessary - otherwise, **please open an issue first, before working on a pr** - if you are interested in contributing but do not know where to start then open an issue or leave a comment ","travisstaloch/kd-tree":"A k-d tree implementation in zig # about  a [k-d tree](https://en.wikipedia.org/wiki/k-d_tree) implementation ported from https://github.com/gishi523/kd-tree  # api  * floats only.  accepts arrays or homogenous structures of any zig float type * search for single nearest neighbor * search for k nearest neighbors * search for all neighbors within radius * visit all nodes with user provided context * validate all nodes  # usage  this package is meant to be consumed with the [zig build system](https://ziglang.org/learn/build-system) and imported as a module.  ```console # latest commit zig fetch --save=kdtree git+https://github.com/travisstaloch/kd-tree ``` ```console # specific commit zig fetch --save=kdtree https://github.com/travisstaloch/kd-tree/archive/<commit-hash>.tar.gz ``` ```zig // build.zig exe.root_module.addimport('kdtree', b.dependency('kdtree', .{}).module('kdtree')); ``` ```zig // myapp.zig const kdtree = @import('kdtree'); ```  ### example test  this code is from [src/root.zig](src/root.zig) where there are also other similar tests.  and there is [demo raylib app](src/main.zig) too.  ```zig test 'basic usage' {     const mypoint = struct { x: f32, y: f32 };     const my_points: [8]mypoint = .{         .{ .x = 2.7175806e0, .y = 2.5162528e0 },         .{ .x = 3.0172718e0, .y = 1.1619115e-1 },         .{ .x = 3.9525537e0, .y = 2.9364395e-1 },         .{ .x = 7.0706835e0, .y = 7.9604106e0 },         .{ .x = 2.6941679e0, .y = 1.9487169 },         .{ .x = 3.7812352e0, .y = 8.3156556e-1 },         .{ .x = 7.326651e-1, .y = 1.2251115e0 },         .{ .x = 8.401675e-1, .y = 2.9021428e0 },     };      // todo: const kdtree = @import('kdtree').kdtree;     const tree = kdtree(mypoint, .{});     var tree = try tree.init(std.testing.allocator, &my_points);     defer tree.deinit(std.testing.allocator);      // validate     try tree.validate();      // visit     var count: u8 = 0;     tree.visit(.{}, &count, struct {         fn visit(_: tree, _: tree.node, c: *u8) bool {             c.* += 1;             return true;         }     }.visit);     try testing.expectequal(my_points.len, count);      const target: mypoint = .{ .x = 5, .y = 5 };      // nearest     const nearest = tree.nnsearch(target);     try testing.expectequal(0, nearest.nearest_point_idx);      // knn     var knn_result: [2]u32 = undefined;     try tree.knnsearch(std.testing.allocator, target, &knn_result);     try testing.expectequal(0, knn_result[0]);     try testing.expectequal(3, knn_result[1]);      // radius     var radius_search_results = std.arraylist(u32).init(std.testing.allocator);     defer radius_search_results.deinit();     const radius = 4;     try tree.radiussearch(target, radius, &radius_search_results);     try testing.expectequal(3, radius_search_results.items.len); } ```  # demo ```console zig build run ``` ![screenshot](https://github.com/user-attachments/assets/ec4a26a9-2c92-4f72-aaed-08c20c296a47) red is the target point and radius.  green + outlined is the closest neighbor.  green are the 5 nearest neighbors.  and blue are within the search radius.  if you want to run the demo app, you'll need to either have raylib available on your system or create a deps/raylib folder and put libraylib.a there along with include/{raylib.h,raymath.h,rlgl.h}  # bench ```console $ ./bench.sh unstable ... ++ zig build -doptimize=releasefast ++ zig-out/bin/bench unstable init time 56.034ms validate time 215.078us nnsearch time 9.28us knnsearch time 838.642us radiussearch time 4.85us time 57.105ms size 100000 $ ./bench.sh median_of_medians ... ++ zig build -doptimize=releasefast ++ zig-out/bin/bench init time 15.637ms validate time 250.359us nnsearch time 9.29us knnsearch time 861.343us radiussearch time 5.34us time 16.767ms size 100000 ```","SimonLSchlee/zig15game":"A 15 puzzle game implemented with raylib. # zig15game a [zig](https://ziglang.org/download/) 15 puzzle game based on [15 puzzle game](https://ziggit.dev/t/15-puzzle-game/4350) by chris boesch,   changed from a console/terminal implementation to a [raylib](https://www.raylib.com/) implementation.  added simple raylib gui and sound effects.   if you are a vim user (or want to train vim keys) play with hjkl, otherwise use wasd or arrow keys!  ## play  [![game screenshot](media/screenshot000.png)](https://simonlschlee.github.io/zig15game/)   https://simonlschlee.github.io/zig15game/  ## discussion ziggit topic for discussion: https://ziggit.dev/t/raylib-15-game/5233   if you have ideas for improvements you can use ziggit or open an issue!  ## install ```bash git clone https://github.com/simonlschlee/zig15game.git cd zig15game zig build run ```  tested with zig version: `0.13.0`    ## other raylib projects  [zigraylib](https://github.com/simonlschlee/zigraylib) ## license public domain or mit ","discord-zig/discord.zig":"Discord library written in Zig # discord.zig  a high-performance bleeding edge discord library in zig, featuring full api coverage, sharding support, and fine-tuned parsing * sharding support: ideal for large bots, enabling distributed load handling. * 100% api coverage & fully typed: offers complete access to discord's api with strict typing for reliable and safe code. * high performance: faster than whichever library you can name (wip) * flexible payload parsing: supports payload parsing through both zlib and zstd*. * language agnostic: primarily in zig, but also compatible with javascript. (perhaps?)  ```zig const client = @import('discord.zig').client; const shard = @import('discord.zig').shard; const discord = @import('discord.zig').discord; const intents = discord.intents; const std = @import('std');  fn ready(_: *shard, payload: discord.ready) void {     std.debug.print('logged in as {s}╲n', .{payload.user.username}); }  fn message_create(_: *shard, message: discord.message) void {     std.debug.print('captured: {?s}╲n', .{ message.content }); }  pub fn main() !void {     var tsa = std.heap.threadsafeallocator{ .child_allocator = std.heap.c_allocator };      var handler = client.init(tsa.allocator());     try handler.start(.{         .token = std.posix.getenv('token') orelse unreachable,         .intents = intents.fromraw(37379),         .run = .{ .message_create = &message_create, .ready = &ready },         .log = .yes,         .options = .{},     });     errdefer handler.deinit(); }  ``` ## installation ```zig // in your build.zig file const exe = b.addexecutable(.{     .name = 'marin',     .root_source_file = b.path('src/main.zig'),     .target = target,     .optimize = optimize, });  const dzig = b.dependency('discord.zig', .{});  exe.root_module.addimport('discord.zig', dzig.module('discord.zig')); ``` tip: make sure you use the latest zig!  ## contributing contributions are welcome! please open an issue or pull request if you'd like to help improve the library. * support server: https://discord.gg/rbhkbt7np5 * the original repo: https://codeberg.org/yuzu/discord.zig  ## general roadmap | task                                                        | status | |-------------------------------------------------------------|--------| | stablish good sharding support with buckets                 | ✅     | | use the priority queues for handling ratelimits (half done) | ❌     | | make the library scalable with a gateway proxy              | ❌     | | get a cool logo                                             | ❌     | | finish the event coverage roadmap                           | ❌     |  ## event coverage roadmap | event                                  | support | |----------------------------------------|---------| | application_command_permissions_update | ❌      | | auto_moderation_rule_create            | ❌      | | auto_moderation_rule_update            | ❌      | | auto_moderation_rule_delete            | ❌      | | auto_moderation_action_execution       | ❌      | | channel_create                         | ❌      | | channel_update                         | ❌      | | channel_delete                         | ❌      | | channel_pins_update                    | ❌      | | thread_create                          | ❌      | | thread_update                          | ❌      | | thread_delete                          | ❌      | | thread_list_sync                       | ❌      | | thread_member_update                   | ❌      | | thread_members_update                  | ❌      | | guild_audit_log_entry_create           | ❌      | | guild_create                           | ❌      | | guild_update                           | ❌      | | guild_delete                           | ❌      | | guild_ban_add                          | ❌      | | guild_ban_remove                       | ❌      | | guild_emojis_update                    | ❌      | | guild_stickers_update                  | ❌      | | guild_integrations_update              | ❌      | | guild_member_add                       | ❌      | | guild_member_remove                    | ❌      | | guild_member_update                    | ❌      | | guild_members_chunk                    | ❌      | | guild_role_create                      | ❌      | | guild_role_update                      | ❌      | | guild_role_delete                      | ❌      | | guild_scheduled_event_create           | ❌      | | guild_scheduled_event_update           | ❌      | | guild_scheduled_event_delete           | ❌      | | guild_scheduled_event_user_add         | ❌      | | guild_scheduled_event_user_remove      | ❌      | | integration_create                     | ❌      | | integration_update                     | ❌      | | integration_delete                     | ❌      | | interaction_create                     | ❌      | | invite_create                          | ❌      | | invite_delete                          | ❌      | | message_create: ?*const fn (message: discord.message) void | ✅ | | message_update: ?*const fn (message: discord.message) void | ✅ | | message_delete: ?*const fn (message: discord.messagedelete) void | ✅ | | message_delete_bulk: ?*const fn (message: discord.messagedeletebulk) void | ✅ | | message_reaction_add                   | ❌      | | message_reaction_remove                | ❌      | | message_reaction_remove_all            | ❌      | | message_reaction_remove_emoji          | ❌      | | presence_update                        | ❌      | | stage_instance_create                  | ❌      | | stage_instance_update                  | ❌      | | stage_instance_delete                  | ❌      | | typing_start                           | ❌      | | user_update                            | ❌      | | voice_channel_effect_send              | ❌      | | voice_state_update                     | ❌      | | voice_server_update                    | ❌      | | webhooks_update                        | ❌      | | entitlement_create                     | ❌      | | entitlement_update                     | ❌      | | entitlement_delete                     | ❌      | | message_poll_vote_add                  | ❌      | | message_poll_vote_remove               | ❌      | | ready: discord.ready                   | ✅      | | resumed                                | ❌      | | any: []const u8                        | ✅      |  ","ringtailsoftware/zigtris":"A minimal terminal Tetris written in Zig # zigtris  a minimal terminal tetris written in zig. tested with zig 0.13.0  `zig build run`  cursor keys to move, space to drop, `q` to quit.  ![](demo.gif)  # why?  this was a quick weekend project to get back into writing some zig. i've never tried to implement tetris, so it was a fun challenge.  some notes for anyone looking at the code:   - it's messy and unoptimised. i was working out how to do it while doing it (and trying to remember zig syntax)  - `display` is a thin wrapper on top of the `mibu` terminal library, it provides a double buffered one pixel per character interface where it only redraws changed pixels on the buffer flip  - `stage` is the game stage and provides a square pixel interface on top of `display` (by printing two chars for each pixel)  - `player` holds the `tetronimo` shapes and movement logic  - `debris` holds the list of fallen blocks for hitchecking and completed line detection  # license  mit  ","Catniped/stl-loader-zig":"A tiny simple zig library for loading STL files with binary and ASCII support # stl-loader-zig  a tiny simple zig library for loading stl files with support for both ascii and binary representations.   ## usage example usage provided in [example.zig](src/example.zig):  ```c const stlloader = @import('stl-loader');  ...  const filepath: []const u8 = 'file.stl';  var gpa = std.heap.generalpurposeallocator(.{}){}; const allocator = gpa.allocator(); defer _ = gpa.deinit();  const mesh = try stlloader.load_stl(allocator, filepath); defer allocator.free(mesh); // do stuff with mesh ```  loading by default should be done thru dispatcher function, which takes a path for the file **relative to the cwd** and automatically chooses which implementation of the reader to use. if the type of the stl file is known at compile time, or you wish to dispatch the functions manually, **note the offsets for the reader required before calling the functions.**  ## notes - at the time of writing this, i am still quite new to zig, so the code may not be perfect. feel free to suggest improvements and bugfixes in the github issues! ","nektro/zig-git":"Inspect into the depths of your .git folder purely from Zig 404: not found","kassane/wolfssl":"WolfSSL library - Using Zig Build # wolfssl embedded ssl/tls library  the [wolfssl embedded ssl library](https://www.wolfssl.com/products/wolfssl/)  (formerly cyassl) is a lightweight ssl/tls library written in ansi c and targeted for embedded, rtos, and resource-constrained environments - primarily because of its small size, speed, and feature set.  it is commonly used in standard operating environments as well because of its royalty-free pricing and excellent cross platform support. wolfssl supports industry standards up to the current [tls 1.3](https://www.wolfssl.com/tls13) and dtls 1.3, is up to 20 times smaller than openssl, and offers progressive ciphers such as chacha20, curve25519, blake2b and post-quantum tls 1.3 groups. user benchmarking and feedback reports dramatically better performance when using wolfssl over openssl.  wolfssl is powered by the wolfcrypt cryptography library. two versions of wolfcrypt have been fips 140-2 validated (certificate #2425 and certificate #3389). fips 140-3 validation is in progress. for additional information, visit the [wolfcrypt fips faq](https://www.wolfssl.com/license/fips/) or contact fips@wolfssl.com.  ## why choose wolfssl?  there are many reasons to choose wolfssl as your embedded, desktop, mobile, or enterprise ssl/tls solution. some of the top reasons include size (typical footprint sizes range from 20-100 kb), support for the newest standards (ssl 3.0, tls 1.0, tls 1.1, tls 1.2, tls 1.3, dtls 1.0, dtls 1.2, and dtls 1.3), current and progressive cipher support (including stream ciphers), multi-platform, royalty free, and an openssl compatibility api to ease porting into existing applications which have previously used the openssl package. for a complete feature list, see [chapter 4](https://www.wolfssl.com/docs/wolfssl-manual/ch4/) of the wolfssl manual.  ## notes, please read  ### note 1 wolfssl as of 3.6.6 no longer enables sslv3 by default.  wolfssl also no longer supports static key cipher suites with psk, rsa, or ecdh. this means if you plan to use tls cipher suites you must enable dh (dh is on by default), or enable ecc (ecc is on by default), or you must enable static key cipher suites with one or more of the following defines:  ``` wolfssl_static_dh wolfssl_static_rsa wolfssl_static_psk ``` though static key cipher suites are deprecated and will be removed from future versions of tls.  they also lower your security by removing pfs.  when compiling `ssl.c`, wolfssl will now issue a compiler error if no cipher suites are available. you can remove this error by defining `wolfssl_allow_no_suites` in the event that you desire that, i.e., you're not using tls cipher suites.  ### note 2 wolfssl takes a different approach to certificate verification than openssl does. the default policy for the client is to verify the server, this means that if you don't load cas to verify the server you'll get a connect error, no signer error to confirm failure (-188).  if you want to mimic openssl behavior of having `ssl_connect` succeed even if verifying the server fails and reducing security you can do this by calling:  ```c wolfssl_ctx_set_verify(ctx, wolfssl_verify_none, null); ```  before calling `wolfssl_new();`. though it's not recommended.  ### note 3 the enum values sha, sha256, sha384, sha512 are no longer available when wolfssl is built with `--enable-opensslextra` (`openssl_extra`) or with the macro `no_old_sha_names`. these names get mapped to the openssl api for a single call hash function. instead the name `wc_sha`, `wc_sha256`, `wc_sha384` and `wc_sha512` should be used for the enum name.   # wolfssl release 5.7.2 (july 08, 2024)  release 5.7.2 has been developed according to wolfssl's development and qa process (see link below) and successfully passed the quality criteria. https://www.wolfssl.com/about/wolfssl-software-development-process-quality-assurance  note: * --enable-heapmath is being deprecated and will be removed by end of 2024  ## vulnerabilities * [medium] cve-2024-1544 potential ecdsa nonce side channel attack in versions of wolfssl before 5.6.6 with wc_ecc_sign_hash calls. generating the ecdsa nonce k samples a random number r and then truncates this randomness with a modular reduction mod n where n is the order of the elliptic curve. analyzing the division through a control-flow revealing side-channel reveals a bias in the most significant bits of k. depending on the curve this is either a negligible bias or a significant bias large enough to reconstruct k with lattice reduction methods. thanks to luca wilke, florian sieck and thomas eisenbarth (university of lübeck) for reporting the vulnerability. details will appear in the proceedings of ccs 24. fixed https://github.com/wolfssl/wolfssl/pull/7020   * [medium] cve-2024-5288 a private key blinding operation, enabled by defining the macro wolfssl_blind_private_key, was added to mitigate a potential row hammer attack on ecc operations. if performing ecc private key operations in an environment where a malicious user could gain fine control over the device and perform row hammer style attacks it is recommended to update the version of wolfssl used and to build with wolfssl_blind_private_key defined. thanks to kemal derya, m. caner tol, berk sunar for the report (vernam applied cryptography and cybersecurity lab at worcester polytechnic institute) fixed in github pull request https://github.com/wolfssl/wolfssl/pull/7416   * [low] when parsing a provided maliciously crafted certificate directly using wolfssl api, outside of a tls connection, a certificate with an excessively large number of extensions could lead to a potential dos. there are existing sanity checks during a tls handshake with wolfssl which mitigate this issue. thanks to bing shi for the report. fixed in github pull request https://github.com/wolfssl/wolfssl/pull/7597  * [low] cve-2024-5991 in the function matchdomainname(), input param str is treated as a null terminated string despite being user provided and unchecked. specifically, the openssl compatibility function x509_check_host() takes in a pointer and length to check against, with no requirements that it be null terminated. while calling without a null terminated string is very uncommon, it is still technically allowed. if a caller was attempting to do a name check on a non*null terminated buffer, the code would read beyond the bounds of the input array until it found a null terminator. fixed in github pull request https://github.com/wolfssl/wolfssl/pull/7604  * [medium] cve-2024-5814 a malicious tls1.2 server can force a tls1.3 client with downgrade capability to use a ciphersuite that it did not agree to and achieve a successful connection. this is because, aside from the extensions, the client was skipping fully parsing the server hello when downgrading from tls 1.3. fixed in github pull request https://github.com/wolfssl/wolfssl/pull/7619  * [medium] ocsp stapling version 2 response verification bypass issue when a crafted response of length 0 is received. found with internal testing. fixed in github pull request https://github.com/wolfssl/wolfssl/pull/7702  * [medium] ocsp stapling version 2 revocation bypass with a retry of a tls connection attempt. a revoked ca certificate could incorrectly be loaded into the trusted signers list and used in a repeat connection attempt. found with internal testing. fixed in github pull request https://github.com/wolfssl/wolfssl/pull/7702   ## new feature additions * added dilithium/ml-dsa: implementation of ml-dsa-44/65/87 (pr 7622) * aes risc-v 64-bit asm: ecb/cbc/ctr/gcm/ccm (pr 7569) * added cuda support for aes encryption (pr 7436) * added support for grpc (pr 7445) * added function wc_rsaprivatekeydecoderaw to import raw rsa private keys (pr 7608) * added crypto callback for sha-3 (pr 7670) * support for infineon modus toolbox with wolfssl (pr 7369) * allow user to send a user_canceled alert by calling wolfssl_sendusercanceled (pr 7590) * c# wrapper sni support added (pr 7610) * quantum-safe algorithm support added to the linux kernel module (pr 7574) * support for nist 800-56c option 1 kdf, using the macro wc_kdf_nist_sp_800_56c added (pr 7589) * aes-xts streaming mode added, along with hardware acceleration and kernel module use (pr 7522, 7560, 7424) * platformio freertos with esp build and addition of benchmark and test example applications (pr 7528, 7413, 7559, 7542)   ## enhancements and optimizations * expanded stm32 aes hardware acceleration support for use with stm32h5 (pr 7578) * adjusted wc_xmss and wc_lms settings to support use with wolfboot (pr 7393) * added the --enable-rpk option to autotools build for using raw public key support (pr 7379) * sha-3 thumb2, arm32 assembly implementation added (pr 7667) * improvements to rsa padding to expose pad/unpad apis (pr 7612) * updates and api additions for supporting socat version 1.8.0.0 (pr 7594) * cmake build improvements, expanding build options with single_threaded and post-quantum algorithms, adjusting the generation of options.h file and using “yes;no” boolean instead of strings (pr 7611, 7546, 7479, 7480, 7380) * improvements for renesas rz support (pr 7474) * improvements to dual algorithm certificates for post-quantum keys (pr 7286) * added wolfssl_sessionissetup so the user can check if a session ticket has been sent by the server (pr 7430) * hostap updates: implement pacs for eap-fast and filter cipher list on tls version change (pr 7446) * changed subject name comparison to match different upper and lower cases (pr 7420) * support for dtls 1.3 downgrade when using psk (pr 7367) * update to static memory build for more generic memory pools used (pr 7418) * improved performance of kyber c implementation (pr 7654) * support for ecc_cache_curve with no malloc (pr 7490) * added the configure option --enable-debug-trace-errcodes (macro wolfssl_debug_trace_error_codes) which enables more debug tracking of error code values (pr 7634) * enhanced wc_makersakey and wc_rsakeytoder to work with wolfssl_no_malloc (pr 7362) * improvements to assembly implementations of chacha20 and poly1305 asm for use with msvc (pr 7319) * cortex-m inline assembly labels with unique number appended (pr 7649) * added secret logging callback to tls <= 1.2, enabled with the macro have_secret_callback (pr 7372) * made wc_rng_drbg_reseed() a public wolfcrypt api (pr 7386) * enabled des3 support without the des3 ciphers. to re-enable des3 cipher suites, use the configure flag --enable-des3-tls-suites (pr 7315) * added stubs required for latest nginx (1.25.5) (pr 7449) * added option for using a custom salt with the function wc_ecc_ctx_set_own_salt (pr 7552) * added pq files for windows (pr 7419) * enhancements to static memory feature, adding the option for a global heap hint (pr 7478) and build options for a lean or debug setting, enabled with --enable-staticmemory=small or --enable-staticmemory=debug (pr 7597) * updated --enable-jni to define session_certs for wolfjsse (pr 7557) * exposed dtls in ada wrapper and updated examples (pr 7397) * added additional minimum tls extension size sanity checks (pr 7602) * esp improvements: updating the examples and libraries, updates for apple homekit sha/srp, and fix for endianness with sha512 software fallback (pr 7607, 7392, 7505, 7535) * made the wc_checkcertsigpubkey api publicly available with the define of the macro wolfssl_small_cert_verify (pr 7599) * added an alpha/preview of additional fips 140-3 full submission, bringing additional algorithms such as srtp-kdf, aes-xts, gcm streaming, aes-cfb, ed25519, and ed448 into the fips module boundary (pr 7295) * xcode support for v5.2.3 of the fips module (pr 7140) * expanded openssl compatibility layer and added ec_point_hex2point (pr 7191)  ## fixes * fixed kyber control-flow timing leak. thanks to antoon purnal from pqshield for the report * fixed the nxp mmcau hw acceleration for sha-256 (pr 7389) * fixed aes-cfb1 encrypt/decrypt on size (8*x-1) bits (pr 7431) * fixed use of %rip with sha-256 x64 assembly (pr 7409) * fixed ocsp response message build for dtls (pr 7671) * handled edge case in wc_ecc_mulmod() with zero (pr 7532) * fixed rpk (raw public key) to follow certificate use correctly (pr 7375) * added sanity check on record header with quic use (pr 7638) * added sanity check for empty directory strings in x.509 when parsing (pr 7669) * added sanity check on non-conforming serial number of 0 in certificates being parsed (pr 7625) * fixed wolfssl_ctx_set1_sigalgs_list() to make the tls connection conform to the selected sig hash algorithm (pr 7693) * various fixes for dual algorithm certificates including small stack use and support for certificate signing requests (pr 7577) * added sanity check for critical policy extension when wolfssl is built without policy extension support enabled (pr 7388) * added sanity check that the ed25519 signature is smaller than the order (pr 7513) * fixed segger emnet to handle non-blocking want read/want write (pr 7581)  for additional vulnerability information visit the vulnerability page at: https://www.wolfssl.com/docs/security-vulnerabilities/  see install file for build instructions. more info can be found on-line at: https://wolfssl.com/wolfssl/docs.html  # resources  [wolfssl website](https://www.wolfssl.com/)  [wolfssl wiki](https://github.com/wolfssl/wolfssl/wiki)  [fips 140-2/140-3 faq](https://wolfssl.com/license/fips)  [wolfssl documentation](https://wolfssl.com/wolfssl/docs.html)  [wolfssl manual](https://wolfssl.com/wolfssl/docs-wolfssl-manual-toc.html)  [wolfssl api reference](https://wolfssl.com/wolfssl/docs-wolfssl-manual-17-wolfssl-api-reference.html)  [wolfcrypt api reference](https://wolfssl.com/wolfssl/docs-wolfssl-manual-18-wolfcrypt-api-reference.html)  [tls 1.3](https://www.wolfssl.com/docs/tls13/)  [wolfssl vulnerabilities](https://www.wolfssl.com/docs/security-vulnerabilities/)  [additional wolfssl examples](https://github.com/wolfssl/wolfssl-examples)  # directory structure  ``` <wolfssl_root> ├── certs   [certificates used in tests and examples] ├── cmake   [cmake build utilities] ├── debian  [debian packaging files] ├── doc     [documentation for wolfssl (doxygen)] ├── docker  [prebuilt docker environments] ├── examples    [wolfssl examples] │   ├── asn1    [asn.1 printing example] │   ├── async   [asynchronous cryptography example] │   ├── benchmark   [tls benchmark example] │   ├── client  [client example] │   ├── configs [example build configurations] │   ├── echoclient  [echoclient example] │   ├── echoserver  [echoserver example] │   ├── pem [example for convert between pem and der] │   ├── sctp    [servers and clients that demonstrate wolfssl's dtls-sctp support] │   └── server  [server example] ├── ide     [contains example projects for various development environments] ├── linuxkm [linux kernel module implementation] ├── m4      [autotools utilities] ├── mcapi   [wolfssl mplab x project files] ├── mplabx  [wolfssl mplab x project files] ├── mqx     [wolfssl freescale codewarrior project files] ├── rpm     [rpm packaging metadata] ├── rtos │   └── nuttx   [port of wolfssl for nuttx] ├── scripts [testing scripts] ├── src     [wolfssl source code] ├── sslsniffer  [wolfssl sniffer can be used to passively sniff ssl traffic] ├── support [contains the pkg-config file] ├── tests   [unit and configuration testing] ├── testsuite   [test application that orchestrates tests] ├── tirtos  [port of wolfssl for ti rtos] ├── wolfcrypt   [the wolfcrypt component] │   ├── benchmark   [cryptography benchmarking application] │   ├── src         [wolfcrypt source code] │   │   └── port    [supported hardware acceleration ports] │   └── test        [cryptography testing application] ├── wolfssl [header files] │   ├── openssl [compatibility layer headers] │   └── wolfcrypt   [header files] ├── wrapper [wolfssl language wrappers] └── zephyr  [port of wolfssl for zephyr rtos] ``` ","neurocyte/flow-syntax":"Syntax highlighting module used by flow and zat # flow-syntax syntax highlighting module used by [flow](https://github.com/neurocyte/flow), [zat](https://github.com/neurocyte/zat) and [zine](https://github.com/kristoff-it/zine) ","Hejsil/zig-crc":"This repository has no description. 404: not found","allyourcodebase/AFLplusplus":"Zig build for AFL++ # aflplusplus  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## zig build for [aflplusplus](https://github.com/aflplusplus/aflplusplus).   ### :arrow_down: dependencies  requires a build of llvm. you can either get one from your favorite package manager, or [build it yourself](https://github.com/ziglang/zig/wiki/how-to-build-llvm,-libclang,-and-liblld-from-source).  ### :rocket: usage  ```sh git clone https://github.com/allyourcodebase/aflplusplus.git cd aflplusplus/ zig build ```  ### :100: easy source fuzzing with afl++  for help fuzzing your executables, see [kristoff-it/zig-afl-kit](https://github.com/kristoff-it/zig-afl-kit).  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/allyourcodebase/aflplusplus/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/allyourcodebase/aflplusplus/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/allyourcodebase/aflplusplus.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/allyourcodebase/aflplusplus/blob/main/license ","allyourcodebase/lz4":"lz4 ported to the zig build system [![ci](https://github.com/allyourcodebase/lz4/actions/workflows/ci.yaml/badge.svg)](https://github.com/allyourcodebase/lz4/actions)  # lz4  this is [lz4](https://github.com/lz4/lz4), packaged for [zig](https://ziglang.org/).  ## installation  first, update your `build.zig.zon`:  ``` # initialize a `zig build` project if you haven't already zig init zig fetch --save git+https://github.com/allyourcodebase/lz4.git#1.10.0-1 ```  you can then import `lz4` in your `build.zig` with:  ```zig const lz4_dependency = b.dependency('lz4', .{     .target = target,     .optimize = optimize, }); your_exe.linklibrary(lz4_dependency.artifact('lz4')); ``` ","allyourcodebase/lmdb":"Lmdb using the zig build system # lmdb [lmdb](https://github.com/lmdb/lmdb/tree/mdb.master/libraries/liblmdb) using the [zig](https://ziglang.org/) build system  ## usage  first, update your `build.zig.zon`:  ```elvish # initialize a `zig build` project if you haven't already zig init # support for `lmdb` starts with 0.9.31 and future releases zig fetch --save https://github.com/ultra-code/lmdb/archive/refs/tags/0.9.31.tar.gz ```  import `lmdb` dependency into build `build.zig` as follows:  ```zig     const lmdb_dep = b.dependency('lmdb', .{         .target = target,         .optimize = optimize,         .lto = true,     }); ```  using `lmdb` artifacts and module in your project ```zig     const exe = b.addexecutable(.{         .name = exe_name,         .root_source_file = b.path('src/main.zig'),         .target = target,         .optimize = optimize,         .strip = strip,     });     exe.want_lto = lto;      const liblmdb = lmdb_dep.artifact('lmdb');     const lmdb_module = lmdb_dep.module('lmdb');      exe.root_module.addimport('mdb', lmdb_module);     exe.linklibrary(liblmdb); ```  ## supported on linux, macos and windows - zig 0.14.0-dev - zig 0.13.0 ","aoemods/zig-essence":"Zig impl of Relic Entertainment's Essence formats # zig-essence  low-level minimal allocation implementation of relic's funky formats in zig with comments and clearly named variables.  sgas: headers should work for all versions of sgas, but more high-level code and complex operations are only tested on aoe4 sgas.   ## getting sgatool  you can grab a copy of `sgatool`, the actually executable portion of `zig-essence`, from the latest successful ci run, the latest release (soon), or by compiling the program yourself.  ### compiling  first, install [zig](https://ziglang.org/). then: ```bash git clone https://github.com/aoemods/zig-sga cd zig-sga zig build # output in ./zig-out/bin!  # or to run it right away (useful for developers) zig build sgatool -- [args] ```  ## using as a library  see `tools/sgatool.zig` and `build.zig` for an example of how `zig-essence` can be used as a library in zig!  ## prior art  credit where credit's due!  thanks janne for the [awesome blog post](https://janne252.dev/content/2021/coh3-pre-alpha-extract-sga) as well as the [sga viewer tooling](https://github.com/janne252/essence-archive-viewer) that inspired this effort. a dozen lines of documentation are based off of a table in janne's blog post. ╲<3  ## license  mit  all files in `dump` are also mit licensed and generated by other sga tools. please do not add any official game archives to `dump`! ","fivemoreminix/zig-gap-buffer":"A gap buffer implementation for Zig. # zig gap buffer  a gap buffer implementation for zig, designed to be idiomatic. the design of this code is styled after the standard library.    feel free to just copy the gap-buffer.zig source file to your project if you'd rather.    ## what is a gap buffer?  a [gap buffer](https://en.wikipedia.org/wiki/gap_buffer) is like a growable array, but the reserved space is in the middle of the data, separating two sides, as opposed to being fixed at the end. this data structure is efficient for inserting and deleting data in close proximity. gap buffers are commonly used in text editors as a simpler method than, say, [ropes](https://en.wikipedia.org/wiki/rope_(data_structure)).    on each side of the gap is a string. the gap of the gap buffer should be at the same location as the cursor in the text editor. when the cursor moves, the gap moves. moving the cursor causes no allocation because it is moving data from the right side of the gap to the left side. inserting text appends to the data on the left side, shrinking the gap. deleting text grows the gap. when data inserted exceeds the gap size, more space is allocated.    gap buffers are not efficient for large files. for more information, see [the gap buffer wikipedia article](https://en.wikipedia.org/wiki/gap_buffer).    ## examples    there are several examples of usage in the test section at the bottom of the `gap-buffer.zig` source file.    but basically, here's your getting started:    ```zig  const std = @import('std');  const gapbuffer = @import('gap-buffer').gapbuffer;    pub fn main() void {      // whatever allocator you wish to use ...      var arena = std.heap.arenaallocator.init(std.heap.page_allocator);      defer arena.deinit();        var gb = try gapbuffer.init(&arena.allocator, '');      // defer gb.deinit(); // arena frees data automatically        // insert some text into the currently empty buffer      try gb.insert('some text', .{ .line = 0, .col = 0 });        var text = try gb.toslice(&arena.allocator); // don't forget to free the string      std.debug.warn('{}╲n', .{text}); // 'some text'  }  ```  ","GoNZooo/zig-editor-core":"Eventually the core of an editor, interactive shell put on top. 404: not found","Cold-Bytes-Games/wwise-zig":"Zig bindings to Audiokinetic Wwise # wwise-zig - zig bindings to audiokinetic wwise (2022.1.13)  this package implement a native [zig](https://ziglang.org/) binding for [audiokinetic wwise](https://www.audiokinetic.com/en/products/wwise). the included c binding is designed only to be used by the zig binding. if you want to expand the c binding to be fully functional please submit any pull requests.  each function name, structs and enums has been renamed to fit the zig coding style. it should be easy to map to the [wwise sdk documentation](https://www.audiokinetic.com/en/library/edge/?source=sdk&id=index.html).  each major version of wwise is contained within a branch. select the correct branch and tag when importing the library with the zig package manager.  the library assumes that you installed wwise using the wwise launcher. we do not distribute any binary from audiokinetic.  this is a 3rd party binding and it is not affiliated with audiokinetic.  [![join our discord!](https://discordapp.com/api/guilds/1161009516771549374/widget.png?style=banner2)](https://discord.gg/jmxttncbys)  ## zig version  this library uses zig nominated [2024.3.0-mach](https://machengine.org/about/nominated-zig/). to install using [`zigup`](https://github.com/marler8997/zigup):  ```sh zigup 0.12.0-dev.3180+83e578a18 ```  ## versioning info  this binding mimic the versioning of wwise but add the zig binding version at the end.  example:  2022.1.9-zig0  * 2022 = year * 1 = major wwise version * 9 = minor wwise version * -zig0 = zig binding version  ## supported platforms  | platform | architecture                   |  tested | | --       | --                             | --      | | windows  | x86 (msvc abi only)            | ❌      | | windows  | x86-64 (msvc abi only)         | ✅      | | linux    | x86-64                         | ✅      | | linux    | aarch64                        | ❌      | | android  | arm64                          | ❌      | | android  | arm                            | ❌      | | android  | x86                            | ❌      | | android  | x86-64                         | ❌      | | mac      | universal (x86-64 and aarch64) | ❌      | | ios      |                                | ❌      | | tvos     |                                | ❌      |  - on windows, the default gnu abi is not supported, always use the msvc abi - on windows, we always use the latest supported visual studio (currently 2022) - on linux, the default i/o hooks are currently not supported (see #1) - uwp is gonna be deprecated so it is not supported - no support for consoles yet  ## import it in your project  1. add this repo in your `build.zig.zon` file, you'll need to add the hash and update the commit hash to the latest commit in the branch ```zig .@'wwise-zig' = .{     .url = 'https://github.com/cold-bytes-games/wwise-zig/archive/90cdc6877369b55af3ee2dfcf091dc547ed59f03.tar.gz',     .hash = '122053d2ec67ebe8a47b45ac32ddf41283b27c3519196b6730d9b826a463d1294299', }, ``` 2. import the dependency in your `build.zig`. see the usage section for the list of available options.  ```zig const std = @import('std'); const wwise_zig = @import('wwise-zig');  pub fn build(b: *std.build) !void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const wwise_dependency = b.dependency('wwise-zig', .{         .target = target,         .optimize = optimize,         .use_communication = true,         .use_default_job_worker = true,         .use_spatial_audio = true,         .use_static_crt = true,         .include_file_package_io_blocking = true,         .configuration = .profile,         .static_plugins = @as([]const []const u8, &.{             'aktonesource',             'akparametriceqfx',             'akdelayfx',             'akpeaklimiterfx',             'akroomverbfx',             'akstereodelayfx',             'aksynthonesource',             'akaudioinputsource',             'akvorbisdecoder',         }),     });      const exe = b.addexecutable(.{         .name = 'wwise-zig-demo',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });      exe.root_module.addimport('wwise-zig', wwise_dependency.module('wwise-zig')); } ```  ## usage  available options: | option | values | description | | -- | -- | -- | | `wwise_sdk` | `[]const u8` | override the path to the wwise sdk, by default it will use the path in environment variable wwisesdk | | `configuration` | debug, profile, release | which library configuration of wwise to use (default: profile) | | `use_static_crt` | `bool` | on windows, do you want to use the staticcrt build of wwise (default: true) | | `use_communication` | `bool` | enable remote communication with wwise authoring. disabled by default on release configuration so you can leave it true at all time (default: true) | | `use_default_job_worker` | `bool` | enable usage of the default job worker given by audiokinetic. (default: false) | | `use_spatial_audio` | `bool` | enable usagee of the spatial audio module (default: false) | | `string_stack_size` | `usize` | stack size to use for functions that accepts akoschar and null-terminated strings (default: 256) | | `include_default_io_hook_blocking` | `bool` | include the default io hook blocking (default: false) | | `include_default_io_hook_deferred` | `bool` | include the default io hook deferred (default: false) | | `include_file_package_io_blocking` | `bool` | include the file package io hook blocking (default: false) | | `include_file_package_io_deferred` | `bool` | include the file package io hook deferred (default: false) | | `static_plugins` | []const []const u8 | list of static plugins to link to (default: empty) |  we recommend using `ak` as your import name to match closely with the c++ api.  ```zig const ak = @import('wwise-zig');  pub fn main() !void {     var memory_settings: ak.akmemsettings = undefined;     ak.memorymgr.getdefaultsettings(&memory_settings);      try ak.memorymgr.init(&memory_settings);     defer ak.memorymgr.term(); } ```  you can also look at the integration demo ported to zig here for how the api is used in a sample application: https://github.com/cold-bytes-games/wwise-zig-demo  ### handling akoschar and c null-terminated strings  `wwise-zig` is trying to save allocations when calling functions that accepts strings by using stack-allocated space to convert to `const akoschar*`/`const char*` or use a fallback allocator if the string is bigger than the stack size.  you can customize the size allocated by modifying the `string_stack_size` when importing the dependency.  each function that handle strings looks similar to this:  ```zig pub fn dumptofile(fallback_allocator: std.mem.allocator, filename: []const u8) !void {     var stack_char_allocator = common.stackcharallocator(fallback_allocator);     var allocator = stack_char_allocator.get();      const filename_oschar = try common.tooschar(allocator, filename);     defer allocator.free(filename_oschar);      c.wwisec_ak_memorymgr_dumptofile(filename_oschar); } ```  ### handling c++ inheritance  you can create derivated zig struct from wwise c++ clases that have virtual methods. each binded class has a `functiontable` object like `iakiohookdeferredbatch` here:  ```zig pub const iakiohookdeferredbatch = opaque {     pub const functiontable = extern struct {         destructor: *const fn (self: *iakiohookblocking) callconv(.c) void,         close: *const fn (self: *iakiohookblocking, in_file_desc: *akfiledesc) callconv(.c) common.akresult,         get_block_size: *const fn (self: *iakiohookblocking, in_file_desc: *akfiledesc) callconv(.c) u32,         get_device_desc: *const fn (self: *iakiohookblocking, out_device_desc: *stream_interfaces.nativeakdevicedesc) callconv(.c) void,         get_device_data: *const fn (self: *iakiohookblocking) callconv(.c) u32,         batch_read: *const fn (             self: *iakiohookdeferredbatch,             in_num_transfers: u32,             in_transfer_items: [*]batchiotransferitem,             in_batch_io_callback: akbatchiocallback,             io_dispatch_results: [*]common.akresult,         ) callconv(.c) common.akresult,         batch_write: *const fn (             self: *iakiohookdeferredbatch,             in_num_transfers: u32,             in_transfer_items: [*]batchiotransferitem,             in_batch_io_callback: akbatchiocallback,             io_dispatch_results: [*]common.akresult,         ) callconv(.c) common.akresult,         batch_cancel: *const fn (             self: *iakiohookdeferredbatch,             in_num_transfers: u32,             in_transfer_items: [*]batchiotransferitem,             io_cancel_all_transfers_for_this_file: [*]*bool,         ) callconv(.c) void,     }; } ``` on the glue side, we inherit from the interface and call those functions with the instance of your zig struct.  each class has a method `createinstance()` and `destroyinstance` that are used to create an instance of your own derivated struct. it uses ak memory manager function to allocate the instance with the `akmemid_integration` memory tag.  ```zig var zig_io_blocking = zigtestiakohookblocking{}; var native_io_blocking = ak.streammgr.iakiohookblocking.createinstance(             &zig_io_blocking,             &ak.streammgr.iakiohookblocking.functiontable{                 .destructor = @ptrcast(&zigtestiakohookblocking.destructor),                 .close = @ptrcast(&zigtestiakohookblocking.close),                 .get_block_size = @ptrcast(&zigtestiakohookblocking.getblocksize),                 .get_device_desc = @ptrcast(&zigtestiakohookblocking.getdevicedesc),                 .get_device_data = @ptrcast(&zigtestiakohookblocking.getdevicedata),                 .read = @ptrcast(&read),                 .write = @ptrcast(&write),             },         ); defer ak.streammgr.iakiohookblocking.destroyinstance(native_io_blocking); ```  however we recommend creating a helper function in your struct to create the correct instance with the function table properly filled.  here's a quick sample of a derivated `iakohookblocking` struct from our test suite: ```zig const zigtestiakohookblocking = struct {     destructor_called: bool = false,     close_called: bool = false,     get_block_size_called: bool = false,     get_device_desc_called: bool = false,     get_device_data_called: bool = false,     read_called: bool = false,     write_called: bool = false,     close_size: i64 = 0,      pub fn destructor(self: *zigtestiakohookblocking) callconv(.c) void {         self.destructor_called = true;     }      pub fn close(self: *zigtestiakohookblocking, in_file_desc: *ak.streammgr.akfiledesc) callconv(.c) ak.akresult {         self.close_size = in_file_desc.file_size;         self.close_called = true;          return .success;     }      pub fn getblocksize(self: *zigtestiakohookblocking, in_file_desc: *ak.streammgr.akfiledesc) callconv(.c) u32 {         _ = in_file_desc;         self.get_block_size_called = true;         return 512;     }      pub fn getdevicedesc(self: *zigtestiakohookblocking, out_device_desc: *ak.nativeakdevicedesc) callconv(.c) void {         self.get_device_desc_called = true;          var zig_device_desc = ak.akdevicedesc{};         zig_device_desc.can_write = false;         zig_device_desc.can_read = true;         zig_device_desc.device_name = 'wwise-zig io';          out_device_desc.* = zig_device_desc.toc() catch unreachable;     }      pub fn getdevicedata(self: *zigtestiakohookblocking) callconv(.c) u32 {         self.get_device_data_called = true;         return 4269;     }      pub fn read(self: *zigtestiakohookblocking, in_file_desc: *ak.streammgr.akfiledesc, in_heuristics: *ak.streammgr.akioheuristics, out_buffer: ?*anyopaque, in_transfer_info: *ak.streammgr.akiotransferinfo) callconv(.c) ak.akresult {         _ = in_file_desc;         _ = in_heuristics;          self.read_called = true;          if (out_buffer) |checked_buffer| {             var read_buffer = @as([*]u8, @ptrcast(checked_buffer));             @memset(read_buffer[in_transfer_info.file_position..in_transfer_info.requested_size], 0xc1);         }          return .success;     }      pub fn write(self: *zigtestiakohookblocking, in_file_desc: *ak.streammgr.akfiledesc, in_heuristics: *ak.streammgr.akioheuristics, in_data: ?*anyopaque, in_transfer_info: *ak.streammgr.akiotransferinfo) callconv(.c) ak.akresult {         _ = in_heuristics;         _ = in_transfer_info;         _ = in_data;         _ = in_file_desc;          self.write_called = true;          return .success;     }      pub fn createiakiohookblocking(self: *zigtestiakohookblocking) *ak.streammgr.iakiohookblocking {         return ak.streammgr.iakiohookblocking.createinstance(             self,             &ak.streammgr.iakiohookblocking.functiontable{                 .destructor = @ptrcast(&destructor),                 .close = @ptrcast(&close),                 .get_block_size = @ptrcast(&getblocksize),                 .get_device_desc = @ptrcast(&getdevicedesc),                 .get_device_data = @ptrcast(&getdevicedata),                 .read = @ptrcast(&read),                 .write = @ptrcast(&write),             },         );     } }; ```  ### use the default i/o hook(s) from the sdk  first you need to include at least one i/o hook in the build options.  all the default i/o are included in the iohooks namespace from the `wwise-zig` package.  use the `create` and `destroy` function with a zig allocator to create a instance of the i/o hook.  after that, you need to call `init` and `setbasepath` like in c++  ```zig const std = @import('std'); const ak = @import('wwise-zig');  pub fn main() !void {     var io_hook = try ak.iohooks.cakfilepackagelowleveliodeferred.create(std.testing.allocator);     defer io_hook.destroy(std.testing.allocator);      try io_hook.init(device_settings, false);     defer io_hook.term();      try io_hook.setbasepath(std.testing.allocator, '.');      const loaded_package_id = try io_hook.loadfilepackage(std.testing.allocator, 'mywwisedata.pck'); } ```  ### generate the sound banks with the zig build system  we are bundling a build step to generate the sound banks. to use it: 1. include the wwise-zig dependency in youtr `build.zig.zon` file. 1. import the wwise-zig module in your `build.zig`. 1. call `addgeneratesooundbanksstep()` and pass the `std.build` instance and some optioons. 1. after that, it is recommended that you add the generate sound banks steps as a dependency of your compile step.  options available: | option | values | description | | -- | -- | -- | | `override_wwise_sdk_path` | `[]const u8` | override the path of the wwise sdk, if not it will use the wwisesdk environment variable | | `platforms` | ` []const wwiseplatform` | explicit list the platforms you want to generate the sound banks, if nothing specified, all the platforms will be generated | | `languages` | `[]const []const u8` | explicit list of the languages to generate, if not specified it will build all the languages | | `target` | `std.zig.crosstarget` | instead of passing the platforms, you can use the target from zig | | `output_folder` | `[]const u8` | output folder of the sound banks, will use the default in the project if omitted | | `sound_banks` | `[]const []const u8` | list of sound banks to generate, if not specified it will build all the sound banks | | `root_output_path` | `[]const u8` | overrides the root output path specified in the soundbank settings|  example: ```zig const std = @import('std'); const wwise_zig = @import('wwise-zig');  pub fn build(b: *std.build) !void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const build_soundbanks_step = try wwise_zig.addgeneratesoundbanksstep(b, 'wwiseproject/integrationdemo.wproj', .{         .target = target,     });       const exe = b.addexecutable(.{         .name = 'wwise-zig-demo',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     exe.step.dependon(&build_soundbanks_step.step);      // [...] } ```  ### generate a zig module with wwise id  if specified in the wwise project settings, you can generate a c header file that contains all the unique id of your events, soundbanks, states, switch, game parameters. we include a way to parse that header file and generate a zig module on the fly.  you need to pass the main `wwise-zig` module to the function because we use `akuniqueid` from the main module.  it is recommended that you add a dependency to the generated sound banks step if you use it in your `build.zig` file.  ```zig const std = @import('std'); const wwise_zig = @import('wwise-zig');  pub fn build(b: *std.build) !void {     // [...]      const wwise_id_module = wwise_zig.generatewwiseidmodule(b, 'wwiseproject/generatedsoundbanks/wwise_ids.h', wwise_package.module, .{         .previous_step = &build_soundbanks_step.step,     });      exe.addmodule('wwise-ids', wwise_id_module); ```  ## license  see license for more info.","ttytm/dmon-zig":"Cross-platform Zig module to monitor changes in directories. # dmon-zig  [badge__build-status]: https://img.shields.io/github/actions/workflow/status/ttytm/dmon-zig/ci.yml?branch=main&logo=github&logocolor=c0caf5&labelcolor=333 [badge__version-lib]: https://img.shields.io/github/v/tag/ttytm/dmon-zig?logo=task&logocolor=c0caf5&labelcolor=333&color= [badge__version-zig]: https://img.shields.io/badge/zig-0.13.0-cc742f?logo=zig&logocolor=c0caf5&labelcolor=333  [![][badge__build-status]](https://github.com/ttytm/dmon-zig/actions?query=branch%3amain) [![][badge__version-lib]](https://github.com/ttytm/dmon-zig/releases/latest) ![][badge__version-zig]  cross-platform zig module to monitor changes in directories. it utilizes the [dmon](https://github.com/septag/dmon?tab=readme-ov-file) c99 library.  ## installation  ```sh # ~/<projectspath>/your-awesome-projct zig fetch --save https://github.com/ttytm/dmon-zig/archive/main.tar.gz ```  ```zig // your-awesome-projct/build.zig const std = @import('std');  pub fn build(b: *std.build) void {   // ..   const dmon_dep = b.dependency('dmon', .{});   const exe = b.addexecutable(.{     .name = 'your-awesome-projct',     // ..   });   exe.root_module.addimport('dmon', dmon_dep.module('dmon'));   // ... } ```  ## usage example  ```v const std = @import('std'); const dmon = @import('dmon'); const print = std.debug.print;  const context = struct {   trigger_count: u32 = 0, };  pub fn watchcb(   comptime ctx: type,   _: dmon.watchid,   action: dmon.action,   root_dir: [*:0]const u8,   file_path: [*:0]const u8,   old_file_path: ?[*:0]const u8,   context: *ctx, ) void {   print('action: {}╲n', .{action});   print('root: {s}╲n', .{root_dir});   print('file path: {s}╲n', .{file_path});   print('old file path: {s}╲n', .{old_file_path orelse ''});   context.trigger_count += 1; }  pub fn main() !void {   dmon.init();   defer dmon.deinit();    const watch_path = '/home/user/documents';   const id = dmon.watch(context, watch_path, watchcb, .{ .recursive = true }, &ctx);   print('starting to watch: {s}; watcher id: {d}╲n', .{ watch_path, id });    while (true) {     if (ctx.trigger_count >= 3) break;   } } ```  for a simple local example watching the cwd: [`dmon-zig/examples/src/main.zig`](https://github.com/ttytm/dmon-zig/blob/main/examples/src/main.zig)  ```sh # perform a lightweight, filtered, yet complete clone git clone --recursive --shallow-submodules --filter=blob:none ╲   https://github.com/ttytm/dmon-zig && ╲ cd dmon-zig/examples ```  ```sh # dmon-zig/examples zig build run ``` ","alexnask/lepto.zig":"Date and time library for zig, inspired by C++20 std::chrono 404: not found","nektro/zig-zstd":"This repository has no description. # zig-zstd zstd wrapper for zig.  https://github.com/facebook/zstd  zstd version: 1.5.0  ## license mit ","mattnite/tar":"tar library that has a bad interface ngl # tar tar library that has a bad interface ngl ","allyourcodebase/nativefiledialog-extended":"nativefiledialog-extended ported to the zig build system [![ci](https://github.com/allyourcodebase/nativefiledialog-extended/actions/workflows/ci.yaml/badge.svg)](https://github.com/allyourcodebase/nativefiledialog-extended/actions)  # nativefiledialog-extended  this is [nativefiledialog-extended](https://github.com/btzy/nativefiledialog-extended), packaged for [zig](https://ziglang.org/).  ## installation  first, update your `build.zig.zon`:  ``` # initialize a `zig build` project if you haven't already zig init zig fetch --save git+https://github.com/allyourcodebase/nativefiledialog-extended.git#1.2.1 ```  you can then import `nativefiledialog-extended` in your `build.zig` with:  ```zig const nfd_dependency = b.dependency('nativefiledialog-extended', .{     .target = target,     .optimize = optimize, }); your_exe.linklibrary(nfd_dependency.artifact('nfd')); ```  ## dependencies  see https://github.com/btzy/nativefiledialog-extended/tree/v1.2.1#dependencies ","softprops/zig-jwt":"A JWT library for zig <h1 align='center'>     zig jwt </h1>  <div align='center'>     a <a href='https://jwt.io/'>jwt</a> library for zig </div>  ---  [![main](https://github.com/softprops/zig-jwt/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/zig-jwt/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/zig-jwt) ![release](https://img.shields.io/github/v/release/softprops/zig-jwt) [![zig support](https://img.shields.io/badge/zig-0.13.0-black?logo=zig)](https://ziglang.org/documentation/0.13.0/)  ## 📼 installing  create a new exec project with `zig init`. copy an example from the examples directory into your into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/softprops/zig-jwt/archive/refs/tags/v0.1.0.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +       // 👇 declare dep properties +        .jwt = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-jwt/archive/refs/tags/v0.1.0.tar.gz', +            // 👇 hash verification +            .hash = '...', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-jwt/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-jwt/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference dep from build.zig.zon +    const jwt = b.dependency('jwt', .{ +        .target = target, +        .optimize = optimize, +    }).module('jwt');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the module to executable +    exe.root_mode.addimport('jwt', jwt);      b.installartifact(exe); } ```  ## examples  see examples directory  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)   ╲- softprops 2024 ","softprops/zig-termsize":"terminal size matters <h1 align='center'>     termsize </h1>  <div align='center'>     terminal size matters </div>  ---  [![ci](https://github.com/softprops/zig-termsize/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/zig-termsize/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/zig-termsize) ![release](https://img.shields.io/github/v/release/softprops/zig-termsize) [![zig support](https://img.shields.io/badge/zig-0.12.0-black?logo=zig)](https://ziglang.org/documentation/0.12.0/)  ## 🍬 features  termsize is a zig library providing a multi-platform interface for resolving your terminal's current size in rows and columns. on most unix systems, this is similar invoking the stty(1) program, requesting the terminal size.  ## examples  ```zig const std = @import('std'); const termsize = @import('termsize');  pub fn main() !void {     std.debug.print(         '{any}',         .{termsize.termsize(std.io.getstdout())},     ); } ```  ## 📼 installing  create a new exec project with `zig init-exe`. copy the echo handler example above into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/softprops/zig-termsize/archive/refs/tags/v0.1.0.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +        // 👇 declare dep properties +        .termsize = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-termsize/archive/refs/tags/v0.1.0.tar.gz', +            // 👇 hash verification +            .hash = '{current-hash}', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-termsize/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-termsize/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{}); +    // 👇 de-reference termsize dep from build.zig.zon +    const termsize = b.dependency('termsize', .{ +        .target = target, +        .optimize = optimize, +    }).module('termsize');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     }); +    // 👇 add the termsize module to executable +    exe.root_module.addimport('termsize', termsize);      b.installartifact(exe); } ```  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.11.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)  ╲- softprops 2024 ","hasanpasha/zmpv":"libmpv bindings in zig # zmpv  `libmpv` bindings in zig.  ## usage  - first fetch the package into your project:    ```bash   zig fetch --save https://github.com/hasanpasha/zmpv/archive/${desired_commot_hash}.tar.gz    ``` - import the package in your `build.zig` file:    ```zig   const zmpv_dep = b.dependency('zmpv', .{ .target = target, .optimize = optimize });   exe.root_module.addimport('zmpv', zmpv_dep.module('zmpv'));   exe.linksystemlibrary('mpv'); # in linux   exe.linklibc();   ```  ## example  ```zig const std = @import('std'); const zmpv = @import('zmpv'); const mpv = zmpv.mpv;  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{ .verbose_log = true }){};     defer {         if (gpa.deinit() == .leak) @panic('detected memory leak');     }     const allocator = gpa.allocator();      const args = try std.process.argsalloc(allocator);     defer std.process.argsfree(allocator, args);     if (args.len < 2) {         std.debug.print('usage: {s} [filename]╲n', .{args[0]});         return;     }      const filename = args[1];      const mpv = try mpv.create(allocator);      try mpv.set_option('osc',.{ .flag = true });     try mpv.set_option('input-default-bindings',.{ .flag = true });     try mpv.set_option('input-vo-keyboard',.{ .flag = true });      try mpv.initialize();     defer mpv.terminate_destroy();      try mpv.command_async(0, &.{ 'loadfile', filename });      try mpv.request_log_messages(.error);      try mpv.observe_property(1, 'fullscreen', .flag);     try mpv.observe_property(2, 'time-pos', .int64);      try mpv.set_property('fullscreen', .{ .flag = true });      while (true) {         const event = mpv.wait_event(-1);         const event_id = event.event_id;         switch (event_id) {             .shutdown, .endfile => break,             .logmessage => {                 const log = event.data.logmessage;                 std.log.debug('[{s}] ╲'{s}╲'', .{ log.prefix, log.text });             },             .propertychange, .getpropertyreply => {                 const property = event.data.propertychange;                  if (std.mem.eql(u8, property.name, 'fullscreen')) {                     std.log.debug('[fullscreen] {}', .{property.data.flag});                 } else if (std.mem.eql(u8, property.name, 'time-pos')) {                     switch (property.data) {                         .int64 => |time_pos| {                             std.log.debug('[time-pos] {}', .{time_pos});                         },                         else => {},                     }                 }             },             else => {},         }     } } ``` ","allyourcodebase/boost-libraries-zig":"Boost Libraries using build.zig # boost libraries using zig build-system  [boost libraries](https://boost.io) using `build.zig`.  replacing the [cmake](https://cmake.org/) and [b2](https://www.bfgroup.xyz/b2/) build system.   > [!important] > for c++ projects, `zig c++` uses llvm-libunwind + llvm-libc++ (static-linking) by default. > except, for msvc target (`-nostdlib++`).   ### requirements  - [zig](https://ziglang.org/download) v0.13.0 or master  ## how to use  build libraries  ```bash # build no-header-only libraries $ zig build -doptimize=<debug|releasesafe|releasefast|releasesmall> ╲     -dtarget=<triple-target> ╲     --summary <all|new> ╲     -dcontext ╲     -djson ╲     -dsystem ╲     -dcontainer ╲     -dcobalt ╲     -dfilesystem ```  #### helper  ```bash project-specific options:   -dtarget=[string]            the cpu architecture, os, and abi to build for   -dcpu=[string]               target cpu features to add or subtract   -ddynamic-linker=[string]    path to interpreter on the target system   -doptimize=[enum]            prioritize performance, safety, or binary size                                  supported values:                                    debug                                    releasesafe                                    releasefast                                    releasesmall   -datomic=[bool]              build boost.atomic library (default: false)   -dcharconv=[bool]            build boost.charconv library (default: false)   -dcobalt=[bool]              build boost.cobalt library (default: false)   -dcontainer=[bool]           build boost.container library (default: false)   -dcontext=[bool]             build boost.context library (default: false)   -dexception=[bool]           build boost.exception library (default: false)   -dfiber=[bool]               build boost.fiber library (default: false)   -dfilesystem=[bool]          build boost.filesystem library (default: false)   -diostreams=[bool]           build boost.iostreams library (default: false)   -djson=[bool]                build boost.json library (default: false)   -dlog=[bool]                 build boost.log library (default: false)   -dnowide=[bool]              build boost.nowide library (default: false)   -dprocess=[bool]             build boost.process library (default: false)   -dpython=[bool]              build boost.python library (default: false)   -drandom=[bool]              build boost.random library (default: false)   -dregex=[bool]               build boost.regex library (default: false)   -dserialization=[bool]       build boost.serialization library (default: false)   -dstacktrace=[bool]          build boost.stacktrace library (default: false)   -dsystem=[bool]              build boost.system library (default: false)   -durl=[bool]                 build boost.url library (default: false)   -dwave=[bool]                build boost.wave library (default: false)   -dshared=[bool]              build as shared library (default: false) ```   ### or use in new zig project  make directory and init  ```bash $ zig init ## add in 'build.zig.zon' boost-libraries-zig package $ zig fetch --save=boost git+https://github.com/allyourcodebase/boost-libraries-zig ``` add in **build.zig** ```zig const std = @import('std'); pub fn build(b: *std.build) !void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const boost_dep = b.dependency('boost', .{         .target = target,         .optimize = optimize,     });     const boost_artifact = boost_dep.artifact('boost');      for(boost_artifact.root_module.include_dirs.items) |include_dir| {         try exe.root_module.include_dirs.append(b.allocator, include_dir);     }     // if not header-only, link library     exe.linklibrary(boost_artifact); } ```  ## license  see: [license](license)","griush/zig-opengl-example":"Minimal example using GFLW/OpenGL/zm made in Zig # triangle example simple opengl example in zig using `zm`, `zig-glfw`, `zigglgen`.  ## usage run in the root `zig build run`. ","allyourcodebase/valgrind.h":"provides valgrind/valgrind.h # valgrind.h  this is a minimal source repository that provides:  ```c #include <valgrind/valgrind.h> ```  ## process  although this file is technically autogenerated in the upstream repository, the only thing that is populated during this configuration is the version numbers.  so in this package we simply hard-code those version numbers. ","jaxron/zigache":"A customizable cache library in Zig with multiple eviction policies. <h1 align='center'>     <picture>       <img width='300' alt='zigache' src='./assets/images/zigache_logo.png'>     </picture>   <br>   <a href='https://github.com/jaxron/zigache/blob/main/license.md'>     <img src='https://img.shields.io/github/license/jaxron/zigache?style=flat-square&color=f27523'>   </a>   <a href='https://github.com/jaxron/zigache/actions/workflows/ci.yml'>     <img src='https://img.shields.io/github/actions/workflow/status/jaxron/zigache/ci.yml?style=flat-square&color=f27523'>   </a>   <a href='https://jaxron.me/zigache/'>     <img src='https://img.shields.io/badge/zigache-docs-00acd7.svg?style=flat-square&color=f27523'>   </a>   <a href='https://github.com/jaxron/zigache/issues'>     <img src='https://img.shields.io/github/issues/jaxron/zigache?style=flat-square&color=f27523'>   </a> </h1>  <p align='center'>   <em><b>zigache</b> is an efficient caching library built in <a href='https://ziglang.org/'>zig</a>, offering customizable cache eviction policies for various application needs.</em> </p>  ---  > [!important] > zigache is currently in **early development** and follows zig's latest build in the master branch.  # 📚 table of contents  - [🚀 features](#-features) - [⚡️ quickstart](#%ef%b8%8f-quickstart) - [👀 examples](#-examples) - [⚙️ configuration](#%ef%b8%8f-configuration) - [📊 benchmarks](#-benchmarks) - [🗺️ roadmap](#%ef%b8%8f-roadmap) - [📄 license](#-license) - [❓ faq](#-faq)  # 🚀 features  zigache offers a rich set of features to designed to meet various caching needs:  - **multiple eviction algorithms:**   - w-tinylfu | [tinylfu: a highly efficient cache admission policy](https://arxiv.org/abs/1512.00727)   - s3-fifo | [fifo queues are all you need for cache eviction](https://dl.acm.org/doi/10.1145/3600006.3613147)   - sieve | [sieve is simpler than lru: an efficient turn-key eviction algorithm for web caches](https://www.usenix.org/conference/nsdi24/presentation/zhang-yazhuo)   - lru | least recently used   - fifo | first-in-first-out - **extensive configuration options:**   - configurable cache size with pre-allocation for performance tuning   - ability to fine-tune cache policies (e.g., tinylfu, s3fifo)   - time-to-live (ttl) support to expire cache entries   - thread safety and sharding settings for concurrent environments   - adjustable max load factor for the cache - **heavy testing and benchmarking** for [stability and performance](#-benchmarks) under various workloads  # ⚡️ quickstart  to use zigache in your project, follow these steps:  1. run this command in your project's root directory:      ```sh     zig fetch --save git+https://github.com/jaxron/zigache.git     ```  2. in your `build.zig`, add:      ```diff     pub fn build(b: *std.build) void {         // options         const target = b.standardtargetoptions(.{});         const optimize = b.standardoptimizeoption(.{});          // build     +   const zigache = b.dependency('zigache', .{     +       .target = target,     +       .optimize = optimize,     +   }).module('zigache');              const exe = b.addexecutable(.{             .name = 'your-project',             .root_source_file = b.path('src/main.zig'),             .target = target,             .optimize = optimize,         });     +   exe.root_module.addimport('zigache', zigache);           b.installartifact(exe);              const run_cmd = b.addrunartifact(exe);         run_cmd.step.dependon(b.getinstallstep());              const run_step = b.step('run', 'run the program');         run_step.dependon(&run_cmd.step);     }     ```  3. now you can import and use zigache in your code like this:      ```zig     const std = @import('std');     const cache = @import('zigache').cache;          pub fn main() !void {         var gpa: std.heap.generalpurposeallocator(.{}) = .init;         defer _ = gpa.deinit();         const allocator = gpa.allocator();              // create a cache with string keys and values         var cache: cache([]const u8, []const u8, .{}) = try .init(allocator, .{             .cache_size = 1,             .policy = .sieve,         });         defer cache.deinit();              // your code...     }     ```  # 👀 examples  explore the usage scenarios in our examples directory:  - [01 | key types](examples/01_key_types.zig) - [02 | ttl entries](examples/02_ttl_entries.zig)  to run an example:  ```sh zig build [example-id] zig build 01 ```  # ⚙️ configuration  zigache offers flexible configuration options to adjust the cache to your needs:  ```zig var cache: cache([]const u8, []const u8, .{     .thread_safety = true,     // enable thread safety for multi-threaded environments     .ttl_enabled = true,       // enable time-to-live (ttl) functionality     .max_load_percentage = 60, // set maximum load factor for the cache (60% occupancy) }) = try .init(allocator, .{     .cache_size = 10000,       // maximum number of items the cache can store     .pool_size = 1000,         // pre-allocated nodes to optimize performance     .shard_count = 16,         // number of shards for concurrent access handling     .policy = .sieve,          // eviction policy in use }); ```  > for more detailed information, refer to the [full documentation](https://jaxron.me/zigache/).  # 📊 benchmarks  this benchmark uses a [zipfian distribution](https://en.wikipedia.org/wiki/zipf%27s_law), run on an intel® core™ i7-8700 cpu, using commit `7a12b1f` of this library.  > [!note] > these results are not conclusive, as performance depends on workload and environment. these benchmarks are comparing eviction policies within this library, and not comparisons with other languages or libraries. you can customize the benchmarks using various flags. for details, run `zig build -h`.  <details> <summary>single threaded (zipf 0.9, 10m keys)</summary>  ## benchmark parameters  ```sh zig build bench -doptimize=releasefast ```  or  ```sh zig build bench -doptimize=releasefast -dreplay=true -dshards=1 -dthreads=1 -dauto='20:50000' -dzipf='0.9' -dkeys=10000000 -dduration=10000 ```  ## results  ### hit rate (%)  <picture>   <img alt='zigache' src='./assets/images/benchmarks/1/hit_rate.png'> </picture>  ### average operation time (ns/op)  <picture>   <img alt='zigache' src='./assets/images/benchmarks/1/ns_op.png'> </picture>  ### operations per second (ops/s)  <picture>   <img alt='zigache' src='./assets/images/benchmarks/1/ops_s.png'> </picture>  </details>  <details> <summary>single threaded (zipf 0.7, 10m keys)</summary>  ## benchmark parameters  ```sh zig build bench -doptimize=releasefast -dzipf='0.7' ```  or  ```sh zig build bench -doptimize=releasefast -dreplay=true -dshards=1 -dthreads=1 -dauto='20:50000' -dzipf='0.7' -dkeys=10000000 -dduration=10000 ```  ## results  ### hit rate (%)  <picture>   <img alt='zigache' src='./assets/images/benchmarks/2/hit_rate.png'> </picture>  ### average operation time (ns/op)  <picture>   <img alt='zigache' src='./assets/images/benchmarks/2/ns_op.png'> </picture>  ### operations per second (ops/s)  <picture>   <img alt='zigache' src='./assets/images/benchmarks/2/ops_s.png'> </picture>  </details>  # 🗺️ roadmap  zigache is in its early stages. our main priority is on implementing features, with performance improvements as a secondary priority. here are some things we have planned for the future:  - [ ] 🧪 improved benchmarking suite - [ ] ⚙️ runtime-configurable api - [ ] 📦 batch operations support - [ ] 📊 metrics and monitoring - [x] 🔄 configuration to adjust eviction policies - [ ] 🔓 lock-free data structures - [ ] 📚 more extensive examples - [ ] ⚡️ async (non-blocking) i/o operations  > 💡 **we value your input!** have suggestions for our roadmap? feel free to open an issue or start a discussion.  # 📄 license  this project is licensed under the mit license. see the [license.md](license.md) file for details.  # ❓ faq  <details>   <summary><b>is zigache production-ready?</b></summary>   <p>zigache is currently in early development. although it has been tested and benchmarked, it may not yet be suitable for all production environments. if you decide to use it in a production setting, please report any problems you encounter.</p> </details>  <details>   <summary><b>which eviction policy should i choose?</b></summary>   <p>it depends on your use case:     <ul>       <li><b>sieve</b>: best for high throughput and high hit rate. (recommended)</li>       <li><b>tinylfu</b>: best for customizability and high hit rate.</li>       <li><b>s3fifo</b>: decent throughput with a decent hit rate.</li>       <li><b>lru</b>: reliable for standard needs but falls behind compared to other options.</li>       <li><b>fifo</b>: high throughput, but lowest hit rates.</li>     </ul>   </p> </details>  <details>   <summary><b>can i use zigache in a multi-threaded environment?</b></summary>   <p>yes, zigache supports thread-safe operations and sharding. sharding reduces contention and there are plans to improve performance further in the future.</p> </details>  <details>   <summary><b>what type of keys does zigache support?</b></summary>   <p>zigache supports most key types like strings, integers, structs, arrays, pointers, enums, and optionals. however, floats are not supported due to precision issues.</p> </details>  <details>   <summary><b>how can i contribute to zigache?</b></summary>   <p>we welcome contributions! please follow the <a href='https://ziglang.org/documentation/master/#style-guide'>zig style guide</a> and ensure that your changes include appropriate tests.</p> </details> ","travisstaloch/static-map":"A generic hashmap backed by static memory # staticmap  a generic hashmap in zig similar to std.arrayhashmap().  # use ```console zig fetch --save git+https://github.com/travisstaloch/static-map ``` ```zig // build.zig: const static_map = b.dependency('static-map', .{}); exe.root_module.addimport('static-map', static_map.module('static-map')); ``` ```zig // main.zig test 'usage' {     // const static_map = @import('static-map');     // init()     const map = static_map.staticstringmap(u8, 16);     var map = map.init();     // put()/get()/contains()     try map.put('abc', 1);     try testing.expect(map.contains('abc'));     try testing.expectequal(1, map.get('abc'));     // getorput()     const gop = map.getorput('abc');     try testing.expectequal(.existing, gop.status);     gop.value_ptr.* = 2;     try testing.expectequal(2, map.get('abc'));     // putassumecapacity()     map.putassumecapacity('def', 3);     try testing.expectequal(3, map.get('def'));     // putnoclobber()     map.putnoclobber('ghi', 4);     try testing.expectequal(4, map.get('ghi'));     // getptr()     map.getptr('def').?.* = 5;     try testing.expectequal(5, map.get('def'));     // count()     try testing.expectequal(3, map.count());     // iterator()     var iter = map.iterator();     var count: u8 = 0;     while (iter.next()) |kv| : (count += 1) {         try std.io.null_writer.print('{s}: {}', .{ kv.key, kv.value });     }     try testing.expectequal(map.count(), count); } ```  # tests  [src/tests.zig](src/tests.zig)  ```console zig build test ```  # bench  this is a plot of data generated by [src/bench.zig](src/bench.zig).  you can generate some data by running [./bench.sh](./bench.sh)  ### releasefast ![screenshot-4](https://github.com/user-attachments/assets/2bc4b4ca-571f-4145-873a-8bf19f5c42c7)  ### debug ![screenshot-2](https://github.com/user-attachments/assets/983c04d8-fd2a-4755-ad69-a8d94de3f28f)  # prior art  https://github.com/vexu/comptime_hash_map  ","leecannon/zig-pc_keyboard":"PS/2 Keyboard Decoder # zig-pc_keyboard  a zig reimplementation of the [pc-keyboard](https://github.com/rust-embedded-community/pc-keyboard) rust crate  ## how to get  ### gyro  `gyro add leecannon/pc_keyboard`  ### zigmod  `zigmod aq add 1/leecannon/pc_keyboard`  ### git  #### submodule  `git submodule add https://github.com/leecannon/zig-pc_keyboard zig-pc_keyboard`  #### clone  `git clone https://github.com/leecannon/zig-pc_keyboard` ","nektro/zig-iso-639-languages":"Zig package for ISO 639 Language codes # zig-iso-639-languages  iso 639 language codes  https://www.iso.org/iso-639-language-codes.html  ## license  0bsd ","dantecatalfamo/9p-zig":"9P2000 protocol implemented in zig # 9p-zig 9p2000 protocol client/server implemented in zig  # files * `src/main.zig` - test case * `src/9p.zig` - library * `u9fs-server.sh` - test server script  # example ## client ```zig const std = @import('std'); const debug = std.debug; const z9p = @import('9p.zig');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();     var allocator = gpa.allocator();      // open connection     const stream = try std.net.tcpconnecttohost(allocator, '127.0.0.1', 5640);     defer stream.close();      std.debug.print('connected╲n', .{});      // initialize client     var client = z9p.simpleclient(allocator, stream.reader(), stream.writer());     defer client.deinit();      // setup protocol     try client.connect(std.math.maxint(u32));      // login to the server with name at endpoint, returning a handle     const root = try client.attach(null, 'dante', '');     defer root.clunk() catch unreachable;     std.debug.print('root: {any}╲n', .{ root });      // return a directory handle associated with the root     const top_dir = try root.walk(&.{ '' });     std.debug.print('top_dir: {any}╲n', .{ top_dir });      // open the directory for reading     try top_dir.open(.{});     std.debug.print('opened: {any}╲n', .{ top_dir });      // get directory information     const stat = try top_dir.stat();     defer stat.deinit();     std.debug.print('stat: {any}╲n', .{ stat });     std.debug.print('size: {d}╲n', .{ stat.length });      // example of reading a directory (or file)     const buf = try top_dir.reader().readallalloc(allocator, 99999);     defer allocator.free(buf);     std.debug.print('reader: {any}╲n', .{ buf });      // list files and directories in a directory     const files = try top_dir.files();     defer files.deinit();     for (files.stats) |s| {         std.debug.print('{s} {s:6} {s:6} {d:8} {s}╲n', .{ s.mode, s.uid, s.gid, s.length, s.name });     }      // close a handle, deallocate it     try top_dir.clunk();      // open another directory     const tmp = try root.walk(&.{ 'tmp' });     // create a file, handle is now associated with the file     try tmp.create('testing', .{ .user_read = true, .user_write = true, .group_read = true, .world_read = true }, .{});     // delete the file associated with the handle, deallocate it     try tmp.remove();      const passwd = try root.walk(&.{ 'etc', 'passwd' });     defer passwd.clunk() catch unreachable;     try passwd.open(.{});     const pass_data = try passwd.reader().readallalloc(allocator, 99999);     defer allocator.free(pass_data);     std.debug.print('/etc/passwd:╲n{s}╲n', .{ pass_data });      const new_file = try root.walk(&.{ 'tmp' });     defer new_file.remove() catch unreachable;     // create a file and write to it     try new_file.create('new_thing.txt', .{ .user_write = true, .user_read = true }, .{ .perm = .write });     const tons_of_data = [_]u8{'a'} ** 10000;     try new_file.writer().print(&tons_of_data, .{}); } ```  ## server  wip ","freakmangd/bitmatch":"Bitmatching in zig # bitmatch simple zig library based off of the rust crate [bitmatch](https://github.com/porglezomp/bitmatch). ```zig const match = bitmatch('00oo_aabb', 0b0011_1001) orelse return error.expectednonnull; try std.testing.expectequal(0b11, match.o); try std.testing.expectequal(0b10, match.a); try std.testing.expectequal(0b01, match.b); ```  ### installing ``` zig fetch --save git+https://github.com/freakmangd/bitmatch ``` `build.zig`: ```zig const bitmatch = b.dependency('bitmatch', .{}); exe.root_module.addimport('bitmatch', bitmatch.module('root')); ```  ### features  the main functions of the library are `bitmatch` and `bitmatchpacked`.  both functions take a match string and a byte to match against.  the match string must be comptime known.  `bitmatch` returns `?struct`. each field is of type `u8`.  `bitmatchpacked` returns `?packed struct(u8)`. each field is the smallest int type required to hold all bits matched by the field's identifier.  ```zig // non-packed const match = bitmatch('aaaa_b010', 0b1000_1010) orelse return error.expectednonnull; try std.testing.expect(@typeof(match.a) == u8); try std.testing.expect(@typeof(match.b) == u8); try std.testing.expectequal(0b0000_1000, match.a); try std.testing.expectequal(0b0000_0001, match.b);  // packed const match = bitmatchpacked('aaaa_b010', 0b1000_1010) orelse return error.expectednonnull; try std.testing.expect(@typeof(match.a) == u4); try std.testing.expect(@typeof(match.b) == u1); try std.testing.expectequal(0b1000, match.a); try std.testing.expectequal(0b1, match.b);  // no identifiers const match = bitmatch('0001_1010', 0b0001_1010) orelse return error.expectednonnull; try std.testing.expectequal(0, @sizeof(@typeof(match))); ```  #### match bits  0s and 1s in the match string are the only characters that decide whether a byte matches the pattern defined.  ```zig // this match returns null as were expecting the last bits to be 1011 // the match fails here -----------v if (bitmatch('aaaa_1011', 0b1010_1001)) |_| return error.expectednull; ```  #### identifiers  an 'identifier' refers to an alphabetic character inside the match string, they are allowed to be in the range a-z and a-z. an identifier captures the bits that share their position. all identifiers will be fields of the return value.  there is a max of 8 identifiers per match string  as this library assumes 8 bits in a byte.  ```zig const match = bitmatch('aaaa_bbbb', 0b0101_1010) orelse return error.expectednonnull; try std.testing.expectequal(0b0101, match.a); try std.testing.expectequal(0b1010, match.b);  const match = bitmatch('abcd_efgh', 0b0101_1010) orelse return error.expectednonnull; try std.testing.expectequal(0b0, match.a); try std.testing.expectequal(0b1, match.b); try std.testing.expectequal(0b0, match.c); // ... try std.testing.expectequal(0b0, match.h);  // identifiers are case-sensitive const match = bitmatch('aaaa_aaaa', 0b0000_1111) orelse return error.expectednonnull; try std.testing.expectequal(0b0000, match.a); try std.testing.expectequal(0b1111, match.a); ```  identifiers can be split as many times as is necessary, they will capture the bits that share their position and concat them. ```zig const match = bitmatch('aa_bb_aa_bb', 0b10_01_00_11); try std.testing.expectequal(0b10_00, match.a); try std.testing.expectequal(0b01_11, match.b); ```  #### underscores underscores in match strings are ignored, and are more lenient than zig's integer literal underscores. you can have as many as you want for the purposes of increasing readability.  these match strings function the same: `'aaaabbbb'`, `'aaaa_bbbb'` `'a_a____aa_bb__b_b_'`  #### wildcards the `?` character is used as a wildcard, matching either a 0 or 1 without capturing it. ```zig const match = bitmatch('???_aa_???', 0b010_01_101) orelse return error.expectednonnull; try std.testing.expectequal(0b01, match.a); ```  if the match string is less than 8 characters, the match string is left-padded with wildcards, making `'aa01'` equivalent to `'????aa01'` ```zig const match = bitmatch('aa01', 0b0000_1101) orelse return error.expectednonnull; try std.testing.expectequal(0b11, match.a); ```  ### more examples see the bottom of `src/init.zig` for more testable examples. you can run them with `zig build test`. ","jiacai2050/zig-rocksdb":"RocksDB binding for Zig 404: not found","jetzig-framework/jetkv":"Key-value store designed for local development # jetkv  _jetkv_ is a key-value store written in _zig_ intended for use in development web servers.  _jetkv_ can be used for:  * background job queuing * persistent data storage * cache  _jetkv_ is used by the [jetzig web framework](https://jetzig.dev/) to provide a zero-setup, in-process key-value store for all of the above.  ## checklist  * :white_check_mark: in-memory storage. * :white_check_mark: string value storage. * :white_check_mark: array value storage. * :white_check_mark: array pop/queue implementation. * :white_check_mark: on-disk storage. * :x: key expiry. * :x: shared memory.  ## usage  ### memory allocator  ```zig var kv = try jetkv.init(allocator, .{ .backend = .memory }); ```  ### file allocator  when using the file allocator, `jetkv.init` receives an allocator in order to provide a consistent api but does not perform any allocations. it is therefore possible to pass `undefined` instead of an allocator when using the file allocator.  the file passed as the `path` field is locked on startup.  ```zig var kv = try jetkv.init(     allocator,     .{         .backend = .file,         .file_backend_options = .{             // path to storage file (jetkv stores all data in a single, platform-agnostic file)             .path = '/path/to/jetkv.db',             // set to `true` to clear the store on each launch.             .truncate = false,             // set the size of the on-disk hash table (each address is currently 4 bytes)             // use `jetkv.addressspacesize` to guarantee a valid size if address size changes in future             .address_space_size = jetkv.addressspacesize(4096),         },     }, ); ```  ### key-value operations  all operations are identical for `.file` and `.memory` backends.  all operations are _o(1)_ complexity for both backends.  read operations receive an allocator to allow separation of internal allocation and value reads. e.g. you may want to use one allocator for the kv store's internal storage and an arena allocator for reading values.  ```zig // put some strings into the kv store try kv.put('foo', 'baz'); try kv.put('bar', 'qux');  // `append` and `prepend` create a new array if one does not already exist try kv.append('example_array', 'quux'); try kv.prepend('example_array', 'corge');  if (try kv.get(allocator, 'foo')) |value| {     // 'baz'     allocator.free(value); }  if (try kv.fetchremove(allocator, 'bar')) |value| {     // 'qux'     allocator.free(value); }  // remove a string from the kv store. does not remove arrays. try kv.remove('foo');  if (kv.pop(allocator, 'example_array')) |value| {     // 'quux'     allocator.free(value); }  if (kv.popfirst(allocator, 'example_array')) |value| {     // 'corge'     allocator.free(value); } ```  ## implementation  ### memory  the memory backend uses a _zig_ `std.stringhashmap` of `[]const u8` for string storage and `std.doublylinkedlist([]const u8)` for array storage.  ### file  the file backend implements a fixed-sized hash table at the beginning of the file.  hash collisions are resolved as singly-linked lists. arrays are implemented as doubly-linked lists.  each index in the hash table references a location in the file which provides address information:  * value type * next linked item (for collision resolution) * next array item * previous array item * end array item * key length * initial key length * value length * initial value length * key * value  values are inserted with a relative amount of over-allocation to allow re-use of space when replacing values.  keys have a maximum length of `1024` bytes in order to allow key comparison to operate exclusively on the stack.  reference counting is used to allow truncating the file when the store becomes empty.  ## license  [mit](license) ","mattnite/zig-mbedtls":"compile mbedtls in your build.zig # mbedtls build package  [![ci](https://github.com/mattnite/zig-mbedtls/actions/workflows/ci.yml/badge.svg)](https://github.com/mattnite/zig-mbedtls/actions/workflows/ci.yml)  ## like this project?  if you like this project or other works of mine, please consider [donating to or sponsoring me](https://github.com/sponsors/mattnite) on github [:heart:](https://github.com/sponsors/mattnite)  ## how to use  this repo contains code for your `build.zig` that can statically compile mbedtls.  ### link to your application  in order to statically link mbedtls into your application:  ```zig const mbedtls = @import('path/to/mbedtls.zig');  pub fn build(b: *std.build.builder) void {     // ...      const lib = mbedtls.create(b, target, optimize);      const exe = b.addexecutable(.{         .name = 'my-program',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     lib.link(exe); } ``` ","allyourcodebase/libpq":"PostgreSQL's libpq ported to the zig build system # `build.zig` for libpq  provides a package to be used by the zig package manager for c programs.  ## status  | architecture ╲ os | linux      | macos | |:------------------|:-----------|-------| | x86_64            | ✅         | ✅    | | arm 64            | (untested) | ✅    |  | refname    | postgresql version | zig `0.12.x` | zig `0.13.x` | zig `0.14.0-dev` | |------------|--------------------|--------------|--------------|------------------| | `5.16.4+1` | `rel_16_4`         | ❌           | ✅           | ✅               |  ## use  add the dependency in your `build.zig.zon` by running the following command: ```zig zig fetch --save git+https://github.com/allyourcodebase/libpq#5.16.4+1 ```  then, in your `build.zig`: ```zig const postgres = b.dependency('libpq', { .target = target, .optimize = optimize }); const libpq = postgres.artifact('pq');  // wherever needed: exe.linklibrary(libpq); ```  ## options  ```   -dssl=[enum]                 choose which dependency to use for ssl. defaults to libressl                                  supported values:                                    openssl                                    libressl                                    none   -ddisable-zlib=[bool]        remove zlib as a dependency   -ddisable-zstd=[bool]        remove zstd as a dependency ```  ## bump dependencies  to update this project dependencies:  ```bash zig fetch --save=upstream git+https://github.com/postgres/postgres#rel_16_4 zig fetch --save          git+https://github.com/allyourcodebase/openssl#3.3.0 zig fetch --save          git+https://github.com/allyourcodebase/libressl#3.9.2+1 zig fetch --save          git+https://github.com/allyourcodebase/zlib#1.3.1 zig fetch --save          git+https://github.com/allyourcodebase/zstd#1.5.6-1 ``` ","allyourcodebase/lua":"lua build system ported to Build.zig # lua  ## 5.4.7  ## warning due to a bug in the 0.13.0 release of the zig compiler you will need the development version of zig in order to build the lua54.dll on windows.  ## build instructions to build all targets run  ```sh zig build ```  ## build artifacts | name      | artifact                  | |:---------:| ------------------------- | | 'lua'     | the main lua library      | | 'lua_exe' | the lua interpreter       | | 'luac'    | the lua bytecode compiler |  ## compile options | name         | type | description                | |:------------:| ---- | -------------------------- | | release      | bool | optimize for end users     | | shared       | bool | build as shared library    | | use_readline | bool | readline support for linux |  ## using in a zig project to add to a zig project run: ``` zig fetch --save https://github.com/allyourcodebase/lua/archive/refs/tags/5.4.7.tar.gz ``` then add the following to your `build.zig`  ```zig const lua_dep = b.dependency('lua', .{     .target = target,     .release = optimize != .debug, }); const lua_lib = lua_dep.artifact('lua'); ``` ","travisstaloch/date-zig":"Fast calendar algorithms ported to zig # date-zig a port of https://github.com/nakedible/datealgo-rs/ to zig.   datealgo-rs is based on https://github.com/cassioneri/eaf  ## support system time related related methods such as `datetime_to_systemtime()` and `systemtime_to_datetime()` currently only support posix based operating systems.   everything else such as `rd_to_date()` and `date_to_rd()` should work on any target and platform.  ## todo * wasm: `zig build test -dtarget=wasm32-wasi -fwasmtime` * windows: `zig build test -dtarget=x86_64-windows -fwine` * other non posix?","ikskuh/zig-ihex":"An intel hex loader written in Zig # zig intel hex parser  a loader for the [intel hex](https://en.wikipedia.org/wiki/intel_hex) format used in embedded development.  ## features - supports all 6 record types - raw record parser (`parseraw`) - user-friendly preprocessor (`parsedata`) - pedantic and lax parsing  ## example  ```zig fn processdata(x: void, offset: u32, data: []const u8) !void {     std.debug.warn('read slice @ 0x{x}: {x}╲n', .{ offset, data }); }  pub fn main() !void {     var file = try std.fs.cwd().openfile('data/example.ihex', .{ .read = true, .write = false });     defer file.close();      var entry_point = try ihex.parsedata(file.reader(), ihex.parsemode{ .pedantic = true }, {}, error{}, processdata);     if (entry_point) |ep| {         std.debug.warn('entry point: 0x{x}╲n', .{ep});     } } ```","zetaframe/zva":"Zig Vulkan Allocator (zva). # zig vulkan allocator (zva)  a zig vulkan memory allocator for use in [zetaframe](https://github.com/zetaframe/zetaframe).  uses snektron's vulkan bindings.  ## usage  in `build.zig`: ```zig const zva = @import(<path to pkg.zig>).pkg(<path to zva root>, <path to generated vulkan bindings>);  step.addpackage(zva.pkg); ``` ","ziglana/zup":"zup.sh - ⚡️blazigly fast⚡️ zig package registry, only possible on ziglana # zup zup.sh - ⚡️blazigly fast⚡️ zig package registry, only possible on ziglana ","nektro/zig-color":"This repository has no description. 404: not found","LmanTW/canvaz":"A simple, easy-to-use image processing library written entirely in Zig. # canvaz  a simple, easy-to-use image processing library written entirely in zig.  > [!note] > canvaz is still in early development and is halted. i might revisit this project after i'm more experienced with zig.  ## example  ```zig const canvaz = @import('canvaz'); const std = @import('std');  const shape = canvaz.shape;  pub fn main() !void {     const canvas = try canvaz.init(512, 512, std.heap.page_allocator);     defer canvas.deinit();      const image = try canvaz.image.initfromfile('image.png', canvas.allocator);     defer image.deinit();      canvas.drawshape(shape.circle(0, 0, 512), canvaz.color.black);     canvas.drawimage(image, shape.roundrectangle(256, 256, 320, 320, 32).move(-0.5, -0.5), .cover);     canvas.drawfilter(canvaz.filter.posterize(0.15), shape.rectangle(0, 0, 256, 512));      try canvas.savetofile('result.png'); } ```  ## installation  1. add canvaz using the zig package manager.  ```sh zig fetch --save 'https://github.com/zigimg/zigimg/archive/[commit hash].tar.gz' ```  2. add canvaz as a dependency to your `build.zig`.  ```zig const canvaz = b.dependency('canvaz', .{     .target = target,     .optimize = optimize })  exe.root_module.addimport('canvaz', canvaz.module('canvaz')); ```  > [!warning] > canvaz uses [zigimg](https://github.com/zigimg/zigimg) which uses the nominated [2024.10.0-mach](https://machengine.org/about/nominated-zig/) version of zig.  # guide  canvaz is designed to be simple and easy-to-use while still offering the capability for advanced more graphics processing. as a result, you can easily perform image and filter masking in canvaz.  ### canvas  <table>  <tr>   <td>initialize and saving a canvas.</td>   <td>clearing and filling the canvas.</td> </tr>    <tr> <td>      ```zig const canvas = try canvaz.init(512, 512, std.heap.page_allocator); defer canvas.deinit();  // save the canvas to a file. canvas.savetofile('result.png') ```    </td> <td>  ```zig // clear the canvas. canvas.clear();  // fill the canvas with a color. canvas.fill(canvaz.color.black) ```  </td> </tr>  </table>  ### color  <table>  <tr>   <td>initialize a color.</td>   <td>modifing the color.</td> </tr>    <tr> <td>      ```zig // initialize a color from rgba. canvaz.color.init(247, 164, 29, 1);  // initialize a color from hex. canvaz.color.initfromhex('#f7a41d'); ```    </td> <td>      ```zig const color = canvaz.color.init(247, 164, 29, 1);  // modify the color. _ = canvaz.color.posterize(0.25);  // note: these methods return a new color, so it's better to use them inline. ```    </td> </tr>  </table>  ### shape  <table>  <tr>   <td>initialize a shape.</td>   <td>moving the shape.</td>   <td>drawing the shape.</td> </tr>    <tr> <td>      ```zig // initialize a shape. _ = canvaz.shape.rectangle(0, 0, 256, 256); _ = canvaz.shape.roundrectangle(0, 0, 256, 256, 64); _ = canvaz.shape.roundrectangle(0, 0, 256); ```    </td> <td>      ```zig const rectangle = canvaz.shape.rectangle(0, 0, 256, 256);  // move the shape relatively by its size. _ = rectangle.move(-0.5, -0.5); _ = rectangle.left(0.5); _ = rectangle.right(0.5); _ = rectangle.up(0.5); _ = rectangle.down(-0.5);  // note: these methods return a new shape, so it's better to use them inline. ```    </td> <td>      ```zig const canvas = try canvaz.init(512, 512, std.heap.page_allocator); defer canvas.deinit();  // draw a centered circle. canvas.drawshape(canvaz.shape.circle(256, 256, 512).move(-0.5, -0.5), canvaz.color.white); ```    </td> </tr>  </table>  ### image  <table>  <tr>   <td>initialize an image.</td>   <td>scaling the image.</td>   <td>drawing the image.</td> </tr>    <tr> <td>      ```zig // initialize an image from a file. const image_file = try canvaz.image.initfromfile('image.png', std.heap.page_allocator); defer image_file.deinit();  // initialize an image from the memory. const image_memory = try canvaz.image.initfromfile(<buffer>, std.heap.page_allocator); defer image_memory.deinit(); ```    </td> <td>      ```zig var image = try canvaz.image.initfromfile('image.png', std.heap.page_allocator); defer image.deinit();  // scale the image. try image.scale(64, 64); ```    </td> <td>      ```zig const canvas = try canvaz.init(512, 512, std.heap.page_allocator); defer canvas.deinit();  const image = try canvaz.image.initfromfile('image.png', std.heap.page_allocator); defer image.deinit();  // draw the image with a rounded rectangle mask. canvas.drawimage(image, canvaz.shape.roundrectangle(0, 0, 512, 512, 64), .cover); ```    </td> </tr>  </table>  > [!note] > check out [zigimg](https://github.com/zigimg/zigimg) for the [supported formats](https://github.com/zigimg/zigimg).  ### filter  <table>  <tr>   <td>drawing the filter.</td> </tr>    <tr> <td>      ```zig const canvas = try canvaz.init(512, 512, std.heap.page_allocator); defer canvas.deinit();  // draw a filter with a circle mask. canvas.drawfilter(canvaz.filter.brighten(0.5), canvaz.shape.circle(0, 0, 512)); ```    </td>  </tr>  </table> ","mattnite/version":"small library for semver # version small library for semver ","nektro/zig-yaml":"This repository has no description. # zig-yaml","leecannon/zig-bootboot":"A zig'ified BOOTBOOT header file # zig-bootboot  this repo contains a zig'ified [bootboot](https://gitlab.com/bztsrc/bootboot) header file.  ## how to get  ### gyro  `gyro add leecannon/bootboot`  ### zigmod  `zigmod aq add 1/leecannon/bootboot`  ### git  #### submodule  `git submodule add https://github.com/leecannon/zig-bootboot zig-bootboot`  #### clone  `git clone https://github.com/leecannon/zig-bootboot` ","DivergentClouds/portmidi-zig":"A Zig wrapper for PortMidi # portmidi-zig a zig wrapper for portmidi  ## dependencies - [portmidi](https://github.com/portmidi/portmidi/)   - made for [commit 103beb1](https://github.com/portmidi/portmidi/tree/103beb136ca9833d47d3f3a150364330d78638e7), other versions may or may not work.  ## see also - [porttime-zig](https://github.com/divergentclouds/porttime-zig) ","andy5995/zigdeck":"A library that creates and shuffles a deck of cards from which you can draw [![linux ci](https://github.com/andy5995/zigdeck/actions/workflows/linux.yml/badge.svg)](https://github.com/andy5995/zigdeck/actions/workflows/linux.yml)  # zigdeck  a library that creates and shuffles a deck of cards from which you can draw  tested with the the development version of [zig](https://ziglang.org/) (may not build with the last release).  ## example  ```zig     // initialize the deck. this must be done before shuffle.     var deck = deck.init();      try std.testing.expectequal(suit.clubs, deck.cards[0].suit);     try std.testing.expectequal(face.ace, deck.cards[0].face);     try std.testing.expectequal(suit.spades, deck.cards[48].suit);     try std.testing.expectequal(face.king, deck.cards[51].face);      // seed the random number generator     var rng = std.rand.defaultprng.init(@as(u64, @intcast(std.time.millitimestamp())));      // shuffle     deck.shuffle(&deck, &rng.random());      // draw one card     const card = deck.gettopcard(&deck) orelse return;      try std.testing.expectequal(suit.clubs, card.suit);     try std.testing.expectequal(face.queen, card.face);      std.debug.print('top card: suit = {}, value = {}╲n', .{ card.suit, card.face }); ```  this library is used by [zigpokerhands](https://github.com/andy5995/zigpokerhands). ","zhuyadong/Closure.zig":"closure for zig. # closure.zig now we can use closure in zig ;) ## example: up value support ```zig const t = std.testing;  var a: i32 = 0;  // test upvalue. // .{ &a, 1 } for: &a => p, 1 => v var clo = closure.init(t.allocator, struct {     pub fn func(p: *i32, v: i32) void {         p.* = v;     } }, .{ &a, 1 }); clo.call(.{}); clo.deinit(); try t.expect(a == 1); ``` ## example: up value + call argument ```zig     const t = std.testing;      var a: i32 = 0;     var b: i64 = 0;     // note:arg must be the first parameter and the type must be std.meta.tuple.     //      parameter[1..] for upvalue (5 => va, 6 => vb).     clo = closure.init(t.allocator, struct {         pub fn func(arg: std.meta.tuple(&.{ *i32, *i64 }), va: i32, vb: i64) void {             arg[0].* = va;             arg[1].* = vb;         }     }, .{ 5, 6 });     clo.call(.{ &a, &b });     clo.deinit();     try t.expect(a == 5 and b == 6); ``` ## example: up value on stack ```zig     //test upvalue on stack with call arg     //note: don't need to call clo.deinit() here, but it's safe to call and it's just do nothing.     clo = closure.make(struct {         pub fn func(arg: std.meta.tuple(&.{ *i32, *i64 }), va: i32, vb: i64) void {             const pa, const pb = arg;             pa.* = va;             pb.* = vb;         }     }, &std.meta.tuple(&.{ i32, i64 }){ 9, 10 });     clo.call(.{ &a, &b });     try t.expect(a == 9 and b == 10); ``` ## example: use invoke for return bool ```zig     a = 0;     clo = closure.make(struct {         pub fn func(arg: tuple(&.{*i32})) bool {             arg[0].* = 11;             return false;         }     }, &.{});     try t.expect(clo.invoke(.{&a}) == false);     try t.expect(a == 11);      clo = closure.make(struct {         pub fn func(arg: tuple(&.{*i32})) void {             arg[0].* = 11;         }     }, &.{});     // invoke on void return function always return true     try t.expect(clo.invoke(.{&a}) == true);     try t.expect(a == 11); ```  ## example: make the parameters of the closure clearly readable ```zig const data = struct {     clo: closure.of(.{.arg32 = i32, .arg64 = i64, .ret = *i64}), }; try std.testing.expect(@typeof(data.clo) == closure); ``` more examples in source code: [here](src/root.zig) ","paoda/zba-gdbstub":"GDB Server for Debugging guest code in paoda/zba # zba-gdbstub  this is a gdbstub server for paoda/zba, because i don't want to import a c library and i _love_ reinventing the wheel i guess.  ## scope  this is tailor made for targeting the gba. anything that isn't necessary for stepping through armv4t code isn't included. this means lots of hardcoded values and assumptions that would be really awful for any halfway decent gdbstub implementation.  this project will have succeeded as soon as i use it to determine why rhythm heaven is stuck in an infinite loop. ","garrisonhh/nix-zig-packager":"package zig 0.11.0+ projects for nix # nix-zig-packager  are you annoyed with zig 0.11.0 incompatibility with nix? me too! this is a fix before the zig compiler people figure it out (which i'm sure they will)  ## adding to your flake  this flake provides an overlay which provides `buildzig11package`. here's a simple flake to build a zig project for `x86_64-linux`:  *unfortunately, you will still need to use the `--impure` flag for this to work*  ```nix {   inputs.zig-packager.url = github:garrisonhh/nix-zig-packager;    outputs = { self, nixpkgs, zig-packager, ... }:     let       system = 'x86_64-linux';        pkgs = (import nixpkgs) {         inherit system;         overlays = [           zig-packager.overlays.default         ];       };     in     {       packages.${system}.default = pkgs.buildzig11package {         src = self;         inherit system;       };     }; } ```","softprops/zig-bson":"zig library for working with bson data 🍃 <h1 align='center'>     zig bson </h1>  <div align='center'>     zig library bindings for <a href='https://bsonspec.org/'>bson</a>, a binary json serialization format. </div>  ---  [![main](https://github.com/softprops/zig-bson/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/zig-bson/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/zig-bson) ![release](https://img.shields.io/github/v/release/softprops/zig-bson) [![zig support](https://img.shields.io/badge/zig-0.13.0-black?logo=zig)](https://ziglang.org/documentation/0.13.0/)   ## examples  see examples directory  ## 📼 installing  create a new exec project with `zig init`. copy an example from the examples directory into your into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/softprops/zig-bson/archive/refs/tags/v0.1.4.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +       // 👇 declare dep properties +        .bson = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-bson/archive/refs/tags/v0.1.4.tar.gz', +            // 👇 hash verification +            .hash = '...', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-bson/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-bson/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference dep from build.zig.zon +    const bson = b.dependency('bson', .{ +        .target = target, +        .optimize = optimize, +    }).module('bson');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the module to executable +    exe.root_mode.addimport('bson', bson);      b.installartifact(exe); } ```  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)   ╲- softprops 2024 ","nektro/zig-UrlValues":"This repository has no description. # zig-urlvalues","FObersteiner/ntp-client":"NTP client CLI in Zig <!-- -*- coding: utf-8 -*- --> [![zig](https://img.shields.io/badge/-zig-f7a41d?style=flat&logo=zig&logocolor=white)](https://ziglang.org/)  [![tests](https://github.com/fobersteiner/ntp-client/actions/workflows/run_tests.yml/badge.svg)](https://github.com/fobersteiner/ntp-client/actions/workflows/run_tests.yml)  [![license: mit](https://img.shields.io/badge/license-mit-yellow.svg)](https://github.com/fobersteiner/ntp-client/blob/master/license)  # ntp client  command line app to query an [ntp](https://datatracker.ietf.org/doc/html/rfc5905) server, e.g. to verify your os clock setting. or get the time independent of your os clock. or mess with your local ntp server.  ## usage  ### building the binary  note: `v0.0.18` and greater requires at least zig `0.14.0-dev.1411+a670f5519` to build.  ```sh zig build -dexe [--release=[safe|small|fast]] # build and run, debug: zig build -dexe run # library tests: zig build test ```  ### ntp library  currently targets sntp ([rfc4330](https://datatracker.ietf.org/doc/html/rfc4330)), does not implement the full ntp spec. `src/ntp.zig` can be used independently in other projects; it is exposed via this project's `build.zig` and `build.zig.zon` files. other dependencies of the binary are lazy, i.e. they won't be fetched if you use only the library in another project.  ### usage of the binary  ```sh usage: ntp_client [options]  options:   -s, --server           ntp server to query (default: pool.ntp.org)   -v, --protocol-version ntp protocol version, 3 or 4 (default: 4)   -4, --ipv4             use ipv4 instead of the default ipv6   --src-ip               ip address to use for sending the query (default: 0::0 / ipv6 auto-select)   --src-port             udp port to use for sending the query (default: 0 / any port)   --dst-port             udp port of destination server (default: 123)   -z, --timezone         timezone to use in console output (default: utc)   -j, --json             print result in json   -i, --interval         interval for repeated queries in seconds (default: null / one-shot operation)   -a, --all              query all ip addresses found for a given server url (default: false / stop after first)   -h, --help             show this help and exit ```  ## demo output  ```sh zig build run -dexe -- -4 -z local ```  ```text ---***--- server name: 'pool.ntp.org' server address: '185.41.106.152:123' --- li=0 vn=4 mode=4 stratum=2 poll=0 (0 s) precision=-25 (29 ns) id: 0x6c6735c0 server root dispersion: 518 us, root delay: 5599 us --- server last synced  : 2024-08-27t09:36:35.013046150+02:00 t1, packet created  : 2024-08-27t09:44:24.203294803+02:00 t2, server received : 2024-08-27t09:44:24.209060683+02:00 t3, server replied  : 2024-08-27t09:44:24.209271892+02:00 t4, reply received  : 2024-08-27t09:44:24.215617157+02:00 (timezone displayed: europe/berlin) --- offset to timserver: -0.000 s (-290 us)  round-trip delay:    0.012 s (12111 us) --- result flags: 0 (ok) ---***--- ```  ## compatibility and requirements  developed & tested mostly on debian linux, on an x86 machine. windows worked last time i tested (build.zig links libc for this), mac os might work (can't test this).  ## zig version  this package tracks zig `0.14.0-dev` (master); might not compile with older versions.  ## dependencies  - [flags](https://github.com/n0s4/flags) for command line argument parsing - [zdt](https://codeberg.org/fobersteiner/zdt) to display timestamps as utc or timezone-local datetimes  ## license  mit. see the license file in the root directory of the repository. ","jiacai2050/zig-jemalloc":"Zig allocator baked by jemalloc 404: not found","malcolmstill/biscuit-zig":"Biscuit implementation for zig # biscuit-zig  > [!warning] > the implementation is wip and should not be used in production  zig implementation of https://www.biscuitsec.org/  ## usage  ### authorizing a token  ```zig var biscuit = try biscuit.frombytes(allocator, token, root_public_key); defer biscuit.deinit();  var authorizer = try biscuit.authorizer(); defer authorizer.deinit();  var errors = std.arraylist(authorizererror).init(allocator); defer errors.deinit();  try authorizer.authorize(&errors); ```  ### attenuating a token  ```zig var biscuit = try biscuit.frombytes(allocator, token, root_public_key); defer biscuit.deinit();  var authorizer = try biscuit.authorizer(); defer authorizer.deinit();  var errors = std.arraylist(authorizererror).init(allocator); defer errors.deinit();  try authorizer.authorize(&errors); ``` ","ziglibs/wavefront-obj":"A parser for wavefront object files # wavefront-obj a parser for wavefront object files  ## dependencies requires package [`zlm`](https://github.com/ziglibs/zlm) to be present. ","seyhajin/llvm-ir-zig":"🚀 A minimal example to create and execute a LLVM IR module in Zig. 404: not found","griush/zig-glfw":"Ziggified GLFW bindings with 100% API coverage, zero-fuss installation, cross compilation, and more. perfected glfw bindings for zig  ## installation `zig fetch --save git+https://github.com/griush/zig-glfw`.  ## features  * zero-fuss installation, cross-compilation at the flip of a switch, and broad platform support. * 100% api coverage. every function, type, constant, etc. has been exposed in a ziggified api.  see also: [what does a ziggified glfw api offer?](https://machengine.org/pkg/mach-glfw/)  ## community maintained  the [mach engine](https://machengine.org/) project no longer uses glfw, and so this project is now community-maintained. pull requests are welcome and will be reviewed. the project will still target [nominated zig versions](https://machengine.org/about/zig-version/) but may not see regular updates as it is no longer a mach project (see [hexops/mach#1166](https://github.com/hexops/mach/issues/1166)).  note: [hexops/glfw]()  some old documentation is available at https://machengine.org/v0.4/pkg/mach-glfw/ ","peterino2/zig_regex":"A regex implementation. # zig regex  a fairly quick regex implementation done a while back for learning purposes, i'll just clean it up and put it out there. this one is largely implemented with tagged unions and recursive descent rather than a state machine or a  byte gobbler so it shows you actually can write zig programs in a fairly functional manner.   in fact it's pretty damn nice for it.  you can test the library with   ```zig zig test gregex.zig ```  usecases can be found in the .zig file itself,  but here's a simple usecase.  ```zig     var test_restr = 'name: *(.*)╲╲((.*)╲╲)$';      var find = try re_find_once(test_restr, 'date: 2077-06-24 name: adam jensen (occupation: killa)╲n', alloc);     defer find.deinit(); // find has an arraylist of regex objects, this should be de-initialized when out of scope.      print('{s}╲n', .{ find.text }); // this will print out the entire string          // the result supports groups     print('find.groups.items[1] = '{s}':╲n', .{find.groups.items[0].text});     print('find.groups.items[2] = '{s}':╲n', .{find.groups.items[0].text}); ```  in terms of sequences, a few of the most commonly supported sequences are supported.  - `*, +, ?` : capture mode operators, respectively; zero or more, one or more, zero or one - `()` : create a match group (does not support nesting) - `[]`: or match group (match any union of elements within) - `a-z`: sequence range match - predefined semantic groups:     - `╲s` : whitespace (capital version is inverted)     - `╲w` : alphanumeric     - `╲d` : digits - `!`: single term negation negates matches that are a single term. does not work on `()` groups or. but will work on or-groups.     - negative look-ahead is not supported.  note: this is the first thing i've ever actually written in zig so there's a few growing pains in visible in the code. ","nektro/zig-js":"[WIP] An ECMAScript module for Zig. # zig-js  an ecmascript module for zig. currently includes a parser.  ## progress  ``` build summary: 3/7 steps succeeded; 3 failed; 3643/4696 tests passed; 16 skipped; 1037 failed test transitive failure ├─ run test 1817/1984 passed, 159 failed, 8 skipped │  └─ zig test debug native success 1m maxrss:2g ├─ run test 1624/1983 passed, 351 failed, 8 skipped │  └─ zig test debug native success 50s maxrss:2g └─ run test 202/729 passed, 527 failed    └─ zig test debug native success 50s maxrss:2g ```  ## built with  - zig 0.11.0 - see [`zigmod.yml`](./zigmod.yml) and [`zigmod.lock`](./zigmod.lock)  ## license  mozilla public license version 2.0  copyright 2023 meghan denny ","kassane/Standalone-Server":"Asio standalone C++ HTTP/S Server (uses zig build-system) # simple-web-server  a very simple, fast, multithreaded, platform independent http and https server and client library implemented using c++11 and asio (both boost.asio and standalone asio can be used). created to be an easy way to make rest resources available from c++ applications.   see https://gitlab.com/eidheim/simple-websocket-server for an easy way to make websocket/websocket secure endpoints in c++. also, feel free to check out the new c++ ide supporting c++11/14/17: https://gitlab.com/cppit/jucipp.   ## features  * asynchronous request handling * thread pool if needed * platform independent * http/1.1 supported, including persistent connections * https supported * chunked transfer encoding and server-sent events * can set timeouts for request/response and content * can set max request/response size * sending outgoing messages is thread safe * client creates necessary connections and perform reconnects when needed  see also [benchmarks](https://gitlab.com/eidheim/simple-web-server/blob/master/docs/benchmarks.md) for a performance comparisons to a few other http libraries.  ## usage  see [http_examples.cpp](https://gitlab.com/eidheim/simple-web-server/blob/master/http_examples.cpp) or [https_examples.cpp](https://gitlab.com/eidheim/simple-web-server/blob/master/https_examples.cpp) for example usage. the following server resources are setup using regular expressions to match request paths: * `post /string` - responds with the posted string. * `post /json` - parses the request content as json, and responds with some of the parsed values. * `get /info` - responds with information extracted from the request. * `get /match/([0-9]+)` - matches for instance `/match/123` and responds with the matched number `123`. * `get /work` - starts a thread, simulating heavy work, and responds when the work is done. * `get` - a special default_resource handler is called when a request path does not match any of the above resources. this resource responds with the content of files in the `web/`-folder if the request path identifies one of these files.  [documentation](https://eidheim.gitlab.io/simple-web-server/annotated.html) is also available, generated from the master branch.  ## dependencies  * boost.asio or standalone asio * boost is required to compile the examples * for https: openssl libraries  installation instructions for the dependencies needed to compile the examples on a selection of platforms can be seen below. default build with boost.asio is assumed. turn on cmake option `use_standalone_asio` to instead use standalone asio.  ### debian based distributions  ```sh sudo apt-get install libssl-dev libboost-filesystem-dev libboost-thread-dev ```  ### arch linux based distributions  ```sh sudo pacman -s boost ```  ### macos  ```sh brew install openssl boost ```  ## compile and run  compile with a c++11 compliant compiler: ```sh cmake -h. -bbuild cmake --build build ```  ### http  run the server and client examples: `./build/http_examples`  direct your favorite browser to for instance http://localhost:8080/  ### https  before running the server, an rsa private key (server.key) and an ssl certificate (server.crt) must be created.  run the server and client examples: `./build/https_examples`  direct your favorite browser to for instance https://localhost:8080/  ## contributing  contributions are welcome, either by creating an issue or a merge request. however, before you create a new issue or merge request, please search for previous similar issues or requests. a response will normally be given within a few days. ","MatthewJohnHeath/zunit":"Quantities with units of measure for unit-safe arithmetic in zig # zunit  this is a library for creating and operating upon floating-point values with units of measure attached: e.g. '8.2 centimetres as a `f32`' or '20.0 seconds as a `comptime_float`.  its aims are:  1. catch errors in dimensions or units at compile time. 2. never have unexpected type mismatches due to floating point errors. 3. have expected 'zig-like' behaviour: peer-type resolution for scalar types and no hidden conversions.   ## the rules  - you can add, subtract or compare (only) quantities with the same units. ```zig     try testing.expect(metres(1.0).gt(metres(-1.0)));     try testing.expect(pixels(1.0).sub(pixels(0.5)).eql(pixels(0.5)));     //will not compile if below is uncommented     //try testing.expect(metres(1.0).gt(pixels(-1.0)));     //try testing.expect(metres(1.0).lt(inches(1.0)));  ``` - you can convert (only) between properties of the same dimensions . ```zig     try testing.expect(bytes(1.0).convert(bit.of(f32).eql(bits(8.0))));      // will not compile if the following isi uncommented     //try testing.expect(bytes(1.0).convert(mole.of(f32)).eql(moles(8.0)));  ``` - you can multiply and divide all quantities with ordinary[*](#ordinary_explanation) units by other such quantities and by floats. the return type of the operation will be worked out for you. ```zig        const speed = metres(1.25).div(seconds(0.25));     try testing.expect(speed.eql(metre.per(second).times(5.0)));     try testing.expect(speed.mul(2.0).eql(metre.per(second).times(10.0))); ``` - you can raise quantities to an arbitrary, rational power providing the power is known at compile time. ```zig     try testing.expect(metre.of(f32).init(2.0).powi(3).eql(metre.tothe(3).times(8.0)));     try testing.expect(second.of(f32).init(4.0).root(2).eql(second.root(2).times(2.0))); ``` - at runtime, values are just floats and operations are just floating point operations. - you can apply scalar multiples to units to create new units (e.g. kilometres or furlongs from metres, degrees from radians). ```zig pub const rot = radian.times(floatprefix(2.0 * std.math.pi)); pub const rot = rot.times; pub const degree = rot.times(intprefix(360).reciprocal); pub const degrees = degree.times;  test 'degrees' {     const epsilon = 0.0000001;     try testing.expect(std.math.approxeqabs(f32, degrees(180.0).convert(radian.of(f32)).value, std.math.pi, epsilon)); } ``` - you can create new base units as needed.  ```zig     const iguana = baseunit('iguana');     const rate_of_iguanas = iguana.times(1.0).div(seconds(0.5));     try testing.expect(rate_of_iguanas.eql(iguana.per(second).times(2.0))); ``` - normal zig peer-type resolution should apply between the scalar types (as long as the units are right).   ```zig        try testing.expect(metre.of(f16).init(2.0).eql(metre.of(f64).init(2.0))); ``` - unexpected type mismatches due to floating-point errors on powers, scalar prefixes, etc. ***cannot possibly*** occur.   ---------------- <a name='ordinary_explanation'>*</a> the exception is properties with an offset from their base unit, like degrees celsius and fahrenheit. the maths and physics of multiplying these without first converting them to the base unit is too weird. ","kj4tmp/gatorcat":"An EtherCAT MainDevice Written in Zig # gatorcat  ![tests](https://github.com/kj4tmp/gatorcat/actions/workflows/main.yml/badge.svg)  gatorcat is an ethercat maindevice written for the zig programming language.  > [!warning] > gatorcat is **alpha** software. using it today means participating in its development.  ## status  - [x] can reach op - [x] can manipulate process data - [x] coe supported - [x] autoconfiguration from sii eeprom - [x] cli for scanning networks  ## road to 0.1.0  - [x] multiple datagrams per frame - [x] topology monitoring - [x] nic interface / vtable - [x] windows support via npcap - [ ] docs - [x] re-organize examples - [x] re-organize multi-platform code  ## todos  - [ ] adjust order of declatations in files - [ ] audit std.log statements - [ ] re-organize files to separate lib from cli - [ ] support dc - [ ] generic nic interface - [ ] eoe - [ ] foe - [ ] cable redundancy - [ ] dynamic pdo assignment via coe - [ ] parse eni.xml - [ ] cli for network diag, error counters etc - [ ] distributed clocks - [ ] topology monitoring - [ ] emergency messages - [ ] map mailbox status into process data - [ ] calculate expected wkcs - [ ] segmented sdo transfer - [ ] eeprom write access   - [ ] nic     - [ ] linux / xdp   - [ ] timers  ## windows setup  1. run `getmac /fo csv /v` in command prompt 2. ifname for npcap is of the format: `╲device╲npf_{538cf305-6539-480e-acd9-bee598e7ae8f}` ","silversquirl/zig-xed":"Intel X86 Encoder Decoder library, as a Zig package # zig package for intel xed  this package compiles intel's x86 encoder decoder library using the zig build system. there is no dependency on python; all generated code is committed into this repository directly. ","isaac-westaway/zlog":"Appplication-level logging library for Zig overview ========  `zlog` is an application-level logging library that provides some apis to write logging message to an output file.  my inspiration came from using google's `glog` library, writing some cool applications with the ability to log actions easily.  so credits go to google.  this code was also taken from my `zigwm` project, which *needed* logging to figure out what was going on.  > [!tip] > like glog, this library is also thread-safe  getting started ---------------  you can install the library by running ```bash zig fetch --save git+https://github.com/isaac-westaway/zlog ```  then add the dependency in your `build.zig` file ```zig const zlog = b.dependency('zlog', .{ .target = target, .optimize = optimize }); exe.root_module.addimport('zlog', zlog.module('zlog')); ```  usage -----  ### quickstart you can get started by initializing the logging file: ```zig pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer std.debug.assert(gpa.deinit() == .ok);     var allocator = gpa.allocator();      try logger.initializelogging(&allocator,          .{ .absolute_path = '/home/isaacwestaway/documents/zig/zlog/', .file_name = 'log' },         .{ .severity = .info }     );     defer logger.log.close(); } ```  and then log a message to the logfile: ```zig ... var log = logger.log;  const str: []const u8 = 'world'; const timestamp: i64 = std.time.timestamp();  const current_time: []const u8 = logger.timestamptodatetime(allocator, timestamp); defer allocator.free(current_time);  try log.info('main', 'hello, {s}', .{ str }); try log.warn('main', 'current timestamp: {d}', .{ timestamp} ); try log.err('main', 'hello {s}, at {s}', .{ str, current_time });  // will crash the program upon logging! try logger.log.fatal('main', 'i am crashing now!', .{}); ``` output: ``` info-main-2024/9/17-0:31:57-t250650:hello, world warn-main-2024/9/17-0:31:57-t250650:current timestamp: 1726533117 error-main-2024/9/17-0:31:57-t250650:hello world, at 2024/9/17-0:31:57 fatal-main-2024/9/17-0:31:57-t250650:i am crashing now! ```  ### using a custom prefix ```zig // the callback must have these two arguments fn testlogprefix(allocator: *std.mem.allocator, log_level: []const u8) []const u8 {     const current_time = logger.timestamptodatetime(allocator.*, std.time.timestamp());     const str: []u8 = std.fmt.allocprint(allocator.*, '{s}: some extra messages!, such as the time: {s}: ', .{ log_level, current_time }) catch {         return undefined;     };     return str; }  pub fn main() !void {      var gpa = std.heap.generalpurposeallocator(.{}){};     defer std.debug.assert(gpa.deinit() == .ok);     var allocator = gpa.allocator();      try logger.initializelogging(&allocator,          .{ .absolute_path = '/home/isaacwestaway/documents/zig/zlog/', .file_name = 'log' },          .{ .severity = .info }     );     try logger.installlogprefix(&testlogprefix);     defer logger.log.close();      var log = logger.log;      const str: []const u8 = 'world';     const timestamp: i64 = std.time.timestamp();      const current_time: []const u8 = logger.timestamptodatetime(allocator, timestamp);     defer allocator.free(current_time);      try log.info('main', 'hello, {s}', .{str});     try log.warn('main', 'current timestamp: {d}', .{timestamp});     try log.err('main', 'hello {s}, at {s}', .{ str, current_time });      // will crash the program upon logging!     try logger.log.fatal('main', 'i am crashing now!', .{}); } ```  output: ``` info: some extra messages!, such as the time: 2024/9/17-0:32:51: hello, world warn: some extra messages!, such as the time: 2024/9/17-0:32:51: current timestamp: 1726533171 error: some extra messages!, such as the time: 2024/9/17-0:32:51: hello world, at 2024/9/17-0:32:51 fatal: some extra messages!, such as the time: 2024/9/17-0:32:51: i am crashing now! ```  todo ----  - some better test cases","by-nir/aws-lambda-zig":"🟠 Write AWS Lambda functions in Zig programming language # aws lambda runtime for zig ![zig v0.13](https://img.shields.io/badge/zig-v0.13-black?logo=zig&logocolor=f7a41d 'zig v0.13') [![mit license](https://img.shields.io/github/license/by-nir/aws-lambda-zig)](/license)  write _aws lambda_ functions in the zig programming language to achieve blazing fast invocations and cold starts!  > [!tip] > check out [aws sdk for zig](https://github.com/by-nir/aws-sdk-zig) for a > comprehensive zig-based aws cloud solution.  ### features  - [x] runtime api - [ ] extensions api - [ ] telemetry api - [x] cloudwatch & x-ray integration - [x] response streaming - [ ] life-cycle hooks - [ ] layers - [ ] structured events - [ ] managed build step  ### benchmark  using zig allows creating small and fast functions.<br /> running the basic [echo demo](#echo) on _`arm64` (`256 mb`, amazon linux 2023)_: - ❄️ `~11ms` cold-start duration - ⚡ `~1.5ms` invocation duration - 💾 `11 mb` max memory consumption - ⚖️ `1.7 mb` function size (zip)  ## usage  ### setup  1. add this package as a dependency to your project. 2. import the `aws-lambda` module in your `build.zig` script.  ### minimal code  ```zig const lambda = @import('aws-lambda');  /// the handler’s logging scope. /// in release builds only _error_ level logs are sent to cloudwatch. const log = lambda.log;  /// entry point for the lambda runtime. pub fn main() void {     lambda.serve(handler); }  /// eeach event is processed separetly by this function. /// the function must have the following signature: fn handler(     allocs: lambda.allocators,      // persistant gpa & invocation-scoped arena.     context: *const lambda.context, // function metadata (including env).     event: []const u8,              // json payload. ) ![]const u8 {     return 'hey there!'; } ```  ### distribute  1. build for **linux** with `aarch64` (`neoverse_n1`+`neon`) or `x86_64` (+`avx2`) architecture. 2. name the executable `bootstrap`. 3. archive the executable into a **zip**. 4. upload the archive to lambda (using _amazon linux 2023_ or another **os-only runtime**). this shouls work through the console, cli, sam or anyci solution.  ## demos  ### hello world returns a short message.  ```zig zig build demo:hello --release ```  ### echo returns the provided payload.  ```zig zig build demo:echo --release ```  ### debug returns the function’s metadata, environment variables and the provided payload.  🛑 _may expose sensative data to the public._  ```zig zig build demo:debug --release ```  ### fail: handler error always returns an error; the runtime logs the error to _cloudwatch_.  ```zig zig build demo:fail --release ```  ### fail: oversized output returns an output larger than the lambda limit; the runtime logs an error to _cloudwatch_.  ```zig zig build demo:oversize --release ```  ### response streaming stream a response to the client.  👉 _be sure to configure the function with streaming enabled._  ```zig zig build demo:stream --release ```  ### response streaming: fail stream a response to the client and eventually fail.  👉 _be sure to configure the function with streaming enabled._  ```zig zig build demo:stream_throw --release ```   ## license  the author and contributors are not responsible for any issues or damages caused by the use of this software, part of it, or its derivatives. see [license](/license) for the complete terms of use.  > [!note] > _aws lambda runtime for zig_ is not an official _amazon web services_ software, nor > is it affiliated with _amazon web services, inc_.  ### acknowledgments  - https://github.com/softprops/zig-lambda-runtime - https://github.com/awslabs/aws-lambda-rust-runtime ","crispy-strawberry/string.zig":"A Rust like String type for Zig # an allocated string type  inspired by rust's `string` type.  implementation mostly ported from rust.    provides helper functions that make working with  strings easier.    i try to keep names consistent with `std.arraylist`    ## using with package manager  1. create `build.zig.zon` in the project root if you don't already have one.  2. add the barebones skeleton. ([this](https://pastebin.com/kkf6kfri) if you don't know what it looks like)  3. inside the dependencies section add -    ```    .string = .{      .url = 'git+https://github.com/crispy-strawberry/string.zig#main',    }    ```  4. run `zig build` and wait for zig to complain about the hash  5. copy the provided hash and add it besides the url like -    ```    .string = .{      .url = '<repo url>',      .hash = '<the provided hash>'    }    ```  6. in your `build.zig`, add -    ```zig    const string = b.dependency('string', .{ .optimize = optimize, .target = target });    // replace exe with whatever you are using.    exe.addmodule('string', string.module('string'));    ```  7. now, in your source files, you can use `string` by-    ```zig    const string = @import('string').string;    ```  8. enjoy :)      ## examples  ```zig  const hello_world = try string.fromstr(allocator, 'hello world!');    std.debug.print('{}╲n', .{hello_world.isascii()});  ```  ","nektro/zig-signal":"This repository has no description. # zig-signal","andrewrk/libvorbis":"libvorbis with the build system replaced by zig this is a fork of [vorbis](https://github.com/xiph/vorbis), packaged for zig. unnecessary files have been deleted, and the build system has been replaced with `build.zig`.  original readme follows:  --------------------------------------------------------------------------------  # vorbis  [![gitlab build status](https://gitlab.xiph.org/xiph/vorbis/badges/master/pipeline.svg)](https://gitlab.xiph.org/xiph/vorbis/-/pipelines) [![travis build status](https://travis-ci.org/xiph/vorbis.svg?branch=master)](https://travis-ci.org/xiph/vorbis) [![appveyor build status](https://ci.appveyor.com/api/projects/status/github/xiph/vorbis?branch=master&svg=true)](https://ci.appveyor.com/project/rillian/vorbis)  vorbis is a general purpose audio and music encoding format contemporary to mpeg-4's aac and twinvq, the next generation beyond mpeg audio layer 3. unlike the mpeg sponsored formats (and other proprietary formats such as realaudio g2 and windows' flavor of the month), the vorbis codec specification belongs to the public domain. all the technical details are published and documented, and any software entity may make full use of the format without license fee, royalty or patent concerns.  this package contains:  - libvorbis, a bsd-style license software implementation of   the vorbis specification by the xiph.org foundation   (https://xiph.org/)  - libvorbisfile, a bsd-style license convenience library   built on vorbis designed to simplify common uses  - libvorbisenc, a bsd-style license library that provides a simple,   programmatic encoding setup interface  - example code making use of libogg, libvorbis, libvorbisfile and   libvorbisenc  ## what's here ##  this source distribution includes libvorbis and an example encoder/player to demonstrate use of libvorbis as well as documentation on the ogg vorbis audio coding format.  you'll need libogg (distributed separately) to compile this library. a more comprehensive set of utilities is available in the vorbis-tools package.  directory:  - `lib` the source for the libraries, a bsd-license implementation of the public domain ogg vorbis audio encoding format.  - `include` library api headers  - `debian` rules/spec files for building debian .deb packages  - `doc` vorbis documentation  - `examples` example code illustrating programmatic use of libvorbis, libvorbisfile and libvorbisenc  - `macosx` project files for macos x.  - `win32` win32 projects files and build automation  - `vq` internal utilities for training/building new lsp/residue and auxiliary codebooks.  ## contact ##  the ogg homepage is located at 'https://xiph.org/ogg/'. vorbis's homepage is located at 'https://xiph.org/vorbis/'. up to date technical documents, contact information, source code and pre-built utilities may be found there.  ## building ##  #### building from master ####  development source is under git revision control at https://gitlab.xiph.org/xiph/vorbis.git. you will also need the newest versions of autoconf, automake, libtool and pkg-config in order to compile vorbis from development source. a configure script is provided for you in the source tarball distributions.      ./autogen.sh     ./configure     make  and as root if desired:      make install  this will install the vorbis libraries (static and shared) into /usr/local/lib, includes into /usr/local/include and api manpages (once we write some) into /usr/local/man.  documentation building requires xsltproc and pdfxmltex.  #### building from tarball distributions ####      ./configure     make  and optionally (as root):      make install  #### building rpm packages ####  after normal configuring:      make dist     rpm -ta libvorbis-<version>.tar.gz  ## building with cmake ##  ogg supports building using [cmake](https://cmake.org/). cmake is a meta build system that generates native projects for each platform. to generate projects just run cmake replacing `your-project-generator` with a proper generator from a list [here](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html):      cmake -g your-project-generator .  note that by default cmake generates projects that will build static libraries. to generate projects that will build dynamic library use `build_shared_libs` option like this:      cmake -g your-project-generator -dbuild_shared_libs=1 .  after projects are generated use them as usual  #### building on windows ####  use proper generator for your visual studio version like:      cmake -g 'visual studio 12 2013' .  #### building on mac os x ####  use xcode generator. to build framework run:      cmake -g xcode -dbuild_framework=1 .  #### building on linux ####  use makefile generator which is default one.      cmake .     make  ## license ##  this file is part of the oggvorbis software codec source code. use, distribution and reproduction of this library source is governed by a bsd-style source license included with this source in 'copying'. please read these terms before distributing.  the oggvorbis source code is copyright (c) 1994-2020 by the xiph.org foundation https://xiph.org/ ","jkoop/zigqlite":"An SQLite binding for Zig. # zigqlite  > [!note]   > forked from https://chiselapp.com/user/javier/repository/zigqlite  an [sqlite](https://sqlite.org) binding for [zig](https://ziglang.org).  ## install  ```sh zig fetch --save https://github.com/jkoop/zigqlite/archive/commit.zip ```  ```zig // build.zig before b.installartifact(exe);  const zigqlite = b.dependency('zigqlite', .{     .target = target,     .optimize = optimize, }).module('zigqlite');  exe.linksystemlibrary('c'); exe.linksystemlibrary('sqlite3'); // apt install libsqlite3-dev exe.root_module.addimport('zigqlite', zigqlite); ```  ## usage  see also, the [api documentation](https://joekoop.com/zigqlite).  to open a database file at the given path, creating it if needed:  ```zig var db = try sqlite.db.open(allocator, 'database.db'); defer db.close() catch unreachable; // @todo figure out if i can handle this error or not ```  create a statment:  ```zig var stmt = try db.prep('select * from iguanas where name = ?'); ```  the sql can include positional arguments like `?` or named arguments like `:argname`.  once prepared, the statement is executed with the `.exec()` function:  ```zig // var cursor = try stmt.exec(args, rowtype); var cursor = try stmt.exec(.{'zero'}, struct { name: []u8, photo_url: []u8 }); ```  where `args` is a tuple or structure holding arguments to fill in the sql command. if field names match named arguments, they are used regardless of order; otherwise the position in the tuple or struct determines the field it fills.  the `rowtype` parameter is a struct type. each returned row will be a value of this type. each field will hold a column from the row, in order. if there are more fields than columns, the extra fields would be filled with their respective default value, if declared in the struct.  the value returned by the `stmt.exec()` function is used to retrieve results row by row with the `.fetch()` function:  ```zig while (try cursor.fetch()) |iguana| {     std.debug.print('{s}'s picture is at {s}╲n', .{ iguana.name, iguana.photo_url }); } ``` ","nektro/zig-licenses-text":"Full license text from https://spdx.org/licenses/. # zig-licenses-text  full license text from https://spdx.org/licenses/.  ## built with - https://github.com/ziglang/zig master - https://github.com/nektro/zigmod package manager - https://github.com/truemedian/zfetch - https://github.com/nektro/zig-json  ## install ``` zigmod aq add 1/nektro/licenses-text ```  ## license mit ","ziglana/solana-zig-program-template":"Minimal Solana Zig program template # solana-zig-program-template minimal solana zig program template ","kassane/libbpf":"Automated upstream mirror for libbpf stand-alone build. <picture>   <source media='(prefers-color-scheme: dark)' srcset='assets/libbpf-logo-sideways-darkbg.png' width='40%'>   <img src='assets/libbpf-logo-sideways.png' width='40%'> </picture>  libbpf [![github actions builds & tests](https://github.com/libbpf/libbpf/actions/workflows/test.yml/badge.svg)](https://github.com/libbpf/libbpf/actions/workflows/test.yml) [![coverity](https://img.shields.io/coverity/scan/18195.svg)](https://scan.coverity.com/projects/libbpf) [![codeql](https://github.com/libbpf/libbpf/workflows/codeql/badge.svg?branch=master)](https://github.com/libbpf/libbpf/actions?query=workflow%3acodeql+branch%3amaster) [![oss-fuzz status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/libbpf.svg)](https://oss-fuzz-build-logs.storage.googleapis.com/index.html#libbpf) [![read the docs](https://readthedocs.org/projects/libbpf/badge/?version=latest)](https://libbpf.readthedocs.io/en/latest/) ======  **this is the official home of the libbpf library.**  *please use this github repository for building and packaging libbpf and when using it in your projects through git submodule.*  libbpf *authoritative source code* is developed as part of [bpf-next linux source tree](https://kernel.googlesource.com/pub/scm/linux/kernel/git/bpf/bpf-next) under `tools/lib/bpf` subdirectory and is periodically synced to github. as such, all the libbpf changes should be sent to [bpf mailing list](http://vger.kernel.org/vger-lists.html#bpf), please don't open prs here unless you are changing github-specific parts of libbpf (e.g., github-specific makefile).  libbpf and general bpf usage questions ======================================  libbpf documentation can be found [here](https://libbpf.readthedocs.io/en/latest/api.html). it's an ongoing effort and has ways to go, but please take a look and consider contributing as well.  please check out [libbpf-bootstrap](https://github.com/libbpf/libbpf-bootstrap) and [the companion blog post](https://nakryiko.com/posts/libbpf-bootstrap/) for the examples of building bpf applications with libbpf. [libbpf-tools](https://github.com/iovisor/bcc/tree/master/libbpf-tools) are also a good source of the real-world libbpf-based tracing tools.  see also ['bpf co-re reference guide'](https://nakryiko.com/posts/bpf-core-reference-guide/) for the coverage of practical aspects of building bpf co-re applications and ['bpf co-re'](https://nakryiko.com/posts/bpf-portability-and-co-re/) for general introduction into bpf portability issues and bpf co-re origins.  all general bpf questions, including kernel functionality, libbpf apis and their application, should be sent to bpf@vger.kernel.org mailing list. you can subscribe to it [here](http://vger.kernel.org/vger-lists.html#bpf) and search its archive [here](https://lore.kernel.org/bpf/). please search the archive before asking new questions. it very well might be that this was already addressed or answered before.  bpf@vger.kernel.org is monitored by many more people and they will happily try to help you with whatever issue you have. this repository's prs and issues should be opened only for dealing with issues pertaining to specific way this libbpf mirror repo is set up and organized.  building libbpf =============== libelf is an internal dependency of libbpf and thus it is required to link against and must be installed on the system for applications to work. pkg-config is used by default to find libelf, and the program called can be overridden with `pkg_config`.  if using `pkg-config` at build time is not desired, it can be disabled by setting `no_pkg_config=1` when calling make.  to build both static libbpf.a and shared libbpf.so: ```bash $ cd src $ make ```  to build only static libbpf.a library in directory build/ and install them together with libbpf headers in a staging directory root/: ```bash $ cd src $ mkdir build root $ build_static_only=y objdir=build destdir=root make install ```  to build both static libbpf.a and shared libbpf.so against a custom libelf dependency installed in /build/root/ and install them together with libbpf headers in a build directory /build/root/: ```bash $ cd src $ pkg_config_path=/build/root/lib64/pkgconfig destdir=/build/root make install ```  bpf co-re (compile once – run everywhere) =========================================  libbpf supports building bpf co-re-enabled applications, which, in contrast to [bcc](https://github.com/iovisor/bcc/), do not require clang/llvm runtime being deployed to target servers and doesn't rely on kernel-devel headers being available.  it does rely on kernel to be built with [btf type information](https://www.kernel.org/doc/html/latest/bpf/btf.html), though. some major linux distributions come with kernel btf already built in:   - fedora 31+   - rhel 8.2+   - opensuse tumbleweed (in the next release, as of 2020-06-04)   - arch linux (from kernel 5.7.1.arch1-1)   - manjaro (from kernel 5.4 if compiled after 2021-06-18)   - ubuntu 20.10   - debian 11 (amd64/arm64)  if your kernel doesn't come with btf built-in, you'll need to build custom kernel. you'll need:   - `pahole` 1.16+ tool (part of `dwarves` package), which performs dwarf to     btf conversion;   - kernel built with `config_debug_info_btf=y` option;   - you can check if your kernel has btf built-in by looking for     `/sys/kernel/btf/vmlinux` file:    ```shell $ ls -la /sys/kernel/btf/vmlinux -r--r--r--. 1 root root 3541561 jun  2 18:16 /sys/kernel/btf/vmlinux ```    to develop and build bpf programs, you'll need clang/llvm 10+. the following distributions have clang/llvm 10+ packaged by default:   - fedora 32+   - ubuntu 20.04+   - arch linux   - ubuntu 20.10 (llvm 11)   - debian 11 (llvm 11)   - alpine 3.13+  otherwise, please make sure to update it on your system.  the following resources are useful to understand what bpf co-re is and how to use it: - [bpf co-re reference guide](https://nakryiko.com/posts/bpf-core-reference-guide/) - [bpf portability and co-re](https://nakryiko.com/posts/bpf-portability-and-co-re/) - [howto: bcc to libbpf conversion](https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/) - [libbpf-tools in bcc repo](https://github.com/iovisor/bcc/tree/master/libbpf-tools)   contain lots of real-world tools converted from bcc to bpf co-re. consider   converting some more to both contribute to the bpf community and gain some   more experience with it.  distributions =============  distributions packaging libbpf from this mirror:   - [fedora](https://src.fedoraproject.org/rpms/libbpf)   - [gentoo](https://packages.gentoo.org/packages/dev-libs/libbpf)   - [debian](https://packages.debian.org/source/sid/libbpf)   - [arch](https://archlinux.org/packages/core/x86_64/libbpf/)   - [ubuntu](https://packages.ubuntu.com/source/jammy/libbpf)   - [alpine](https://pkgs.alpinelinux.org/packages?name=libbpf)  benefits of packaging from the mirror over packaging from kernel sources:   - consistent versioning across distributions.   - no ties to any specific kernel, transparent handling of older kernels.     libbpf is designed to be kernel-agnostic and work across multitude of     kernel versions. it has built-in mechanisms to gracefully handle older     kernels, that are missing some of the features, by working around or     gracefully degrading functionality. thus libbpf is not tied to a specific     kernel version and can/should be packaged and versioned independently.   - continuous integration testing via     [github actions](https://github.com/libbpf/libbpf/actions).   - static code analysis via [lgtm](https://lgtm.com/projects/g/libbpf/libbpf)     and [coverity](https://scan.coverity.com/projects/libbpf).  package dependencies of libbpf, package names may vary across distros:   - zlib   - libelf  [![libbpf distro packaging status](https://repology.org/badge/vertical-allrepos/libbpf.svg)](https://repology.org/project/libbpf/versions)   bpf-next to github sync =======================  all the gory details of syncing can be found in `scripts/sync-kernel.sh` script. see [sync.md](sync.md) for instruction.  some header files in this repo (`include/linux/*.h`) are reduced versions of their counterpart files at [bpf-next](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/)'s `tools/include/linux/*.h` to make compilation successful.  license =======  this work is dual-licensed under bsd 2-clause license and gnu lgpl v2.1 license. you can choose between one of them if you use this work.  `spdx-license-identifier: bsd-2-clause or lgpl-2.1` ","furpu/jwt.zig":"Zig JSON Web Token package. # jwt.zig  zig implementation of json web tokens ([rfc 7519](https://datatracker.ietf.org/doc/html/rfc7519)).  ## claims  claim verification is not implemented yet.  future work includes adding features to verify `aud`, `exp`, `iat` and `nbf` claims as described in [section 4](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1) of the rfc.  ## algorithms  | supported | alg parameter | description | |:---------:|---------------|-------------| | ✅        | none          | no digital signature or mac value included | | ✅        | hs256         | hmac using sha-256 hash algorithm | | ✅        | hs384         | hmac using sha-384 hash algorithm | | ✅        | hs512         | hmac using sha-512 hash algorithm | | ✅        | es256         | ecdsa using p-256 curve and sha-256 hash algorithm | | ✅        | es384         | ecdsa using p-384 curve and sha-384 hash algorithm | | ❌        | es512         | ecdsa using p-521 curve and sha-512 hash algorithm | | ❌        | ps256         | rsassa-pss using sha-256 hash algorithm | | ❌        | ps384         | rsassa-pss using sha-384 hash algorithm | | ❌        | ps512         | rsassa-pss using sha-512 hash algorithm | | ❌        | rs256         | rsassa-pkcs1-v1_5 using sha-256 hash algorithm | | ❌        | rs384         | rsassa-pkcs1-v1_5 using sha-384 hash algorithm | | ❌        | rs512         | rsassa-pkcs1-v1_5 using sha-512 hash algorithm | ","tammoippen/zig-plotille":"Plot graphs and histograms in the terminal.  ![example workflow](https://github.com/tammoippen/zig-plotille/actions/workflows/main.yml/badge.svg)  # zig-plotille  draw in the terminal.  - use colors: ansi, 8bit or true color, if your terminal allows. - have a canvas for general braille dots drawing. - have a crappy hist implementation (todo insert link). - have a figure for scatter plots, histograms, line plots. also supports text and vline, vspan, hline, hspan.  re-implementation of the (python) [plotille](https://github.com/tammoippen/plotille) with the intention to (at some point) provide a c-api as well.  for usage (for now) have a look at the examples/ and also in the code (tests).  ","jnordwick/znh":"Zig Microbenchmarking Harness: for generating microbenchmarks in zig, but way inferior to JMH 404: not found","tiawl/shaderc.zig":"shaderc packaged for @ziglang # shaderc.zig  this is a fork of [google/shaderc][1] packaged for [zig][2]  ## why this fork ?  the intention under this fork is to package [google/shaderc][1] for [zig][2]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`, * a cron runs every day to check [google/shaderc][1]. then it updates this repository if a new release is available.  ## how to use it  the goal of this repository is not to provide a [zig][2] binding for [google/shaderc][1]. there are at least as many legit ways as possible to make a binding as there are active accounts on github. so you are not going to find an answer for this question here. the point of this repository is to abstract the [google/shaderc][1] compilation process with [zig][2] (which is not new comers friendly and not easy to maintain) to let you focus on your application. so you can use **shaderc.zig**: - as raw (no available example, open an issue if you are interested in, we will be happy to help you), - as a daily updated interface for your [zig][2] binding of [google/shaderc][1] (see [here][11] for a private usage).  ## dependencies  the [zig][2] part of this package is relying on the latest [zig][2] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [google/shaderc](https://github.com/tiawl/shaderc.zig/blob/trunk/.references/shaderc)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/spaceporn][3]  this repository is automatically updated when a new release is available from these repositories: * [google/shaderc][1] * [tiawl/toolbox][4] * [tiawl/glslang.zig][5] * [tiawl/spirv.zig][6] * [tiawl/spaceporn-action-bot][7] * [tiawl/spaceporn-action-ci][8] * [tiawl/spaceporn-action-cd-ping][9] * [tiawl/spaceporn-action-cd-pong][10]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/google/shaderc [2]:https://github.com/ziglang/zig [3]:https://github.com/tiawl/spaceporn [4]:https://github.com/tiawl/toolbox [5]:https://github.com/tiawl/glslang.zig [6]:https://github.com/tiawl/spirv.zig [7]:https://github.com/tiawl/spaceporn-action-bot [8]:https://github.com/tiawl/spaceporn-action-ci [9]:https://github.com/tiawl/spaceporn-action-cd-ping [10]:https://github.com/tiawl/spaceporn-action-cd-pong [11]:https://github.com/tiawl/spaceporn/blob/trunk/src/compiler/bindings/shaderc/shaderc.zig ","joachimschmidt557/zig-termbox":"A termbox implementation in zig # zig-termbox  a work-in-progress implementation of the termbox api in [zig](https://ziglang.org/)  works with zig 0.13.0 ","srmadrid/zml":"Zig Mathematics Library # zml: zig mathematics library  a zig numerical and symbolic mathematics library.  ## current features  - basic n-dimensional array support.  ## installation  to use this library in your project, run  ```bash zig fetch --save git+https://github.com/srmadrid/zml ```  and add it to your build.zig file:  ```zig const zml = b.dependency('zml', .{}); exe.root_module.addimport('zml', zml.module('zml')); ```  ## notes  this library is in the early stages of development and is not yet ready for use. breaking changes are to be expected every commit, and only the most basic functionality is currently implemented (see [current features](#current-features) for more information). ","TheHonestHare/zkinder":"A pattern matching library for zig a library that implements pattern matching in fully userland zig. tested on zig version 0.14.0-dev.1391+e084c46ed but should probably work on master  ## code example ```zig const ki = @import('zkinder'); const bind = ki.bind; const __ = ki.__;  const thing: struct {     age: u32,     birth: u64,     pos: struct { x: u8, y: u8 }  } = .{.age = 3, .birth = 2, .pos = .{.x = 90, .y = 20}};  const m = ki.match(&thing); // bind puts the value of the variable in the result const res = m.arm(.{.age = 3, .birth = bind('hello'), .pos = .{.x = bind('x'), .y = 20}}); try std.testing.expectequal(2, res.?.hello); try std.testing.expectequal(90, res.?.x);  const res2 = m.arm(.{.age = 3, .birth = bind('hello'), .pos = bind('pos')}); try std.testing.expectequal(2, res2.?.hello); try std.testing.expectequal(90, res2.?.pos.x); try std.testing.expectequal(20, res2.?.pos.y);  // this arm doesn't match because age = 2, will return null const res3 = m.arm(.{.age = 2, .birth = bind('hello'), .pos = bind('pos')}); try std.testing.expectequal(null, res3);  // __ will match on anything const res4 = m.arm(.{.age = __, .birth = __, .pos = .{.x = __, .y = bind('y')}}); try std.testing.expectequal(20, res4.?.y); ``` ## current features: - arbitrary nested patterns   - structs   - union(enum) (todo: more testing)   - enums (todo: more testing)   - ints, floats, bools (todo: more testing)   - optionals (todo: more testing)     - match on double optionals using `nonnull`   - arrays     - can even match on a subarray using `ref_rest` (see 'custom array matchers')   - single item pointers (patterns match on the child type)   - slices     - support same features as arrays, plus different length patterns - `matching` for no exhaustive checking, single arm - extracting values out via `bind` - matching aginst anything via `__` - matching on integer ranges via `range` - extracting values out only if it matches a predicate with `bind_if` - support for creating your own match predicates   - both `bind` and `__` use no special casing, you could implement yourself   - any custom matcher must be of type `fn (comptime type) custommatcher`   - the impl will take in this type, pass in the type it needs to bind to and collect all the needed captures   - todo: make like 10x more ergonomic ## planned features: - matching on vectors, others maybe? - optimize this so its not just willy nilly checking basically - exhaustive patterns (hardmode) - unreachable pattern errors (if i feel like it) - more helper match predicates such as `partial`, `ref`, - safety check for ensuring a match only ever matches on one branch  ## custom matchers: a custom matcher is any function of the form `fn (comptime type) matcher`, where the input is the type it is being matched against. `bind(<name>)` and `__` are both custom matchers implementable you could just as easily implement  for example, in the pattern,  `.{.age = 2, .birth = __, .pos = __}`  `__` is actually a function which will take the types of `thing.birth` and `thing.pos` respectively.   `matcher` is defined as such: ```zig pub const matcher = struct {     captures: type,     trybind: fn (self: matcher, val_ptr: anytype, out_ptr: anytype) bool, }; ``` `captures` is a struct type where each field is an output the matcher produces. this is needed for features like `bind`. all fields are combined, using comptime, into one giant struct that is returned from the arm.  `trybind` is where all the magic happens. - `self` allows you to access the `captures` field - `val_ptr` is a pointer to the field being matched against. the fields type will be the same type that was passed into the custom matcher. - `out_ptr` lets you write to the `out` of the arm, if you had any captures. for example, `out_ptr.hello = 2` would write 2 to the `hello` field of the output. you can only write to fields that were already declared as captures - return `true` if the value in `val_ptr` matches whatever criteria you want, or `false` if not  ## custom array matchers: these are similar to custom matchers, but they only work in array or slice patterns. `ref_rest(<name>)` is a custom array matcher. instead of having to have a pattern for the entire length of the array, you can match over part of it.  you can only have custom array matcher per array/slice pattern  ```test 'match: arrays' {     const list = [_]u8{ 0, 9, 100, 140 };     const m = comptime match(&list);     const res = m.arm(.{ 0, 9, 100, bind('num') });     const res2 = m.arm(.{ ref_rest('first2'), 100, 140 });     const res3 = m.arm(.{ bind('head'), ref_rest('tail') });     const res4 = m.arm(.{ 1, ref_rest('tail') });     const res5 = m.arm(.{ 0, ref_rest('middle'), 140 });      try std.testing.expectequal(140, res.?.num);     try std.testing.expectequalslices(u8, &.{ 0, 9 }, res2.?.first2);     try std.testing.expectequal(0, res3.?.head);     try std.testing.expectequalslices(u8, &.{ 9, 100, 140 }, res3.?.tail);     try std.testing.expectequal(null, res4);     try std.testing.expectequalslices(u8, &.{ 9, 100 }, res5.?.middle); } ```  to make your own, you need a thing of type `fn (comptime type, comptime ?usize) subslicematcher`. the first parameter is the child type of the array or slice, and the second is the length of the array, or null if it is a slice subslicematcher has a `captures` field similar to a custom matcher, as well as a `trybind` fn. the only difference is that instead of `val_ptr`, it will take `subslice`,  if the matched against type is an array, `subslice` will be a pointer to the subarray that is not matched against in the rest of the pattern if the matched againt type is a slice, `subslice` will be the subslice that is not matched against in the rest of the pattern ","tiawl/X11.zig":"X11 headers packaged for @ziglang # x11.zig  this is a fork of [hexops/x11-headers][1] which itself gather various [x11][2] headers [glfw][3] needs.  ## why this forkception ?  the intention under this fork is the same as [hexops][4] had when they opened their repository: gather [x11][2] headers and package them to compile [glfw][4] with [zig][5].  however this repository has subtle differences for maintainability tasks: * no shell scripting, * a cron runs every day to check [x11][2] repositories. then it updates this repository if a new release is available.  ## how to use it  the current usage of this repository is centered around [tiawl/glfw.zig][3] compilation. but you could use it for your own projects. headers are here and there are no planned evolution to modify them. see [tiawl/glfw.zig][3] to see how you can use it. maybe for your own need, some headers are missing. if it happens, open an issue: this repository is open to potential usage evolution.  ## dependencies  the [zig][5] part of this package is relying on the latest [zig][5] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [xorg/lib/libx11](https://github.com/tiawl/x11.zig/blob/trunk/.references/x11) * [xorg/lib/libxcb](https://github.com/tiawl/x11.zig/blob/trunk/.references/xcb) * [xorg/proto/xcbproto](https://github.com/tiawl/x11.zig/blob/trunk/.references/xcbproto) * [xorg/lib/libxcursor](https://github.com/tiawl/x11.zig/blob/trunk/.references/xcursor) * [xorg/lib/libxext](https://github.com/tiawl/x11.zig/blob/trunk/.references/xext) * [xorg/lib/libxfixes](https://github.com/tiawl/x11.zig/blob/trunk/.references/xfixes) * [xorg/lib/libxi](https://github.com/tiawl/x11.zig/blob/trunk/.references/xi) * [xorg/lib/libxinerama](https://github.com/tiawl/x11.zig/blob/trunk/.references/xinerama) * [xkbcommon/libxkbcommon](https://github.com/tiawl/x11.zig/blob/trunk/.references/xkbcommon) * [xorg/proto/xorgproto](https://github.com/tiawl/x11.zig/blob/trunk/.references/xorgproto) * [xorg/lib/libxrandr](https://github.com/tiawl/x11.zig/blob/trunk/.references/xrandr) * [xorg/lib/libxrender](https://github.com/tiawl/x11.zig/blob/trunk/.references/xrender) * [xorg/lib/libxscrnsaver](https://github.com/tiawl/x11.zig/blob/trunk/.references/xscrnsaver)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/glfw.zig][6]  this repository is automatically updated when a new release is available from these repositories: * [xorg/lib/libx11][2] * [xorg/lib/libxcb][7] * [xorg/proto/xcbproto][8] * [xorg/lib/libxcursor][9] * [xorg/lib/libxext][10] * [xorg/lib/libxfixes][11] * [xorg/lib/libxi][12] * [xorg/lib/libxinerama][13] * [xkbcommon/libxkbcommon][14] * [xorg/proto/xorgproto][15] * [xorg/lib/libxrandr][16] * [xorg/lib/libxrender][17] * [xorg/lib/libxscrnsaver][18] * [tiawl/toolbox][19] * [tiawl/spaceporn-action-bot][20] * [tiawl/spaceporn-action-ci][21] * [tiawl/spaceporn-action-cd-ping][22] * [tiawl/spaceporn-action-cd-pong][23]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/hexops/x11-headers [2]:https://gitlab.freedesktop.org/xorg/lib/libx11 [3]:https://github.com/glfw/glfw [4]:https://github.com/hexops [5]:https://github.com/ziglang/zig [6]:https://github.com/tiawl/glfw.zig [7]:https://gitlab.freedesktop.org/xorg/lib/libxcb [8]:https://gitlab.freedesktop.org/xorg/proto/xcbproto [9]:https://gitlab.freedesktop.org/xorg/lib/libxcursor [10]:https://gitlab.freedesktop.org/xorg/lib/libxext [11]:https://gitlab.freedesktop.org/xorg/lib/libxfixes [12]:https://gitlab.freedesktop.org/xorg/lib/libxi [13]:https://gitlab.freedesktop.org/xorg/lib/libxinerama [14]:https://gitlab.freedesktop.org/xkbcommon/libxkbcommon [15]:https://gitlab.freedesktop.org/xorg/proto/xorgproto [16]:https://gitlab.freedesktop.org/xorg/lib/libxrandr [17]:https://gitlab.freedesktop.org/xorg/lib/libxrender [18]:https://gitlab.freedesktop.org/xorg/lib/libxscrnsaver [19]:https://github.com/tiawl/toolbox [20]:https://github.com/tiawl/spaceporn-action-bot [21]:https://github.com/tiawl/spaceporn-action-ci [22]:https://github.com/tiawl/spaceporn-action-cd-ping [23]:https://github.com/tiawl/spaceporn-action-cd-pong ","eddineimad0/tomlz":"A Toml Parser written in zig a toml parser written in zig that targets v1.0 specs of toml.  ## supported zig versions ✅ [0.13.0](https://ziglang.org/documentation/0.13.0/)     ## test suite coverage [toml-test](https://github.com/toml-lang/toml-test) is a language-agnostic test suite to verify the correctness of toml parsers and writers.  currently for the parser only 2 tests(invalid set) are failing and 413 are passing.  ## usage ```zig const std = @import('std'); const toml = @import('tomlz'); const io = std.io; pub fn main() !void {     var gpa_allocator = std.heap.generalpurposeallocator(.{}){};     defer std.debug.assert(gpa_allocator.deinit() == .ok);     const allocator = gpa_allocator.allocator();      // the toml parser takes an allocator and uses it internally     for all allocations.     var p = toml.parser.init(gpa_allocator.allocator());     // when done deinit the parser to free all allocated resources.     defer p.deinit();       const toml_input =         ╲╲message = 'hello, world!'     ;     // the toml parser accepts a io.streamsource as an input source.     // the streamsource should live as long as the parser.     var toml_stream = io.streamsource{         .const_buffer = io.fixedbufferstream([]const u8){             .buffer = src,             .pos = 0,         },     };      // use parse to start parsing the input source.     var parsed = p.parse(&toml_stream) catch {         std.log.err('the stream isn't a valid toml document, {}╲n',.{err});         // handle error.     };      // parsed is of type toml.tomltable which is an alias to      // std.stringhashmap(tomlvalue).     // toml.tomlvalue type is a union with the following fields:     // pub const tomlvalue = union(tomltype) {     //     boolean: bool,     //     integer: i64,     //     float: f64,     //     string: []const u8,     //     array: []tomlvalue,     //     table: tomltable,     //     tablesarray: []tomltable,     //     datetime: datetime,     // };     // aside from datetime all other types are standard zig types.     // all data returned by the parser is owned by the parser and      // will be freed once deinit is called or if parse() is called again,     // consider cloning anything you need to outlive the parser.       var iter = parsed.iterator();     while (iter.next()) |pair| {         // the key is of type []const u8.         std.debug.print('╲n{s} => ', .{pair.key_ptr.*});         switch (pair.value_ptr.*) {             // ... do whatever         }     } } ```  ## build options the build.zig file contains various options that can be used to customize the behaviour of the parser when building, check it out for more details. ","nektro/zig-asn1":"Zig parser for ASN.1 DER binary encoding. # zig-asn1  zig parser for asn.1 der binary encoding.  - [itu x.680](https://www.itu.int/rec/dologin_pub.asp?lang=e&id=t-rec-x.680-202102-i!!pdf-e&type=items) abstract syntax notation one (asn.1) - [itu x.690](https://www.itu.int/rec/dologin_pub.asp?lang=e&id=t-rec-x.690-202102-i!!pdf-e&type=items) asn.1 encoding rules ","srjilarious/testz":"A testing library for zig  ![testz logo](images/testz.png)   ![version badge](https://img.shields.io/badge/version-0.5.2-brightgreen) ![zig version badge](https://img.shields.io/badge/zig%20version-0.13.0-%23f7a41d?logo=zig) ![license badge](https://img.shields.io/badge/license-mit-blue)  # overview  testz is a testing library for zig that provides some extra features compared to the built in unit testing.  - color output with both a verbose mode and non-verbose mode   - in verbose mode, you can see the name of each test run and how long it took to run.   - in both cases a test run summary lets you know how many tests ran and the overall time. - easy filtering by group tag or test name itself   - making it easier to set a breakpoint and debug a single test. - stack traces of relevant code only   - skips stack frames from `testz` itself as well as `main` where the test runner is called. - provides a test runner utility function with argument parsing for a default use case. - has a test discovery helper that searches for tests by finding public functions in a passed in module, allowing tests to be skipped by prepending `skip_` to the start of the function name.  testz runners are just another executable you setup in your `build.zig`, with the library providing a number of helpers to make it as easy as possible to create tests.  debugging is simple since you can run your debugger just like with any normal flat executable and use the built in filtering to narrow down what test or set of tests gets run.  # example  here's what the example project running a couple of tests in non-verbose mode looks like:  ![non-verbose output](images/non_verbose_output.png)  here's the verbose mode of output from the example project:  ![failing test example, verbose output](images/verbose_output.png)  ## code example  ### test module  here's what a module of tests looks like:  ```zig const std = @import('std'); const testz = @import('testz');  pub fn allownontestzerrorstest() !void {     const mem = try std.heap.page_allocator.alloc(u8, 10);     defer std.heap.page_allocator.free(mem);     try testz.expectequal(true, true); }  pub fn alwaysfailtest() !void {     try testz.fail(); }  pub fn successtest() !void {     try testz.expectequal(12, 12);     try testz.expectequalstr('hello', 'hello');     try testz.expectnotequal(10, 20);     try testz.expectnotequalstr('hello', 'world');     try testz.expecttrue(true);     try testz.expectfalse(false); }  pub fn skip_test() !void {     // nothing to see here. } ```  the test functions are simply any public function in a module you pass into `discovertests`.  the `testz` library has a number of `expectxyz` functions you can use to make assertions in your code.  if one fails, `testz` will capture the name of the failed test, error message, and stack trace (with contextual lines).  ### test runner   here is an example test runner program that you would create in your project.  it shows test discovery and using the built in test runner with standard argument parsing.  ```tests/main.zig const std = @import('std'); const testz = @import('testz');  const discoveredtests = testz.discovertests(.{      testz.group{ .name = 'expect tests', .tag = 'expect', .mod = @import('./expect_tests.zig') },      testz.group{ .name = 'misc tests', .tag = 'misc', .mod = @import('./misc_tests.zig') }  });  pub fn main() !void {     try testz.testzrunner(discoveredtests); } ```  the function `testsz.discovertests`, takes a tuple of either direct module `@import`s, or `testz.group` structs, which contain a group name and tag for filtering as well as the module to scan for test functions.  ### a `build.zig` setup  run `zig fetch --save https://github.com/srjilarious/testz` to add `testz` as a dependency in your `build.zig.zon` file.  next, in your `build.zig`, you would create a new exe for your tests and add:  ```zig     const testzmod = b.dependency('testz', .{});     [...]     testsexe.root_module.addimport('testz', testzmod.module('testz')); ``` see the project under `example/` for how this looks in a simple dummy project.  # planned features  the library has all of the initial features i set out to implement.  feel free to open an issue or open a pr if there is a feature you'd like to see!  ### roadmap / ideas - [ ] capture number of assertions in each test  ","arats-io/zig-regex-oniguruma":"Zig Regex Wrapper for Oniguruma # zig regex wrapper for oniguruma  using https://github.com/kkos/oniguruma.  oniguruma is a modern and flexible regular expressions library. it encompasses features from different regular expression implementations that traditionally exist in different languages.  ## usage  include the libregex-oniguruma into the `build.zig.zon` file.  ``` .dependencies = .{     .libregex-oniguruma = .{         .url = 'https://github.com/arats-io/zig-regex-oniguruma/archive/refs/tags/v0.1.0.tar.gz',         .hash = '12201fd38f467e6c64ee7bca53da95863b6c05da77fc51daf0ab22079ede57cbd4e2',     }, }, ``` ","echoptic/bitflags":"This repository has no description. # bitflags ## usage add this to your `build.zig`: ```zig const bitflags = b.dependency('bitflags', .{}); exe.root_module.addimport('bitflags', bitflags.module('root')); ``` and this to your source code: ```zig const bitflags = @import('bitflags'); ``` ## example ```zig const std = @import('std'); const assert = std.debug.assert; const bitflags = @import('bitflags');  // the `bitflags` function generates a struct that has all flags and needed padding. const flags = bitflags.bitflags(enum(u8) {     // the value `a`, at bit position `0`.     a = 0b00000001,     // the value `b`, at bit position `1`.     b = 0b00000010,     // the value `c`, at bit position `4`.     c = 0b00010000, });  pub fn main() !void {     const flags: flags = @bitcast(@as(u8, 0b10001));      // check which flags are used.     assert(flags.a and !flags.b and flags.c);      // you can also check flags like this, but you need to make sure that there are     // no unspecified bits present in the number or the result won't be correct.     assert(std.meta.eql(flags, .{ .a = true, .c = true }));      // if you don't think the input will contain only expected bit flags,     // you can use `bitflags.zerounused` to set all padding fields to 0.     assert(std.meta.eql(bitflags.zerounused(flags), .{ .a = true, .c = true })); } ``` ## zig version support currently supported zig version is the latest master. ","leecannon/zig-xbeam":"A very partial re-implementation of the rust crate crossbeam. # zig-xbream  this repo is a *very* partial (pull requests welcome) re-implementation of the rust crate [crossbeam](https://github.com/crossbeam-rs/crossbeam).  only the following types are implemented:  #### data structures  * `xbeam.queue.arrayqueue` - a bounded mpmc queue that allocates a fixed-capacity buffer on construction. * `xbeam.queue.arrayqueuenoalloc` - an implementation of `arrayqueue` that does not allocate.   #### utilities  * `xbeam.utils.backoff` - for exponential backoff in spin loops. * `xbeam.utils.cache_line_length` - replacement for the rust `cachepadded`, used like this:      ```zig      var aligned: usize align(xbeam.utils.cache_line_length) = 0;     ```   ### contributions are welcome!  ## how to use  download the repo somehow then either:  ### use a package manager  * [zigmod](https://github.com/nektro/zigmod) * [zkg](https://github.com/mattnite/zkg)  ### add as package in `build.zig`  * to `build.zig` add:       ```zig    exe.addpackagepath('xbeam', 'zig-xbeam/src/index.zig'); // or whatever the path is    ``` * then the package is available within any zig file:       ```zig    const xbeam = @import('xbeam');    ```  ### import directly  in any zig file add: ```zig const xbeam = @import('../zig-xbeam/src/index.zig'); // or whatever the path is from *that* file ``` ","GoNZooo/zig-humantime":"Mini library for expressing integer time values in more human readable ways # zig-humantime  this library exports two functions to convert human readable time strings into integer values:  ```zig test '1h2m3s' {     const time = comptime seconds('1h2m3s');     // @compilelog(time) -> 7446     testing.expectequal(time, 3723); }  test '2h4m6s' {     const time = comptime seconds('2h4m6s');     testing.expectequal(time, (3600 * 2) + (4 * 60) + 6); }  test '1h2m3s in milliseconds' {     const format_string = '1h2m3s';     const time = milliseconds(format_string);     // @compilelog(time) -> runtime value     testing.expectequal(time, comptime seconds(format_string) * 1000); }  test '5d4h3m2s' {     testing.expectequal(seconds('5d4h3m2s'), 446582); } ```","g41797/syslog":"Zig syslog client ![](_logo/syslogzig-removebg.png)  # <center>zig syslog client</center>  <center>  [![ci](https://github.com/g41797/syslog/actions/workflows/ci.yml/badge.svg)](https://github.com/g41797/syslog/actions/workflows/ci.yml)[![wiki](https://img.shields.io/badge/wikipedia-%23000000.svg?style=for-the-badge&logo=wikipedia&logocolor=white)](https://en.wikipedia.org/wiki/syslog) <img src='https://img.shields.io/badge/linux-fcc624?style=flat&logo=linux&logocolor=black' width='48' height='24'>&nbsp; <img src='https://img.shields.io/badge/macos-000000?style=flat&logo=apple&logocolor=white' width='48' height='24'>&nbsp; <img src='https://img.shields.io/badge/windows-0078d6?style=flat&logo=windows&logocolor=white' width='48' height='24'>&nbsp;  </center>     this is a [syslog](https://en.wikipedia.org/wiki/syslog) client library for zig:  |           |                                                                    | |-----------|:------------------------------------------------------------------:| | protocols |                              udp, tcp                              |   | rfc       | subset of [rfc5424](https://datatracker.ietf.org/doc/html/rfc5424) | | tested on |       mac, windows, linux                   |    for the curious: [it explained: syslog](https://www.paessler.com/it-explained/syslog)       ## hello, zig!       when client code calls ```zig     logger.write_info('hello, zig!'); ```  [syslog client](src/syslog.zig) sends following text message to syslog receiver process: > > <190>1 2024-10-09t09:07:11+00:00 blkf zigprocess 18548 1 - hello, zig! >           let's see what this message consist of:     | value | rfc definition  | description                                            | |:-----------:|:---------------:|:-------------------------------------------------------| |   190     |     prival      | [priority](#priority)                               | |   1     |     version     | always 1                                               | |   2024-10-09t09:07:11+00:00     |    timestamp    | full-date 't' full-time                                | |   blkf     |    hostname     | hostname or '-'                                        | |   zigprocess     |    app-name     | application name provided by caller                    | |   18548     |     procid      | process id or  '-'                                     | |   1     |      msgid      | message id - sequential number generated automatically | |   -     | structured-data | always '-'                                             | |   hello, zig!     |       msg       | message                                                |            ### priority  >              priority = facility * 8 + severity   **facility** represents the machine process that created the syslog event  | rfc5424.facility      | value | description | |:----------------------|  :---:           |          :--- | | .kern                 | 0  |     kernel messages | | .user                 | 1  |     random user-level messages | | .mail                 | 2  |     mail system | | .daemon               | 3  |     system daemons | | .auth                 | 4  |     security/authorization messages | | .syslog               | 5  |     messages generated internally by syslogd | | .lpr                  | 6  |     line printer subsystem | | .news                 | 7  |     network news subsystem | | .uucp                 | 8  |     uucp subsystem | | .cron                 | 9  |     clock daemon | | .authpriv             | 10 |     security/authorization messages (private) | | .ftp                  | 11 |     ftp daemon | | .local0               | 16 |     local use 0 | | .local1               | 17 |     local use 1 | | .local2               | 18 |     local use 2 | | .local3               | 19 |     local use 3 | | .local4               | 20 |     local use 4 | | .local5               | 21 |     local use 5 | | .local6               | 22 |     local use 6 | | .local7               | 23 |     local use 7 |            **severity** describes the severity level of the syslog message in question.  | level | rfc5424.severity | description | | :---:          |:-----------------|          :--- | |0| .emerg           |  system is unusable               | |1| .alert           |  action must be taken immediately | |2| .crit            |  critical conditions              | |3| .err             |  error conditions                 | |4| .warning         |  warning conditions               | |5| .notice          |  normal but significant condition | |6| .info            |  informational                    | |7| .debug           |  debug-level messages             |   ### quiz  what are *facility* and *severity* of **'hello, zig!'** message?  ### for leisure time  - [what is syslog?](https://www.auvik.com/franklyit/blog/what-is-syslog/) - [syslog-ng open source edition](https://www.syslog-ng.com/products/open-source-log-management/) - [the rocket-fast system for log processing](https://www.rsyslog.com/) - [old brave syslogd](https://linux.die.net/man/8/syslogd) - [kafka syslog connector](https://www.confluent.io/hub/confluentinc/kafka-connect-syslog) - [nats syslog connector](https://github.com/g41797/syslog2nats)  ## installation  add *syslog* to build.zig.zon: ```bach zig fetch --save=syslog git+https://github.com/g41797/syslog ```  add *syslog* to build.zig: ```zig     const syslog = b.dependency('syslog', .{         .target = target,         .optimize = optimize,     });      const lib = b.addstaticlibrary(..);     lib.root_module.addimport('syslog', syslog.module('syslog'));      const lib_unit_tests = b.addtest(...);     lib_unit_tests.root_module.addimport('syslog', syslog.module('syslog')); ```  import *syslog*:  ```zig const syslog = @import('syslog'); ```  ## usage  ### configuration  syslog uses following configuration: ```zig pub const syslogopts = struct {     // application:     name: []const u8 = 'zigprocess',     fcl: rfc5424.facility = .local7,      // transport:     proto: protocol = .udp,     addr: []const u8 = '127.0.0.1',     port: u16 = 514, }; ```  ### initialization  ```zig     var logger: syslog.syslog = .{};     try logger.init(std.testing.allocator, .{         .name = 'runner',         .fcl = .daemon         .port = 12345,     });     defer logger.deinit(); ```  after initialization you can call syslog on different threads.  ### logging   there are two groups of apis: - write: message is straight text  ```zig     pub inline fn write_<severity>(slog: *syslog, msg: []const u8) !void {...}     ....     logger.write_debug('hello, zig!'); ``` - print: message will be formatted before send ```zig     pub inline fn print_<severity>(slog: *syslog, comptime fmt: []const u8, msg: anytype) !void {...}     ....     const name = 'world';     logger.print_debug('hello, {s}!', .{name}); ```  ### filtering  set filter: ```zig     // disable send messages with .info & .debug severities     logger.setfilter(.info);// disable send messages with .info & .debug severities  ```  reset filter: ```zig     logger.setfilter(null);  ```  ## license [mit](license)   <br /> <center>  *powered by*  [![clion](_logo/clion_icon.png)][refclion]  [refclion]: https://www.jetbrains.com/clion/  </center>","tiawl/oniguruma.zig":"oniguruma packaged for @ziglang # oniguruma.zig  this is a fork of [kkos/oniguruma][1] to package the libonig c api for [zig][2]  ## why this fork ?  the intention under this fork is to package [kkos/oniguruma][1] for [zig][2]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`, * a cron runs every day to check [kkos/oniguruma][1]. then it updates this repository if a new release is available.  ## how to use it  the goal of this repository is not to provide a [zig][2] binding for [kkos/oniguruma][1]. there are at least as many legit ways as possible to make a binding as there are active accounts on github. so you are not going to find an answer for this question here. the point of this repository is to abstract the [kkos/oniguruma][1] compilation process with [zig][2] (which is not new comers friendly and not easy to maintain) to let you focus on your application. so you can use **oniguruma.zig**: - as raw (no available example now), - as a daily updated interface for your [zig][2] binding of [kkos/oniguruma][1] (no available exemple now).  ## dependencies  the [zig][2] part of this package is relying on the latest [zig][2] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [kkos/oniguruma](https://github.com/tiawl/oniguruma.zig/blob/trunk/.references/oniguruma)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/libjq.zig][3]  this repository is automatically updated when a new release is available from these repositories: * [kkos/oniguruma][1] * [tiawl/toolbox][4] * [tiawl/spaceporn-action-bot][5] * [tiawl/spaceporn-action-ci][6] * [tiawl/spaceporn-action-cd-ping][7] * [tiawl/spaceporn-action-cd-pong][8]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/kkos/oniguruma [2]:https://github.com/ziglang/zig [3]:https://github.com/tiawl/libjq.zig [4]:https://github.com/tiawl/toolbox [5]:https://github.com/tiawl/spaceporn-action-bot [6]:https://github.com/tiawl/spaceporn-action-ci [7]:https://github.com/tiawl/spaceporn-action-cd-ping [8]:https://github.com/tiawl/spaceporn-action-cd-pong ","travisstaloch/combinatorics.zig":"A port of Julia's combinatorics library along with miscellaneous related tools. # combinatorics.zig  an incomplete port of julia's [combinatorics library](https://github.com/juliamath/combinatorics.jl) along with miscellaneous related tools.  __warning__ this library is very immature, untested and may have bugs.  use at your own risk.  this library provides itertors over set permutations and combinations.  it also provides an [`nchoosek`](src/misc.zig) iterator.  `combination` set sizes are limited to 127.  `permutations` and `nthperm` set sizes are limited to 34.  for larger set sizes use `nthpermbig`, `permutationsbig`, `nchoosekbig` and `combinationsbig`.     # usage   ## get source   ### via [gyro](https://github.com/mattnite/gyro) package manager  - in console   - `$ gyro add --src github travisstaloch/combinatorics.zig` - in build.zig   - `const pkgs = @import('gyro').pkgs;`   - `pkgs.addallto(exe/lib/tests);`  ### otherwise   copy relevent files from src/ into your project or `git submodule` the entire project.   ## run tests to test this project ```console zig build test ```  or with gyro ```console gyro build test ```   ## examples look at the tests in [permutations.zig](src/permutations.zig), [combinations.zig](src/combinations.zig) and [misc.zig](src/misc.zig).  tests are usually found at the bottom of the files or directly after the thing they're testing.     # todo - export a c api - support larger sets by using big integers   - [x] nthpermbig and permutationsbig   - [x] nchoosekbig and combinationsbig","weskoerber/kewpie":"A simple query string parser for Zig. [![test](https://github.com/weskoerber/kewpie/actions/workflows/test.yaml/badge.svg)](https://github.com/weskoerber/kewpie/actions/workflows/test.yaml) [![docs](https://github.com/weskoerber/kewpie/actions/workflows/docs.yaml/badge.svg)](https://github.com/weskoerber/kewpie/actions/workflows/docs.yaml)  # kewpie  a simple query string parser for zig.  ## getting started  ### prerequisites  - [zig](https://ziglang.org/download) (`0.12.0` or newer)  ### installation  1. add kewpie as a dependency in your project using zig's package manager      ```console     zig fetch --save git+https://github.com/weskoerber/kewpie.git#0.1.1     ```  2. add kewpie module to your `build.zig`      ```zig     const kewpie = b.dependency('kewpie', .{         .target = target,         .optimize = optimize,     });     exe.root_module.addimport('kewpie', kewpie.module('kewpie'));     ```  ### usage  - parse entire query string into a hash map      ```zig     const std = @import('std');     const kewpie = @import('kewpie');      pub fn main() !void {         var gpa = std.heap.generalpurposeallocator(.{}){};         defer if (gpa.deinit() != .ok) @panic('leak');          const uri = try std.uri.parse('https://example.com?hello=world');          const query_params = try kewpie.parse(gpa.allocator(), uri);         defer query_params.deinit();          if (query_params.get('hello')) |value| {             // `value` holds the value `world`             // ...         }     }     ```  - parse the query string into an iterator      ```zig     const std = @import('std');     const kewpie = @import('kewpie');      pub fn main() !void {         const uri = try std.uri.parse('https://example.com?hello=world');          var query_params = kewpie.iter(uri);         while (query_params.next()) |param| {             // `param` holds a queryparam struct             // ...         }     }     ``` ","allyourcodebase/libmaxminddb":"Zig build of libmaxminddb library. # libmaxminddb  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## zig build of [libmaxminddb library](https://github.com/maxmind/libmaxminddb).  ### :rocket: usage  - add `libmaxminddb` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/allyourcodebase/libmaxminddb/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `libmaxminddb` dependency in `build.zig`.  ```zig const libmaxminddb_dep = b.dependency('libmaxminddb', .{     .target = target,     .optimize = optimize, }); const maxminddb_mod = libmaxminddb_dep.module('maxminddb'); <compile>.root_module.addimport('maxminddb', maxminddb_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/allyourcodebase/libmaxminddb/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/allyourcodebase/libmaxminddb/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/allyourcodebase/libmaxminddb.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/allyourcodebase/libmaxminddb/blob/main/license ","kassane/libzmq":"ZeroMQ core engine in C++, implements ZMTP/3.1 # zeromq  [![build status](https://github.com/zeromq/libzmq/actions/workflows/ci.yaml/badge.svg)](https://github.com/zeromq/libzmq/actions/workflows/ci.yaml) [![build status](https://ci.appveyor.com/api/projects/status/e2ks424yrs1un3wt?svg=true)](https://ci.appveyor.com/project/zeromq/libzmq) [![coverage status](https://coveralls.io/repos/github/zeromq/libzmq/badge.svg?branch=master)](https://coveralls.io/github/zeromq/libzmq?branch=master) [![conan center](https://shields.io/conan/v/zeromq)](https://conan.io/center/zeromq)  ## welcome  the zeromq lightweight messaging kernel is a library which extends the standard socket interfaces with features traditionally provided by specialised messaging middleware products. zeromq sockets provide an abstraction of asynchronous message queues, multiple messaging patterns, message filtering (subscriptions), seamless access to multiple transport protocols and more.  ## supported platforms <a name='#platforms'/>  libzmq is mainly written in c++98 with some optional c++11-fragments. for configuration either autotools or cmake is employed. see below for some lists of platforms, where libzmq has been successfully compiled on.  ### supported platforms with primary ci  | os and version                         | architecture            | compiler and version          | build system | remarks                                                                                                                               | |----------------------------------------|-------------------------|-------------------------------|--------------|---------------------------------------------------------------------------------------------------------------------------------------| | android ndk r25                        | arm, arm64, x86, x86_64 | llvm (see ndk)                | autotools    | draft                                                                                                                                       | | ubuntu 14.04.5 lts (trusty)            | amd64                   | clang 5.0.0                   | autotools    | stable, extras: gssapi, pgm, norm, c++98 mode only                                                                                    | | ubuntu 14.04.5 lts (trusty)            | amd64                   | gcc 4.8.4                     | autotools    | stable, draft, extras: gssapi, pgm, norm, tipc, ipv6, also poller=poll, poller=select, also valgrind and address sanitizer executions | | ubuntu 14.04.5 lts (trusty)            | amd64                   | gcc 4.8.4                     | cmake 3.12.2 | stable                                                                                                                                | | windows server 2012 r2                 | x86                     | visual studio 2008            | cmake 3.12.2 | draft                                                                                                                                 | | windows server 2012 r2                 | x86                     | visual studio 2010 sp1        | cmake 3.12.2 | draft                                                                                                                                 | | windows server 2012 r2                 | x86                     | visual studio 2012 update 5   | cmake 3.12.2 | draft                                                                                                                                 | | windows server 2012 r2                 | x86, amd64              | visual studio 2013 update 5   | cmake 3.12.2 | draft, stable (x86 release only), also poller=epoll                                                                                   | | windows server 2012 r2                 | x86                     | visual studio 2015 update 3   | cmake 3.12.2 | draft                                                                                                                                 | | windows server 2016                    | x86                     | visual studio 2017 15.9.6     | cmake 3.13.3 | draft                                                                                                                                 | | cygwin 3.0.0 on windows server 2012 r2 | amd64                   | gcc 7.4.0                     | cmake 3.6.2  | draft                                                                                                                                 | | msys2 ? on windows server 2012 r2      | amd64                   | gcc 6.4.0                     | cmake ?      | draft                                                                                                                                 | | mac os x 10.13                         | amd64                   | xcode 9.4.1, apple llvm 9.1.0 | autotools    | stable, draft                                                                                                                         | | mac os x 10.13                         | amd64                   | xcode 9.4.1, apple llvm 9.1.0 | cmake 3.11.4 | draft                                                                                                                                 |  note: the platforms are regularly updated by the service providers, so this information might get out of date without any changes on the side of libzmq. for appveyor, refer to https://www.appveyor.com/updates/ regarding platform updates. for travis-ci, refer to https://changelog.travis-ci.com/ regarding platform updates.  ### supported platforms with secondary ci  | os and version               | architecture               | compiler and version | build system | remarks | |------------------------------|----------------------------|----------------------|--------------|---------| | centos 6                     | x86, amd64                 | ?                    | autotools    |         | | centos 7                     | amd64                      | ?                    | autotools    |         | | debian 8.0                   | x86, amd64                 | ?                    | autotools    |         | | debian 9.0                   | arm64, x86, amd64          | ?                    | autotools    |         | | fedora 28                    | arm64, arm32, amd64        | ?                    | autotools    |         | | fedora 29                    | arm64, arm32, amd64        | ?                    | autotools    |         | | fedora rawhide               | arm64, arm32, amd64        | ?                    | autotools    |         | | redhat enterprise linux 7    | amd64, ppc64               | ?                    | autotools    |         | | suse linux enterprise 12 sp4 | arm64, amd64, ppc64, s390x | ?                    | autotools    |         | | suse linux enterprise 15     | amd64                      | ?                    | autotools    |         | | xubuntu 12.04                | x86, amd64                 | ?                    | autotools    |         | | xubuntu 14.04                | x86, amd64                 | ?                    | autotools    |         | | xubuntu 16.04                | x86, amd64                 | ?                    | autotools    |         | | xubuntu 18.04                | x86, amd64                 | ?                    | autotools    |         | | xubuntu 18.10                | x86, amd64                 | ?                    | autotools    |         |  ### supported platforms with known active users  at the time of writing, no explicit reports have been available. please report your experiences by opening a pr adding an entry or moving an entry from the section below.  under 'last report', please name either the sha1 in case of an unreleased version, or the version number in case of a released version.  | os and version | architecture      | compiler and version | build system | last report             | remarks | |----------------|-------------------|----------------------|--------------|-------------------------|---------| | solaris 10     | x86, amd64, sparc | gcc 8.1.0            | cmake        | 2019/03/18              |         | | dragonfly bsd  | amd64             | gcc 8.3              | autotools    | 2018/08/07 git-72854e63 |         | | ibm i          | ppc64             | gcc 6.3              | autotools    | 2019/10/02 git-25320a3  |         | | qnx 7.0        | x86_64            | gcc 5.4.0            | cmake        | 4.3.2                   |         | | windows 10     | arm64             | visual studio 2019   | cmake        | 2021/11/15 git-2375ca8b |         | | windows 10     | arm64             | clang                | cmake        | 2021/11/15 git-2375ca8b |         |  ### supported platforms without known active users  note: this list is incomplete and inaccurate and still needs some work.  | os and version         | architecture | compiler and version     | build system     | remarks | |------------------------|--------------|--------------------------|------------------|---------| | any linux distribution | x86, amd64   | gcc ?+, clang ?+, icc ?+ | autotools, cmake |         | | sunos, solaris         | x86, amd64   | sunpro                   | autotools, cmake |         | | gnu/kfreebsd           | ?            | ?                        | autotools, cmake |         | | freebsd                | ?            | ?                        | autotools, cmake |         | | netbsd                 | ?            | ?                        | autotools, cmake |         | | openbsd                | ?            | ?                        | autotools, cmake |         | | dragonfly bsd          | amd64        | gcc 8.3                  | autotools, cmake |         | | hp-ux                  | ?            | ?                        | autotools, cmake |         | | gnu/hurd               | ?            | ?                        | autotools        |         | | vxworks 6.8            | ?            | ?                        | ?                |         | | windows ce             | ?            | ?                        | ?                |         | | windows uwp            | ?            | ?                        | ?                |         | | openvms                | ?            | ?                        | ?                |         |  ### unsupported platforms  | os and version | architecture | compiler and version | remarks                                                                 | |----------------|--------------|----------------------|-------------------------------------------------------------------------| | qnx 6.3        | ?            | gcc 3.3.5            | see #3371, support was added by a user, but not contributed to upstream |  for more details, see [here](supportedplatforms.md).  for some platforms (linux, mac os x), [prebuilt binary packages are supplied by the zeromq organization](#installation). for other platforms, you need to [build your own binaries](#build).  ## installation of binary packages <a name='installation'/>  ### linux  for linux users, pre-built binary packages are available for most distributions. note that draft apis can change at any time without warning, pick a stable build to avoid having them enabled.  #### latest releases  ##### deb  [![obs release stable](https://img.shields.io/badge/obs%20master-stable-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3arelease-stable&package=libzmq3-dev) [![obs release draft](https://img.shields.io/badge/obs%20master-draft-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3arelease-draft&package=libzmq3-dev)  ##### rpm  [![obs release stable](https://img.shields.io/badge/obs%20master-stable-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3arelease-stable&package=zeromq-devel) [![obs release draft](https://img.shields.io/badge/obs%20master-draft-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3arelease-draft&package=zeromq-devel)  #### bleeding edge packages  ##### deb  [![obs release stable](https://img.shields.io/badge/obs%20master-stable-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3agit-stable&package=libzmq3-dev) [![obs release draft](https://img.shields.io/badge/obs%20master-draft-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3agit-draft&package=libzmq3-dev)  ##### rpm  [![obs release stable](https://img.shields.io/badge/obs%20master-stable-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3agit-stable&package=zeromq-devel) [![obs release draft](https://img.shields.io/badge/obs%20master-draft-yellow.svg)](http://software.opensuse.org/download.html?project=network%3amessaging%3azeromq%3agit-draft&package=zeromq-devel)  #### example: debian 9 latest release, no draft apis      echo 'deb http://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/debian_9.0/ ./' >> /etc/apt/sources.list     wget https://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/debian_9.0/release.key -o- | sudo apt-key add     apt-get install libzmq3-dev  ### osx  for osx users, packages are available via brew.      brew install zeromq  ## installation of package manager <a name='package manager'/>  ### vcpkg  vcpkg is a full platform package manager, you can easily install libzmq via vcpkg.      git clone https://github.com/microsoft/vcpkg.git     ./bootstrap-vcpkg.bat # for powershell     ./bootstrap-vcpkg.sh # for bash     ./vcpkg install zeromq  ## build from sources <a name='build'/>  to build from sources, see the install file included with the distribution.  ### android  to build from source, see [readme](./builds/android/readme.md) file in the android build directory.  ## resources  extensive documentation is provided with the distribution. refer to doc/zmq.html, or 'man zmq' after you have installed libzmq on your system.  website: http://www.zeromq.org/  development mailing list: zeromq-dev@lists.zeromq.org announcements mailing list: zeromq-announce@lists.zeromq.org  git repository: http://github.com/zeromq/libzmq  zeromq developers can also be found on the irc channel #zeromq, on the libera chat network (irc.libera.chat).  ## license  the project license is specified in license.  libzmq is free software; you can redistribute it and/or modify it under the terms of the mozilla public license version 2.0.  ## contributing  this project uses [c4(collective code construction contract)](https://rfc.zeromq.org/spec:42/c4/) process for contributions. ","nektro/zig-iso-3166-countrys":"Zig package for ISO 3166 Country Codes # zig-iso-3166-countrys  iso 3166 country codes  https://www.iso.org/iso-3166-country-codes.html  ## license  0bsd ","liyu1981/tmpfile.zig":"a convenient util to use tmp files with zig # tmpfile.zig  ## why  so far as i found there is no good lib in `zig` for creating temp files, so i write one for myself. this util file provides methods to create temp dir or temp file in system temp folder less tedious and manageable.  see code for example  ```zig var tmp_file = try thismodule.tmpfile(.{}); defer tmp_file.deinit(); // file will be deleted when deinit try tmp_file.f.writeall('hello, world!'); try tmp_file.f.seekto(0); var buf: [4096]u8 = undefined; var read_count = try tmp_file.f.readall(&buf); try testing.expectequal(read_count, 'hello, world!'.len); try testing.expectequalslices(u8, buf[0..read_count], 'hello, world!'); ```  or complexer  ```zig var tmp_dir = try thismodule.tmpdirowned(.{}); defer {     tmp_dir.deinit();     tmp_dir.allocator.destroy(tmp_dir); }  var tmp_file = try thismodule.tmpfile(.{ .tmp_dir = tmp_dir }); defer tmp_file.deinit(); try tmp_file.f.writeall('hello, world!'); try tmp_file.f.seekto(0); var buf: [4096]u8 = undefined; var read_count = try tmp_file.f.readall(&buf); try testing.expectequal(read_count, 'hello, world!'.len); try testing.expectequalslices(u8, buf[0..read_count], 'hello, world!');  var tmp_file2 = try thismodule.tmpfile(.{ .tmp_dir = tmp_dir }); defer tmp_file2.deinit(); try tmp_file2.f.writeall('hello, world!2'); try tmp_file2.f.seekto(0); read_count = try tmp_file2.f.readall(&buf); try testing.expectequal(read_count, 'hello, world!2'.len); try testing.expectequalslices(u8, buf[0..read_count], 'hello, world!2'); ```  ## useage  use zig packager  ```bash zig fetch --save https://github.com/liyu1981/tmpfile.zig/archive/refs/heads/main.tar.gz ```  (or lock on any commit as) ```bash zig fetch --save zig fetch https://github.com/liyu1981/zcmd.zig/archive/<commit hash>.tar.gz ```  this lib is also provided for `build.zig`, use like  ```zig // in build.zig const tmpfile = @import('tmpfile').tmpfile; ```  ## license  mit ","kassane/zbpf":"Write bpf in Zig # zbpf writing ebpf in zig. thanks to zig's comptime and btf, we can equip ebpf with strong type system both at comptime and runtime!  ## notable advantages when writing ebpf program with `zbpf`  ### different available methods based on the type of program's context  suppose you want to trace the kernel function [path_listxattr](https://github.com/torvalds/linux/blob/7475e51b87969e01a6812eac713a1c8310372e8a/fs/xattr.c#l856-l857), and here's its prototype:  ``` static ssize_t path_listxattr(const char __user *pathname, char __user *list,             size_t size, unsigned int lookup_flags) ``` as you can see, it has 4 input parameters and return type is `ssize_t`. with `ctx = bpf.kprobe{.name = 'path_listxattr'}.ctx()`, you could retrieve the input parameter with `ctx.arg0()`, `ctx.arg1()`, `ctx.arg2()` and `ctx.arg3()` respectively, and return value with `ctx.ret()`. the type will be consistent with the above prototype. if you try to access a non-existing parameter, e.g. `ctx.arg4()`, you will get a compilation error.  this also applies to `syscall` with `bpf.ksyscall`, `tracepoint` with `bpf.tracepoint` and `fentry` with `bpf.fentry`.  ### no more tedious error handling  when writing in c, you always have to check the error conditions (the return value of the helper function, pointer validation, ...) with `zbpf`, you won't care about the these cases, we handle it under the hood for you, just focus on the business logic.  the following are some examples:  - `bpf.map` takes care bpf map's `update` and `delete` error. - `bpf.perfeventarray` handles event output failure. - `bpf.ringbuffer` also handles space reservation. - `bpf.xdp` validates the pointer for you.  if some error happens, you could get all the information (file, line number, return value ...) you need to debug in the kernel trace buffer:  ``` ~> sudo bpftool prog tracelog test-11717   [005] d..21 10990692.273976: bpf_trace_printk: error occur at src/bpf/map.zig:110 return -2 ```  ## how to use  ## prerequisite  - make sure the linux kernel is built with `config_debug_info_btf=y`. - the only runtime library is `libc` (this is not even necessary if you build with musl-libc).  ## build  - download the [lastest zig](https://ziglang.org/download/). - clone this repostory. - build with `zig build -dbpf=/path/to/your/bpf/prog.zig -dmain=/path/to/your/main.zig`.  for cross-compiling, you could specify the target with `-dtarget=<target>`, the list of all supported targets could be retrieved by `zig targets`.  moreover, you could specify the target kernel with `-dvmlinux=/path/to/vmlinux` to extract btf from it, otherwise, current kernel's btf will be used.  that's all! the generated binary is located at `./zig-out/bin/zbpf`, feel free to run it on your target machine.  here's the [documentations generated by zig's autodoc](https://tw4452852.github.io/zbpf) for you reference.  ## tools/trace  `trace` is a tool built on top of `zbpf` framework to trace kernel functions and syscalls. it's heavily inspired by [retsnoop](https://github.com/anakryiko/retsnoop). one improvement i made (which is also what i feel when using retsnoop) is that `trace` support show parameters according its type (thanks to the zig type system). this is very helpful when debugging linux kernel. for more details, you could check the implementation: [bpf side](https://github.com/tw4452852/zbpf/blob/main/src/trace.bpf.zig) and [host side](https://github.com/tw4452852/zbpf/blob/main/src/trace.zig).  you could specify the kernel functions you want to trace with: `zbpf build trace -dkprobe=<kernel_function_name> -dkprobe=...` and for system calls: `zbpf build trace -dsyscall=<syscall_name> -dsyscall=...`. you could even mix them.  and here's a quick demo:  [![asciicast](https://asciinema.org/a/620205.svg)](https://asciinema.org/a/620205)  ## samples  for each supported feature, we have the corresponding unit test. you could find them under `samples/` (bpf side) and `src/tests` (host side). build it with `zig build test -dtest=<name>` and run it with `sudo zig-out/bin/test`.  name | bpf side | host side --- | --- | --- exit | [source](samples/exit.zig) | [source](src/tests/exit.zig) panic | [source](samples/panic.zig) | [source](src/tests/panic.zig) trace_printk | [source](samples/trace_printk.zig) | [source](src/tests/trace_printk.zig) array | [source](samples/array.zig) | [source](src/tests/array.zig) hash | [source](samples/hash.zig) | [source](src/tests/hash.zig) perf_event | [source](samples/perf_event.zig) | [source](src/tests/perf_event.zig) ringbuf | [source](samples/ringbuf.zig) | [source](src/tests/ringbuf.zig) tracepoint | [source](samples/tracepoint.zig) | [source](src/tests/tracepoint.zig) iterator | [source](samples/iterator.zig) | [source](src/tests/iterator.zig) fentry | [source](samples/fentry.zig) | [source](src/tests/fentry.zig) kprobe | [source](samples/kprobe.zig) | [source](src/tests/kprobe.zig) kmulprobe | [source](samples/kmulprobe.zig) | [source](src/tests/kmulprobe.zig) xdp ping | [source](samples/xdp_ping.zig) | [source](src/tests/xdp_ping.zig)  **have fun!** ","nektro/zig-intrusive-parser":"Core plumbing to make text or binary document parsers with Data Oriented Design # zig-intrusive-parser ![loc](https://sloc.xyz/github/nektro/zig-intrusive-parser) [![license](https://img.shields.io/github/license/nektro/zig-intrusive-parser.svg)](https://github.com/nektro/zig-intrusive-parser/blob/master/license)  core plumbing to make text or binary document parsers with data oriented design  ## used by  - https://github.com/nektro/zig-json - https://github.com/nektro/zig-webidl  ## license  mpl-2.0 ","nektro/zig-flag":"Config management for Zig. # zig-flag  config management for zig.  ## built with - zig master     - https://github.com/ziglang/zig - zigmod package manager     - https://github.com/nektro/zigmod  - https://github.com/nektro/zig-extras  ## install ``` zigmod aq add 1/nektro/flag ```  ## license mit ","andrewrk/libogg":"libogg with the build system replaced by zig this is a fork of [ogg](https://github.com/xiph/ogg), packaged for zig. unnecessary files have been deleted, and the build system has been replaced with `build.zig`. ","eldesh/basis_concept-zig":"A collection of basis concept and their operations # basis concept zig  **basis_concept-zig** is a collection library of 'basis concept' and some operations on them. some basic concepts such as `copyable` are provided.   ## concept  *concept* are named constraints on types such as `clonable`.   in the zig language, polymorphic functions are sometimes typed `fn (anytype) t`. often, however, functions with such types implicitly require some properties for their types. the `concept` allows such implicit constraints to be named.  naming such implicit constraint allows us to deal explicitly with constraints on types. further, some associated polymorphic functions are able to be implemented to each concept such like `cloneable.clone`.   ## examples  ### equivalence of generic data type  to compare equivalence of data of various types:  ``` /// a type constructed from various `iseq` types const s = struct {   val_int: u32,   val_opt: ?u8,   val_eit: error{myerror}![5]u8, };  const s1: s = ...; const s2: s = ...; if (eq.eq(&s1, &s2)) {     ... } ```   ### check for cloneability  when you want to implement `clone` on a container type only for types that are clonable.  ``` pub fn container(comptime t: type) type {   return struct {     pub const self: type = @this();     pub const cloneerror: type = std.mem.allocator.error;     ..     pub usingnamespace if (isclonable(t))       struct {         pub fn clone(self: *const self) cloneerror!self {           .. t.clone() ..         }       }     else       struct {}; // empty   }; }  // for a clonable type c: var c = container(c); var d = try c.clone(); // clonable  // for a not clonable type n: var n = container(n); // _ = try n.clone(); // compilation error ```   ### comparison by total order  when you want to pass an ordering function for a key type of a mapping container.  ``` var map: map(key, value) = makekeyvaluemap(key, value, ord.on(key)); map.insert(key1, value1); map.insert(key2, value2); ... ```   ## support  this library is developped with:  - debian (x86_64) 10.4 - zig 0.9.1 with zigmod r79 - zig 0.10.0 with zigmod r80   ## build  to build, executing the following commands:  ```sh zigmod fetch zig build ```   ## unit test  to performs unit tests:  ```sh zig build test ```   ## generate docs  to generate documents:  ```sh zig build doc ```  a html documents would be generated under the `./docs` directory.   ## provided concept  - trivialeq   concept for types that trivially comparable value with `==`.   this concept is defined for checking the type is comparable with `==`.   then any extra method is not provided.  - trivialdestroy   concept for types that trivially destroyable implicitly.   then any extra method is not provided.  - copyable   trivially copyable values with `=`.   `copy` means to duplicate a value that has no resources shared with the original one.   in other words, it must not contain a pointer.  - clonable   duplicable values using `clone` method if exists.   similar to copyable, `clonable` means that the value can be duplicated. however, the concept can be satisfied if the `clone` method is implemented even if the value cannot be copied in the trivial way.   in other words, if a type is `copyable`, it is automatically `clonable` as well.  - partialeq   `partialeq` concept means that a partial equivalence relation is defined for the type.   the partiality comes from the fact that the relation does not require reflexivity.   that is, the relation must satisfy the following properties. for all x, y and z:    - `partialeq.eq(x, y) == partialeq.eq(y, x)`   - `partialeq.eq(x, y) == partialeq.eq(y, z) == partialeq.eq(x, z)`  - eq   `eq` concept means that a full equivalence relation is defined for the type.   addition to `partialeq`, this concept requires relations to have reflexivity.    - `eq.eq(x, y) == eq.eq(y, x)`   - `eq.eq(x, y) and eq.eq(y, z)` implies `eq.eq(x, z)`   - `eq.eq(x, x)`    furthermore, this concept also contains `ne` method, which must be consistent with `eq`.  - partialord   `partialord` concept means parial ordering relation.   such relations require the type satisfies properties and have consistensy to `partialeq`.    - `partialord.partial_cmp(x, y).?.compare(.eq)` implies `partialeq.eq(x, y)`   - `partialord.partial_cmp(x, y).?.compare(.le)` implies `partialord.partial_cmp(x, y).?.compare(.lt) or partialeq.eq(x, y)`   - `partialord.partial_cmp(x, y).?.compare(.ge)` implies `partialord.partial_cmp(x, y).?.compare(.lt) or partialeq.eq(x, y)`   - ord   concept for types that forms total order.   implementations must be consistent with `partialord`.    - `ord.cmp(x, y) == partialord.partial_cmp(x, y).?`  - destroy   the `destroy` concept provides an interface for destroying values.   values of types implementing this concept can be destroyed by `destroy(@this())` or `destroy(@this(), std.mem.allocator)`.   ## module hierarchy   - basis_concept (the root module)     - copy     - iscopyable     - clone         - isclonable         - clone     - partial_ord         - ispartialord         - partialord     - ord         - isord         - ord     - trivial_eq         - istrivialeq     - partial_eq         - ispartialeq         - partialeq     - eq         - iseq         - eq     - trivial_destroy         - istrivialdestroy     - destroy         - destroy     - prelude         - clone         - partialeq         - partialord         - ord         - eq         - destroy   ## concept convention  implementations of concept on types, are follows some conventions. for any concept `c`, `implc`, `isc` and `c` maybe implemented.  - `fn implc(comptime t:type) bool`       determine if the type `t` satisfies concept `c` directly.  - `fn isc(comptime t:type) bool`       determine if the type `t` satisfies concept `c`.  - `const c = struct { ... };`       namespace `c` that implements generic functions that depend on the concept `c`.  - `fn derivec(comptime t:type) type`       derive functions that depend on `c`.  ","basdp/skia-zig":"Zig bindings for the Skia 2D Graphics Library <p align='center'>     <h1 align='center'>skia zig bindings</h1> </p>  <p align='center'>     <a href='https://github.com/basdp/skia-zig/actions/workflows/build.yml'><img src='https://github.com/basdp/skia-zig/actions/workflows/build.yml/badge.svg' /></a> </p>  <p align='center'>zig bindings for the famous <a href='https://skia.org/'>skia 2d graphics library</a>.</p>  ## overview  this repository provides zig bindings to the skia c api. it builds skia for multiple platforms and exposes the raw c headers to be used directly in zig projects. **no wrappers** are provided—this is a low-level binding to the c layer only.  this repository is using the [skia fork from the mono project](https://github.com/mono/skia), as they actively maintain a c wrapper for skia (which is c++ only). we need c wrappers to bridge to zig.   ## features  - pre-built skia binaries - exposes the raw skia c api headers to zig - easy to import and use directly from zig code without any dependencies or extra build steps  ## project status *warning*: this wrapper is in a very early stage and is _not_ stable for production use. also not all features and plaforms are implemented.  - [x] skia build for windows x86_64 - [ ] skia build for macos x86_64 - [ ] skia build for macos apple silicon - [ ] skia build for linux  ## getting started  ### usage  1. import the `skia-zig` package into your project: ```bash zig fetch --save https://github.com/basdp/skia-zig/releases/latest/download/skia-zig-package.zip ```  2. add the dependency to your `build.zig` file, somewhere below `b.addexecutable(...)` or whatever you are building:  ```zig const skia_dep = b.dependency('skia-zig', .{     .target = target,     .optimize = optimize, }); exe.root_module.addimport('skia-zig', skia_dep.module('skia-zig')); ```  3. you can now import `skia-zig` in your zig code: ```zig const skia = @import('skia-zig');  pub fn main() !void {     const gr_glinterface = skia.gr_glinterface_create_native_interface();     defer skia.gr_glinterface_unref(gr_glinterface);     const gr_context = skia.gr_direct_context_make_gl(gr_glinterface) orelse return error.skiacreatecontextfailed;     defer skia.gr_direct_context_free_gpu_resources(gr_context);      const gl_info = skia.gr_gl_framebufferinfo_t{         .ffboid = 0,         .fformat = gl.rgba8,     };      const samples: c_int = ... // get from gl or something     const stencil_bits: c_int = ... // get from gl or something      const backendrendertarget = skia.gr_backendrendertarget_new_gl(640, 480, samples, stencil_bits, &gl_info) orelse return error.skiacreaterendertargetfailed;      const color_type = skia.rgba_8888_sk_colortype;     const colorspace = null;     const props = null;     const surface = skia.sk_surface_new_backend_render_target(@ptrcast(gr_context), backendrendertarget, skia.bottom_left_gr_surface_origin, color_type, colorspace, props) orelse return error.skiacreatesurfacefailed;     defer skia.sk_surface_unref(surface);      const canvas = skia.sk_surface_get_canvas(surface) orelse unreachable;      while (/* app is running */) {         skia.sk_canvas_clear(canvas, 0xffffffff);          const fill = skia.sk_paint_new() orelse return error.skiacreatepaintfailed;         defer skia.sk_paint_delete(fill);         skia.sk_paint_set_color(fill, 0xff0000ff);         skia.sk_canvas_draw_paint(canvas, fill);          // your skia drawing here          skia.sk_canvas_flush(canvas);     } } ```   ### setting your abi to msvc on windows  skia requires the `msvc` abi on windows, so make sure you target that abi. there are two possible  options to do so (only one of these is necessary):  1. set the target from the command line while building:      ```bash     zig build -dtarget=x86_64-windows-msvc     ```  2. or better yet; replace the `const target = ...` line in your `build.zig` file:      ```zig     const target = b.standardtargetoptions(.{ .default_target = .{         .abi = if (b.graph.host.result.os.tag == .windows) .msvc else null,     } });     ``` ","ikskuh/zig-ode":"Zig ODE sdk # zig-ode ","nektro/zig-cookies":"This repository has no description. # zig-cookies","travisstaloch/case":"a case conversion and detection library in zig with a c api # case a case conversion and detection library in zig  cases supported: camelcase, pascalcase, snake_case, constant_case, kebab-case, header-case, lower case, upper case, capital case  ## [lib.zig](src/lib.zig)  uses readers and writers throughout. supports non-allocating and comptime use.   * `to(case, reader, writer)` - converts to case from reader into writer * `of(text)` - return `case` of text. may be 'unknown'. * `bufto(buf, case, text)` - writes converted text to buf in specified case * `allocto(allocator, case, text)` - allocates a buffer and writes converted text to buffer in specified case * `alloctoz()` - same as allocto() but null terminated * `comptimeto(case, text)` - allocates buffer at comptime * `comptimetolen(case, text, len)` - same as comptimeto() but allows user to specify buffer len * `length(case, text)` - returns length needed to convert text to case * `iscamel(text)` - true if text case is camel. similar methods for each case * `upper(reader, writer, opts), camel(reader, writer)` - conversion functions for each case. upper(), lower() and capital() have an additional opts param. * `toext(case, reader, writer, opts)` there are variants of all 'to' methods such as `toext(), lengthext()`. these are for upper, lower and capital cases when you want to specify options. * `opts: options`   * fill - string used to replace non alpha numeric characters.  default empty.  when empty, don't replace non alpha numeric characters.   * apostrophe - keep / remove.  default keep.  ## c api  * [c_api.zig](src/c_api.zig) - exports methods similar to most public zig methods above * [case.h](src/case.h)   * `case` enum guaranteed to be in sync with `case` enum in lib.zig  ## tests  `$ zig build test` runs the following   * [tests.zig](src/tests.zig) - pretty thorough zig tests which also test the c api methods   * [test.c](src/test.c) - a small demo program which exercises the c api   ## build  `$ zig build`  creates `zig-out/lib/libcase.a` and `zig-out/include/case.h`  * zig package manager support  ## related [nbubna/case](https://github.com/nbubna/case)  ## inspiration thanks to [cmgriffing](https://github.com/cmgriffing) for suggesting this ","bcrist/Zig-TempAllocator":"Arena allocator for interactive programs and simulations 404: not found","kassane/sanitizers-zig":"LLVM sanitizers for zig-toolchain # llvm sanitizers for zig  ## description  this is a collection of sanitizers for zig. it is a work in progress.   ## requirements  - [zig](https://ziglang.org/download/) v0.13.0 or master  ## add  - [x] addresssanitizer - [ ] memorysanitizer - [x] undefinedbehaviorsanitizer - [x] leaksanitizer - [x] realtimesanitizer (llvm 20)  ## supported platforms  - [x] linux (gnu|musl) - [ ] windows - [ ] macos   ## experimental real-time sanitizer (llvm 20)  > [!note] > this is an experimental feature and is not yet ready for production use. > currently, zig master version is llvm 19. my tests use zig-fork w/ llvm 20.  ```bash $ zig build rtsan -dtests real-time violation: intercepted call to real-time unsafe function `malloc` in real-time context! stack trace:     #0 0x00000102e659  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102e659)     #1 0x00000102bf80  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102bf80)     #2 0x00000102bef5  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102bef5)     #3 0x00000102c23c  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102c23c)     #4 0x00000102cdc1  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102cdc1)     #5 0x0000010891f7  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x10891f7)     #6 0x00000102b824  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102b824)     #7 0x00000102b7a2  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102b7a2)     #8 0x00000102b713  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102b713)     #9 0x00000102b42c  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102b42c)     #10 0x00000102b10e  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102b10e)     #11 0x00000102aeaa  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102aeaa)     #12 0x00000102adc8  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102adc8)     #13 0x00000102ae25  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102ae25)     #14 0x77feed58de07  (/usr/lib/libc.so.6+0x25e07) (buildid: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3)     #15 0x77feed58decb  (/usr/lib/libc.so.6+0x25ecb) (buildid: 98b3d8e0b8c534c769cb871c438b4f8f3a8e4bf3)     #16 0x00000102ad74  (/home/kassane/sanitizers-llvm/.zig-cache/o/18b7cbe81f65f9f9049547f69b71a77e/test-rtsan+0x102ad74)  rtsan └─ run test-rtsan failure error: the following command exited with error code 1: ```  ### references  - official-doc: https://clang.llvm.org/docs/realtimesanitizer.html - base: https://github.com/realtime-sanitizer/rtsan","rockorager/msgpack-zig":"msgpack encoding and decoding in zig | msgpack.org[Zig] # msgpack-zig  msgpack-zig provides a simple api for encoding and decoding msgpack data. the api is designed to similar to `std.json`. msgpack inherently requires less allocation than json so the return values are slightly different.  > [!important] > msgpack-zig uses zig 0.13.0  ## usage  > [!note] > refer to the [documentation](https://rockorager.github.io/msgpack-zig/) for additional usage.  there are two main functions provided by msgpack-zig:  ```zig /// pack a given type as a msgpack value pub fn pack(comptime t: type, writer: std.io.anywriter) anyerror!void {}  /// unpack the next msgpack value from reader as type t pub fn unpack(comptime t: type, reader: std.io.anyreader) anyerror!void {} ```  for packing, any type which has a function signature `msgpackpack(self: t, writer: std.io.anywriter) anyerror!void` will use this function has for packing. otherwise it will be packed using the defaults.  likewise, unpacking types can implement `msgpackunpack(writer: std.io.anywriter) anyerror!t` to unpack from a stream, or `msgpackunpackfromvalue(value: msgpack.value) anyerror!t` to unpack from a msgpack.value.  ## value  msgpack values are stored internally as a tagged union. note that we impose a limitation on maps: the keys *must* be strings, similar to json (the msgpack specification allows for any msgpack type to be a key).  ```zig pub const value = union(enum) {     i64: i64,     u64: u64,     f64: f64,     nil: void,     bool: bool,     str: []const u8,     bin: []const u8,     array: []value,     map: std.stringhashmap(value),     ext: struct {         id: i8,         data: []const u8,     }, }; ```  ## roadmap  - [ ] automatic unpacking of `map` to structs ","notCalle/parzig":"Parser Combinator library for Zig [![zig-nightly](https://github.com/notcalle/parzig/workflows/zig-nightly/badge.svg)](https://github.com/notcalle/parzig/actions?query=workflow%3azig-nightly) [![zig-v0.8.0](https://github.com/notcalle/parzig/workflows/zig-v0.8.0/badge.svg)](https://github.com/notcalle/parzig/actions?query=workflow%3azig-v0.8.0)  # parzig  a parser combinator library for [zig].  ## install  - git submodule    ```shell   git submodule add https://github.com/notcalle/parzig lib/parzig   ```    ```zig   const parzig = pkg { .name = 'parzig', .path = 'lib/parzig/exports.zig' };   ```  - import declaration for [`zkg`]    ```zig   pub const parzig = zkg.import.git(       'https://github.com/notcalle/parzig',       'main',       null,   );   ```  ## examples  - party ghosts vs ghost parties    ```zig   usingnamespace @import('parzig');    const ghost = char('👻');   const party = char('🥳');    const ghost = '👻';   const party = '🥳';    test 'ghost party' {       const ghostparty = ghost.seq(party));       const ghost_party = ghost ++ party;       const party_ghost = party ++ ghost;        std.testing.expectequalslices(           u8,           ghost_party,           ghostparty.parse(ghost_party).value().?,       );        std.testing.expect(.none == ghostparty.parse(party_ghost));   }   ```  - numeric expression evaluator    ```zig   usingnamespace @import('parzig');    const expression = parser(struct {       pub fn parse(input: input) result(i32) {           return term.opt(addsub.seq(term)).map(evalexpression);       }   });    const term = parser(struct {       pub fn parse(input: input) result(i32) {           return factor.opt(muldiv.seq(factor)).map(evalterm);       }   });    const factor = parser(struct {       pub fn parse(input: input) result(i32) {           return opt(char('-')).seq(number.or(paren)).map(evalfactor);       }   });    const number = parser(struct {       pub fn parse(input: input) result(i32) {           return charrange('0', '9').many1.map(evalnumber);       }   });    const paren = parser(struct {       pub fn parse(input: input) result(i32) {           return char('(').seq(expression).seq(char(')')).map(evalparen);       }   });    // ...    test '' {       std.testing.expectequal(           result(i32).some(7, ''),           expression.parse('-(1-2)*3+4'),       );   }   ```  [zig]: https://ziglang.org [`zkg`]: https://github.com/mattnite/zkg ","Chanyon/minimd-zig":"simple markdown parser ### simple-markdown-parse  ---  ### markdown grammar  - headline    ```      # heading1 => <h1></h1>      ## heading2 => <h2></h2>      ### heading3 => <h3></h3>      #### heading4 => <h4></h4>      ##### heading5 => <h5></h5>      ###### heading6 => <h6></h6>    ```  - paragraph    ```      hello world      <p>hello world</p>    ```  - strong    ```      **test** => <strong>test</strong>      *test* => <em>test</em>      ***test*** => <strong><em>test</em></strong>      __hello__ => <strong>test</strong>    ```  - blockquote    ```      > hello => <blockquote>hello</blockquote>        > hello      >      >> world       => <blockquote>hello<blockquote>world</blockquote></blockquote>     ```  - separation line    ```      --- => <hr>    ```  - link    ```      [link](https://github.com/) => <a href='https://github.com/'>link</a>      <https://github.com> => <a href='https://github.com/'>https://github.com</a>    ```  - image    ```      ![img](/assets/img/philly-magic-garden.jpg)      => <img src='/assets/img/philly-magic-garden.jpg' alt='img'>        [![image](/assets/img/ship.jpg)](https://github.com/chanyon)      => <a href='https://github.com/chanyon'><img src='/assets/img/ship.jpg' alt='image'></a>'    ```  - delete line    ```      ~~test~~ => <p><s>test</s></p>      hello~~test~~world => <p>hello<s>test</s>world</p>    ```  - code    ```    `test` => <code>test</code>    `` `test` `` => <code> `test` </code>    =```      {       'width': '100px',       'height': '100px',      'fontsize': '16px',      'color': '#ccc',      }     =```     => <pre><code><br>{<br>  'width': '100px',<br>  'height': '100px',<br>  'fontsize': '16px',<br>  'color': '#ccc',<br>}<br></code></pre>    ```    - footnote    ```    test[^1]    [^1]: ooooo    =>  <p>test<a id='src-1' href='#target-1'>[1]</a></p>    <section>    <p><a id='target-1' href='#src-1'>[^1]</a>:  ooo</p>    </section>    ```  - task list    ```    - [ ] task one    - [x] task two    ```  - table    ```    | syntax      | description | test |    | :---------- | ----------: | :-----: |    | header      | title       |  will |    | paragraph   | text        |  why  |    ```    - unordered list    ```    - test      - test2          - test3      - test4    - test5    - test6    ```  - ordered list    ```    1. test      1. test2          1. test3      2. test4    2. test5    3. test6    ```  - escape characters    ```     ╲[╲]     ╲<test╲>     ╲*test╲* ╲! ╲# ╲~ ╲-     ╲_ test ╲_ ╲(╲)    ```    ### done  - [x] 无序列表  - [x] 有序列表  - [x] 表格语法  - [x] 内嵌html  - [x] 脚注(footnote)  - [x] task list   - [x] 转义字符  - [x] html tag inline style  - [x] 代码块高亮 ╲```c ```  - [x] 标题目录","allyourcodebase/zstd":"zstd ported to the zig build system [![ci](https://github.com/allyourcodebase/zstd/actions/workflows/ci.yaml/badge.svg)](https://github.com/allyourcodebase/zstd/actions)  # zstd  this is [zstd](https://github.com/facebook/zstd), packaged for [zig](https://ziglang.org/).  ## installation  first, update your `build.zig.zon`:  ``` # initialize a `zig build` project if you haven't already zig init zig fetch --save git+https://github.com/allyourcodebase/zstd.git#1.5.6-1 ```  you can then import `zstd` in your `build.zig` with:  ```zig const zstd_dependency = b.dependency('zstd', .{     .target = target,     .optimize = optimize, }); your_exe.linklibrary(zstd_dependency.artifact('zstd')); ``` ","zhuyadong/xterm256.zig":"print text with xterm256 style [中文](readme.cn.md) | [english](readme.md) # print text with `xterm256` colors and styles ## install in the project root directory: ```shell zig fetch 'git+https://github.com/zhuyadong/xterm256.zig' --save=xterm256 ``` if you want to install a specific version: ```shell zig fetch 'git+https://github.com/zhuyadong/xterm256.zig#<ref id>' --save=xterm256 ```  ## usage examples ```zig const xterm = @import('xterm256');  // print 'hello' in red xterm.print(.{.fg = .red}, 'hello', .{});  // print 'hello' in red with a white background xterm.print(.{.fg = .{.r=5}, .bg = .white}, 'hello', .{});  // print 'hello' with color number 222 xterm.print(.{.fg = .x222}, 'hello', .{});  // print 'hello' in bold red xterm.print(.{.fg = .red, .style = .{.bold}}, 'hello', .{});  // if there is a `prefix`, only the `prefix` part will be colored xterm.print(.{.fg = .red, .prefix='error:'}, ' something wrong.', .{});  // save the sequence to print 'hello' in red to buf var buf: [128]u8 = undefined; _ = try xterm.bufprint(&buf, .{.fg = .red}, 'hello', .{});  // complex style const complexstyle = .{     .fg = .x222,     .bg = .{.b = 5, .g = 5},     .style = .{.bold, .underline},     .prefix = 'complex:', }; xterm.print(complexstyle, 'hello', .{}); ``` ## style definition format ```zig .{     .fg = <color>,     .bg = <color>,     .style = .{.style1, .style2 ...},     .prefix='prefix text' } ``` where `<color>` can be one of the following formats: - .<color_name> - .{.r=[0,5], .g=[0-5], .b=[0-5]} - .{.gray=[0-23]} > in the `rgb` format, you can omit 1-2 of `r`, `g`, `b`  `<color_name>` includes the following items: - .x[16-255] - .black - .red - .green - .yellow - .blue - .magenta - .cyan - .white - .bright_black - .bright_red - .bright_green - .bright_yellow - .bright_blue - .bright_magenta - .bright_cyan - .bright_white  `style` includes the following items: - .bold - .italic - .underline - .slowblink - .rapidblink - .reverse - .invisible - .strikethrough","nektro/zig-sqlite3":"sqlite3 wrapper for Zig # zig-sqlite3 sqlite3 wrapper for zig.  contains sqlite 3.38.0 ","weskoerber/mac_address":"A cross-platform library to retrieve the MAC address from your network interfaces without libc. [![test](https://github.com/weskoerber/mac_address/actions/workflows/test.yaml/badge.svg)](https://github.com/weskoerber/mac_address/actions/workflows/test.yaml) [![docs](https://github.com/weskoerber/mac_address/actions/workflows/docs.yaml/badge.svg)](https://github.com/weskoerber/mac_address/actions/workflows/docs.yaml)  # `mac_address`  a cross-platform library to retrieve the mac address from your network interfaces without `libc`.  ## requirements  - [zig](https://github.com/ziglang/zig) compiler (`0.12.0` or newer)[^1]  ## install  first, add the dependency to your `build.zig.zon` using `zig fetch`:  ```console zig fetch --save git+https://github.com/weskoerber/mac_address#main ```  then, import `mac_address` into your `build.zig`:  ```zig const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const mac_address = b.dependency('mac_address', .{             .target = target,             .optimize = optimize,     }).module('mac_address');      const my_exe = b.addexecutable(.{         .name = 'my_exe',         .root_source_file = b.path('src/main.zig'),         .target = target,         .optimize = optimize,     });      my_exe.root_module.addimport(mac_address); } ```  ## usage  see the `examples` directory for example usage. example executables can be built by setting the `examples` option to `true`:  ```zig     const mac_address = b.dependency('mac_address', .{             .target = target,             .optimize = optimize,             .examples = true,     }).module('mac_address'); ```  ## cross-platform support  | `mac_address` api  | linux | windows | | ------------------ | ----- | ------- | | `getall`           | ✅    | ✅      | | `getallnoloopback` | ✅    | ✅      |  - ✅ = supported - 📝 = planned - ❌ = not supported  ---  [^1]: shameless plug: if you're using a unix-like operating system or wsl on     windows, consider using a zig compiler version manager i wrote called     [zvm](https://github.com/weskoerber/zvm). once downloaded and in your     `path`, just run `zvm install 0.12.0` (or `zvm install master` to get the     latest nightly). ","cksac/faker-zig":"A faker library for Zig # faker.zig a faker library for zig  # examples ```zig const faker = @import('faker'); const std = @import('std'); const en = faker.locale.en; const base = faker.locale.base; const print = std.debug.print;  fn genericstype(comptime t: type) type {     return struct {         data: t,     }; }  pub fn main() !void {     // create faker with locales and random     const allocator = std.heap.page_allocator;     var rng = std.rand.defaultprng.init(0);     const f = faker(.{ .locales = .{ en, base } }).init(allocator, rng.random());      // primitive types     const u8_val = f.dummy(u8);     print('u8_val = {}╲n', u8_val);      const f32_val = f.dummy(f32);     print('f32_val = {}╲n', f32_val);      // arrays and vectors     const arr_val = f.dummy([3]u8);     print('arr_val = {}╲n', arr_val);      const multi_dim_arr_val = f.dummy([2][3]u8);     print('multi_dim_arr_val = {}╲n', multi_dim_arr_val);      const vec_val = f.dummy(@vector(4, i32));     print('vec_val = {}╲n', vec_val);      // struct     const point = struct {         x: f32,         y: f32,     };     const point_val = f.dummy(point);     print('point_val = {}╲n', point_val);      const generic_val = f.dummy(genericstype(u8));     print('generic_val = {}╲n', generic_val);      // enum     const enumtype = enum {         ok,         not_ok,     };     const enum_val = f.dummy(enumtype);     print('enum_val = {}╲n', enum_val);      // union     const uniontype = union(enumtype) {         ok: u8,         not_ok: void,     };     const union_val = f.dummy(uniontype);     print('union_val = {}╲n', union_val);      // strings     const str_val = f.dummy([]const u8);     print('str_val = {s}╲n', str_val);      // customization     const blogunmanaged = struct {         const self = @this();          id: u32,         tag: []const u8,         title: []u8,         body: []u8,          pub fn deinit(self: self, allocator: allocator) void {             allocator.free(self.title);             allocator.free(self.body);         }          pub const @'faker.fields' = struct {             pub const tag = .{ 'color', 'human' };             pub const title = .{ 'lorem', 'words', .{ .min = 5, .max = 10 } };              pub fn body(comptime opt: anytype, f: faker.faker(opt)) []u8 {                 return f.lorem.words(.{ .min = 20, .max = 30 });             }         };     };      const blog = f.dummy(blogunmanaged);     defer blog.deinit(f.allocator);     std.debug.print('blog.id {d}╲n', .{blog.id});     std.debug.print('blog.tag {s}╲n', .{blog.tag});     std.debug.print('blog.title {s}╲n', .{blog.title});     std.debug.print('blog.body {s}╲n', .{blog.body});      // user impls     const non_null_option = struct {         pub fn is(             comptime t: type,         ) bool {             return @typeinfo(t) == .optional;         }          pub fn dummy(comptime t: type, comptime opt: anytype, f: faker.faker(opt)) t {             const info = @typeinfo(t).optional;             return f.dummy(info.child);         }     };      const user = struct {         const self = @this();         id: u32,         friends: ?std.arraylist(u8),          pub fn deinit(self: self) void {             if (self.friends) |v| v.deinit();         }     };     const f2 = faker.faker(.{         .locales = .{ en, base },         .user_impls = .{non_null_option},     }).init(allocator, rng.random());      const user_val = f2.dummy(user);     defer user_val.deinit();     print('user_val = {}╲n', user_val); } ```  # credit faker-zig was inspired by and use locale data generated from [faker-js/faker v8.1.0](https://github.com/faker-js/faker) commit: https://github.com/cksac/faker-zig/commit/5a5f9072541bab9ce4728a03b1126298f81a9260  # orignal faker-js/faker license faker - copyright (c) 2022-2023  this software consists of voluntary contributions made by many individuals. for exact contribution history, see the revision history available at https://github.com/faker-js/faker  permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'software'), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:  the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.  the software is provided 'as is', without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.  ===  from: https://github.com/faker-js/faker/commit/a9f98046c7d5eeaabe12fc587024c06d683800b8 to: https://github.com/faker-js/faker/commit/29234378807c4141588861f69421bf20b5ac635e  based on faker.js, copyright marak squires and contributor, what follows below is the original license.  ===  faker.js - copyright (c) 2020 marak squires http://github.com/marak/faker.js/  faker.js was inspired by and has used data definitions from:   * https://github.com/stympy/faker/ - copyright (c) 2007-2010 benjamin curtis  * http://search.cpan.org/~jasonk/data-faker-0.07/ - copyright 2004-2005 by jason kohles  permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'software'), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:  the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.  the software is provided 'as is', without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software. ","bcrist/microbe":"Embedded Zig framework for ARM microcontrollers 404: not found","dasimmet/zig-raspberry-pico-sdk":"This repository has no description. # raspberry pico-sdk on the zig buildsystem  ## requirements  - zig 0.13.0 or higher - ~~libudev-dev for libusb on linux~~  the last zig version i built against (ubuntu linux 24.04 x86_64):  ```console foo@bar:~$ zig version 0.14.0-dev.2164+6b2c8fc68 ```  ## picotool  this repo builds the raspberry picotool from the sdk source on the zig buildsystem:  ```console foo@bar:~$ zig build run picotool:     tool for interacting with rp2040/rp2350 device(s) in bootsel mode, or with an rp2040/rp2350 binary  synopsis:     picotool info [-b] [-p] [-d] [--debug] [-l] [-a] [device-selection]     picotool info [-b] [-p] [-d] [--debug] [-l] [-a] <filename> [-t <type>]     picotool config [-s <key> <value>] [-g <group>] [device-selection]     picotool config [-s <key> <value>] [-g <group>] <filename> [-t <type>]     picotool load [--ignore-partitions] [--family <family_id>] [-p <partition>] [-n] [-n] [-u] [-v] [-x] <filename> [-t <type>] [-o <offset>]                 [device-selection]     picotool link [--quiet] [--verbose] <outfile> [-t <type>] <infile1> [-t <type>] <infile2> [-t <type>] [<infile3>] [-t <type>] [-p] <pad>     picotool save [-p] [device-selection]     picotool save -a [device-selection]     picotool save -r <from> <to> [device-selection]     picotool verify [device-selection]     picotool reboot [-a] [-u] [-g <partition>] [-c <cpu>] [device-selection]     picotool otp list|get|set|load|dump|permissions|white-label     picotool partition info|create     picotool uf2 info|convert     picotool version [-s] [<version>]     picotool coprodis [--quiet] [--verbose] <infile> [-t <type>] <outfile> [-t <type>]     picotool help [<cmd>]  commands:     info        display information from the target device(s) or file.                 without any arguments, this will display basic information for all connected rp2040 devices in bootsel mode     config      display or change program configuration settings from the target device(s) or file.     load        load the program / memory range stored in a file onto the device.     link        link multiple binaries into one block loop.     save        save the program / memory stored in flash on the device to a file.     verify      check that the device contents match those in the file.     reboot      reboot the device     otp         commands related to the rp2350 otp (one-time-programmable) memory     partition   commands related to rp2350 partition tables     uf2         commands related to uf2 creation and status     version     display picotool version     coprodis    post-process coprocessor instructions in disassembly files.     help        show general help or help for a specific command  use 'picotool help <cmd>' for more info ```  ## picotool zig build interface  ```zig // build.zig const pico_sdk = @import('zig-raspberry-pico-sdk'); const load_step = pico_sdk.load(b, .{     .firmware = lazypath_to_firmware_uf2,     .execute = true,     .sudo = b.option(bool, 'load-with-sudo', 'run picotool load with sudo') orelse false, }, .{}); b.step('load').dependon(load_step); ``` ","alichraghi/basis-universal-zig":"Zig binding of Basis Universal # note: moved to https://github.com/hexops/mach  ## basis universal zig  zig binding of basis universal _compatible with [v16.3](https://github.com/binomialllc/basis_universal/tree/1.16.3)_  ### usage  see `test 'encode/transcode'` in `src/main.zig` for usage example ","zigster64/datastor.zig":"Data persistence library for Zig # datastor.zig  fast & light data persistence layer for zig  ## version log  - dec 2023 - v0.0.0 - init project - jan 2024 - v0.2.0 - new key types (serial / uuid / string)  ## intended use is for:  - object persistence using local storage, for edge / iot / local game world, etc - thread safe for use in a single process only - persist table, timeseries and tree structured data - situations where using an external db would be overkill - where performance is more important than general flexibility  on disk format uses s2s format for object storage (see https://github.com/ziglibs/s2s)  s2s is battle tested code, but it does lack a few types that it can serialize out of the box. you can code around this easy enough, but its something you should be aware of.  ---   ## not intended for :  - any situation where the entire dataset will not fit in memory - scalable, multi-process database backends. - general purpose data persistence. datastor has a highly opinionated approach to dealing with static vs timeseries data. that may not suit the way your data is structured. - current data format uses native `usize` quite a bit, so the datafiles are not 100% portable between machines with different word sizes.  for any of the 'not intended' use cases above, best look at options such as sqlite, duckdb for embedded dbs or server based postgresql w/ timeseriesdb extensions over the network.  references:  - [postgres libraries for zig](http://github.com/karlseguin/pg.zig) - [duckdb libraries for zig](http://github.com/karlseguin/zuckdb.zig) - [sqlite for zig](https://github.com/search?q=language:zig%20sqlite&type=repositories) - [mysql for zig](https://github.com/search?q=language:zig%20mysql&type=repositories) - [redis for zig](https://github.com/search?q=language:zig%20redis&type=repositories)  ----  ## project scope - how it works  `datastor.zig` provides an embedded 'object persistence' api for collections of zig types.  in concept, a datastor is a light comptime wrapper around your struct, that provides :  - an ordered hashmap collection of elements, synched to disk - crud operations against that collection - a single 'primary key' stored as extra metadata against the user-supplied struct - primary keys can be one of : (serial number, uuid, custom string) - timeseries extension, to provide each record in a table with an unlimited audit trail of state transitions - timeseries handy functions to get element state at a point in time / events over a period, etc - handles tagged union data, so each table may store multiple variants of a type, but still using a strict schema across types - handles tree structured data, so you can optionally overlay a heirachy on top of your collection - utility functions for tree data to reparent nodes, or move nodes up and down within their parent block  the example directory contains a large number of example scenarios, datastores, and reports.  the wiki contains a structured walk through tutorial for how to use the different datastore types.  ---  # types of datastore  ## [table data](#table-data)  for 2d tables, where each row is an instance of your data struct, with additional metadata to record the key, etc.  example: a table of customer information.  ## [tree data](#tree-data)  for tree structured data, where each row is an instance of your data struct, with additional metadata that references the parent row.  example: a tree of projects within a heirachy of projects  ## [timeseries data](#timeseries-data)  for streaming / event / state transition data, where each row is an instance of your event data, with additional metadata to  reference the parent record, and a timestamp for when the record was created.  example: lets say we have a game, with a table of 'monster'.  we can add a timeseries datastore, which tracks the (x,y) location and current hitpoints of any monster at each turn in the game. this keeps the original monster table un-modified, and tracks an audit trail of state transitions for  all monsters in a separate timeseries array.  ---  # operations on a datastore  | function | description | notes | |---|---|---| | load() | loads the datastore from disk | | | save() | saves the datastore to disk | | | items() []record | returns an ordered arraylist of all items in the datastore | caller owns the arraylist, must free() after use | | append(value) key | add an item to the datastore. will compute a new primary key for the record | returns the value of the newly computed primary key for the new record | | put(key, value) | updates the value of the record with the given key || | get(key) record | returns the record with the given key || | delete(key) | deletes the record with the given key | 'deleted' records are kept on disk, but marked as invalid | | vacuum() | vacuum will strip out all deleted records from the datastore, and re-number the serial primary keys, plus any referenced records in timeseries datastores || | select(filterfn) []record | returns an ordered arraylist of all the items that match the given filter. the filter is a function that takes the record value, and returns true if it matches | caller owns the arraylist, and must free() after use | | migrate(oldstruct, newstruct) | converts existing datastores from the old record structure to a new record structure ||    ---  # types of keys  ## serial  tables with a serial primary key.   when a new record is added to a table, it automatically gets assigned to (number of records + 1)  ## uuid  uuid primary keys generate a new random uuidv4 value when new records are created  ## string  a string key is a custom user-generated key for new records  the owning structure must define a function to generate a new key based on the record contents, and the record number  for table datastores : `pub fn newid(self, allocator, record_number) []const u8`  for tree datastores, optionally include this function :  `pub fn newnodeid(self, allocator, parent_key, record_number, sibling_count) []const u8` ... or fallback to `newid()` if newnodeid() is not provided   ---   # table data  a table is a collection of records, where each record is mapped to a zig struct, and has a unique key that identifies that record.  records are stored on disk in insert order, and retrieving all the records from the store are also in the original insert order.  create a table type:  |function| description | notes | |--------|-------------|-------| | table(itemtype) type | returns a new type, representing a table datastore, with a serial key || | tablewithkey(itemtype, keytype) type | returns a new type, representing a table datastore, with the specified key type | key can be one of .serial, .uuid, .string |  init / deinit a table:  |function| description | notes | |--------|-------------|-------| | init(allocator, filename) !table | returns a new instance of a table, with the associated file || | deinit() | frees up memory allocated by the table. this includes memory allocated for each record | if the base struct for the store includes a `free(allocator)`, this will be called on each record |  table specific operations  |function| description | notes | |--------|-------------|-------| | append(itemtype) !keytype | appends a new record to the store. returns the value of the generated key | the new records are not saved to disk, until save() is called on the store, to allow updates to be batched. |  ---  # tree data  create a tree type  |function| description | notes | |--------|-------------|-------| | tree(itemtype) type | returns a new type, representing a tree datastore, with a serial key || | treewithkey(itemtype, keytype) type | returns a new type, representing a tree datastore, with the specified key type | key can be one of .serial, .uuid, .string |   init / deinit a tree:  |function| description | notes | |--------|-------------|-------| | init(allocator, filename) !table | returns a new instance of a table, with the associated file || | deinit() | frees up memory allocated by the table. this includes memory allocated for each record | if the base struct for the store includes a `free(allocator)`, this will be called on each record |  table specific functions. all the functions that are available to a table also apply to a tree.  tree specific operations  |function| description | notes | |--------|-------------|-------| | putnode(parent_key, key, value) !void ||  ---   ## timeseries data  ---  ---  # everything from here down needs to be rewritten / deleted     ## intial state information vs state transitions  datastor takes a highly opinionated approach to separating data persistence between 'static' data, and 'timeseries' data.  static data is for : - initial state data / config / assets - may be updated occassionally after initial boot - static data is explicitly loaded and saved to and from disk using functions `table.load()` and `table.save()` - there is no per-record disk i/o. `load()` loads the whole table from disk, and `save()` saves the whole table to disk  timeseries data is for : - recording state transitions in the static data, after system start - timestamped audit trail of events for each element of static data - timeseries data is loaded on `table.load()`, and automatically appended to disk on every `table.addevent(event)` - disk i/o is per record - everytime a new timeseries event is added   the api considers that the initial state of an item, and its collection of events over time, form a single coherent entity with a single logical api.  on disk, its splits these into 2 files - 1 file for the initial static data, that is only occassionally updated (if ever), and 1 other file for the timeseries / event  data, that is frequently appended to.  the datastor api then wraps this as a single storage item.  --- # wrapped datatype  for any given struct t, the datastor will maintain a collection of   itemtype(t)  which is a wrapper around your original struct t.  this itemtype(t) wrapper includes extra fields such as the unique id of this record, the id of the parent record, etc.  example - creating a datastor on this type : ```zig const mydatatype = struct {   x: usize,   y: usize, } ```  using key type `usize`, will create a wrapper object around mydatatype that adds an `id` field of type usize, and several extra convenience functions.  ie ```zig struct {   id: usize,   value: mydatatype, } ```  when you `put()` or `append()` to the datastor, you pass in `mydatatype`  when you `get()` or iterate over the `items()` in the datastor, you get back the wrapped type, so you have access to the  unique id associated with your original data.  ie: ```zig for (db.items()) |item| {    std.debug.print('item with id {d}:', .{item.id});    std.debug.print('value: {}╲n', .{item.value}); } ``` ---  todo - rewrite from here down   # api overview  ## for static-only data :  | function | description | |----------|-------------| | table(comptime k:type, comptime t:type) |  returns a table object that wraps a collection of (struct) t<br><br>t must have a function `free()` if it contains fields that are allocated on load (such as strings) |  | table.init(allocator, filename: []const u8) | initialises the table | | table.deinit()                              | free any memory resources consumed by the table | | | | | table.load() !void                          | explicitly load the collection from disk | | table.save() !void                          | explicitly save the data to disk | | | | | table.items() []item                          | returns a slice of all the items in the table, in insertion order | | table.get(id) ?item                            | gets the element of type t, with the given id (or null if not found) | | | | | table.put(t)                                | add or overwrite element of type t to the table. does not write to disk yet. batch up many updates, then call `save()` once |  | table.append(t) usize  (autoincrement !)          | adds a new element of type t to the table, setting the id of the new record to the next value in sequence. returns the new id<br><br>if the base type has a function `newid(count: usize) keytype`, then it uses that to get the next key value |   autoincrement note - datatsor calculates the 'next sequence' as `table.len + 1`, which is quick and simple enough.  if loading data into a datastor, then use one method or the other, but avoid mixing them together, as the id forms the key in the hashtable.  ## for static + timeseries data :  | function | description | |----------|-------------| | tablewithtimeseries(comptime t:type, comptime eventt: type) |  returns a table object that wraps a collection of (struct) t, with an unlimited array of eventt events attached<br><br>t must have a field named `id:usize` that uniquely identifies the record<br>t must have a function `free()` if it contains fields that are allocated on load (such as strings)<br><br>eventt must have a field named `parent_id:usize` and `timestamp:i64` |  | table.init(allocator, table_filename: []const u8, event_filename: []const u8) | initialises the table  | | table.deinit()                              | free any memory resources consumed by the table | | | | | table.load() !void                          | explicitly load the collection from disk | | table.save() !void                          | explicitly save the data to disk | | | | | table.items() []t                          | returns a slice of all the items in the table, in insertion order | | table.get(id) ?t                           | gets the element of type t, with the given id (or null if not found) | | | | | table.put(t)                                | add or overwrite element of type t to the table. does not write to disk yet. batch up many updates, then call `save()` once |  | table.append(t) usize  (autoincrement !)          | adds a new element of type t to the table, setting the id of the new record to the next value in sequence. returns the new id | | | | | timeseries functions | | | table.eventcount() usize                    | how many events all up ? | | table.eventcountfor(id: usize) usize       | how many events for the given element ?| | | | | table.getallevents() []eventt               | get all the events for all elements in this datastor, in timestamp order | | table.geteventsbetween(from, to: i64) arraylist(eventt) | get an arraylist of all events between to 2 timestamps.<br><br>caller owns the list and must `deinit()` after use | | table.geteventsfor(id: usize) arraylist(eventt) | get an arraylist for all events asssociated with this element in the datastor.<br><br>caller owns the list and must `deinit()` after use | | table.geteventsforbetween(id: usize, from, to: i64) arraylist(eventt) | get an arraylist of all events for element matching id, between to 2 timestamps.<br><br>caller owns the list and must `deinit()` after use | | | | | table.addevent(event)                       | add the given event to the collection. will append to disk as well as update the events in memory | | table.latestevent(id: usize)               | get the latest event for element matching id | | table.eventat(id: usize, timestamp: i64)   | get the state of the element matching id at the given timestamp. will return the event that is on or before the given timestamp |   ## tree / heirachy table support  in order to be treated as a tree, elements of the table must have a field `parent_id: usize`  for tagged union types, the tagged union must provide 2 functions `getparentid() usize` and `setparentid(usize)`   | function | description | |----------|-------------| | getchildren(parent_id) arraylist(t) | returns an arraylist(t) of child nodes with this parent.<br><br>caller owns the arraylist and must `deinit()` after use |  --- # table data examples  ## define a cat struct that can be used as a datastor  ```zig const cat = struct {     id: usize = 0,     breed: []const u8,     color: []const u8,     length: u16,     aggression: f32,      const self = @this();      // struct must supply a free() function for the datastor to manage cleaning up memory allocations     pub fn free(self: self, allocator: std.mem.allocator) void {         allocator.free(self.breed);         allocator.free(self.color);     } } ```  ## load a datastor based on our cat struct  ```zig pub fn load_simple_table() !void {     const gpa = std.heap.page_allocator;      var catdb = try datastor.table(cat).init(gpa, 'db/cats.db');     defer catdb.deinit();     try catdb.load();      // print out all the cats      for (catdb.items() |cat| {         std.debug.print('cat {d} is a {s} {s}, that is {d} inches long, with an aggression rating of {:.2f}╲n', .{             cat.id,             cat.color,             cat.breed,             cat.length,             cat.aggression,         });     }      // update one of the cats to be more aggressive, and save the datastor     var my_cat = catdb.get(2) orelse return;     my_cat.aggression += 0.1;     catdb.put(my_cat);     catdb.save(); } ```  produces output: ```zig cat 0 is id: 1 breed: siamese color: white length: 30, aggression factor: 7.00e-01 cat 1 is id: 2 breed: burmese color: grey length: 24, aggression factor: 6.00e-01 cat 2 is id: 3 breed: tabby color: striped length: 32, aggression factor: 5.00e-01 cat 3 is id: 4 breed: bengal color: tiger stripes length: 40, aggression factor: 9.00e-01 ```  ---   # timeseries data examples  so far so good. our virtural world is now populated with a group of cats.  however, our cats (when they are not sleeping), like to get up and move around.  we need to track where are cats are and what they are doing.  but we dont want to have to keep overwritting state information against our cats everytime something happens.  we can get around this by adding timeseries data to each cat. timeseries data is a fast append-only, timestamped record of events that tracks what happens with a cat at a point in time.  using a timeseries log, we keep the original state information about all our cats in a pristine condition, and can use the timeseries data to quickly work out what state any cat is in at a point in time.  ## example - define timeseries / event data for each cat  ```zig // a timeseries record of events that are associated with a cat const catevent = struct {     parent_id: usize = 0, // parent_id is the id of the cat that this event belongs to     timestamp: i64,     x: u16,     y: u16,     attacks: bool,     kills: bool,     sleep: bool,     description: []const u8,      const self = @this();      // events struct must also supply a free() function for the datastor to manage cleaning up memory allocations     // since the event contains a string 'description' that is allocated on demand.     pub fn free(self: self, allocator: std.mem.allocator) void {         allocator.free(self.description);     } } ```  ## example - load cats+timeseries data, and run several different reports  ```zig pub fn cats_with_timeseries_data() !void {     const gpa = std.heap.page_allocator;      // use tablewithtimeseries - give it 2 struct types     // one for the static info on the cat, and the other to store events     var catdb = try datastor.tablewithtimeseries(cat, catevent).init(       gpa,       'db/cats.db',       'db/cats.events',     );     defer catdb.deinit();      // load both the base table, and all the events for all cats     try catdb.load();      // print out all the events in timestamp order     std.debug.print('all events for all cats in timestamp order:╲n', .{});     for (catdb.getallevents()) |event| {         std.debug.print('{s}', .{event});     }      // now print out cats in the datastor,     // along with an audit trail of events for each cat     std.debug.print('╲nall cats with full audit trail:╲n', .{});     for (catdb.items()) |cat| {         std.debug.print('cat {s}╲n', .{cat});         const events = try catdb.geteventsfor(cat.id);         defer events.deinit();         for (events.items) |event| {             std.debug.print('  - at {d}: {s} -> moves to ({d},{d}) status: (asleep:{any}, attacking:{any})╲n',             .{                event.timestamp, event.description,                event.x, event.y,                event.sleep, event.attacks,             });         }     }      // iterate through 4 timestamps and show the state of all cats at the given timestamp     for (0..4) |i| {         const t = i * 10 + 1;         std.debug.print('╲nstate of all cats at timestamp {d}╲n', .{t});         for (catdb.items()) |cat| {             if (catdb.eventat(cat.id, @intcast(t))) |e| {                 std.debug.print('  - {s} {s} since {d} at ({d},{d}) status: (asleep: {any}, attacking: {any})╲n',                 .{                   cat.breed,                   e.description,                   e.timestamp,                   e.x, e.y,                   e.sleep,                   e.attacks,                 });             } else unreachable;         }     }      // get the latest status for each cat     std.debug.print('╲ncurrent state of all cats, based on latest event for each╲n', .{});     for (catdb.items()) |cat| {         const e = catdb.latestevent(cat.id).?;         std.debug.print('  - {s} is currently doing - {s} since {d} at ({d},{d}) status: (asleep: {any}, attacking: {any})╲n',             .{                 cat.breed,                 e.description,                 e.timestamp,                 e.x, e.y,                 e.sleep,                 e.attacks,             });     } } ```  produces output : ```zig parentid: 1 timestamp: 1 at 10,10  attacks: false kills false sleeps true comment: starts at location parentid: 2 timestamp: 1 at 20,10  attacks: false kills false sleeps true comment: starts at location parentid: 3 timestamp: 1 at 10,20  attacks: false kills false sleeps true comment: starts at location parentid: 4 timestamp: 1 at 20,20  attacks: false kills false sleeps true comment: starts at location parentid: 1 timestamp: 10 at 10,10  attacks: false kills false sleeps false comment: awakes parentid: 1 timestamp: 20 at 20,10  attacks: true kills false sleeps false comment: attacks burmese parentid: 2 timestamp: 21 at 20,10  attacks: false kills false sleeps false comment: awakes parentid: 3 timestamp: 21 at 10,20  attacks: false kills false sleeps false comment: awakes parentid: 2 timestamp: 25 at 20,10  attacks: true kills false sleeps false comment: retaliates against siamese parentid: 3 timestamp: 29 at 10,20  attacks: false kills false sleeps true comment: goes back to sleep parentid: 4 timestamp: 30 at 20,20  attacks: false kills false sleeps false comment: awakes from all the commotion parentid: 4 timestamp: 40 at 20,10  attacks: true kills false sleeps false comment: attacks burmese and siamese  all cats with full audit trail: cat id: 1 breed: siamese color: white length: 30, aggression factor: 7.00e-01   - at 1: starts at location -> moves to (10,10) status: (asleep:true, attacking:false)   - at 10: awakes -> moves to (10,10) status: (asleep:false, attacking:false)   - at 20: attacks burmese -> moves to (20,10) status: (asleep:false, attacking:true) cat id: 2 breed: burmese color: grey length: 24, aggression factor: 6.00e-01   - at 1: starts at location -> moves to (20,10) status: (asleep:true, attacking:false)   - at 21: awakes -> moves to (20,10) status: (asleep:false, attacking:false)   - at 25: retaliates against siamese -> moves to (20,10) status: (asleep:false, attacking:true) cat id: 3 breed: tabby color: striped length: 32, aggression factor: 5.00e-01   - at 1: starts at location -> moves to (10,20) status: (asleep:true, attacking:false)   - at 21: awakes -> moves to (10,20) status: (asleep:false, attacking:false)   - at 29: goes back to sleep -> moves to (10,20) status: (asleep:true, attacking:false) cat id: 4 breed: bengal color: tiger stripes length: 40, aggression factor: 9.00e-01   - at 1: starts at location -> moves to (20,20) status: (asleep:true, attacking:false)   - at 30: awakes from all the commotion -> moves to (20,20) status: (asleep:false, attacking:false)   - at 40: attacks burmese and siamese -> moves to (20,10) status: (asleep:false, attacking:true)  state of all cats at timestamp 1   - siamese starts at location since 1 at (10,10) status: (asleep: true, attacking: false)   - burmese starts at location since 1 at (20,10) status: (asleep: true, attacking: false)   - tabby starts at location since 1 at (10,20) status: (asleep: true, attacking: false)   - bengal starts at location since 1 at (20,20) status: (asleep: true, attacking: false)  state of all cats at timestamp 11   - siamese awakes since 10 at (10,10) status: (asleep: false, attacking: false)   - burmese starts at location since 1 at (20,10) status: (asleep: true, attacking: false)   - tabby starts at location since 1 at (10,20) status: (asleep: true, attacking: false)   - bengal starts at location since 1 at (20,20) status: (asleep: true, attacking: false)  state of all cats at timestamp 21   - siamese attacks burmese since 20 at (20,10) status: (asleep: false, attacking: true)   - burmese awakes since 21 at (20,10) status: (asleep: false, attacking: false)   - tabby awakes since 21 at (10,20) status: (asleep: false, attacking: false)   - bengal starts at location since 1 at (20,20) status: (asleep: true, attacking: false)  state of all cats at timestamp 31   - siamese attacks burmese since 20 at (20,10) status: (asleep: false, attacking: true)   - burmese retaliates against siamese since 25 at (20,10) status: (asleep: false, attacking: true)   - tabby goes back to sleep since 29 at (10,20) status: (asleep: true, attacking: false)   - bengal awakes from all the commotion since 30 at (20,20) status: (asleep: false, attacking: false)  current state of all cats, based on latest event for each   - siamese is currently doing - attacks burmese since 20 at (20,10) status: (asleep: false, attacking: true)   - burmese is currently doing - retaliates against siamese since 25 at (20,10) status: (asleep: false, attacking: true)   - tabby is currently doing - goes back to sleep since 29 at (10,20) status: (asleep: true, attacking: false)   - bengal is currently doing - attacks burmese and siamese since 40 at (20,10) status: (asleep: false, attacking: true) ```  ---  # union datatype example  ## define a union that can be used in a datastor  ```zig const animaltype = enum { cat, dog };  const animal = union(animaltype) {     const self = @this();      cat: cats.cat,     dog: dogs.dog,      // union types must have id getters and setters for now     // bit annoying, but im not sure yet how to get around this     pub fn setid(self: *self, id: usize) void {         switch (self.*) {             .cat => |*cat| cat.id = id,             .dog => |*dog| dog.id = id,         }     }     pub fn getid(self: self) usize {         switch (self) {             .cat => |cat| return cat.id,             .dog => |dog| return dog.id,         }     }      pub fn free(self: self, allocator: allocator) void {         switch (self) {             .cat => |cat| cat.free(allocator),             .dog => |dog| dog.free(allocator),         }     } }; ```  ## save data to a union datastor  ```zig pub fn createtable() !void {     const gpa = std.heap.page_allocator;     var animaldb = try datastor.table(animal).init(gpa, 'db/animals.db');     defer animaldb.deinit();      // add a cat     try animaldb.append(animal{         .cat = .{             // note - we dupe these items onto the heap, because we want these strings              // to live beyond the scope of just this function             .breed = try gpa.dupe(u8, 'siamese'),             .color = try gpa.dupe(u8, 'sliver'),             .length = 28,             .aggression = 0.9,         },     });      // add a dog     try animaldb.append(animal{         .dog = .{             .breed = try gpa.dupe(u8, 'colley'),             .color = try gpa.dupe(u8, 'black and white'),             .height = 33,             .appetite = 0.9,         },     });      try animaldb.save(); }  ```  ## load union data from a datastor  ```zig pub fn loadtable() !void {     const gpa = std.heap.page_allocator;     var animaldb = try datastor.table(animal).init(gpa, 'db/animals.db');     defer animaldb.deinit();      try animaldb.load();     for (animaldb.items(), 0..) |animal, i| {         std.debug.print('animal {d} is {any}:╲n', .{ i, animal });     } } ```  produces output  ```zig animal 0 is animals.animal{ .cat = id: 1 breed: siamese color: sliver length: 28, aggression factor: 9.00e-01 }: animal 1 is animals.animal{ .dog = id: 2 breed: colley color: black and white height: 33, appetite: 9.00e-01 }: ```  ---  # tree / heirachical data examples  ## define a complicated struct that also represents tree structured data  ```zig //////////////////////////////////////////////////////////////////////////////// // 3 types of things we can find in the forrest  const tree = struct {     id: usize = 0,     parent_id: usize,     x: u8, y: u8, height: u8, };  const creature = struct {     const self = @this();     id: usize = 0,     parent_id: usize,     x: u8, y: u8, name: []const u8, weight: u8,      // needs a free() function because it has a slice that gets allocated     pub fn free(self: self, allocator: allocator) void {         allocator.free(self.name);     } };  const rock = struct {     id: usize = 0,     parent_id: usize,     x: u8, y: u8, width: u8, };  const forrestinhabitanttype = enum { tree, creature, rock };  const forrest = union(forrestinhabitanttype) {     const self = @this();     tree: tree,     creature: creature,     rock: rock,      // need these boilerplate functions to be able to act as datastor over this union type     pub fn setid(self: *self, id: usize) void {         switch (self.*) {             .tree => |*tree| tree.id = id,             .creature => |*creature| creature.id = id,             .rock => |*rock| rock.id = id,         }     }      pub fn getid(self: self) usize {         switch (self) {             .tree => |tree| return tree.id,             .creature => |creature| return creature.id,             .rock => |rock| return rock.id,         }     }      pub fn free(self: self, allocator: allocator) void {         switch (self) {             .creature => |creature| creature.free(allocator),             // only creatures need to be freed             else => {},         }     }      // adding these functions allows our forrest to act as a heirachy of nodes     pub fn setparentid(self: *self, id: usize) void {         switch (self.*) {             .tree => |*tree| tree.parent_id = id,             .creature => |*creature| creature.parent_id = id,             .rock => |*rock| rock.parent_id = id,         }     }      pub fn getparentid(self: self) usize {         switch (self) {             .tree => |tree| return tree.parent_id,             .creature => |creature| return creature.parent_id,             .rock => |rock| return rock.parent_id,         }     } };   ```  ## add some data to the forrest datastor  ```zig pub fn createtable() !void {     const gpa = std.heap.page_allocator;      var forrestdb = try datastor.table(forrest).init(gpa, 'db/forrest.db');     defer forrestdb.deinit();      const root_id = try forrestdb.append(.{ .tree = .{ .parent_id = 0, .x = 10, .y = 10, .height = 10 } });     {         const pine_tree = try forrestdb.append(.{ .tree = .{ .parent_id = root_id, .x = 15, .y = 12, .height = 8 } });         {             _ = try forrestdb.append(.{ .creature = .{                 .parent_id = pine_tree,                 .x = 15,                 .y = 12,                 .name = try gpa.dupe(u8, 'squirrel'),                 .weight = 3,             } });             _ = try forrestdb.append(.{ .rock = .{ .parent_id = pine_tree, .x = 15, .y = 12, .width = 2 } });         }         const gum_tree = try forrestdb.append(.{ .tree = .{ .parent_id = root_id, .x = 8, .y = 12, .height = 6 } });         {             _ = try forrestdb.append(.{ .creature = .{                 .parent_id = gum_tree,                 .x = 8,                 .y = 12,                 .name = try gpa.dupe(u8, 'koala'),                 .weight = 10,             } });             _ = try forrestdb.append(.{ .creature = .{                 .parent_id = gum_tree,                 .x = 8,                 .y = 12,                 .name = try gpa.dupe(u8, 'kangaroo'),                 .weight = 20,             } });         }         const weed = try forrestdb.append(.{ .tree = .{ .parent_id = root_id, .x = 5, .y = 5, .height = 2 } });         {             const moss_rock = try forrestdb.append(.{ .rock = .{ .parent_id = weed, .x = 5, .y = 6, .width = 2 } });             {                 _ = try forrestdb.append(.{ .creature = .{                     .parent_id = moss_rock,                     .x = 5,                     .y = 6,                     .name = try gpa.dupe(u8, 'ant'),                     .weight = 1,                 } });                 _ = try forrestdb.append(.{ .creature = .{                     .parent_id = moss_rock,                     .x = 5,                     .y = 6,                     .name = try gpa.dupe(u8, 'wasp'),                     .weight = 1,                 } });             }         }     }      try forrestdb.save(); } ```  ## load and display tree structured data using recursion  ```zig  const forrestdb = datastor.table(forrest);  pub fn loadtable() !void {     const gpa = std.heap.page_allocator;     var forrestdb = try forrestdb.init(gpa, 'db/forrest.db');     defer forrestdb.deinit();      try forrestdb.load();      std.debug.print('structured display for the contents of the forrest:╲n╲n', .{});     try printforrestrecursive(forrestdb, 0, 0); }  fn printforrestrecursive(forrestdb: forrestdb, parent_id: usize, nesting: usize) !void {     const children = try forrestdb.getchildren(parent_id);     defer children.deinit();     for (children.items) |forrest| {         for (0..nesting) |_| {             std.debug.print('    ', .{});         }         std.debug.print(' {}:╲n', .{forrest});         try printforrestrecursive(forrestdb, forrest.getid(), nesting + 1);     } }  ```  produces output :  ```zig structured display for the contents of the forrest:   forrest.forrest{ .tree = forrest.tree{ .id = 1, .parent_id = 0, .x = 10, .y = 10, .height = 10 } }:      forrest.forrest{ .tree = forrest.tree{ .id = 2, .parent_id = 1, .x = 15, .y = 12, .height = 8 } }:          forrest.forrest{ .creature = .id = 3, .parent_id = 2, .x = 15, .y = 12, .name = squirrel, .weight = 3 }:          forrest.forrest{ .rock = forrest.rock{ .id = 4, .parent_id = 2, .x = 15, .y = 12, .width = 2 } }:      forrest.forrest{ .tree = forrest.tree{ .id = 5, .parent_id = 1, .x = 8, .y = 12, .height = 6 } }:          forrest.forrest{ .creature = .id = 6, .parent_id = 5, .x = 8, .y = 12, .name = koala, .weight = 10 }:          forrest.forrest{ .creature = .id = 7, .parent_id = 5, .x = 8, .y = 12, .name = kangaroo, .weight = 20 }:      forrest.forrest{ .tree = forrest.tree{ .id = 8, .parent_id = 1, .x = 5, .y = 5, .height = 2 } }:          forrest.forrest{ .rock = forrest.rock{ .id = 9, .parent_id = 8, .x = 5, .y = 6, .width = 2 } }:              forrest.forrest{ .creature = .id = 10, .parent_id = 9, .x = 5, .y = 6, .name = ant, .weight = 1 }:              forrest.forrest{ .creature = .id = 11, .parent_id = 9, .x = 5, .y = 6, .name = wasp, .weight = 1 }: ```  please note that in this example of loading and displaying a heirachy, there is no thrashing of the datastor  to look up sub-queries of sub-queries from disk.  there is a single disk i/o operation up front to load the entire tree into memory, and then all the subsequent calls to get the children of a node are just run against the in-memory tree.  this is fine (and super fast) for tree data that remains relatively static.  ---  # performance  err ... im not going to post benchmarks with the tiny amount of data i have here, no point. keep in mind that disk io occurs once at startup to load the data, and once every time a new event is added.  all data lookups are from memory only, so expect them to be quick.   static data is indexed through the hashmap key, and timeseries event data is not indexed at all, just appended always in timestamp order. therefore all event lookups are full table scans.  this should be fine for timeseries data up to ... 10k records before it starts melting down  ? (dont know, just guessing)  anything under 1000 records though, a full list scan is probably about as fast as a hashmap lookup anyway. (dont know, havnt measured yet)  for the record though ....  on a mac m2 pro, to create the cats database, and timeseries events, insert all the records above, and save the data to disk = approx 1.5ms  once the db is created, running all the above queries, to: - generate a list of all events for all cats - generate a report of for each cat, show full audit trail - step through 4 different timestamps, and print the status of each cat at that point in time - then for all cats, show the current status based on  the last event  total query time for all that = approx 30us (microseconds)  or 0.03ms  ----  ## todo list / future goals   - be able to change the type of the id field from `usize` to - anything. - add automatic uuid stamps for all entities - add the ability to pass functions so you can do `map/filter/reduce` type ops on the datastor contents - add something like a `datastor.zig.zon` file in a directory to allow some logical grouping of datastors into a larger db schema - data version management & migration updates  - be able to load and save objects in s2s binary format to http endpoints / s3 style cloud storage  - add the ability to attach middleware to datastors.  idea is something like - register a callback to fire when a table is updated or a new event is added. - add the ability to register clients that subscribe to event updates for a given record - needs that middleware function above. - add the abliity to register user defined serializers on a per-user-struct basis (ie - if `serialize()` exists on the struct, then use it) - ability to shard datastors that may get very large - import / export to and from excel / csv / json formats - add multiple nodes, with replication and failover - add option to use protobuf format as the serialization format  ## future goals - ui support  this comes in 2 parts.  part 1 is having these as library functions that you can add to your app that does :  - add a web based datastor viewer (zig app that spawns a local web server + htmx app to navigate through stores, render datastor contents, etc) - add a  native ui app (zig app using libui-ng tables)  part 2 is having a generic standalone program that does the same thing with existing datastor files.  part 1 is easy, because your app code already has the structs defined in code. part 2 is going to be hard, as s2s provides no schema info. will have to sort that problem out first  ","arats-io/zuffy":"This repository has no description. # zig uffy library  current zig uffy library do offer bunch of extra functionality!  work in progress...; if somewthing is not working, feel free to contribute or open a issue.  require zig version: **0.14.0-dev.850+ddcb7b1c1**  ## usage  include the zuffy into the `build.zig.zon` file.  ``` zig fetch --save https://github.com/arats-io/zuffy/archive/refs/tags/v<version>.tar.gz  .dependencies = .{     .zuffy = .{         .url = 'https://github.com/arats-io/zuffy/archive/refs/tags/v0.1.14.tar.gz',         .hash = '12201fd38f467e6c64ee7bca53da95863b6c05da77fc51daf0ab22079ede57cbd4e2',     }, }, ```  ## list of modules  ### pools  - [x] generic pool       using allocator and the locker - [x] generic pool lock & memory free       based on on implementation of @kprotty's from https://github.com/kprotty/zap - [x] thread pool       copied from @kprotty's from https://github.com/kprotty/zap  ### bytes  - [x] buffer - [x] utf8buffer (stringbuilder)  ---  ### time and time zoneinfo  - [x] time - [x] time zoneinfo  #### usage  environment variable `tz` can be used to calculate a time for a different timezone.  ``` export tz='europe/tiraspol';  2023 nov 5th sun 22:33:05.477603  utc+03:00 ```  in case if machine is not having a way to fetch desired zoninfo, the library is considering embeded zip(and gziped) archive with all zone information.  ``` export tz='europe/tiraspol.zip';  2023 nov 5th sun 22:33:05.477603 utc+03:00 ```  **note**  [time zones info](https://www.iana.org/time-zones) data are embeded (zip and gziped, having 92kb) into the code.  - [x] ╲*nix systems - [ ] windows systems  ---  ### archives  - [x] zip   - [x] archive extraction   - [ ] archive creation - [ ] more archive formats to be added ...  ---  ### lists  - [x] circularlist (fifo & lifo) - [x] skiplist  ---  ### eazy logger  [zlog](./src/zlog.md)  # contributing  contributions of all kinds is welcome! ","jerome-trc/viletech":"Doom source port and related technologies # viletech  ## about  viletech is a collection of doom-related rust technologies, oriented towards the building of new tools, game engines, and games descending from id software's id tech 1 engine.  the goals of the viletech 'project' are as follows, in descending order of priority: 1. [![justforfunnoreally.dev badge](https://img.shields.io/badge/justforfunnoreally-dev-9ff)](https://justforfunnoreally.dev) 2. build a new doom source port that fulfills all my specific needs. 3. publicly expose the technologies developed in service of 2., especially where some functionality did not already have an implementation in an available library.  beware that this project: - is deep in development. you should not assume that any of the code herein is even sound. - is strictly a solo hobby project. the code within this repository is going to be deeply disorganized for the foreseeable future.  ## contents  - `/assets` contains non-code resources used by executable artifacts at runtime. - `/c` contains the c component of the viletech engine - inherited from [dsda-doom](https://github.com/kraflab/dsda-doom) - pending translation to zig. - `/client` contains the code for the viletech engine's zig executable. - `/crates` contains rust libraries associated with this project. - `/demotest` is a suite of integration tests for ensuring that the viletech engine is capable of running [demos](https://doomwiki.org/wiki/demo) with perfect accuracy. - `/depend` contains files, git subtrees and submodules from other projects. - `/doc` contains documentation for developers. - `/legal` contains license information for outside code. - `/libs` contains zig libraries associated with this project. - `/sample` contains data used for automated testing.  <!--  ## developer guide  todo  -->  ## licensing, attribution  a complete list of attributions and other third-party licensing information can be found [here](/attrib.md).  all viletech-original source - i.e., that which is no way covered by the terms of the document provided above - is provided under either of   * apache license, version 2.0, ([license-apache](license-apache) or https://www.apache.org/licenses/license-2.0)  * mit license ([license-mit](license-mit) or https://opensource.org/licenses/mit)  at your option. ","softprops/zig-doh":"DNS over HTTPS client  <h1 align='center'>     zig doh </h1>  <div align='center'>     a dns over https client interface </div>  ---  [![main](https://github.com/softprops/zig-doh/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/zig-doh/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/zig-doh) ![release](https://img.shields.io/github/v/release/softprops/zig-doh) [![zig support](https://img.shields.io/badge/zig-0.13.0-black?logo=zig)](https://ziglang.org/documentation/0.13.0/)   ## examples  see examples directory  ## 📼 installing  create a new exec project with `zig init`. copy an example from the examples directory into your into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/softprops/zig-doh/archive/refs/tags/v0.1.0.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +       // 👇 declare dep properties +        .doh = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-doh/archive/refs/tags/v0.1.0.tar.gz', +            // 👇 hash verification +            .hash = '...', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-doh/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-doh/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference dep from build.zig.zon +    const doh = b.dependency('doh', .{ +        .target = target, +        .optimize = optimize, +    }).module('doh');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the module to executable +    exe.root_mode.addimport('doh', doh);      b.installartifact(exe); } ```  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)   ╲- softprops 2024","egegungordu/zig-fsrs":"Zig implementation of FSRS # zig-fsrs  this is an implementation of [fsrs-4.5](https://github.com/open-spaced-repetition/fsrs4anki/wiki/the-algorithm) in zig.   this project is on zig 0.13.0  ```zig const std = @import('std'); const fsrs = @import('zig-fsrs'); const card = fsrs.card;  pub fn main() !void {     var f = fsrs.fsrs.init(.{});     const initial_card = fsrs.card.init();     var now = std.time.timestamp();      // schedule the initial card     var s = f.schedule(initial_card, now);      // good was selected on new card     const updated_card = s.select(.good).card;      std.debug.print('initial card:╲n{}╲n╲n', .{initial_card});     std.debug.print('after first rep (good):╲n{}╲n╲n', .{updated_card}); } ```  ## getting started  ### 1. add zig-fsrs to your own zig project:  fetch zig-fsrs:  ```shell zig fetch --save git+https://github.com/egegungordu/zig-fsrs ```  ### 2. add zig-fsrs to your `build.zig` file:  ```zig const zig_fsrs = b.dependency('zig-fsrs', .{}); exe.root_module.addimport('zig-fsrs', zig_fsrs.module('zig-fsrs')); ```  now you can import zig-fsrs in your code:  ```zig const fsrs = @import('zig-fsrs'); ```  ## basic usage  ### 1. create a new fsrs instance  ```zig var f = fsrs.fsrs.init(.{}); ```  the parameters are optional. the parameters are:  | parameter         | type    | default value                                                                                                                             | | ----------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------- | | request_retention | f32     | 0.9                                                                                                                                       | | maximum_interval  | i32     | 36500                                                                                                                                     | | w                 | [17]f32 | { 0.4872, 1.4003, 3.7145, 13.8206, 5.1618, 1.2298, 0.8975, 0.031, 1.6474, 0.1367, 1.0461, 2.1072, 0.0793, 0.3246, 1.587, 0.2272, 2.8755 } |  ### 2. create a new card  ```zig const initial_card = fsrs.card.init(); ```  ### 3. schedule the card  ```zig const review_time = std.time.timestamp(); var scheduled_cards = f.schedule(initial_card, review_time); ```  `schedule()` will return a `scheduledcards` struct which contains the possible cards given the rating. to select a card, use the `select` method, which will return a `reviewedcard` struct.  ```zig const good = scheduled_cards.select(.good); const new_card = good.card; ```  ### card fields  | field          | type  | description                                                                 | | -------------- | ----- | --------------------------------------------------------------------------- | | state          | state | the state of the card. can be `new`, `learning`, `review`, or `relearning`. | | reps           | i32   | the number of repetitions of the card.                                      | | lapses         | i32   | the number of times the card was remembered incorrectly.                    | | stability      | f32   | a measure of how well the card is remembered.                               | | difficulty     | f32   | the inherent difficulty of the card content.                                | | elapsed_days   | i64   | the number of elapsed days since the card was last reviewed.                | | scheduled_days | i64   | the next scheduled days for the card.                                       | | due            | i64   | the due date for the next review.                                           | | last_review    | i64   | the last review date of the card.                                           |  ## examples  to run the examples:  ```shell zig build example -dexample=example_name ```  check out the [examples](examples) directory for more examples.  ## development  ```shell git clone https://github.com/egegungordu/zig-fsrs.git cd zig-fsrs ```  to run the tests:  ```shell zig build test --summary all ``` ","Durobot/zigStructPrint":"Small library to pretty-print Zig structs (and arrays) zigstructprint  small library to pretty-print zig structs (and arrays)  **zigstructprint** is licensed under under [the mit license](https://en.wikipedia.org/w/index.php?title=mit_license&useskin=vector) and available from https://github.com/durobot/zigstructprint  please note that only zig **0.14.0-dev.1421+f87dd43c1** (give or take) and up is supported because of [this breaking change](https://github.com/ziglang/zig/commit/0fe3fd01ddc2cd49c6a2b939577d16b9d2c65ea9) in the zig standard library. if you need zigstructprint for an earlier version of zig, get [this version](https://github.com/durobot/zigstructprint/releases/tag/v0.1-beta) instead.  to use, either drop [zsp.zig](https://github.com/durobot/zigstructprint/blob/main/src/zsp.zig) into your project, or, if you prefer zig package manager:  1. in `build.zig.zon`, in `.dependencies`, add     ```zig    .zigstructprint =    .{        .url = 'https://github.com/durobot/zigstructprint/archive/<commit hash, 40 hex digits>.tar.gz',        .hash = '<zig package hash, 68 hex digits>' // use arbitrary hash, get correct hash from the error     }    ```  2. in `build.zig`, in `pub fn build`, before `b.installartifact(exe);`, add     ```zig    const zsp = b.dependency('zigstructprint',    .{        .target = target,        .optimize = optimize,    });    exe.root_module.addimport('zigstructprint', zsp.module('zigstructprint'));    ```  build with `zig build`, as you normally do.  actually printing out your struct:  ```zig const zsp = @import('zigstructprint'); . . . const mystruct = struct {     a: i8 = -10,     b: u32 = 10,     c: [3]u8 = [_]u8 { 1, 2, 3 },     d: [2]nested = .{ .{ .f = 10.0, .g = 'hello' }, .{ .f = -20.0, .g = 'bye' }, },     e: [3]color = .{ .red, .green, .yellow },      const nested = struct { f: f32, g: []const u8 };     const color = enum { red, yellow, green }; }; const ms = mystruct {}; zsp.printstruct(ms, true, 0); // try `false` to get full type names ```  and the output is:  ```zig {     a: i8 = -10     b: u32 = 10     c: [3]u8 = [ 1, 2, 3, ]     d: [2]nested = [ { f: f32 = 10, g: []const u8 = 'hello', }, { f: f32 = -20, g: []const u8 = 'bye', }, ]     e: [3]color = [ red, green, yellow, ] } ```","bogwi/eruzero":"Bullet-Train fast hashmap for Zig # eruzero bullet-train fast hashmap for zig.  eruzero aims to be a replacement for zig's standard hashmap.  the motivation was to create a simple and fast map based on an implicit data structure that works well with any key out of the box, without providing context or a custom hasher. the only exceptions are .float and untagged .union types. *(floats can be hashed, though. a convenient and fast key wrapper that breaks the float on integer and memo parts with controlled precision is present in the tests part of the code.)*  eruzero supports the main std/hashmap api. new features are dedicated update to an existing value, scaling down the underlying memory when no longer needed, basic operations on sets, and automatic tombstone cleanup, making the map very resistant to the problem.  ## include in your project  for `build.zig.zon`  ```zig .{     .name = 'name_of_your_package',     .version = 'version_of_your_package',     .dependencies = .{         .eruzero = .{             .url = 'https://github.com/bogwi/eruzero/archive/master.tar.gz',             .hash = '1220dbe03c05ad89578e952ed3f2ff1fa611495f770773c711979ac00e48fd2825e9',         },     }, }  ``` if the hash has changed, you will get a gentle  `error: hash mismatch` where in the field `found:` zig brings you the correct value.  for `build.zig`  ```zig     const eruzero = b.dependency('eruzero', .{});     exe.addmodule('eruzero', eruzero.module('eruzero')); ```  ## bench benchmark is inspired by https://github.com/xacrimon/dashmap, which has its benchmark ported of the libcuckoo benchmark.  there are four tests in total:  **rh: read heavy**╲ [read 98, insert 1,  remove 1,  update 0 ]╲ models caching of data in places such as web servers and disk page caches.  **ex: exchange**╲ [read 10, insert 40, remove 40, update 10]╲ replicates a scenario where the map is used to exchange data.  **exh: exchange heavy**╲ [read 1, insert 98, remove 98, update 1]╲ this test is an inverse of *rh* test. hard for any map.  **rg: rapid grow**╲ [read 5,  insert 80, remove 5,  update 10]╲ a scenario where the map is used to collect large amounts of data in a short burst.  all tests except *rg* are designed to keep the map small. the keys are rotated, so the tests are tombstone-heavy. especially the *exh* test. at the end of the test, on the default 1m ops, the map has wrenched with 980k tombstones under the size of only 1!   benchmark against zig's both hashmap and arrayhashmap can be called in the command line via  ``` zig build bench ``` the default test runs on one million ops. you can run it with any number of operations; append the number as `zig build bench -- 12345678`. it is okay to format the number as 12_345_678 with an underscore. unintentionally, we can make the number too large, which may not be what we want.  ## performance and stats   for each card, the tests are run as four independent loops of 100 ops each until the specified cap is reached. the results are interesting. sure, a map like eruzero, which does not let deleted items accumulate, will have a huge advantage over the one without such a heuristic. also, it seems that building a hashmap backed by an underlying arraylist is much more effective than talking directly to the allocator, at least in zig's universe. further discussion is needed.  we did this on u64 keys, wyhash for both maps, gpa allocator, releasefast mode, and apple m1 laptop. if you have built a hashmap that supports zig's std:hashmap api and would like to see it included in the benchmark, drop us a line. you are very welcome.  *tp*: throughput: millions of operations per second.╲ *rt*: runtime   : time spent on the test, in seconds.╲ *aggregate*: this is an absolute measurement of an individual hashmap's *throughput* (total number of ops the map has engaged through the four tests in a row divided by the combined *runtime*) contrary to single tests measuring relative performances.   ```                      hashmap benchmark|                1_000_000 ops:each test|  |name         |tp mops:sec|    rt :sec|  ===================================== |eruzero                              | |rh           |     251.46|   0.003977| |ex           |      63.16|   0.015832| |exh          |      64.25|   0.015563| |rg           |      47.46|   0.021070| |aggregate    |      70.87|   0.056442|  |arrayhashmap                         | |rh           |     139.60|   0.007163| |ex           |      81.52|   0.012268| |exh          |      81.63|   0.012250| |rg           |      24.66|   0.040544| |aggregate    |      55.38|   0.072225|  |hashmap                              | |rh           |      62.65|   0.015961| |ex           |      13.04|   0.076673| |exh          |       8.28|   0.120821| |rg           |      57.06|   0.017524| |aggregate    |      17.32|   0.230980|                        hashmap benchmark|               10_000_000 ops:each test|  |name         |tp mops:sec|    rt :sec|  ===================================== |eruzero                              | |rh           |     256.21|   0.039030| |ex           |      62.19|   0.160800| |exh          |      59.97|   0.166756| |rg           |      36.06|   0.277308| |aggregate    |      62.12|   0.643895|  |arrayhashmap                         | |rh           |     141.78|   0.070530| |ex           |      84.29|   0.118637| |exh          |      83.80|   0.119330| |rg           |      17.61|   0.567956| |aggregate    |      45.64|   0.876454|  |hashmap                              | |rh           |      64.22|   0.155703| |ex           |      13.20|   0.757729| |exh          |       8.34|   1.199348| |rg           |      36.86|   0.271328| |aggregate    |      16.78|   2.384107|                        hashmap benchmark|              100_000_000 ops:each test|  |name         |tp mops:sec|    rt :sec|  ===================================== |eruzero                              | |rh           |     258.13|   0.387407| |ex           |      65.79|   1.520057| |exh          |      62.78|   1.592761| |rg           |      26.91|   3.715796| |aggregate    |      55.43|   7.216020|  |arrayhashmap                         | |rh           |     144.43|   0.692390| |ex           |      86.05|   1.162134| |exh          |      84.47|   1.183876| |rg           |      17.79|   5.621304| |aggregate    |      46.19|   8.659705|  |hashmap                              | |rh           |      64.08|   1.560445| |ex           |      13.21|   7.567642| |exh          |       8.34|  11.988912| |rg           |      25.86|   3.867002| |aggregate    |      16.01|  24.984001|  ```  ## conclusions based on the above data, if you are building an application that is *read heavy*, consider using the eruzero map, which is specifically designed for static reading with occasional removals. if you are building an application similar to the *exchange* test, consider using arrayhashmap, which has excellent removal performance and almost instant iteration over the entire map (not tested here). zig's hashmap is great for growing and reading small volumes under 1m entries. in general, eruzero completed four tests in the least amount of time.  if you do not want external dependencies, you should still consider using zig's excellent arrayhashmap in your projects, which is an overall better alternative to zig's hashmap. arrayhashmap is somewhat underestimated in zig's community (as it seems, scavenging the github data) because it grows slower than std:hashmap and because of popular synthetic tests, usually consisting of *grow-clear-put_again-get-iterate-remove* sequence or similar, used to benchmark hashmaps. and somehow it got into people's heads that the map that runs the sequence faster is better. in fact, the arrayhashmap will not come out on top in such synthetic tests. however, tests that do not measure the hashmap's performance by the number of deleted entries it holds at runtime cannot tell the whole truth.   ","kassane/wamr-zig":"Zig bindings from WebAssembly Micro Runtime (WAMR) # wamr-zig  ### overview  based on [wamr rust sdk](https://github.com/bytecodealliance/wamr-rust-sdk). it is the wrapper of [*wasm_export.h*](https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/core/iwasm/include/wasm_export.h) but with zig style.   ### requirements  - [zig](https://ziglang.org/download/) v0.13.0 or master. - [cmake](https://cmake.org/download/) v3.12.0 or master. - [llvm libs](https://github.com/llvm/llvm-project/releases) v16.0.0 or master.  #### core concepts  - *runtime*. it is the environment that hosts all the wasm modules. each process has one runtime instance. - *module*. it is the compiled .wasm or .aot. it can be loaded into runtime and instantiated into instance. - *instance*. it is the running instance of a module. it can be used to call export functions. - *function*. it is the exported function.  #### wasi concepts  - *wasiargs*. it is used to configure the wasi environment.   - *pre-open*. all files and directories in the list will be opened before the .wasm or .aot loaded.   - *allowed address*. all ip addresses in the *allowed address* list will be allowed to connect with a socket.   - *allowed dns*.   ### how to use  - **new project** ```bash # create directory $ mkdir project-name $ cd project-name $ zig init # add dependency in zon file $ zig fetch --save=wamr-zig git+https://github.com/wamr-zig/wamr-zig ``` add in **build.zig** ```zig const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const wamr_zig = b.dependency('wamr-zig', .{         .target = target,         .optimize = optimize,     });      // your project     [exe|lib].root_module.addimport('wamr', wamr_zig.module('wamr')); } ```","travisstaloch/flagset":"A command line flag parsing package # flagset a command line flag parsing package  # goals simplicity, fast compile times, and small binary size with measured use of comptime.  # features * auto generated usage/help text   * format width specifier controls column width.  i.e. `'{: <25}'` sets width to 25. * positional (unnamed) flags may occur in any position, not just after named flags.  positional flags are always parsed in declaration order. * compososition: `parse()` methods return unparsed args or a modified iterator.  this allows for composing flagsets by passing `parse_result.unparsed_args` on to further `parse()` methods with different flagsets.   * flag parsing stops when all flags have been parsed, just before the first non-flag argument ('-' is a non-flag argument) or after the terminator '--' * parse into pointers by passing optional runtime `parseoptions.ptrs` fields * custom flag parsing with `flagset.flag.options.parsefn`.  this also makes it possible to parse into other types such as structs. * parse integers from utf8 strings by setting `flagset.flag.options.int_from_utf8` * abbreviated short bool flags: '-abc' is parsed the same as '-a -b -c' * accept command line args as slice or iterator with `parsefromslice()` and `parsefromiter()`   * supports any iterator with a `fn next() ?[]const u8` such as `std.process.args()`, `std.mem.tokenize()`, `std.mem.split()` # use ```console zig fetch --save git+https://github.com/travisstaloch/flagset ```  ```zig // build.zig const flagset_dep = b.dependency('flagset', .{     .target = target,     .optimize = optimize, }); exe.root_module.addimport('flagset', flagset_dep.module('flagset')); ```  [src/demo.zig](src/demo.zig) ```zig const std = @import('std'); const flagset = @import('flagset');  pub fn main() !void {     const flags = [_]flagset.flag{         .init(bool, 'flag', .{ .short = 'f', .desc = 'flag description' }),         .init(u32, 'count', .{ .desc = 'count description' }),         .init(enum { one, two }, 'enum', .{ .kind = .positional, .desc = 'enum description' }),         .init(?[]const u8, 'opt-string', .{ .short = 's', .desc = 'opt-string description' }),         .init([]const u8, 'string', .{ .desc = 'string description' }),         .init([]const u8, 'pos-str', .{ .kind = .positional, .desc = 'pos-str description' }),         .init(u8, 'with-default', .{ .desc = 'with-default description', .default_value = &@as(u8, 10) }),     };      var args = try std.process.argswithallocator(std.heap.page_allocator); // todo use a better allocator     defer args.deinit();      var result = flagset.parsefromiter(&flags, args, .{}) catch |e| switch (e) {         error.helprequested => {             std.debug.print('{: <45}', .{flagset.fmtusage(&flags, .full,                 ╲╲                 ╲╲usage: demo <options>                 ╲╲                 ╲╲             )});             return;         },         else => return e,     };     std.debug.print('parsed: {}╲n', .{flagset.fmtparsed(&flags, result.parsed, .{})});     std.debug.print('unparsed args: ', .{});     while (result.unparsed_args.next()) |arg| std.debug.print('{s} ', .{arg});     std.debug.print('╲n', .{}); } ``` ```console $ zig build demo -- -h  usage: demo <options>  options:   --help, -h                                 show this message and exit   --flag, --no-flag, -f                      flag description   --count <u32>                              count description   <enum:one|two>                             enum description   --opt-string, --no-opt-string, -s <string> opt-string description   --string <string>                          string description   <pos-str:string>                           pos-str description   --with-default <u8>                        with-default description  $ zig build demo -- --flag --count 10 two --no-opt-string --string 's' pos-str --foo --bar parsed: --flag --count 10 two --no-opt-string --string s pos-str --with-default 10 unparsed args: --foo --bar   ```  # more examples * [src/tests.zig](src/tests.zig)  # references * https://github.com/games-by-mason/structopt * https://pkg.go.dev/flag ","zephyrchien/libev-zig":"Zig binding for libev, with coroutine support. 404: not found","tiawl/vulkan.zig":"vulkan headers packaged for @ziglang # vulkan.zig  this is a fork of [hexops/vulkan-headers][1] which is itself a fork of [khronosgroup/vulkan-headers][2].  ## why this forkception ?  the intention under this fork is the same as [hexops][10] had when they forked [khronosgroup/vulkan-headers][2]: package the headers for [zig][3]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`.  however this repository has subtle differences for maintainability tasks: * no shell scripting, * a cron runs every day to check [khronosgroup/vulkan-headers][2]. then it updates this repository if a new release is available.  ## how to use it  the current usage of this repository is centered around [tiawl/glfw.zig][3] compilation. but you could use it for your own projects. headers are here and there are no planned evolution to modify them. see [tiawl/glfw.zig][3] to see how you can use it.  ## dependencies  the [zig][3] part of this package is relying on the latest [zig][3] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [khronosgroup/vulkan-headers](https://github.com/tiawl/vulkan.zig/blob/trunk/.references/vulkan)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/glfw.zig][4]  this repository is automatically updated when a new release is available from these repositories: * [khronosgroup/vulkan-headers][2] * [tiawl/toolbox][5] * [tiawl/spaceporn-action-bot][6] * [tiawl/spaceporn-action-ci][7] * [tiawl/spaceporn-action-cd-ping][8] * [tiawl/spaceporn-action-cd-pong][9]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/hexops/vulkan-headers [2]:https://github.com/khronosgroup/vulkan-headers [3]:https://github.com/ziglang/zig [4]:https://github.com/tiawl/glfw.zig [5]:https://github.com/tiawl/toolbox [6]:https://github.com/tiawl/spaceporn-action-bot [7]:https://github.com/tiawl/spaceporn-action-ci [8]:https://github.com/tiawl/spaceporn-action-cd-ping [9]:https://github.com/tiawl/spaceporn-action-cd-pong [10]:https://github.com/hexops ","bcrist/Zig-BitHelper":"Zig utilities for low-level bit manipulation 404: not found","roastpie/zig-pkg":"Zig Package Aggregator  # zig package aggregator ","joachimschmidt557/zig-smaz":"Port of smaz string compression to zig # zig-smaz  port of the [smaz string compression algorithm](https://github.com/antirez/smaz) to [zig](https://ziglang.org)  works with zig 0.13.0 ","joachimschmidt557/zig-wcwidth":"[WIP] Implementation of wcwidth() in zig # zig-wcwidth  a port of [wcwidth](https://github.com/jquast/wcwidth) to zig  supports zig 0.13.0 ","kassane/lvgl":"LVGL using zig build (v0.11.0) **important note** the next major version (v9.0.0) is developed in the master branch. the last stable version is available in the [release/v8.3](https://github.com/lvgl/lvgl/tree/release/v8.3) branch.  ---  <a href='https://github.com/sponsors/lvgl' target='_blank'><img align='left' src='https://lvgl.io/assets/images/sponsor.png' height='32px'></a>  <p align='right'>   <b>english</b> | <a href='./docs/readme_zh.md'>中文</a> | <a href='./docs/readme_pt_br.md'>português do brasil</a> | <a href='./docs/readme_jp.md'>日本語</a> </p>  <br>  <p align='center'>   <img src='https://lvgl.io/assets/images/logo_lvgl.png'> </p>    <h1 align='center'>light and versatile graphics library</h1>   <br> <div align='center'>   <img src='https://github.com/kisvegabor/test/raw/master/smartwatch_demo.gif'>   &nbsp;   <img border='1px' src='https://lvgl.io/assets/images/lvgl_widgets_demo.gif'> </div> <br> <p align='center'> <a href='https://lvgl.io' title='homepage of lvgl'>website </a> | <a href='https://docs.lvgl.io/' title='detailed documentation with 100+ examples'>docs</a> | <a href='https://forum.lvgl.io' title='get help and help others'>forum</a> | <a href='https://lvgl.io/demos' title='demos running in your browser'>demos</a> | <a href='https://lvgl.io/services' title='graphics design, ui implementation and consulting'>services</a> | <a href='https://squareline.io/' title='ui editor for lvgl'>squareline studio</a> </p> <br>  ## :ledger: overview  **mature and well-known**<br> lvgl is the most popular free and open source embedded graphics library to create beautiful uis for any mcu, mpu and display type. it's supported by industry leading vendors and projects like  arm, stm32, nxp, espressif, nuvoton, arduino, rt-thread, zephyr, nuttx, adafruit and many more.  **feature rich**<br> it has all the features to create modern and beautiful guis: 30+ built-in widgets, a powerful style system, web inspired layout managers, and a typography system supporting many languages. to integrate lvgl into your platform, all you need is at least 32kb ram and 128 kb flash, a c compiler, a frame buffer, and at least an 1/10 screen sized buffer for rendering.  **ui editor**<br> squareline studio is a professional yet affordable drag and drop ui editor for lvgl. it runs on windows, linux and macos too and you can try it out even without registering to the website.  **services**<br> our team is ready to help you with graphics design, ui implementation and consulting services. contact us if you need some support during the development of your next gui project.  ## :rocket: features  **free and portable**   - a fully portable c (c++ compatible) library with no external dependencies.   - can be compiled to any mcu or mpu, with any (rt)os.   - supports monochrome, epaper, oled or tft displays, or even monitors. [porting guide](https://docs.lvgl.io/master/porting/project.html)   - distributed under the mit license, so you can easily use it in commercial projects too.   - needs only 32kb ram and 128 kb flash, a frame buffer, and at least an 1/10 screen sized buffer for rendering.   - os, external memory and gpu are supported but not required.  **widgets, styles, layouts and more**   - 30+ built-in [widgets](https://docs.lvgl.io/master/widgets/index.html):  button, label, slider, chart, keyboard, meter, arc, table and many more.   - flexible [style system](https://docs.lvgl.io/master/overview/style.html) with  ~100 style properties to customize any part of the widgets in any state.   - [flexbox](https://docs.lvgl.io/master/layouts/flex.html) and [grid](https://docs.lvgl.io/master/layouts/grid.html)-like layouts engines to automatically size and position the widgets in a responsive way.   - texts are rendered with utf-8 encoding supporting cjk, thai, hindi, arabic, persian writing systems.   - word wrapping, kerning, text scrolling, sub-pixel rendering, pinyin-ime chinese input, emojis in texts.   - rendering engine supporting animations, anti-aliasing, opacity, smooth scrolling, shadows, image transformation, etc     - supports mouse, touchpad, keypad, keyboard, external buttons, encoder [input devices](https://docs.lvgl.io/master/porting/indev.html).   - [multiple display](https://docs.lvgl.io/master/overview/disp.html#multiple-display-support) support.  **binding and build support**   - [micropython binding](https://blog.lvgl.io/2019-02-20/micropython-bindings) exposes lvgl api   - [pikascript binding](https://blog.lvgl.io/2022-08-24/pikascript-and-lvgl) python on mcu lighter and easier.   - no custom build system is used. you can build lvgl as you build the other files of your project.   - support for make and [cmake](https://docs.lvgl.io/master/get-started/platforms/cmake.html) is included out of the box.   - [develop on pc](https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html) and use the same ui code on embedded hardware.   - convert the c ui code to html file with our [emscripten port](https://github.com/lvgl/lv_web_emscripten).  **docs, tools, and services**   - detailed [documentation](https://docs.lvgl.io/) with [100+ simple examples](https://docs.lvgl.io/master/index.html)   - [squareline studio](https://squareline.io/) - a professional and easy-to-use ui editor software to speed up and simplify the ui development.   - [services](https://lvgl.io/services) such as user interface design, implementation and consulting to make ui development simpler and faster.  ## :heart: sponsor  if lvgl saved you a lot of time and money or you just had fun using it, consider [supporting its development](https://github.com/sponsors/lvgl).  **how do we spend the donations?**<br> our goal is to provide financial compensation for people who do the most for lvgl. it means not only the maintainers but anyone who implements a great feature should get a payment from the accumulated money. we use the donations to cover our operational costs like servers and related services.  **how to donate?**<br> we use [github sponsors](https://github.com/sponsors/lvgl) where you can easily send one time or recurring donations. you can also see all of our expenses  in a transparent way.  **how to get paid for your contribution?**<br> if someone implements or fixes an issue labeled as [sponsored](https://github.com/lvgl/lvgl/labels/sponsored) he or she will get a payment for that work. we estimate the required time, complexity and importance of the issue and set a price accordingly. to jump in just comment on a [sponsored](https://github.com/lvgl/lvgl/labels/sponsored) issue saying 'hi, i'd like to deal with it. this is how i'm planning to fix/implement it...'. a work is considered ready when it's approved and merged by a maintainer. after that you can submit and expense at [opencollective.com](https://opencollective.com/lvgl) and you will receive the payment in a few days.  **organizations supporting lvgl**<br> [![sponsors of lvgl](https://opencollective.com/lvgl/organizations.svg?width=600)](https://opencollective.com/lvgl)  **individuals supporting lvgl**<br> [![backers of lvgl](https://opencollective.com/lvgl/individuals.svg?width=600)](https://opencollective.com/lvgl)  ## :package: packages lvgl is available as: - [arduino library](https://docs.lvgl.io/master/integration/framework/arduino.html) - [platformio package](https://registry.platformio.org/libraries/lvgl/lvgl) - [zephyr library](https://docs.lvgl.io/master/integration/os/zephyr.html) - [esp32 component](https://components.espressif.com/components/lvgl/lvgl) - [nxp mcuxpresso component](https://www.nxp.com/design/software/embedded-software/lvgl-open-source-graphics-library:littlevgl-open-source-graphics-library) - [nuttx library](https://docs.lvgl.io/master/integration/os/nuttx.html) - [rt-thread rtos](https://docs.lvgl.io/master/integration/os/rt-thread.html) - cmsis-pack - [riot os package](https://doc.riot-os.org/group__pkg__lvgl.html#details)   ## :robot: examples  see some examples of creating widgets, using layouts and applying styles. you will find c and micropython code, and links to try out or edit the examples in an online micropython editor.  for more examples check out the [examples](https://github.com/lvgl/lvgl/tree/master/examples) folder.   ### hello world label  ![simple hello world label example in lvgl](https://github.com/kisvegabor/test/raw/master/readme_example_1.png)  <details>   <summary>c code</summary>  ```c /*change the active screen's background color*/ lv_obj_set_style_bg_color(lv_scr_act(), lv_color_hex(0x003a57), lv_part_main);  /*create a white label, set its text and align it to the center*/ lv_obj_t * label = lv_label_create(lv_scr_act()); lv_label_set_text(label, 'hello world'); lv_obj_set_style_text_color(lv_scr_act(), lv_color_hex(0xffffff), lv_part_main); lv_obj_align(label, lv_align_center, 0, 0); ``` </details>  <details>   <summary>micropython code | <a href='https://sim.lvgl.io/v8.3/micropython/ports/javascript/index.html?script_direct=4ab7c40c35b0dc349aa2f0c3b00938d7d8e8ac9f' target='_blank'>online simulator</a></summary>  ```python # change the active screen's background color scr = lv.scr_act() scr.set_style_bg_color(lv.color_hex(0x003a57), lv.part.main)  # create a white label, set its text and align it to the center label = lv.label(lv.scr_act()) label.set_text('hello world') label.set_style_text_color(lv.color_hex(0xffffff), lv.part.main) label.align(lv.align.center, 0, 0) ``` </details> <br>  ### button with click event  ![lvgl button with label example](https://github.com/kisvegabor/test/raw/master/readme_example_2.gif)  <details>   <summary>c code</summary>  ```c lv_obj_t * btn = lv_btn_create(lv_scr_act());                   /*add a button to the current screen*/ lv_obj_center(btn);                                             /*set its position*/ lv_obj_set_size(btn, 100, 50);                                  /*set its size*/ lv_obj_add_event(btn, btn_event_cb, lv_event_clicked, null); /*assign a callback to the button*/  lv_obj_t * label = lv_label_create(btn);                        /*add a label to the button*/ lv_label_set_text(label, 'button');                             /*set the labels text*/ lv_obj_center(label);                                           /*align the label to the center*/ ...  void btn_event_cb(lv_event_t * e) {   printf('clicked╲n'); } ``` </details>  <details>   <summary>micropython code | <a href='https://sim.lvgl.io/v8.3/micropython/ports/javascript/index.html?script_startup=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/header.py&script=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/widgets/slider/lv_example_slider_2.py&script_direct=926bde43ec7af0146c486de470c53f11f167491e' target='_blank'>online simulator</a></summary>  ```python def btn_event_cb(e):   print('clicked')  # create a button and a label btn = lv.btn(lv.scr_act()) btn.center() btn.set_size(100, 50) btn.add_event(btn_event_cb, lv.event.clicked, none)  label = lv.label(btn) label.set_text('button') label.center() ``` </details> <br>  ### checkboxes with layout ![checkboxes with layout in lvgl](https://github.com/kisvegabor/test/raw/master/readme_example_3.gif)  <details>   <summary>c code</summary>  ```c  lv_obj_set_flex_flow(lv_scr_act(), lv_flex_flow_column); lv_obj_set_flex_align(lv_scr_act(), lv_flex_align_center, lv_flex_align_start, lv_flex_align_center);  lv_obj_t * cb; cb = lv_checkbox_create(lv_scr_act()); lv_checkbox_set_text(cb, 'apple'); lv_obj_add_event(cb, event_handler, lv_event_all, null);  cb = lv_checkbox_create(lv_scr_act()); lv_checkbox_set_text(cb, 'banana'); lv_obj_add_state(cb, lv_state_checked); lv_obj_add_event(cb, event_handler, lv_event_all, null);  cb = lv_checkbox_create(lv_scr_act()); lv_checkbox_set_text(cb, 'lemon'); lv_obj_add_state(cb, lv_state_disabled); lv_obj_add_event(cb, event_handler, lv_event_all, null);  cb = lv_checkbox_create(lv_scr_act()); lv_obj_add_state(cb, lv_state_checked | lv_state_disabled); lv_checkbox_set_text(cb, 'melon╲nand a new line'); lv_obj_add_event(cb, event_handler, lv_event_all, null); ```  </details>  <details>   <summary>micropython code | <a href='https://sim.lvgl.io/v8.3/micropython/ports/javascript/index.html?script_startup=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/header.py&script=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/widgets/slider/lv_example_slider_2.py&script_direct=311d37e5f70daf1cb0d2cad24c7f72751b5f1792' target='_blank'>online simulator</a></summary>  ```python def event_handler(e):     code = e.get_code()     obj = e.get_target_obj()     if code == lv.event.value_changed:         txt = obj.get_text()         if obj.get_state() & lv.state.checked:             state = 'checked'         else:             state = 'unchecked'         print(txt + ':' + state)   lv.scr_act().set_flex_flow(lv.flex_flow.column) lv.scr_act().set_flex_align(lv.flex_align.center, lv.flex_align.start, lv.flex_align.center)  cb = lv.checkbox(lv.scr_act()) cb.set_text('apple') cb.add_event(event_handler, lv.event.all, none)  cb = lv.checkbox(lv.scr_act()) cb.set_text('banana') cb.add_state(lv.state.checked) cb.add_event(event_handler, lv.event.all, none)  cb = lv.checkbox(lv.scr_act()) cb.set_text('lemon') cb.add_state(lv.state.disabled) cb.add_event(event_handler, lv.event.all, none)  cb = lv.checkbox(lv.scr_act()) cb.add_state(lv.state.checked | lv.state.disabled) cb.set_text('melon') cb.add_event(event_handler, lv.event.all, none) ```  </details> <br>  ### styling a slider ![styling a slider with lvgl](https://github.com/kisvegabor/test/raw/master/readme_example_4.gif)   <details>   <summary>c code</summary>  ```c lv_obj_t * slider = lv_slider_create(lv_scr_act()); lv_slider_set_value(slider, 70, lv_anim_off); lv_obj_set_size(slider, 300, 20); lv_obj_center(slider);  /*add local styles to main part (background rectangle)*/ lv_obj_set_style_bg_color(slider, lv_color_hex(0x0f1215), lv_part_main); lv_obj_set_style_bg_opa(slider, 255, lv_part_main); lv_obj_set_style_border_color(slider, lv_color_hex(0x333943), lv_part_main); lv_obj_set_style_border_width(slider, 5, lv_part_main); lv_obj_set_style_pad_all(slider, 5, lv_part_main);  /*create a reusable style sheet for the indicator part*/ static lv_style_t style_indicator; lv_style_init(&style_indicator); lv_style_set_bg_color(&style_indicator, lv_color_hex(0x37b9f5)); lv_style_set_bg_grad_color(&style_indicator, lv_color_hex(0x1464f0)); lv_style_set_bg_grad_dir(&style_indicator, lv_grad_dir_hor); lv_style_set_shadow_color(&style_indicator, lv_color_hex(0x37b9f5)); lv_style_set_shadow_width(&style_indicator, 15); lv_style_set_shadow_spread(&style_indicator, 5); 4 /*add the style sheet to the slider's indicator part*/ lv_obj_add_style(slider, &style_indicator, lv_part_indicator);  /*add the same style to the knob part too and locally overwrite some properties*/ lv_obj_add_style(slider, &style_indicator, lv_part_knob);  lv_obj_set_style_outline_color(slider, lv_color_hex(0x0096ff), lv_part_knob); lv_obj_set_style_outline_width(slider, 3, lv_part_knob); lv_obj_set_style_outline_pad(slider, -5, lv_part_knob); lv_obj_set_style_shadow_spread(slider, 2, lv_part_knob); ```  </details>  <details>   <summary>micropython code | <a href='https://sim.lvgl.io/v8.3/micropython/ports/javascript/index.html?script_startup=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/header.py&script=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/widgets/slider/lv_example_slider_2.py&script_direct=c431c7b4dfd2cc0dd9c392b74365d5af6ea986f0' target='_blank'>online simulator</a> </summary>   ```python # create a slider and add the style slider = lv.slider(lv.scr_act()) slider.set_value(70, lv.anim.off) slider.set_size(300, 20) slider.center()  # add local styles to main part (background rectangle) slider.set_style_bg_color(lv.color_hex(0x0f1215), lv.part.main) slider.set_style_bg_opa(255, lv.part.main) slider.set_style_border_color(lv.color_hex(0x333943), lv.part.main) slider.set_style_border_width(5, lv.part.main) slider.set_style_pad_all(5, lv.part.main)  # create a reusable style sheet for the indicator part style_indicator = lv.style_t() style_indicator.init() style_indicator.set_bg_color(lv.color_hex(0x37b9f5)) style_indicator.set_bg_grad_color(lv.color_hex(0x1464f0)) style_indicator.set_bg_grad_dir(lv.grad_dir.hor) style_indicator.set_shadow_color(lv.color_hex(0x37b9f5)) style_indicator.set_shadow_width(15) style_indicator.set_shadow_spread(5)  # add the style sheet to the slider's indicator part slider.add_style(style_indicator, lv.part.indicator) slider.add_style(style_indicator, lv.part.knob)  # add the same style to the knob part too and locally overwrite some properties slider.set_style_outline_color(lv.color_hex(0x0096ff), lv.part.knob) slider.set_style_outline_width(3, lv.part.knob) slider.set_style_outline_pad(-5, lv.part.knob) slider.set_style_shadow_spread(2, lv.part.knob) ``` </details> <br>  ### english, hebrew (mixed ltr-rtl) and chinese texts  ![english, hebrew and chinese texts with lvgl](https://github.com/kisvegabor/test/raw/master/readme_example_5.png)  <details>   <summary>c code</summary>  ```c lv_obj_t * ltr_label = lv_label_create(lv_scr_act()); lv_label_set_text(ltr_label, 'in modern terminology, a microcontroller is similar to a system on a chip (soc).'); lv_obj_set_style_text_font(ltr_label, &lv_font_montserrat_16, 0); lv_obj_set_width(ltr_label, 310); lv_obj_align(ltr_label, lv_align_top_left, 5, 5);  lv_obj_t * rtl_label = lv_label_create(lv_scr_act()); lv_label_set_text(rtl_label,'מעבד, או בשמו המלא יחידת עיבוד מרכזית (באנגלית: cpu - central processing unit).'); lv_obj_set_style_base_dir(rtl_label, lv_base_dir_rtl, 0); lv_obj_set_style_text_font(rtl_label, &lv_font_dejavu_16_persian_hebrew, 0); lv_obj_set_width(rtl_label, 310); lv_obj_align(rtl_label, lv_align_left_mid, 5, 0);  lv_obj_t * cz_label = lv_label_create(lv_scr_act()); lv_label_set_text(cz_label,                   '嵌入式系统（embedded system），╲n是一种嵌入机械或电气系统内部、具有专一功能和实时计算性能的计算机系统。'); lv_obj_set_style_text_font(cz_label, &lv_font_simsun_16_cjk, 0); lv_obj_set_width(cz_label, 310); lv_obj_align(cz_label, lv_align_bottom_left, 5, -5); ```  </details>  <details>   <summary>micropython code | <a href='https://sim.lvgl.io/v8.3/micropython/ports/javascript/index.html?script_startup=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/header.py&script=https://raw.githubusercontent.com/lvgl/lvgl/0d9ab4ee0e591aad1970e3c9164fd7c544ecce70/examples/widgets/slider/lv_example_slider_2.py&script_direct=18bb38200a64e10ead1aa17a65c977fc18131842' target='_blank'>online simulator</a></summary>  ```python ltr_label = lv.label(lv.scr_act()) ltr_label.set_text('in modern terminology, a microcontroller is similar to a system on a chip (soc).') ltr_label.set_style_text_font(lv.font_montserrat_16, 0);  ltr_label.set_width(310) ltr_label.align(lv.align.top_left, 5, 5)  rtl_label = lv.label(lv.scr_act()) rtl_label.set_text('מעבד, או בשמו המלא יחידת עיבוד מרכזית (באנגלית: cpu - central processing unit).') rtl_label.set_style_base_dir(lv.base_dir.rtl, 0) rtl_label.set_style_text_font(lv.font_dejavu_16_persian_hebrew, 0) rtl_label.set_width(310) rtl_label.align(lv.align.left_mid, 5, 0)  font_simsun_16_cjk = lv.font_load('s:../../assets/font/lv_font_simsun_16_cjk.fnt')  cz_label = lv.label(lv.scr_act()) cz_label.set_style_text_font(font_simsun_16_cjk, 0) cz_label.set_text('嵌入式系统（embedded system），╲n是一种嵌入机械或电气系统内部、具有专一功能和实时计算性能的计算机系统。') cz_label.set_width(310) cz_label.align(lv.align.bottom_left, 5, -5)  ``` </details>  ## :arrow_forward: get started this list will guide you to get started with lvgl step-by-step.  **get familiar with lvgl**    1. check the [online demos](https://lvgl.io/demos) to see lvgl in action (3 minutes)   2. read the [introduction](https://docs.lvgl.io/master/intro/index.html) page of the documentation (5 minutes)   3. get familiar with the basics on the [quick overview](https://docs.lvgl.io/master/get-started/quick-overview.html) page (15 minutes)  **start to use lvgl**    4. set up a [simulator](https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html) (10 minutes)   5. try out some [examples](https://github.com/lvgl/lvgl/tree/master/examples)   6. port lvgl to a board. see the [porting](https://docs.lvgl.io/master/porting/index.html) guide or check the ready to use [projects](https://github.com/lvgl?q=lv_port_)  **become a pro**    7. read the [overview](https://docs.lvgl.io/master/overview/index.html) page to get a better understanding of the library (2-3 hours)   8. check the documentation of the [widgets](https://docs.lvgl.io/master/widgets/index.html) to see their features and usage  **get help and help others**    9. if you have questions go to the [forum](http://forum.lvgl.io/)   10. read the [contributing](https://docs.lvgl.io/master/contributing.html) guide to see how you can help to improve lvgl (15 minutes)  **go for more**    11. download and try out [squareline studio](https://squareline.io/).   12. contact us for [services](https://lvgl.io/services).   ## :handshake: services lvgl llc was established to provide a solid background for lvgl library and to offer several type of services to help you in ui development. with 15+ years of experience in the user interface and graphics industry we can help you the bring your ui to the next level.  - **graphics design** our in-house graphics designers are experts in creating beautiful modern designs which fit to your product and the resources of your hardware. - **ui implementation** we can also implement your ui based on the design you or we have created. you can be sure that we will make the most out of your hardware and lvgl. if a feature or widget is missing from lvgl, don't worry, we will implement it for you. - **consulting and support** we can support you with consulting as well to avoid pricey and time consuming mistakes during the ui development. - **board certification** for companies who are offering development boards, or production ready kits we do board certification which shows how board can run lvgl.   check out our [demos](https://lvgl.io/demos) as reference. for more information take look at the [services page](https://lvgl.io/services).  [contact us](https://lvgl.io/#contact) and tell how we can help.   ## :star2: contributing lvgl is an open project and contribution is very welcome. there are many ways to contribute from simply speaking about your project, through writing examples, improving the documentation, fixing bugs or even hosting your own project under the lvgl organization.  for a detailed description of contribution opportunities visit the [contributing](https://docs.lvgl.io/master/contributing.html) section of the documentation.  more than 300 people already left their fingerprint in lvgl. be one them! see your here! :slightly_smiling_face:  <a href='https://github.com/lvgl/lvgl/graphs/contributors'>   <img src='https://contrib.rocks/image?repo=lvgl/lvgl&max=48' /> </a>  ... and many other. ","burlindw/zig-build-utils":"A collection of common utilities for Zig build scripts inspired by the build scripts used by Zig and ZLS. # zig-build-utils  a collection of common utilities for zig build scripts inspired by the build scripts used by [zig](https://github.com/ziglang/zig) and [zls](https://github.com/zigtools/zls).  ## how to use  run the following command from a project's root to add `zig-build-utils` as as dependency:  ```sh zig fetch --save git+https://github.com/burlindw/zig-build-utils.git ```  import `build-utils` in `build.zig`. it is not necessary to call `std.build.dependency()` as there are no exported modules or artifacts.  ```zig const std = @import('std'); const utils = @import('build-utils');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});     const version = utils.getbuildversion(b);      const exe = b.addexecutable(.{         .name = 'your-exe-name',         .target = target,         .optimize = optimize,         .version = version,         .root_source_file = b.path('src/main.zig'),     });     b.installartifact(exe); } ```     ","kassane/beast":"HTTP and WebSocket built on Boost.Asio in C++11 (uses zig build) <img width='880' height = '80' alt = 'boost.beast title'     src='https://raw.githubusercontent.com/boostorg/beast/master/doc/images/readme2.png'>  # http and websocket built on boost.asio in c++11  branch                                                    | linux / windows                                                                                                                          | coverage                                                                                                                              | documentation                                                                                                                                              | matrix                                                                                                                                         | ----------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------| [master](https://github.com/boostorg/beast/tree/master)   | [![build status](https://drone.cpp.al/api/badges/boostorg/beast/status.svg?ref=refs/heads/master)](https://drone.cpp.al/boostorg/beast)  | [![codecov](https://img.shields.io/codecov/c/github/boostorg/beast/master.svg)](https://codecov.io/gh/boostorg/beast/branch/master)   | [![documentation](https://img.shields.io/badge/documentation-master-brightgreen.svg)](http://www.boost.org/doc/libs/master/libs/beast/doc/html/index.html) | [![matrix](https://img.shields.io/badge/matrix-master-brightgreen.svg)](http://www.boost.org/development/tests/master/developer/beast.html)    | [develop](https://github.com/boostorg/beast/tree/develop) | [![build status](https://drone.cpp.al/api/badges/boostorg/beast/status.svg?ref=refs/heads/develop)](https://drone.cpp.al/boostorg/beast) | [![codecov](https://img.shields.io/codecov/c/github/boostorg/beast/develop.svg)](https://codecov.io/gh/boostorg/beast/branch/develop) | [![documentation](https://img.shields.io/badge/documentation-develop-brightgreen.svg)](https://www.boost.org/doc/libs/develop/libs/beast/index.html)       | [![matrix](https://img.shields.io/badge/matrix-develop-brightgreen.svg)](https://www.boost.org/development/tests/develop/developer/beast.html) |  ## contents  - [introduction](#introduction) - [appearances](#appearances) - [description](#description) - [requirements](#requirements) - [git branches](#branches) - [building](#building) - [usage](#usage) - [license](#license) - [contact](#contact) - [contributing](#contributing-we-need-your-help)  ## introduction  beast is a c++ header-only library serving as a foundation for writing interoperable networking libraries by providing **low-level http/1, websocket, and networking protocol** vocabulary types and algorithms using the consistent asynchronous model of boost.asio.  this library is designed for:  * **symmetry:** algorithms are role-agnostic; build clients, servers, or both.  * **ease of use:** boost.asio users will immediately understand beast.  * **flexibility:** users make the important decisions such as buffer or   thread management.  * **performance:** build applications handling thousands of connections or more.  * **basis for further abstraction.** components are well-suited for building upon.  ## appearances  | <a href='https://github.com/vinniefalco/cppcon2018'>cppcon 2018</a> | <a href='https://www.bishopfox.com/case_study/securing-beast/'>bishop fox 2018</a> | | ------------ | ------------ | | <a href='https://www.youtube.com/watch?v=7fqwajelmek'><img width='320' height = '180' alt='beast' src='https://raw.githubusercontent.com/vinniefalco/cppcon2018/master/cppcon2018.png'></a> | <a href='https://youtu.be/4ttyybgdaj0'><img width='320' height = '180' alt='beast security review' src='https://raw.githubusercontent.com/vinniefalco/beastassets/master/bishopfox2018.png'></a> |  | <a href='https://github.com/vinniefalco/cppcon2018'>cppcon 2017</a> | <a href='http://cppcast.com/2017/01/vinnie-falco/'>cppcast 2017</a> | <a href='https://raw.githubusercontent.com/vinniefalco/beastassets/master/cppcon2016.pdf'>cppcon 2016</a> | | ------------ | ------------ | ----------- | | <a href='https://www.youtube.com/watch?v=wsunnyekpni'><img width='320' height = '180' alt='beast' src='https://raw.githubusercontent.com/vinniefalco/cppcon2017/master/cppcon2017.png'></a> | <a href='http://cppcast.com/2017/01/vinnie-falco/'><img width='180' height='180' alt='vinnie falco' src='https://avatars1.githubusercontent.com/u/1503976?v=3&u=76c56d989ef4c09625256662eca2775df78a16ad&s=180'></a> | <a href='https://www.youtube.com/watch?v=ujzgrcvpfwi'><img width='320' height = '180' alt='beast' src='https://raw.githubusercontent.com/vinniefalco/beastassets/master/cppcon2016.png'></a> |  ## description  this software is in its first official release. interfaces may change in response to user feedback. for recent changes see the [changelog](changelog.md).  * [official site](https://github.com/boostorg/beast) * [documentation](https://www.boost.org/doc/libs/master/libs/beast/) (master branch) * [autobahn|testsuite websocket results](https://vinniefalco.github.io/boost/beast/reports/autobahn/index.html)  ## requirements  this library is for programmers familiar with boost.asio. users who wish to use asynchronous interfaces should already know how to create concurrent network programs using callbacks or coroutines.  * **c++11:** robust support for most language features. * **boost:** boost.asio and some other parts of boost. * **openssl:** required for using tls/secure sockets and examples/tests  when using microsoft visual c++, visual studio 2017 or later is required.  one of these components is required in order to build the tests and examples:  * properly configured bjam/b2 * cmake 3.5.1 or later (windows only)  ## building  beast is header-only. to use it just add the necessary `#include` line to your source files, like this: ```c++ #include <boost/beast.hpp> ```  if you use coroutines you'll need to link with the boost.coroutine library. please visit the boost documentation for instructions on how to do this for your particular build system.  ## github  to use the latest official release of beast, simply obtain the latest boost distribution and follow the instructions for integrating it into your development environment. if you wish to build the examples and tests, or if you wish to preview upcoming changes and features, it is suggested to clone the 'boost superproject' and work with beast 'in-tree' (meaning, the libs/beast subdirectory of the superproject).  the official repository contains the following branches:  * [**master**](https://github.com/boostorg/beast/tree/master) this   holds the most recent snapshot with code that is known to be stable.  * [**develop**](https://github.com/boostorg/beast/tree/develop) this   holds the most recent snapshot. it may contain unstable code.  each of these branches requires a corresponding boost branch and all of its subprojects. for example, if you wish to use the **master** branch version of beast, you should clone the boost superproject, switch to the **master** branch in the superproject and acquire all the boost libraries corresponding to that branch including beast.  to clone the superproject locally, and switch into the main project's directory use: ``` git clone --recursive https://github.com/boostorg/boost.git cd boost ```  'bjam' is used to build beast and the boost libraries. on a non-windows system use this command to build bjam: ``` ./bootstrap.sh ```  from a windows command line, build bjam using this command: ``` .╲bootstrap.bat ```  ## building tests and examples building tests and examples requires openssl installed. if openssl is installed in a non-system location, you will need to copy the [user-config.jam](tools/user-config.jam) file into your home directory and set the `openssl_root` environment variable to the path that contains an installation of openssl.  ### ubuntu/debian if installed into a system directory, openssl will be automatically found and used. ```bash sudo apt install libssl-dev ``` ### windows replace `path` in the following code snippets with the path you installed vcpkg to. examples assume a 32-bit build, if you build a 64-bit version replace `x32-windows` with `x64-windows` in the path. - using [vcpkg](https://github.com/microsoft/vcpkg) and cmd: ```bat vcpkg install openssl --triplet x32-windows set openssl_root=path╲installed╲x32-windows ```  - using [vcpkg](https://github.com/microsoft/vcpkg) and powershell: ```powershell vcpkg install openssl --triplet x32-windows $env:openssl_root = 'path╲x32-windows' ```  - using [vcpkg](https://github.com/microsoft/vcpkg) and bash: ```bash vcpkg.exe install openssl --triplet x32-windows export openssl_root=path/x32-windows ```  ### mac os using [brew](https://github.com/homebrew/brew): ```bash brew install openssl export openssl_root=$(brew --prefix openssl) # install bjam tool user specific configuration file to read openssl_root # see https://www.bfgroup.xyz/b2/manual/release/index.html cp ./libs/beast/tools/user-config.jam $home ```  make sure the bjam tool (also called 'b2') is available in the path your shell uses to find executables. the beast project is located in 'libs/beast' relative to the directory containing the boot superproject. to build the beast tests, examples, and documentation use these commands: ``` export path=$pwd:$path b2 -j2 libs/beast/test cxxstd=11      # bjam must be in your $path b2 -j2 libs/beast/example cxxstd=11   # '-j2' means use two processors b2 libs/beast/doc                     # doxygen and saxon are required for this ```    additional instructions for configuring, using, and building libraries in superproject may be found in the [boost wiki](https://github.com/boostorg/boost/wiki/getting-started).  ## visual studio  cmake may be used to generate a very nice visual studio solution and a set of visual studio project files using these commands:  ``` cd libs/beast mkdir bin cd bin cmake -g 'visual studio 17 2022' -a win32 ..  # for 32-bit windows builds, or cmake -g 'visual studio 17 2022' -a x64 ..    # for 64-bit windows builds ```  the files in the repository are laid out thusly:  ``` ./     bin/            create this to hold executables and project files     bin64/          create this to hold 64-bit windows executables and project files     doc/            source code and scripts for the documentation     include/        where the header files are located     example/        self contained example programs     meta/           metadata for boost integration     test/           the unit tests for beast     tools/          scripts used for ci testing ```  ## usage  these examples are complete, self-contained programs that you can build and run yourself (they are in the `example` directory).  https://www.boost.org/doc/libs/develop/libs/beast/doc/html/beast/quick_start.html  ## license  distributed under the boost software license, version 1.0. (see accompanying file [license_1_0.txt](license_1_0.txt) or copy at https://www.boost.org/license_1_0.txt)  ## contact  please report issues or questions here: https://github.com/boostorg/beast/issues  ---  ## contributing (we need your help!)  if you would like to contribute to beast and help us maintain high quality, consider performing code reviews on active pull requests. any feedback from users and stakeholders, even simple questions about how things work or why they were done a certain way, carries value and can be used to improve the library. code review provides these benefits:  * identify bugs * documentation proof-reading * adjust interfaces to suit use-cases * simplify code  you can look through the closed pull requests to get an idea of how reviews are performed. to give a code review just sign in with your github account and then add comments to any open pull requests below, don't be shy! <p>https://github.com/boostorg/beast/pulls</p>  here are some resources to learn more about code reviews:  * <a href='https://blog.scottnonnenberg.com/top-ten-pull-request-review-mistakes/'>top 10 pull request review mistakes</a> * <a href='https://static1.smartbear.co/smartbear/media/pdfs/best-kept-secrets-of-peer-code-review_redirected.pdf'>best kept secrets of peer code review (pdf)</a> * <a href='https://static1.smartbear.co/support/media/resources/cc/11_best_practices_for_peer_code_review_redirected.pdf'>11 best practices for peer code review (pdf)</a> * <a href='http://www.evoketechnologies.com/blog/code-review-checklist-perform-effective-code-reviews/'>code review checklist – to perform effective code reviews</a> * <a href='https://www.codeproject.com/articles/524235/codeplusreviewplusguidelines'>code review guidelines</a> * <a href='https://github.com/isocpp/cppcoreguidelines/blob/master/cppcoreguidelines.md'>c++ core guidelines</a> * <a href='https://www.oreilly.com/library/view/c-coding-standards/0321113586/'>c++ coding standards (sutter & alexandrescu)</a>  beast thrives on code reviews and any sort of feedback from users and stakeholders about its interfaces. even if you just have questions, asking them in the code review or in issues provides valuable information that can be used to improve the library - do not hesitate, no question is insignificant or unimportant! ","Vemahk/zig-ulid":"A binary, zero-allocation Ulid implementation written in Zig. # zig-ulid  a binary, zero-alloc [zig](https://ziglang.org/) implementation of [ulid](https://github.com/ulid/spec).  tested with zig 0.12.0 and 0.13.0.  if not for b.path(), it would probably work for 0.11.0.  ## features  - [x] no allocations - [x] to/from string - [x] monotonicity  ## examples  ```zig  // default usage const ulid = @import('ulid'); const id = ulid.new(); const str = id.tostring(); // e.g. '01j0j510yn2kzv7apee1bq8byp' const copy = try ulid.parsestring(str); // == id  const epoch_ms: u48 = ulid.timestamp(); const random_data: [10]u8 = ulid.data();  // monotonic var monotonic = ulid.monotonicfactory{}; const ulid_1 = try monotonic.next(); // e.g. '01j0jby3exavvz227ve93qjd2m' const ulid_2 = try monotonic.next(); // e.g. '01j0jby3exavvz227ve93qjd2n'  // or using the global factory (not recommended but available) const ulid_3 = try ulid.newmonotonic(); // e.g. '01j0jc10bfe2cjb7m2szxx98nh' const ulid_4 = try ulid.newmonotonic(); // e.g. '01j0jc10bfe2cjb7m2szxx98nj'  ```  ## use  build.zig.zon  ``` .ulid = .{     .url = 'https://github.com/vemahk/zig-ulid/archive/<git_commit_hash>.tar.gz', }, ```  build.zig  ```zig  const target = b.standardtargetoptions(.{}); const optimize = b.standardoptimizeoption(.{});  const root = b.path('src/main.zig'); const exe = b.addexecutable(.{     .name = 'your_project',     .root_source_file = root,     .target = target,     .optimize = optimize, });  const dep_opts = .{ .target = target, .optimize = optimize }; const ulid_mod = b.dependency('ulid', dep_opts).module('ulid'); exe.root_module.addimport('ulid', ulid_mod);  b.installartifact(exe);  ``` ","kassane/hana":"Your standard library for metaprogramming (uses zig build-system) # boost.hana <a target='_blank' href='http://semver.org'>![version][badge.version]</a> <a target='_blank' href='https://travis-ci.org/boostorg/hana'>![travis status][badge.travis]</a> <a target='_blank' href='https://ci.appveyor.com/project/ldionne/hana'>![appveyor status][badge.appveyor]</a> <a target='_blank' href='https://godbolt.org/z/36mvzmb7n'>![try it online][badge.tryit]</a> <a target='_blank' href='https://gitter.im/boostorg/hana'>![gitter chat][badge.gitter]</a>  > your standard library for metaprogramming  ## overview <!-- important: keep this in sync with example/overview.cpp --> ```cpp #include <boost/hana.hpp> #include <cassert> #include <string> namespace hana = boost::hana; using namespace hana::literals;  struct fish { std::string name; }; struct cat  { std::string name; }; struct dog  { std::string name; };  int main() {   // sequences capable of holding heterogeneous objects, and algorithms   // to manipulate them.   auto animals = hana::make_tuple(fish{'nemo'}, cat{'garfield'}, dog{'snoopy'});   auto names = hana::transform(animals, [](auto a) {     return a.name;   });   assert(hana::reverse(names) == hana::make_tuple('snoopy', 'garfield', 'nemo'));    // no compile-time information is lost: even if `animals` can't be a   // constant expression because it contains strings, its length is constexpr.   static_assert(hana::length(animals) == 3u, '');    // computations on types can be performed with the same syntax as that of   // normal c++. believe it or not, everything is done at compile-time.   auto animal_types = hana::make_tuple(hana::type_c<fish*>, hana::type_c<cat&>, hana::type_c<dog*>);   auto animal_ptrs = hana::filter(animal_types, [](auto a) {     return hana::traits::is_pointer(a);   });   static_assert(animal_ptrs == hana::make_tuple(hana::type_c<fish*>, hana::type_c<dog*>), '');    // and many other goodies to make your life easier, including:   // 1. access to elements in a tuple with a sane syntax.   static_assert(animal_ptrs[0_c] == hana::type_c<fish*>, '');   static_assert(animal_ptrs[1_c] == hana::type_c<dog*>, '');    // 2. unroll loops at compile-time without hassle.   std::string s;   hana::int_c<10>.times([&]{ s += 'x'; });   // equivalent to s += 'x'; s += 'x'; ... s += 'x';    // 3. easily check whether an expression is valid.   //    this is usually achieved with complex sfinae-based tricks.   auto has_name = hana::is_valid([](auto&& x) -> decltype((void)x.name) { });   static_assert(has_name(animals[0_c]), '');   static_assert(!has_name(1), ''); } ```   ## documentation you can browse the documentation online at http://boostorg.github.io/hana. the documentation covers everything you should need including installing the library, a tutorial explaining what hana is and how to use it, and an extensive reference section with examples. the remainder of this readme is mostly for people that wish to work on the library itself, not for its users.  an offline copy of the documentation can be obtained by checking out the `gh-pages` branch. to avoid overwriting the current directory, you can clone the `gh-pages` branch into a subdirectory like `doc/html`: ```shell git clone http://github.com/boostorg/hana --branch=gh-pages --depth=1 doc/html ```  after issuing this, `doc/html` will contain exactly the same static website that is [available online][hana.docs]. note that `doc/html` is automatically ignored by git so updating the documentation won't pollute your index.   ## hacking on hana setting yourself up to work on hana is easy. first, you will need an installation of [cmake][]. once this is done, you can `cd` to the root of the project and setup the build directory: ```shell mkdir build cmake -s . -b build ```  sometimes, you'll want to specify a custom compiler because the system's compiler is too old: ```shell cmake -s . -b build -dcmake_cxx_compiler=/path/to/compiler ```  usually, this will work just fine. however, on some older systems, the standard library and/or compiler provided by default does not support c++14. if this is your case, the [wiki][hana.wiki] has more information about setting you up on different systems.  normally, hana tries to find boost headers if you have them on your system. it's also fine if you don't have them; a few tests requiring the boost headers will be disabled in that case. however, if you'd like hana to use a custom installation of boost, you can specify the path to this custom installation: ```shell cmake -s . -b build -dcmake_cxx_compiler=/path/to/compiler -dboost_root=/path/to/boost ```  you can now build and run the unit tests and the examples: ```shell cmake --build build --target check ```  you should be aware that compiling the unit tests is pretty time and ram consuming, especially the tests for external adapters. this is due to the fact that hana's unit tests are very thorough, and also that heterogeneous sequences in other libraries tend to have horrible compile-time performance.  there are also optional targets which are enabled only when the required software is available on your computer. for example, generating the documentation requires [doxygen][] to be installed. an informative message will be printed during the cmake generation step whenever an optional target is disabled. you can install any missing software and then re-run the cmake generation to update the list of available targets.  > #### tip > you can use the `help` target to get a list of all the available targets.  if you want to add unit tests or examples, just add a source file in `test/` or `example/` and then re-run the cmake generation step so the new source file is known to the build system. let's suppose the relative path from the root of the project to the new source file is `path/to/file.cpp`. when you re-run the cmake generation step, a new target named `path.to.file` will be created, and a test of the same name will also be created. hence, ```shell cmake --build build --target path.to.file # builds the program associated to path/to/file.cpp ctest --test-dir build -r path.to.file # runs the program as a test ```  > #### tip for sublime text users > if you use the provided [hana.sublime-project](hana.sublime-project) file, > you can select the '[hana] build current file' build system. when viewing a > file to which a target is associated (like a test or an example), you can > then compile it by pressing ⌘b, or compile and then run it using ⇧⌘b.   ## project organization the project is organized in a couple of subdirectories. - the [benchmark](benchmark) directory contains compile-time and runtime   benchmarks to make sure the library is as fast as advertised. the benchmark   code is written mostly in the form of [eruby][] templates. the templates   are used to generate c++ files which are then compiled while gathering   compilation and execution statistics. - the [cmake](cmake) directory contains various cmake modules and other   scripts needed by the build system. - the [doc](doc) directory contains configuration files needed to generate   the documentation. the `doc/html` subdirectory is automatically ignored   by git; you can conveniently store a local copy of the documentation by   cloning the `gh-pages` branch into that directory, as explained above. - the [example](example) directory contains the source code for all the   examples of both the tutorial and the reference documentation. - the [include](include) directory contains the library itself, which is   header only. - the [test](test) directory contains the source code for all the unit tests.   ## contributing please see [contributing.md](contributing.md).   ## license please see [license.md](license.md).   ## releasing releasing is now done exclusively via the boost release process. there are no separate releases of hana since the library is now pretty stable.   <!-- links --> [badge.appveyor]: https://ci.appveyor.com/api/projects/status/github/boostorg/hana?svg=true&branch=master [badge.gitter]: https://img.shields.io/badge/gitter-join%20chat-blue.svg [badge.travis]: https://travis-ci.org/boostorg/hana.svg?branch=master [badge.version]: https://badge.fury.io/gh/boostorg%2fhana.svg [badge.tryit]: https://img.shields.io/badge/try%20it-online-blue.svg [cmake]: http://www.cmake.org [doxygen]: http://www.doxygen.org [eruby]: http://en.wikipedia.org/wiki/eruby [hana.docs]: http://boostorg.github.io/hana [hana.wiki]: https://github.com/boostorg/hana/wiki ","voidstar240/zig-wayland-client":"A Zig native wayland client library # zig wayland client a zig native wayland client library. this library is not designed to identically replicate the functionality of the lib-wayland-client library from the mainline wayland project. this is instead a new take on interfacing with wayland by focusing on the primitives of the wayland protocol.  for in depth usage information see `window_app` in the `examples/` directory. the core wayland protocol isn't particularly useful on its own so the `window_app` example uses the `xdg shell` and `xdg decoration` protocol extensions to create a proper desktop style window. for the example to work your compositor will have to support at least `xdg shell`. if your compositor doesn't support `xdg decoration` the content will still show, but the window won't have decorations (this is the case with gnome/mutter).  ## installation ``` zig fetch --save git+https://github.com/voidstar240/zig-wayland-client ```  ## contribution this project is by no means complete, however it is usable. if you encounter any bugs or have any suggestions please create an issue. if you are a developer and want to improve the project feel free to create a pull request with your changes. ","ahmdhusam/zexpress":"An HTTP/1.1 server library for the Zig programming language # zexpress web server  an http/1.1 server library for the zig programming language. designed with a focus on simplicity and efficiency, zexpress uses the chain of responsibility design pattern, allowing for a dynamic chain of handlers to process requests.  ## installation  the zig build system has the concept of modules, which are other source files written in zig. let’s make use of a module.  1. create a new zig project:  ```shell zig init ```  2. add zexpress as a dependency in your `build.zig.zon` file:  ```shell zig fetch --save git+https://github.com/ahmdhusam/zexpress.git ```  3. update your `build.zig` file to include zexpress:  ```zig pub fn build(b: *std.build) void {     // ... existing code ...      const exe = b.addexecutable(.{         .name = 'your-project-name',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });      // add zexpress as a module     const zexpress_module = b.dependency('zexpress', .{         .target = target,         .optimize = optimize,     }).module('zexpress');     exe.root_module.addimport('zexpress', zexpress_module);      b.installartifact(exe);     // ... existing code ... } ```  ## usage example  here's a simple example demonstrating how to use zexpress:  ```zig const std = @import('std'); const zexpress = @import('zexpress');  var storage: std.autohashmap(u64, u8) = undefined;  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     defer _ = gpa.deinit();      const allocator = gpa.allocator();      storage = std.autohashmap(u64, u8).init(allocator);      const app = try zexpress.server.init(allocator, .{ .reuse_port = true });     defer app.deinit();      try app.use('/users', zexpress.handler.init(&.{getmiddleware}, gethandler));     // todo: name it set until the implementation of methods routers.     try app.use('/users/set', .{ .middlewares = &.{setmiddleware}, .handlerfn = sethandler });      // new route with named parameter     try app.use('/users/:userid', .{ .middlewares = &.{}, .handlerfn = getuserhandler });      try app.listen(8080, errorhandler); }  const usermodel = struct { userid: u64, health: u8 };  fn errorhandler(err: anyerror, req: *zexpress.req, res: *zexpress.res) void {     _ = req;      // has the responsibility to handle all errors.     switch (err) {         else => |errvalue| {             const errname = @errorname(errvalue);             const message = std.mem.replaceowned(u8, res.allocator, errname, '_', ' ') catch unreachable;              _ = res.json(.{ .status = res._status.tonumber(), .message = message }) catch unreachable;         },     } }  fn setmiddleware(req: *zexpress.req, res: *zexpress.res) !void {     if (req.method != .post) {         _ = res.status(.not_found);         return error.not_found;     }      const body = try req.bodyas(*const usermodel);      if (body.health > 100) {         _ = res.status(.bad_request);         return error.health_should_be_less_than_or_eql_100;     } }  fn sethandler(req: *zexpress.req, res: *zexpress.res) !void {     const body = try req.bodyas(*const usermodel);      try storage.put(body.userid, body.health);      _ = try res.status(.ok).json(.{ .message = 'the health was successfully stored.' }); }  fn getmiddleware(req: *zexpress.req, res: *zexpress.res) !void {     if (req.method != .get) {         _ = res.status(.not_found);         return error.not_found;     } }  fn gethandler(req: *zexpress.req, res: *zexpress.res) !void {     // it's optional to run the deinit method.     var list = std.arraylist(usermodel).init(req.allocator);      var usersiter = storage.iterator();      while (usersiter.next()) |user| {         try list.append(.{ .userid = user.key_ptr.*, .health = user.value_ptr.* });     }      _ = try res.status(.ok).json(.{ .data = try list.toownedslice() }); }  fn getuserhandler(req: *zexpress.req, res: *zexpress.res) !void {     const userid = try std.fmt.parseint(u64, req.params.get('userid').?, 10);      if (storage.get(userid)) |health| {         _ = try res.status(.ok).json(.{ .data = .{ .userid = userid, .health = health } });     } else {         _ = res.status(.not_found);         return error.user_not_found;     } } ```  this example sets up a simple server with three routes: - `get /users`: retrieves all users and their health. - `post /users/set`: sets a user's health. - `get /users/:userid`: retrieves a specific user's health using a named parameter.  to run the example:  1. save the code in `src/main.zig` 2. run `zig build run`  the server will start on port 8080. you can test it using curl or any http client.  example requests:  ```shell # get all users curl http://localhost:8080/users  # set a user's health curl -x post -h 'content-type: application/json' -d '{'userid': 1, 'health': 100}' http://localhost:8080/users/set  # get a specific user's health curl http://localhost:8080/users/1 ```  in the last example, `1` is the `:userid` parameter, which can be accessed in the handler using `req.params.get('userid')`.   ## features  - simple and efficient http/1.1 server - middleware support - json request and response handling - error handling  ## contributing  contributions are welcome! please feel free to submit a pull request.  ## license  this project is licensed under the mit license. ","tiawl/wayland.zig":"wayland headers packaged for @ziglang # wayland.zig  this is a fork of [hexops/wayland-headers][1] which itself gather various [wayland][2] headers [glfw][3] needs.  ## why this forkception ?  the intention under this fork is the same as [hexops][13] had when they opened their repository: gather [wayland][2] headers and package them to compile [glfw][3] with [zig][4].  however this repository has subtle differences for maintainability tasks: * no shell scripting, * a cron runs every day to check [wayland][2] repositories. then it updates this repository if a new release is available.  ## how to use it  the current usage of this repository is centered around [tiawl/glfw.zig][3] compilation. but you could use it for your own projects. headers are here and there are no planned evolution to modify them. see [tiawl/glfw.zig][3] to see how you can use it. maybe for your own need, some headers are missing. if it happens, open an issue: this repository is open to potential usage evolution.  ## dependencies  the [zig][4] part of this package is relying on the latest [zig][4] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [wayland/wayland](https://github.com/tiawl/wayland.zig/blob/trunk/.references/wayland) * [wayland/wayland-protocols](https://github.com/tiawl/wayland.zig/blob/trunk/.references/wayland-protocols)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/glfw.zig][5]  this repository is automatically updated when a new release is available from these repositories: * [wayland/wayland][6] * [wayland/wayland-protocols][7] * [tiawl/toolbox][8] * [tiawl/spaceporn-action-bot][9] * [tiawl/spaceporn-action-ci][10] * [tiawl/spaceporn-action-cd-ping][11] * [tiawl/spaceporn-action-cd-pong][12]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/hexops/wayland-headers [2]:https://gitlab.freedesktop.org/wayland [3]:https://github.com/glfw/glfw [4]:https://github.com/ziglang/zig [5]:https://github.com/tiawl/glfw.zig [6]:https://gitlab.freedesktop.org/wayland/wayland [7]:https://gitlab.freedesktop.org/wayland/wayland-protocols [8]:https://github.com/tiawl/toolbox [9]:https://github.com/tiawl/spaceporn-action-bot [10]:https://github.com/tiawl/spaceporn-action-ci [11]:https://github.com/tiawl/spaceporn-action-cd-ping [12]:https://github.com/tiawl/spaceporn-action-cd-pong [13]:https://github.com/hexops ","thekorn/minijinja.zig":"zig bindings for minijinja # minijinja.zig  ![ci workflow](https://github.com/thekorn/minijinja.zig/actions/workflows/ci.yaml/badge.svg)  zig bindings for the amazing [minijinja](https://github.com/mitsuhiko/minijinja) templating engine. it's a thin wrapper around the c abi of minijinja.  **note**: this is a work in progress and mac only at the moment.  ## requirements  - zig >= 0.14 - rustup (for building minijinja-capi) or - a nix environment (and then use `nix develop` to get a shell with all dependencies)  ## usage  add this package to your zig project:  ```bash $ zig fetch --save git+https://github.com/thekorn/minijinja.zig#main ```  add dependency and import to the `build.zig` file:  ```zig ... const minijinja = b.dependency('minijinja', .{     .target = target,     .optimize = optimize, }); ... exe.root_module.addimport('minijinja', minijinja.module('minijinja')); ```  and then, just use it in the code:  ```zig const std = @import('std');  const minijinja = @import('minijinja'); const environment = minijinja.environment; const context = minijinja.context;  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     const allocator = gpa.allocator();     const templ =         ╲╲<ul>         ╲╲{%- for user in users %}         ╲╲  <li>{{ user.name }}</li>         ╲╲{%- endfor %}         ╲╲</ul>     ;      var env = try environment.init();     defer env.deinit();      env.set_debug(true);      try env.add_template('list', templ);      const user = struct {         name: []const u8,     };      const users = [_]user{         .{ .name = 'hans' },         .{ .name = 'wurst' },     };      const t = try env.render_template_struct(allocator, 'list', .{ .users = users });     defer allocator.free(t);      std.debug.print('{s}╲n', .{t}); } ```  which results in  ``` <ul>   <li>hans</li>   <li>wurst</li> </ul> ```  ## tests  using `nix` tests can be run like  ```bash $ nix develop -c zig build test --summary all ``` ","bogwi/Musubi":"All purpose Graph in ZIG # all purpose graph in zig.  ## description  an implementation of an adjacency map graph, where all edges incident on a vertex are collected into a map, using the adjacent vertex as a key. ╲ the graph can be initiated as one of four variants, subjects of graph type: `.directed,.undirected` and mode: `.weighted, .unweighted`. ```zig const graph = musubi(vertexid, edgeid, edgewt, .undirected, .unweighted); var graph: graph = .{}; graph.init(allocator); defer graph.deinit(); ```  `vertexid`, a vertex type, can be anything that can be hashed, such as numeric types, structs, arrays, snippets of code, or anything except floats and untagged enums. ╲ `edgeid`, an edge type, can be anything. ╲ `edgewt`, the weight type of the edge, if the graph was initiated as weighted; any numeric type. if the graph is unweighted, the type is void.   here is the full api at the moment:  *general api* ╲ a set of standard procedures typically found in graph adts. ``` vertex:     .id:                         vertexid     init:                            void  edge:     .origin:                       vertex     .destination:                  vertex     .id:                           edgeid     .weight:                       edgewt     init:                            void     endpoints: pairv:                  origin                 destination     opposite:                      vertex    init:                                void deinit:                              void  clearandfree:                        void clearretainingcapacity:              void ensuretotalcapacity:                !void  cloneintoself:                      !void cloneintoselfwithallocator:         !void mergeintoself:                      !void  makevertex:                        vertex insertvertex:                     !vertex insertvertexifvertex:               !void removevertex:                        bool gotvertex:                           bool vertexcount:                          u64 vertices:                       ?[]vertex adjacentvertices:               ?[]vertex verticesintoset:             !allvertices     allvertices:         .vertices:           arrayhashmap         deinit:                      void         list:                    []vertex         count:                      usize         gotvertex:                   bool         deletevertex:                bool  makeedge:                            edge insertedge:                         !edge insertedgeifedge:                   !void removeedge:                          bool gotedge:                             bool gotedgeifedge:                       bool getedge:                            ?edge edgecount:                          usize degree:                             usize incidentedges:                    ?[]edge edgesintoset:                    alledges     alledges:         .edges:              arrayhashmap         deinit:                      void         list:                      []edge         count:                      usize         gotedge:                     bool         deleteedge:                  bool  ``` *special api*   *tree traversing* ``` traversetree:                  !arraylist traversetreeiftarget:          !arraylist ``` the tree traversing procedure supports four algorithms by passing a corresponding enum to the above function: >`treetraversealg:`  >`.bfs`, breadth-first, iterative ╲ `.pre`, preorder, recursive ╲ `.post`, postorder, recursive ╲ `.ino`, inorder, recursive   *graph traversing* ``` connectiontree:              !connections connectiontreeexcept:        !connections connectiontreethrough:       !connections  connectiontreeiftarget:       !connection connectiontreeiftargetexcept: !connection connectiontreeiftargetthrough:!connection ``` the graph traversing procedure supports four + 1 algorithm by passing a corresponding enum to the above functions:  >`searchalg:`  >`.bfs`, breadth-first search, iterative ╲ `.dfsa`, depth-first search, iterative ╲ `.dfsb`, depth-first search, iterative, true recursion emulation ╲ `.dfsc`, depth-first search, pure recursive ╲ `.dij` , dijkstra shortest path, iterative.   which algorithm is better? that depends. `.bfs` and `.dij` are both shortest path algorithms. the only difference between them is that `.bfs` gives the shortest path based on how many edges it needs to travel to reach the goal, while `.dij` considers the weights of the edges, treating them like distances between vertices. if all edges have the same weight, then `.dij` will give the same result as `.bfsd`. ╲ the depth-first group of algorithms is different and graph-dependent. if the graph is undirected, where all vertices are randomly connected, they will not necessarily produce the shortest paths from origin to destination. they explore the graph as a whole and are useful for finding the longest possible paths. if we have such an undirected tangly graph with 1m randomly connected vertices, and if it is possible to travel from the first vertex to the last vertex and visit all the nodes, the recursive `.dfsc` algorithm will find this path from 1m - 1 vertex. ╲ `.dfsb` is the author's iterative algorithm, which emulates true recursion to a large extent. in some scenarios, the paths it produces are identical to true recursion with an identical stack trace, but may differ in branches. it is only designed for undirected graphs as a `dfsc` replacement. ╲ `.dfsa` is a lazy iterative algorithm often found in books and used worldwide. it is an inversion of `.bfs` where the queue is substituted for the stack. in the case of an undirected, randomly connected graph, the paths it produces will be much shorter than those of the recursive `.dfsc`.   additional parameters are ╲ `knockout`, a set of vertices to remove from the traversal or to traverse only ╲ `target`, the target of the traversal, the traversal will stop when the target is reached ╲ `depth`, the depth of the traversal, which has slightly different goals depending on the algorithm.  the traversal process computes a connection tree from the given starting vertex to all other vertices in the map. ╲ the connection tree has its own documented api for working with the result: ``` connection     .found:                          bool     .explore:                 connections     deinit:                          void  connections:     .origin:                       vertex     .path:                   arrayhashmap     .discovered:             arrayhashmap     .last_lookup:                  vertex     deinit:                          void     connectedto:                     bool     getallconnected:             []vertex       getdistanceto:                 edgewt               getpathto:                  ![]vertex     walkpathto:                 !walkpath         walkpath:             .cnt:            *connections             .idx:                     u64             next:                 ?vertex             reset:                   void     poppathto:                   !poppath         poppath:             .cnt:            *connections             .dest:                 vertex             next:                 ?vertex             reset:                   void ```  *common-problems algorithms and their apis* ╲ *topological sort* ``` topologicalsort:                     topo     topo:         .topo:                  arraylist         .acyclic:                    bool         getall:                 ?[]vertex         getpositions:             ?vertex         getfirst:                 ?vertex         getlast:                  ?vertex         walk:                    walktopo    ``` *minimum spanning tree* ```   primjarnikmst:                        mst kruskalmst:                           mst     mst         .cost:                        u64         .tree:               arrayhashmap                   .len:                       usize         getedges:                  []edge         getvertexpairs:           []pairv         gotvertexpair:               bool   ``` ## performance musubi's underlying adt is zig's superior arrayhashmap, which has unmatched iteration speed over keys and values, and can extract keys and values as a matter of course. this speeds up the graph routine considerably. for example, calling `vertices()` will give you an array of all the vertices in the graph without harvesting them all into a container and only then returning them to the user. the same goes for finding `incidentedges()` of a vertex or its `adjacentvertices()`.  ### testing  apple m1 laptop with 32gb of ram, ╲ releasefast optimization  #### complete binary tree ``` 20m vertices: u64 20m-1 edges: void creation:            time: 7.667  bfs                  time: 2.682 pre                  time: 3.020 post                 time: 3.033 ino                  time: 3.019 ``` although not advertised, musubi remembers the insertion order and can be used as a general or binary tree for your projects. the only consequence is that broken links have to be repaired manually when vertices or edges are removed. the graph is not a linked tree and cannot behave as such. nerveless tree traversal is implemented for directed graphs and is quite fast.  #### undirected, weighted, randomly connected, cobweb-looking graph  ``` 25k vertices: u64  500k edges:    u1 creation:            time: 0.105 sec  tree - connection tree paths - origin -> others         25k  bfs tree                 time: 0.019 bfs paths                time: 0.001 dfs a tree               time: 0.021 dfs a paths              time: 0.342 a dfs b tree               time: 0.031 dfs b paths              time: 5.056 a dfs c tree               time: 0.020 dfs c paths              time: 6.181 a dij tree                 time: 0.027 dij paths                time: 0.002  mst: prim-jarnik: cost: 29751 time: 0.062,  throughput: 8.089  kruskal:     cost: 29751 time: 0.082,  throughput: 6.108 ``` (a) constructing all 25k-1 paths computed by depth-first algorithms happens to be a costly task. as mentioned above, dfs algorithms on undirected randomly constructed graphs tend to produce the longest paths possible, with `.dfsc` as a true recursive algorithm producing the longest paths. therefore, the *paths* test is omitted in the following results. however, such graphs are not real scenarios, but only benchmarking vessels. it also does not mean that dfs traversing should not be used at all to find a connection between two points of interest when working with such a tangled graph.  ``` 50k vertices: u64  1m edges:      u1 creation:            time: 0.313 sec  tree - connection tree paths - origin -> others         50k   bfs tree                 time: 0.057 bfs paths                time: 0.004 dfs a tree               time: 0.057 dfs a paths                 dfs b tree               time: 0.086 dfs b paths               dfs c tree               time: 0.056 a dfs c paths               dij tree                 time: 0.103 dij paths                time: 0.005  mst: prim-jarnik: cost: 59264 time: 0.146  throughput: 6.830  kruskal:     cost: 59264 time: 0.226  throughput: 4.418 ``` (a) in an experiment, recursive `.dfsc` was found to break at about 1_200_000 edges for the graph described above, so there is no data for this algorithm implementation for larger graphs. for small undirected random graphs < 1.2m edges, using a purely recursive `.dfsc` algorithm should be fine.   ``` 100k vertices: u64  2m edges:       u1 creation:            time: 0.785 sec  tree - connection tree paths - origin -> others        100k  bfs tree                 time: 0.131 bfs paths                time: 0.009 dfs a tree               time: 0.129 dfs a paths               dfs b tree               time: 0.199 dfs b paths               dfs c tree                dfs c paths               dij tree                 time: 0.246 dij paths                time: 0.015  mst: prim-jarnik:  cost: 118512             time: 0.354  throughput: 5.650  kruskal: cost: 118512             time: 0.503  throughput: 3.978 ```  ``` 1m vertices: u64  20m edges:    u1 creation:           time: 13.289 sec  tree - connection tree paths - origin -> others          1m  bfs tree                 time: 3.213 bfs paths                time: 0.177 dfs a tree               time: 3.221 dfs a paths               dfs b tree               time: 3.550 dfs b paths               dfs c tree                dfs c paths               dij tree                 time: 6.335 dij paths                time: 0.347  mst: prim-jarnik:  cost: 1184658            time: 7.624 throughput: 2.623  kruskal: cost: 1184658            time: 9.918 throughput: 2.017 ```  #### directed, weighted, acyclic, randomly connected graph ``` 1m vertices: u64  20m+ edges:  u64 creation:            time: 7.083 sec  tree - connection tree paths - origin -> others          1m  bfs tree                 time: 0.483 bfs paths                time: 0.105 dfs a tree               time: 0.446 dfs a paths              time: 0.138 dfs b tree            not applicable dfs b paths           not applicable    dfs c tree               time: 0.469 dfs c paths              time: 0.144 dij tree                 time: 1.582 dij paths                time: 0.239  topological sort         time: 1.684 ``` ``` 5m vertices: u64  102m+ edges: u64 creation:           time: 46.741 sec  tree - connection tree paths - origin -> others          5m  bfs tree                 time: 4.741 bfs paths                time: 0.765 dfs a tree               time: 3.743 dfs a paths              time: 0.914 dfs b tree            not applicable   dfs b paths           not applicable   dfs c tree               time: 4.026 dfs c paths              time: 0.907 dij tree                 time: 15.195 dij paths                time: 2.739  topological sort         time: 20.585 ``` in the case of a directed graph, the results are very different. the cost of finding every path from the origin to every other vertex is very modest. since there are no cycles, the recursive `.dfsc` algorithm that examines 102m edges works correctly and does not break.   ","thechampagne/cutenet-zig":"Zig binding for cutenet a networking library for games requiring an optional reliability layer over UDP with a baked in security scheme. # cutenet-zig  [![](https://img.shields.io/github/v/tag/thechampagne/cutenet-zig?label=version)](https://github.com/thechampagne/cutenet-zig/releases/latest) [![](https://img.shields.io/github/license/thechampagne/cutenet-zig)](https://github.com/thechampagne/cutenet-zig/blob/main/license)  zig binding for **cutenet** a networking library for games requiring an optional reliability layer over udp with a baked in security scheme.  ### references  - [cutenet](https://github.com/randygaul/cute_headers/blob/master/cute_net.h) - **1.03**  ### license  this repo is released under the [zlib license](https://github.com/thechampagne/cutenet-zig/blob/main/license). ","nektro/zig-unicode-uca":"Zig bindings for the contributory data files for the Unicode Collation Algorithm. # zig-unicode-uca  zig bindings for the unicode collation algorithm  last updated as of unicode 16.0.0  https://www.unicode.org/reports/tr10/  > this report is the specification of the unicode collation algorithm (uca), which details how to compare two unicode strings while remaining conformant to the requirements of the unicode standard. the uca also supplies the default unicode collation element table (ducet) as the data specifying the default collation order for all unicode characters.  https://www.unicode.org/public/uca/latest/  ## installation ``` zigmod aq add 1/nektro/unicode-uca ```  ## usage this package provides `.allkeys` and `.decomps` namespaces.  ## license mit ","tiawl/glslang.zig":"glslang packaged for @ziglang # glslang.zig  this is a fork of [khronosgroup/glslang][1] packaged for [zig][2]  ## why this fork ?  the intention under this fork is to package [khronosgroup/glslang][1] for [zig][2]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`, * a cron runs every day to check [khronosgroup/glslang][1]. then it updates this repository if a new release is available.  ## how to use it  the goal of this repository is not to provide a [zig][2] binding for [khronosgroup/glslang][1]. there are at least as many legit ways as possible to make a binding as there are active accounts on github. so you are not going to find an answer for this question here. the point of this repository is to abstract the [khronosgroup/glslang][1] compilation process with [zig][2] (which is not new comers friendly and not easy to maintain) to let you focus on your application. so you can use **glslang.zig**: - as raw (no available example, open an issue if you are interested in, we will be happy to help you), - as a daily updated interface for your [zig][2] binding of [khronosgroup/glslang][1] (again: no available example).  ## important note  the current usage of this repository is centered around [tiawl/shaderc.zig][3] compilation. so for your usage it could break because some files have been filtered in the process. if it happens, open an issue: this repository is open to potential usage evolution.  ## dependencies  the [zig][2] part of this package is relying on the latest [zig][2] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [khronosgroup/glslang](https://github.com/tiawl/glslang.zig/blob/trunk/.references/glslang)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/shaderc.zig][3]  this repository is automatically updated when a new release is available from these repositories: * [khronosgroup/glslang][1] * [tiawl/toolbox][4] * [tiawl/spaceporn-action-bot][5] * [tiawl/spaceporn-action-ci][6] * [tiawl/spaceporn-action-cd-ping][7] * [tiawl/spaceporn-action-cd-pong][8]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/khronosgroup/glslang [2]:https://github.com/ziglang/zig [3]:https://github.com/tiawl/shaderc.zig [4]:https://github.com/tiawl/toolbox [5]:https://github.com/tiawl/spaceporn-action-bot [6]:https://github.com/tiawl/spaceporn-action-ci [7]:https://github.com/tiawl/spaceporn-action-cd-ping [8]:https://github.com/tiawl/spaceporn-action-cd-pong ","0xrinegade/apz":"blazigly spicy http server # apz zig api ","tiawl/spirv.zig":"spirv-tools packaged for @ziglang  # spirv.zig  this is a fork of [hexops/spirv-tools][1] which itself is a fork of [khronosgroup/spirv-tools][2].  ## why this forkception ?  the intention under this fork is the same as [hexops][11] had when they forked [khronosgroup/spirv-tools][2]: package the headers for [zig][4]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`.  however this repository has subtle differences for maintainability tasks: * no shell scripting, * a cron runs every day to check [khronosgroup/spirv-tools][2] and [khronosgroup/spirv-headers][3]. then it updates this repository if a new release is available.  ## how to use it  the current usage of this repository is centered around [tiawl/shaderc.zig][3] compilation. but you could use it for your own projects. headers are here and there are no planned evolution to modify them. see [tiawl/shaderc.zig][3] to see how you can use it. maybe for your own need, some headers are missing. if it happens, open an issue: this repository is open to potential usage evolution.  ## dependencies  the [zig][4] part of this package is relying on the latest [zig][4] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [khronosgroup/spirv-tools](https://github.com/tiawl/spirv.zig/blob/trunk/.references/spirv-tools) * [khronosgroup/spirv-headers](https://github.com/tiawl/spirv.zig/blob/trunk/.references/spirv)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/shaderc.zig][5]  this repository is automatically updated when a new release is available from these repositories: * [khronosgroup/spirv-tools][2] * [khronosgroup/spirv-headers][3] * [tiawl/toolbox][6] * [tiawl/spaceporn-action-bot][7] * [tiawl/spaceporn-action-ci][8] * [tiawl/spaceporn-action-cd-ping][9] * [tiawl/spaceporn-action-cd-pong][10]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/hexops/spirv-tools [2]:https://github.com/khronosgroup/spirv-tools [3]:https://github.com/khronosgroup/spirv-headers [4]:https://github.com/ziglang/zig [5]:https://github.com/tiawl/shaderc.zig [6]:https://github.com/tiawl/toolbox [7]:https://github.com/tiawl/spaceporn-action-bot [8]:https://github.com/tiawl/spaceporn-action-ci [9]:https://github.com/tiawl/spaceporn-action-cd-ping [10]:https://github.com/tiawl/spaceporn-action-cd-pong [11]:https://github.com/hexops ","bcrist/Zig-DeepHashMap":"Zig std.HashMaps with deep keys 404: not found","Hejsil/fmtbuf":"Buffered formatting that figures out the buffer size for you <!--- readme.md is autogenerated. please edit example/readme.md.template instead. --> # fmtbuf  an alternative to `std.fmt.bufprintz` which can:  * automatically figure out the buffer size at compile time * can be partially formatted, allowing for a prefix to be formatted and reused.  ```zig const fmtbuf = @import('fmtbuf').fmtbuf; const std = @import('std');  test {     var buf = fmtbuf('[{}] = {}', std.meta.tuple(&.{ usize, u8 })){};     try std.testing.expectequalstrings('[0] = 0', buf.format(.{ 0, 0 }));     try std.testing.expectequalstrings('[12] = 3', buf.format(.{ 12, 3 }));      var partial = buf.partialformat(1, .{500});     try std.testing.expectequalstrings('[500] = 0', partial.format(.{0}));     try std.testing.expectequalstrings('[500] = 1', partial.format(.{1}));     try std.testing.expectequalstrings('[500] = 2', partial.format(.{2})); }  ```  ","bcrist/zbox":"SVG Block Diagram Generator 404: not found","footearth/zig-js":"Access the JS host environment from Zig compiled to WebAssembly. # zig-js  zig-js is a zig library (and accompanying js glue) that enables zig running in a webassembly environment to interact with a javascript-based host.  note this makes it particularly easy for zig to call into js. this doesn't help for js calling into zig. this is more akin to go's `syscall/js` package and not like rust's `wasm-bindgen`.  note: the main branch of this repository attempts to remain compatible with the latest nightly release of zig, and therefore may not be compatible with official zig releases.  ## example  ```zig // get and set objects and properties const document = try js.global.get(js.object, 'document'); defer document.deinit();  const title = try document.getalloc(js.string, alloc, 'title'); defer alloc.free(title); std.log.info('the title is: {s}', .{str});  try document.set('title', js.string('a new title.'));  // call functions js.global.call(void, 'alert', .{js.string('hello from zig!')}); ```  the code is a bit verbose with the error handling but since js is a dynamic language there are potential invalid types at every step of the way. additionally, `deinit` calls are necessary to dereference garbage-collected values on the host side.  under the covers, this is hiding a lot of complexity since the js/wasm abi only allows passing numeric types and sharing memory.  ## usage  to use this library, you must integrate a component in both the zig and js environment. for zig, vendor this repository and add the package. for example in your build.zig:  ```zig const js = @import('zig-js');  pub fn build(b: *std.build.builder) !void {   // ... other stuff    exe.addpackage(js.pkg); } ```  from js, install and import the package in the `js/` directory (in the future this will be published to npm). a typescript example is shown below but js could just as easily be used:  ```typescript import { zigjs } from 'zig-js-glue';  // initialize the stateful zigjs class. you should use one per wasm instance. const zigjs = new zigjs();  fetch('my-wasm-file.wasm').then(response =>   response.arraybuffer() ).then(bytes =>   // when creating your wasm instance, pass along the zigjs import   // object. you can merge this import object with your own since zigjs   // uses its own namespace.   webassembly.instantiate(bytes, zigjs.importobject()) ).then(results => {   const { memory, my_func } = results.instance.exports;    // set the memory since zigjs interfaces with memory.   zigjs.memory = memory;    // run any of your exported functions!   my_func(); }); ```  **warning:** the zig-js version used in your zig code and js code must match. i'm not promising any protocol stability right now so pin your versions appropriately. to determine what version is compatible, look up the tagged version in this repository and the corresponding commits.  ## internals  the fundamental idea in this is based on the go [syscall/js](https://pkg.go.dev/syscall/js) package. the implementation is relatively diverged since zig doesn't have a runtime or garbage collection, but the fundamental idea of sharing 'refs' and the format of those refs is based on go's implementation.  the main idea is that zig communicates to js what values it would like to request, such as the 'global' object. js generates a 'ref' for this object (a unique 64-bit numeric value) and sends that to zig. this ref now uniquely identifies the value for future calls such as 'give me the 'document' property on this ref.'  the ref itself is a 64-bit value. for numeric types, the ref _is_ the value. we take advantage of the fact that all numbers in javascript are ieee 754 encoded 64-bit floats and use nan as a way to send non-numeric values to zig (nan-boxing).  nan in ieee 754 encoding is `0111_1111_1111_<anything but all 0s>` in binary. we use a common nan value of `0111_1111_1111_1000_0000...` so that we can use the bottom (least-significant) 49 bits to store type information and a 32-bit id.  the 32-bit id is just an index into an array on the js side. a simple scheme is used to reuse ids after they're dereferenced.  ## performance  usage of this package causes the wasm/js boundary to be crossed a lot and this is generally not very fast and not an optimal way to use wasm. the optimal way to use wasm is more like a gpu: have the host (or wasm module) preload a bunch of work into a byte buffer and send it over in one single call. however, this approach is pretty painful. this packge makes interfacing with js very, very easy. consider the tradeoffs and choose what is best for you. ","dweiller/zli":"Simple CLI parsing for Zig # zli  zli is a cli argument parsing module for zig. the aim is to provide cli parameters in a simple, declarative way and have zli parse them as well as generate `--help` and `--version` flags and usage error messages.  ## features    - [x] short options     + boolean short options be be given in clusters e.g. `ls -lhf`     + the last short option in a cluster may take an argument as the next command line word, e.g.       `tar -xf file.tar`   - [x] long options     + arguments to long options may be the next command line word or separated from the option by an       equals sign   - [x] automatic handling of `--help` and `--version` options   - [x] typed argument parsing     + supports booleans, floats, integers, enums, `[]u8` and `[:s]u8` (for some sentinel `s`)   - [x] git-style subcommands  ## usage a usage example is given by `src/main.zig`. cli parameters are declared like so: ```zig const arg_spec = [_]zli.arg{     .{         .name = .{ .long = .{ .full = 'file', .short = 'f' } },         .short_help = 'file name',         .type = []const u8,     },     .{         .name = .{ .short = 'a' },         .short_help = 'short only option',         .type = u8,     },     .{         .name = .{ .long = .{ .full = 'a-really-long-arg' } },         .short_help = 'how does this look?',         .type = enum { yes, no },     },     .{         .name = .{ .long = .{ .full = 'complicated', .short = 'k' } },         .short_help = 'this option is very complicated and the 'short' help message included here is so long that we want some nice line breaking to occur',     },     .{         .name = .{ .long = .{ .full = 'flag-1', .short = '1' } },         .short_help = 'just a flag',         .type = bool,     },     .{         .name = .{ .short = '2' },         .short_help = 'another flag',         .type = bool,     }, };  const version = std.semanticversion{     .major = 0,     .minor = 0,     .patch = 0, };  const cli = zli.clicommand('zli-example-app', .{ .parameters = &arg_spec, .version = version }); ``` cli parameters can then be parsed with `try cli.parse(allocator)`. the auto-generated help message generated by the example is: ``` zli-example-app 0.0.0  options:    -f, --file                     file name   -a                             short only option       --a-really-long-arg        how does this look?   -k, --complicated              this option is very complicated and the 'short' help message                                    included here is so long that we want some nice line                                    breaking to occur   -1, --flag-1                   just a flag   -2                             another flag       --help                     print this help message       --version                  print version information ``` which can you can see by running `zig build run -- --help`.  to use zli in a project you can use the zig package manager by using `https://github.com/dweiller/zli/archive/[[commit-sha]].tar.gz` as the dependency url and then grabbing the 'zli' module, e.g.:  add zli to your `build.zig.zon`: ```sh zig fetch --save=zli https://github.com/dweiller/zli/archive/[[commit-sha]].tar.gz ```  `build.zig`: ```zig pub fn build(b: *std.build) void {      // -- snip --      const exe = ...; // your executable      const zli = b.dependency('zli').module('zli');     exe.root_module.addimport('zli', zli);      // -- snip -- } ``` ","johan0A/gc.zig":"a Zig garbage collector interface for the bdwgc garbage collector. # gc.zig a [zig](https://ziglang.org/) garbage collector package that provides a garbage collector interface as well as the [bdwgc boehm gc](https://github.com/ivmai/bdwgc) garbage collector and more.  ## usage  ```zig const zig_gc = @import('zig_gc');  pub fn main() !void {     // create a new garbage collector interface     const gc = zig_gc.bdwgarbagecollector.gc();       // coerce the gc interface to the standard allocator interface before passing it to arraylist     var list = std.arraylist(u8).init(gc.allocator());       try list.appendslice('hello');     try list.appendslice(' world');      std.debug.print('{s}╲n', .{list.items});     // the program will exit without memory leaks :d } ``` why use a specialized garbage collector interface? (`gc`) <br> 1. it signals to the caller that the function was made with the intention of using a garbage collector. 2. (not yet implemented) the garbage collector can benefit from more information being passsed in about the allocation for better performance. for example, if the allocationg contains pointers or not. and that is not possible with the standard allocator interface.  otherwise, the bdwgarbagecollector acts similarely to a standard allocator and can be used with the standard allocator interface by using `gc.allocator(self: gc)` or `bdwgarbagecollector.allocator()`.  ## install  1. add `zig_gc` to the depency list in `build.zig.zon`:   ```sh zig fetch --save https://github.com/johan0a/gc.zig/archive/refs/tags/0.2.0.tar.gz ```  2. config `build.zig`:  ```zig ... const zig_gc = b.dependency('zig_gc', .{     .target = target,     .optimize = optimize, });  exe.root_module.addimport('zig_gc', zig_gc.module('zig_gc')); ... ```   ## license  licensed under the [mit license](license). ","srmadrid/zgm":"Zig Graphics Mathematics # zgm: zig graphics mathematics  a zig library for mathematics for graphics programming.  ## current features  - vectors - matrices   - column-major   - transformations are offered only for homogeneous coordinates, i.e., 3x3 matrices work as 2d transformations and 4x4 matrices work as 3d transformations, and no 2x2 or 3x3 matrices are provided for 2d or 3d transformations, respectively. - quaternions - colors  all transformations assume a right-handed coordinate system.  ## installation  to use this library in your project, run  ```bash zig fetch --save git+https://github.com/srmadrid/zgm ```  and add it to your `build.zig` file:  ```zig const zgm = b.dependency('zgm', .{}); exe.root_module.addimport('zgm', zgm.module('zgm')); ``` ","blockkwork/ja3-spoof":"http client for zig that spoofs tls/ssl ja3 ## ttl/ssl ja3 spoof  <img src='https://raw.githubusercontent.com/ziglang/logo/9d06c090ca39ef66019a639241ea2d7e448b9fe1/ziggy.svg' width='300'>  **a curl-based zig http client that can spoof [tls/ssl ja3](https://github.com/salesforce/ja3)**  ### 📦 installing  #### 1. install ja3_spoof ``` zig fetch --save https://github.com/blockkwork/ja3-spoof/archive/refs/tags/[latest tag].tar.gz ``` example ``` zig fetch --save https://github.com/blockkwork/ja3-spoof/archive/refs/tags/0.0.1.tar.gz ```  #### 2. add ja3_spoof to build.zig add to build.zig ```zig const ja3_spoof = b.dependency('ja3_spoof', .{}).module('ja3_spoof'); exe.root_module.addimport('ja3_spoof', ja3_spoof); ```   ### 🚀 examples example in ./examples folder    run with command:  ``` make example ```  ```zig const client = ja3_spoof.init(.{         .allocator = allocator,         .custom_cookies = 'cookie',         .custom_user_agent = 'ja3 spoof',         .custom_ciphers = 'aes256-sha', }) catch |err| {         std.debug.print('error: {}╲n', .{err});         return; };  const response = client.send('https://tools.scrapfly.io/api/tls') catch |err| {         std.debug.print('error: {}╲n', .{err});         return; };  std.debug.print('status_code: {}╲nresponse: {s}╲n', .{ response.status_code, response.response }); ```    ### 🛡️ spoofing to spoof ja3 you need to change .custom_ciphers to any other in client options ","nektro/zig-licenses":"generated data from https://spdx.org/licenses/. # zig-licenses  generated data from https://spdx.org/licenses/.  includes extra declarations for osi approved licenses.  includes extra declarations for https://blueoakcouncil.org/list classes.  ## license mit ","nektro/zig-fmt-valueliteral":"Print a value to a writer as it would be written in Zig syntax as a (x) literal. # zig-fmt-valueliteral  print a value to a writer as it would be written in zig syntax as a (x) literal.  ## api - `pub fn fmtvalueliteral(w: std.io.writer, value: anytype, comptime print_type_name: bool) !void`     - `w` is an `anytype` for any value that implements `std.io.writer`. it will then print the respective syntax literal to it.     - `value` is anything you'd like it to print. should it fail to print a value you feel it should be able to please open an issue.     - `print_type_name` is a bool for whether or not you'd like it to print `@typename(t)` or `.` when printing structs, enums, and unions.  ## license mit ","bogwi/pieQ":"Priority Queue for Zig # priority queue in zig  ## foreword  how fast is pieq? on the apple m1 cpu, inserting in random order and removing 100,000,000 unsigned 32-bit integer pairs in releasefast mode takes `1.5` seconds for insert and about `20` seconds for remove. the cumulative time stayed within `22` seconds for many attempts, which pushes pieq a bit into hashmap territory. and pieq does not warp under heavy load because there are no recursive calls. add+remove time compared to zig's standard priorityqueue library shows that pieq is twice as fast.  the api is designed to be as literal and self-explanatory as possible. pieq uses an implicit data structure, so there is no memory allocation routine. the possible error interface is reduced to a bare minimum, like warning you if the queue is empty and you still want to pull something from it; that must be an error. every public method has a comprehensive doc string where needed, and the full api is used in the test section. interesting uncommon features like changing the root or locking the root are also implemented.  pieq has two modes of operation, min-oriented and max-oriented, which are turned on by passing `.min` or `.max` parameters during initiation. this is along with the general idea of a priority queue. however, keys can also be complex types. pieq gives you the ability to define what is min and what is max, and is designed to handle any key, anything you know how to compare; if not, invent how. for example, pieq can be easily used as a data filter, sorting multi-valued elements together, such as enum's literals. or you can filter items with certain keys you are interested in and put them strictly in front of the queue to pop them earlier than the rest. maybe you want to queue vectors as keys, or functions that call other functions, you can do that.  there could be many dozens of possible use cases, i can't mention them all, but the testing section is a good place to start. applications that come to mind are heavy load balancers, stock market or large financial tasks - schedulers, medical solutions; then graphs, dijkstra, of course, statistics, and anywhere you need scheduled event processing.  ## benchmark if you are interested in how well pieq runs on your system, try `bench` step. run this: ```zig zig build bench -- 12345678 ``` and you will get stats for your machine  ``` pieq:        12_345_678 items |action  |push    |pop     |sum     | |time:sec|0.1563  |2.0006  |2.1569  | |ns:item |12.6578 |162.0510|174.7088| ```  running `zig build bench` without arguments tests on the default 1mil. with modern cpus, it makes sense to test harder, at least above 10mils. or if you know in advance the amount of data you intend to run, it is great to do such a test; or against other priority queue implementations to find the best option for your code.   ## usage  1. add `pieq` as a dependency in your `build.zig.zon`.      <!-- <details> -->      <!-- <summary><code>build.zig.zon</code> example </summary> -->      ```zig     .{         .name = 'name_of_your_package',         .version = 'version_of_your_package',         .dependencies = .{             .pieq = .{                 .url = 'https://github.com/bogwi/pieq/archive/master.tar.gz',                 .hash = '1220dbe03c05ad89578e9522d3f2ff1fa611495f770773c711979ac00e48fd2825e9',             },         },     }     ```     if the hash has changed, you will get a gentle  `error: hash mismatch` where in the field `found:` zig brings you the correct value.      <!-- </details> -->  2. add `pieq` as a module in your `build.zig`.      <!-- <details> -->      <!-- <summary><code>build.zig</code> example </summary> -->      ```zig     const pieq = b.dependency('pieq', .{});     exe.addmodule('pieq', pieq.module('pieq'));     ```     using the module in test scopes, requires one more declaration with the same constant (if you need the module in tests, of course).     ```zig     unit_tests.addmodule('pieq', pieq.module('pieq'));      ```       <!-- </details> -->  3. import the module.     ```zig         const pieq = @import('pieq').pieq;     ``` 4. this is your comparison function if you want numbers.     ```zig         fn compareu32(ismin: bool, a: u32, b: u32) bool {             while (ismin)                 return a <= b;             return a >= b;         }     ``` 5. and this this how you initiate the queue.     ```zig         var minqueue = pieq(u32, u32, .min, compareu32).init(your_allocator);         defer minqueue.deinit();     ```  to find out more, see the testing section, file `pieq.zig`. tests and code are placed together so you can explore the implementation better, hovering over the functions and all. thanks. ","kassane/druntime-zigbuild":"D runtime build using zig-build # druntime + phobos (standalone) for zig-build (abs)  > [!note] > a standalone runtime + stdlib (for easy cross-compile) using abs is the goal of this project  **more info:** [issue#6: cross-compile with druntime + phobos2](https://github.com/kassane/anotherbuildstep/issues/6)  ```bash project-specific options:   -dtarget=[string]            the cpu architecture, os, and abi to build for   -dcpu=[string]               target cpu features to add or subtract   -ddynamic-linker=[string]    path to interpreter on the target system   -doptimize=[enum]            prioritize performance, safety, or binary size                                  supported values:                                    debug                                    releasesafe                                    releasefast                                    releasesmall   -dlinkage=[enum]             change linking mode (default: static)                                  supported values:                                    static                                    dynamic   -dphobos=[bool]              build phobos library (default: false) ```","softprops/zig-jsonlog":"format zig std logs as structured JSON <h1 align='center'>     jsonlog </h1>  <div align='center'>     a zero-allocation json formatting logging library for zig </div>  ---  [![ci](https://github.com/softprops/zig-jsonlog/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/zig-jsonlog/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/zig-jsonlog) ![releases](https://img.shields.io/github/v/release/softprops/zig-jsonlog) [![zig support](https://img.shields.io/badge/zig-0.13.0-black?logo=zig)](https://ziglang.org/documentation/0.13.0/)  ## 🍬 features  - make your logs easy to query with tools like aws cloud watch insights - zero-allocation - append arbitrary metadata to your logs - automatic newline insertion  coming soon...  - configurable writers    currently jsonlog writes to stderr, as the default std log fn does. we'd like to make the writer user configurable.  ## examples  ```zig const std = @import('std'); const jsonlog = @import('jsonlog'); const log = std.log.scoped(.demo);  pub const std_options: std.options = .{     // configure the std lib log api fn to use jsonlog formatting     .logfn = jsonlog.logfn, };  pub fn main() void {     // std log interface     log.debug('debug', .{});     log.info('info', .{});     log.warn('warn', .{});     log.err('err', .{});      // jsonlog interface for provoding arbitrary structured metadata     jsonlog.info('things are happening', .{}, .{         .endpoint = '/home',         .method = 'get',     });      // create a custom scope for doing the same     jsonlog.scoped(.demo).warn('things could be better', .{}, .{         .endpoint = '/home',         .method = 'get',     }); } ```  ```json {'ts':'2024-03-20t15:07:15.363z','level':'debug','msg':'debug','scope':'demo'} {'ts':'2024-03-20t15:07:15.364z','level':'info','msg':'info','scope':'demo'} {'ts':'2024-03-20t15:07:15.364z','level':'warning','msg':'warn','scope':'demo'} {'ts':'2024-03-20t15:07:15.364z','level':'error','msg':'err','scope':'demo'} {'ts':'2024-03-20t15:07:15.364z','level':'info','msg':'things are happening','scope':'default','meta':{'endpoint':'/home','method':'get'}} {'ts':'2024-03-20t15:07:15.364z','level':'warning','msg':'things could be better','scope':'demo','meta':{'endpoint':'/home','method':'get'}} ```  ## 📼 installing  create a new exec project with `zig init-exe`. copy the echo handler example above into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/softprops/zig-jsonlog/archive/refs/tags/v0.2.1.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +       // 👇 declare dep properties +        .jsonlog = .{ +            // 👇 uri to download +            .url = 'https://github.com/softprops/zig-jsonlog/archive/refs/tags/v0.2.1.tar.gz', +            // 👇 hash verification +            .hash = '...', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/softprops/zig-jsonlog/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/zig-jsonlog/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference jsonlog dep from build.zig.zon +    const jsonlog = b.dependency('jsonlog', .{ +        .target = target, +        .optimize = optimize, +    }).module('jsonlog');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the jsonlog module to executable +    exe.root_mode.addimport('jsonlog', jsonlog);      b.installartifact(exe); } ```  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)  ╲- softprops 2024 ","nitrogenez/zig-river-config":"River configuration with the power of a programming language. 404: not found","weskoerber/escalator":"A library for privelege-escalation written in Zig. # escalator  a library for privelege-escalation written in zig.  ## requirements  - [zig](https://github.com/ziglang/zig) compiler (`0.12.0` or newer)  ## install  first, add the dependency to your `build.zig.zon` using `zig fetch`:  ```console zig fetch --save git+https://github.com/weskoerber/escalator#main ```  then, import `escalator` into your `build.zig`:  ```zig const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const escalator = b.dependency('escalator', .{             .target = target,             .optimize = optimize,     }).module('escalator');      const my_exe = b.addexecutable(.{         .name = 'my_exe',         .root_source_file = b.path('src/main.zig'),         .target = target,         .optimize = optimize,     });      my_exe.root_module.addimport(escalator); } ```  ## usage  documentation can be found at https://weskoerber.github.io/escalator. the docs are generated by zig's autodoc feature and deployed via github actions.  also see the `examples` directory for example usage. example executables can be built by setting the `examples` option to `true`:  ```zig     const mac_address = b.dependency('escalator', .{             .target = target,             .optimize = optimize,             .examples = true,     }).module('escalator'); ```  ## acknowlegments  - [dns2utf8/sudo.rs](https://gitlab.com/dns2utf8/sudo.rs) ","r4gus/ccdb":"CBOR Credential Database Format # cbor credential database format  this document describes a format to store secrets at rest based on the cbor data format. it is designed as an alternative to other file formats like kdbx used with keepass and keepassxc.  ## source code  ### installation  > requires zig version 0.13.0  #### module  the `ccdb` module can be added to your projects by adding `ccdb` to your list of dependencies in `build.zig.zon`.  ```zig .dependencies = .{     //...     .ccdb = .{         .url = 'https://github.com/r4gus/ccdb/archive/refs/tags/0.1.0.tar.gz',         // adjust the hash if you use another version!         .hash = '12202413b8cfe91ea51f3680b8eaa5645870a6e3fabc5cb9076c80f8182ea1d4028f',     }, }, ```  you can then import the module within your `build.zig`.  ```zig const ccdb_dep = b.dependency('ccdb', .{     .target = target,     .optimize = optimize, });  // create a exe or library and then... exe.root_module.addimport('ccdb', ccdb_dep.module('ccdb')); ```  #### command line tool  you can manage a ccdb database from the command line using `ccdbcmd`. run `build zig -doptimize=releasesmall` to build the executable.  ## documentation  you can build the documentation by running `bikeshed` within the `/docs` folder. ","takuma-shishido/otimorm":"library for PostgreSQL ORM written in zig 🔥 # otimorm > [!important] > **this project is still under development and there are bugs**   > if you find a bug, please open an issue. i will fix it as soon as possible.  `otimorm` is an easy-to-use orm for postgresql that works with the latest version of zig.    tested with `0.14.0-dev`  ## code example see [this](https://github.com/takuma-shishido/otimorm/blob/develop/example/main.zig).  ## todo  - support for more complex queries  ## credit  this project was inspired by [zig-orm](https://github.com/aeronavery/zig-orm) ","kassane/json":"JSON for Modern C++ (uses zig build-system) [![json for modern c++](docs/json.gif)](https://github.com/nlohmann/json/releases)  [![build status](https://ci.appveyor.com/api/projects/status/1acb366xfyg3qybk/branch/develop?svg=true)](https://ci.appveyor.com/project/nlohmann/json) [![ubuntu](https://github.com/nlohmann/json/workflows/ubuntu/badge.svg)](https://github.com/nlohmann/json/actions?query=workflow%3aubuntu) [![macos](https://github.com/nlohmann/json/workflows/macos/badge.svg)](https://github.com/nlohmann/json/actions?query=workflow%3amacos) [![windows](https://github.com/nlohmann/json/workflows/windows/badge.svg)](https://github.com/nlohmann/json/actions?query=workflow%3awindows) [![coverage status](https://coveralls.io/repos/github/nlohmann/json/badge.svg?branch=develop)](https://coveralls.io/github/nlohmann/json?branch=develop) [![coverity scan build status](https://scan.coverity.com/projects/5550/badge.svg)](https://scan.coverity.com/projects/nlohmann-json) [![codacy badge](https://app.codacy.com/project/badge/grade/e0d1a9d5d6fd46fcb655c4cb930bb3e8)](https://www.codacy.com/gh/nlohmann/json/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=nlohmann/json&amp;utm_campaign=badge_grade) [![cirrus ci](https://api.cirrus-ci.com/github/nlohmann/json.svg)](https://cirrus-ci.com/github/nlohmann/json) [![fuzzing status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/json.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:json) [![try online](https://img.shields.io/badge/try-online-blue.svg)](https://wandbox.org/permlink/1mp10jbaano6fuc7) [![documentation](https://img.shields.io/badge/docs-mkdocs-blue.svg)](https://json.nlohmann.me) [![github license](https://img.shields.io/badge/license-mit-blue.svg)](https://raw.githubusercontent.com/nlohmann/json/master/license.mit) [![github releases](https://img.shields.io/github/release/nlohmann/json.svg)](https://github.com/nlohmann/json/releases) [![vcpkg version](https://img.shields.io/vcpkg/v/nlohmann-json)](https://vcpkg.link/ports/nlohmann-json) [![packaging status](https://repology.org/badge/tiny-repos/nlohmann-json.svg)](https://repology.org/project/nlohmann-json/versions) [![github downloads](https://img.shields.io/github/downloads/nlohmann/json/total)](https://github.com/nlohmann/json/releases) [![github issues](https://img.shields.io/github/issues/nlohmann/json.svg)](https://github.com/nlohmann/json/issues) [![average time to resolve an issue](https://isitmaintained.com/badge/resolution/nlohmann/json.svg)](https://isitmaintained.com/project/nlohmann/json 'average time to resolve an issue') [![cii best practices](https://bestpractices.coreinfrastructure.org/projects/289/badge)](https://bestpractices.coreinfrastructure.org/projects/289) [![github sponsors](https://img.shields.io/badge/github-sponsors-ff69b4)](https://github.com/sponsors/nlohmann) [![reuse status](https://api.reuse.software/badge/github.com/nlohmann/json)](https://api.reuse.software/info/github.com/nlohmann/json) [![discord](https://img.shields.io/discord/1003743314341793913)](https://discord.gg/6mrgxkvx7y)  - [design goals](#design-goals) - [sponsors](#sponsors) - [support](#support) ([documentation](https://json.nlohmann.me), [faq](https://json.nlohmann.me/home/faq/), [discussions](https://github.com/nlohmann/json/discussions), [api](https://json.nlohmann.me/api/basic_json/), [bug issues](https://github.com/nlohmann/json/issues)) - [examples](#examples)   - [read json from a file](#read-json-from-a-file)   - [creating `json` objects from json literals](#creating-json-objects-from-json-literals)   - [json as first-class data type](#json-as-first-class-data-type)   - [serialization / deserialization](#serialization--deserialization)   - [stl-like access](#stl-like-access)   - [conversion from stl containers](#conversion-from-stl-containers)   - [json pointer and json patch](#json-pointer-and-json-patch)   - [json merge patch](#json-merge-patch)   - [implicit conversions](#implicit-conversions)   - [conversions to/from arbitrary types](#arbitrary-types-conversions)   - [specializing enum conversion](#specializing-enum-conversion)   - [binary formats (bson, cbor, messagepack, ubjson, and bjdata)](#binary-formats-bson-cbor-messagepack-ubjson-and-bjdata) - [supported compilers](#supported-compilers) - [integration](#integration)   - [cmake](#cmake)   - [package managers](#package-managers)   - [pkg-config](#pkg-config) - [license](#license) - [contact](#contact) - [thanks](#thanks) - [used third-party tools](#used-third-party-tools) - [projects using json for modern c++](#projects-using-json-for-modern-c) - [notes](#notes) - [execute unit tests](#execute-unit-tests)  ## design goals  there are myriads of [json](https://json.org) libraries out there, and each may even have its reason to exist. our class had these design goals:  - **intuitive syntax**. in languages such as python, json feels like a first class data type. we used all the operator magic of modern c++ to achieve the same feeling in your code. check out the [examples below](#examples) and you'll know what i mean.  - **trivial integration**. our whole code consists of a single header file [`json.hpp`](https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp). that's it. no library, no subproject, no dependencies, no complex build system. the class is written in vanilla c++11. all in all, everything should require no adjustment of your compiler flags or project settings.  - **serious testing**. our code is heavily [unit-tested](https://github.com/nlohmann/json/tree/develop/tests/src) and covers [100%](https://coveralls.io/r/nlohmann/json) of the code, including all exceptional behavior. furthermore, we checked with [valgrind](https://valgrind.org) and the [clang sanitizers](https://clang.llvm.org/docs/index.html) that there are no memory leaks. [google oss-fuzz](https://github.com/google/oss-fuzz/tree/master/projects/json) additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. to maintain high quality, the project is following the [core infrastructure initiative (cii) best practices](https://bestpractices.coreinfrastructure.org/projects/289).  other aspects were not so important to us:  - **memory efficiency**. each json object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). the default generalization uses the following c++ data types: `std::string` for strings, `int64_t`, `uint64_t` or `double` for numbers, `std::map` for objects, `std::vector` for arrays, and `bool` for booleans. however, you can template the generalized class `basic_json` to your needs.  - **speed**. there are certainly [faster json libraries](https://github.com/miloyip/nativejson-benchmark#parsing-time) out there. however, if your goal is to speed up your development by adding json support with a single header, then this library is the way to go. if you know how to use a `std::vector` or `std::map`, you are already set.  see the [contribution guidelines](https://github.com/nlohmann/json/blob/master/.github/contributing.md#please-dont) for more information.   ## sponsors  you can sponsor this library at [github sponsors](https://github.com/sponsors/nlohmann).  ### :office: corporate sponsor  [![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/codacy-logo-black.svg/320px-codacy-logo-black.svg.png)](https://github.com/codacy/about)  ### :label: named sponsors  - [michael hartmann](https://github.com/refx-mike) - [stefan hagen](https://github.com/sthagen) - [steve sperandeo](https://github.com/homer6) - [robert jefe lindstädt](https://github.com/eljefedelrodeodeljefe) - [steve wagner](https://github.com/ciroque) - [lion yang](https://github.com/lionnatsu)  thanks everyone!  ## support  :question: if you have a **question**, please check if it is already answered in the [**faq**](https://json.nlohmann.me/home/faq/) or the [**q&a**](https://github.com/nlohmann/json/discussions/categories/q-a) section. if not, please [**ask a new question**](https://github.com/nlohmann/json/discussions/new) there.  :books: if you want to **learn more** about how to use the library, check out the rest of the [**readme**](#examples), have a look at [**code examples**](https://github.com/nlohmann/json/tree/develop/docs/examples), or browse through the [**help pages**](https://json.nlohmann.me).  :construction: if you want to understand the **api** better, check out the [**api reference**](https://json.nlohmann.me/api/basic_json/).  :bug: if you found a **bug**, please check the [**faq**](https://json.nlohmann.me/home/faq/) if it is a known issue or the result of a design decision. please also have a look at the [**issue list**](https://github.com/nlohmann/json/issues) before you [**create a new issue**](https://github.com/nlohmann/json/issues/new/choose). please provide as much information as possible to help us understand and reproduce your issue.  there is also a [**docset**](https://github.com/kapeli/dash-user-contributions/tree/master/docsets/json_for_modern_c%2b%2b) for the documentation browsers [dash](https://kapeli.com/dash), [velocity](https://velocity.silverlakesoftware.com), and [zeal](https://zealdocs.org) that contains the full [documentation](https://json.nlohmann.me) as offline resource.  ## examples  here are some examples to give you an idea how to use the class.  beside the examples below, you may want to:  → check the [documentation](https://json.nlohmann.me/)╲ → browse the [standalone example files](https://github.com/nlohmann/json/tree/develop/docs/examples)  every api function (documented in the [api documentation](https://json.nlohmann.me/api/basic_json/)) has a corresponding standalone example file. for example, the [`emplace()`](https://json.nlohmann.me/api/basic_json/emplace/) function has a matching [emplace.cpp](https://github.com/nlohmann/json/blob/develop/docs/examples/emplace.cpp) example file.  ### read json from a file  the `json` class provides an api for manipulating a json value. to create a `json` object by reading a json file:  ```cpp #include <fstream> #include <nlohmann/json.hpp> using json = nlohmann::json;  // ...  std::ifstream f('example.json'); json data = json::parse(f); ```  ### creating `json` objects from json literals  assume you want to create hard-code this literal json value in a file, as a `json` object:  ```json {   'pi': 3.141,   'happy': true } ```  there are various options:  ```cpp // using (raw) string literals and json::parse json ex1 = json::parse(r'(   {     'pi': 3.141,     'happy': true   } )');  // using user-defined (raw) string literals using namespace nlohmann::literals; json ex2 = r'(   {     'pi': 3.141,     'happy': true   } )'_json;  // using initializer lists json ex3 = {   {'happy', true},   {'pi', 3.141}, }; ```  ### json as first-class data type  here are some examples to give you an idea how to use the class.  assume you want to create the json object  ```json {   'pi': 3.141,   'happy': true,   'name': 'niels',   'nothing': null,   'answer': {     'everything': 42   },   'list': [1, 0, 2],   'object': {     'currency': 'usd',     'value': 42.99   } } ```  with this library, you could write:  ```cpp // create an empty structure (null) json j;  // add a number that is stored as double (note the implicit conversion of j to an object) j['pi'] = 3.141;  // add a boolean that is stored as bool j['happy'] = true;  // add a string that is stored as std::string j['name'] = 'niels';  // add another null object by passing nullptr j['nothing'] = nullptr;  // add an object inside the object j['answer']['everything'] = 42;  // add an array that is stored as std::vector (using an initializer list) j['list'] = { 1, 0, 2 };  // add another object (using an initializer list of pairs) j['object'] = { {'currency', 'usd'}, {'value', 42.99} };  // instead, you could also write (which looks very similar to the json above) json j2 = {   {'pi', 3.141},   {'happy', true},   {'name', 'niels'},   {'nothing', nullptr},   {'answer', {     {'everything', 42}   }},   {'list', {1, 0, 2}},   {'object', {     {'currency', 'usd'},     {'value', 42.99}   }} }; ```  note that in all these cases, you never need to 'tell' the compiler which json value type you want to use. if you want to be explicit or express some edge cases, the functions [`json::array()`](https://json.nlohmann.me/api/basic_json/array/) and [`json::object()`](https://json.nlohmann.me/api/basic_json/object/) will help:  ```cpp // a way to express the empty array [] json empty_array_explicit = json::array();  // ways to express the empty object {} json empty_object_implicit = json({}); json empty_object_explicit = json::object();  // a way to express an _array_ of key/value pairs [['currency', 'usd'], ['value', 42.99]] json array_not_object = json::array({ {'currency', 'usd'}, {'value', 42.99} }); ```  ### serialization / deserialization  #### to/from strings  you can create a json value (deserialization) by appending `_json` to a string literal:  ```cpp // create object from string literal json j = '{ ╲'happy╲': true, ╲'pi╲': 3.141 }'_json;  // or even nicer with a raw string literal auto j2 = r'(   {     'happy': true,     'pi': 3.141   } )'_json; ```  note that without appending the `_json` suffix, the passed string literal is not parsed, but just used as json string value. that is, `json j = '{ ╲'happy╲': true, ╲'pi╲': 3.141 }'` would just store the string `'{ 'happy': true, 'pi': 3.141 }'` rather than parsing the actual object.  the string literal should be brought into scope with `using namespace nlohmann::literals;` (see [`json::parse()`](https://json.nlohmann.me/api/operator_literal_json/)).  the above example can also be expressed explicitly using [`json::parse()`](https://json.nlohmann.me/api/basic_json/parse/):  ```cpp // parse explicitly auto j3 = json::parse(r'({'happy': true, 'pi': 3.141})'); ```  you can also get a string representation of a json value (serialize):  ```cpp // explicit conversion to string std::string s = j.dump();    // {'happy':true,'pi':3.141}  // serialization with pretty printing // pass in the amount of spaces to indent std::cout << j.dump(4) << std::endl; // { //     'happy': true, //     'pi': 3.141 // } ```  note the difference between serialization and assignment:  ```cpp // store a string in a json value json j_string = 'this is a string';  // retrieve the string value auto cpp_string = j_string.template get<std::string>(); // retrieve the string value (alternative when a variable already exists) std::string cpp_string2; j_string.get_to(cpp_string2);  // retrieve the serialized value (explicit json serialization) std::string serialized_string = j_string.dump();  // output of original string std::cout << cpp_string << ' == ' << cpp_string2 << ' == ' << j_string.template get<std::string>() << '╲n'; // output of serialized value std::cout << j_string << ' == ' << serialized_string << std::endl; ```  [`.dump()`](https://json.nlohmann.me/api/basic_json/dump/) returns the originally stored string value.  note the library only supports utf-8. when you store strings with different encodings in the library, calling [`dump()`](https://json.nlohmann.me/api/basic_json/dump/) may throw an exception unless `json::error_handler_t::replace` or `json::error_handler_t::ignore` are used as error handlers.  #### to/from streams (e.g. files, string streams)  you can also use streams to serialize and deserialize:  ```cpp // deserialize from standard input json j; std::cin >> j;  // serialize to standard output std::cout << j;  // the setw manipulator was overloaded to set the indentation for pretty printing std::cout << std::setw(4) << j << std::endl; ```  these operators work for any subclasses of `std::istream` or `std::ostream`. here is the same example with files:  ```cpp // read a json file std::ifstream i('file.json'); json j; i >> j;  // write prettified json to another file std::ofstream o('pretty.json'); o << std::setw(4) << j << std::endl; ```  please note that setting the exception bit for `failbit` is inappropriate for this use case. it will result in program termination due to the `noexcept` specifier in use.  #### read from iterator range  you can also parse json from an iterator range; that is, from any container accessible by iterators whose `value_type` is an integral type of 1, 2 or 4 bytes, which will be interpreted as utf-8, utf-16 and utf-32 respectively. for instance, a `std::vector<std::uint8_t>`, or a `std::list<std::uint16_t>`:  ```cpp std::vector<std::uint8_t> v = {'t', 'r', 'u', 'e'}; json j = json::parse(v.begin(), v.end()); ```  you may leave the iterators for the range [begin, end):  ```cpp std::vector<std::uint8_t> v = {'t', 'r', 'u', 'e'}; json j = json::parse(v); ```  #### custom data source  since the parse function accepts arbitrary iterator ranges, you can provide your own data sources by implementing the `legacyinputiterator` concept.  ```cpp struct mycontainer {   void advance();   const char& get_current(); };  struct myiterator {     using difference_type = std::ptrdiff_t;     using value_type = char;     using pointer = const char*;     using reference = const char&;     using iterator_category = std::input_iterator_tag;      myiterator& operator++() {         mycontainer.advance();         return *this;     }      bool operator!=(const myiterator& rhs) const {         return rhs.target != target;     }      reference operator*() const {         return target.get_current();     }      mycontainer* target = nullptr; };  myiterator begin(mycontainer& tgt) {     return myiterator{&tgt}; }  myiterator end(const mycontainer&) {     return {}; }  void foo() {     mycontainer c;     json j = json::parse(c); } ```  #### sax interface  the library uses a sax-like interface with the following functions:  ```cpp // called when null is parsed bool null();  // called when a boolean is parsed; value is passed bool boolean(bool val);  // called when a signed or unsigned integer number is parsed; value is passed bool number_integer(number_integer_t val); bool number_unsigned(number_unsigned_t val);  // called when a floating-point number is parsed; value and original string is passed bool number_float(number_float_t val, const string_t& s);  // called when a string is parsed; value is passed and can be safely moved away bool string(string_t& val); // called when a binary value is parsed; value is passed and can be safely moved away bool binary(binary_t& val);  // called when an object or array begins or ends, resp. the number of elements is passed (or -1 if not known) bool start_object(std::size_t elements); bool end_object(); bool start_array(std::size_t elements); bool end_array(); // called when an object key is parsed; value is passed and can be safely moved away bool key(string_t& val);  // called when a parse error occurs; byte position, the last token, and an exception is passed bool parse_error(std::size_t position, const std::string& last_token, const detail::exception& ex); ```  the return value of each function determines whether parsing should proceed.  to implement your own sax handler, proceed as follows:  1. implement the sax interface in a class. you can use class `nlohmann::json_sax<json>` as base class, but you can also use any class where the functions described above are implemented and public. 2. create an object of your sax interface class, e.g. `my_sax`. 3. call `bool json::sax_parse(input, &my_sax)`; where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your sax interface.  note the `sax_parse` function only returns a `bool` indicating the result of the last executed sax event. it does not return a  `json` value - it is up to you to decide what to do with the sax events. furthermore, no exceptions are thrown in case of a parse error - it is up to you what to do with the exception object passed to your `parse_error` implementation. internally, the sax interface is used for the dom parser (class `json_sax_dom_parser`) as well as the acceptor (`json_sax_acceptor`), see file [`json_sax.hpp`](https://github.com/nlohmann/json/blob/develop/include/nlohmann/detail/input/json_sax.hpp).  ### stl-like access  we designed the json class to behave just like an stl container. in fact, it satisfies the [**reversiblecontainer**](https://en.cppreference.com/w/cpp/named_req/reversiblecontainer) requirement.  ```cpp // create an array using push_back json j; j.push_back('foo'); j.push_back(1); j.push_back(true);  // also use emplace_back j.emplace_back(1.78);  // iterate the array for (json::iterator it = j.begin(); it != j.end(); ++it) {   std::cout << *it << '╲n'; }  // range-based for for (auto& element : j) {   std::cout << element << '╲n'; }  // getter/setter const auto tmp = j[0].template get<std::string>(); j[1] = 42; bool foo = j.at(2);  // comparison j == r'(['foo', 1, true, 1.78])'_json;  // true  // other stuff j.size();     // 4 entries j.empty();    // false j.type();     // json::value_t::array j.clear();    // the array is empty again  // convenience type checkers j.is_null(); j.is_boolean(); j.is_number(); j.is_object(); j.is_array(); j.is_string();  // create an object json o; o['foo'] = 23; o['bar'] = false; o['baz'] = 3.141;  // also use emplace o.emplace('weather', 'sunny');  // special iterator member functions for objects for (json::iterator it = o.begin(); it != o.end(); ++it) {   std::cout << it.key() << ' : ' << it.value() << '╲n'; }  // the same code as range for for (auto& el : o.items()) {   std::cout << el.key() << ' : ' << el.value() << '╲n'; }  // even easier with structured bindings (c++17) for (auto& [key, value] : o.items()) {   std::cout << key << ' : ' << value << '╲n'; }  // find an entry if (o.contains('foo')) {   // there is an entry with key 'foo' }  // or via find and an iterator if (o.find('foo') != o.end()) {   // there is an entry with key 'foo' }  // or simpler using count() int foo_present = o.count('foo'); // 1 int fob_present = o.count('fob'); // 0  // delete an entry o.erase('foo'); ```   ### conversion from stl containers  any sequence container (`std::array`, `std::vector`, `std::deque`, `std::forward_list`, `std::list`) whose values can be used to construct json values (e.g., integers, floating point numbers, booleans, string types, or again stl containers described in this section) can be used to create a json array. the same holds for similar associative containers (`std::set`, `std::multiset`, `std::unordered_set`, `std::unordered_multiset`), but in these cases the order of the elements of the array depends on how the elements are ordered in the respective stl container.  ```cpp std::vector<int> c_vector {1, 2, 3, 4}; json j_vec(c_vector); // [1, 2, 3, 4]  std::deque<double> c_deque {1.2, 2.3, 3.4, 5.6}; json j_deque(c_deque); // [1.2, 2.3, 3.4, 5.6]  std::list<bool> c_list {true, true, false, true}; json j_list(c_list); // [true, true, false, true]  std::forward_list<int64_t> c_flist {12345678909876, 23456789098765, 34567890987654, 45678909876543}; json j_flist(c_flist); // [12345678909876, 23456789098765, 34567890987654, 45678909876543]  std::array<unsigned long, 4> c_array {{1, 2, 3, 4}}; json j_array(c_array); // [1, 2, 3, 4]  std::set<std::string> c_set {'one', 'two', 'three', 'four', 'one'}; json j_set(c_set); // only one entry for 'one' is used // ['four', 'one', 'three', 'two']  std::unordered_set<std::string> c_uset {'one', 'two', 'three', 'four', 'one'}; json j_uset(c_uset); // only one entry for 'one' is used // maybe ['two', 'three', 'four', 'one']  std::multiset<std::string> c_mset {'one', 'two', 'one', 'four'}; json j_mset(c_mset); // both entries for 'one' are used // maybe ['one', 'two', 'one', 'four']  std::unordered_multiset<std::string> c_umset {'one', 'two', 'one', 'four'}; json j_umset(c_umset); // both entries for 'one' are used // maybe ['one', 'two', 'one', 'four'] ```  likewise, any associative key-value containers (`std::map`, `std::multimap`, `std::unordered_map`, `std::unordered_multimap`) whose keys can construct an `std::string` and whose values can be used to construct json values (see examples above) can be used to create a json object. note that in case of multimaps only one key is used in the json object and the value depends on the internal order of the stl container.  ```cpp std::map<std::string, int> c_map { {'one', 1}, {'two', 2}, {'three', 3} }; json j_map(c_map); // {'one': 1, 'three': 3, 'two': 2 }  std::unordered_map<const char*, double> c_umap { {'one', 1.2}, {'two', 2.3}, {'three', 3.4} }; json j_umap(c_umap); // {'one': 1.2, 'two': 2.3, 'three': 3.4}  std::multimap<std::string, bool> c_mmap { {'one', true}, {'two', true}, {'three', false}, {'three', true} }; json j_mmap(c_mmap); // only one entry for key 'three' is used // maybe {'one': true, 'two': true, 'three': true}  std::unordered_multimap<std::string, bool> c_ummap { {'one', true}, {'two', true}, {'three', false}, {'three', true} }; json j_ummap(c_ummap); // only one entry for key 'three' is used // maybe {'one': true, 'two': true, 'three': true} ```  ### json pointer and json patch  the library supports **json pointer** ([rfc 6901](https://tools.ietf.org/html/rfc6901)) as alternative means to address structured values. on top of this, **json patch** ([rfc 6902](https://tools.ietf.org/html/rfc6902)) allows describing differences between two json values - effectively allowing patch and diff operations known from unix.  ```cpp // a json value json j_original = r'({   'baz': ['one', 'two', 'three'],   'foo': 'bar' })'_json;  // access members with a json pointer (rfc 6901) j_original['/baz/1'_json_pointer]; // 'two'  // a json patch (rfc 6902) json j_patch = r'([   { 'op': 'replace', 'path': '/baz', 'value': 'boo' },   { 'op': 'add', 'path': '/hello', 'value': ['world'] },   { 'op': 'remove', 'path': '/foo'} ])'_json;  // apply the patch json j_result = j_original.patch(j_patch); // { //    'baz': 'boo', //    'hello': ['world'] // }  // calculate a json patch from two json values json::diff(j_result, j_original); // [ //   { 'op':' replace', 'path': '/baz', 'value': ['one', 'two', 'three'] }, //   { 'op': 'remove','path': '/hello' }, //   { 'op': 'add', 'path': '/foo', 'value': 'bar' } // ] ```  ### json merge patch  the library supports **json merge patch** ([rfc 7386](https://tools.ietf.org/html/rfc7386)) as a patch format. instead of using json pointer (see above) to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified.  ```cpp // a json value json j_document = r'({   'a': 'b',   'c': {     'd': 'e',     'f': 'g'   } })'_json;  // a patch json j_patch = r'({   'a':'z',   'c': {     'f': null   } })'_json;  // apply the patch j_document.merge_patch(j_patch); // { //  'a': 'z', //  'c': { //    'd': 'e' //  } // } ```  ### implicit conversions  supported types can be implicitly converted to json values.  it is recommended to **not use** implicit conversions **from** a json value. you can find more details about this recommendation [here](https://www.github.com/nlohmann/json/issues/958). you can switch off implicit conversions by defining `json_use_implicit_conversions` to `0` before including the `json.hpp` header. when using cmake, you can also achieve this by setting the option `json_implicitconversions` to `off`.  ```cpp // strings std::string s1 = 'hello, world!'; json js = s1; auto s2 = js.template get<std::string>(); // not recommended std::string s3 = js; std::string s4; s4 = js;  // booleans bool b1 = true; json jb = b1; auto b2 = jb.template get<bool>(); // not recommended bool b3 = jb; bool b4; b4 = jb;  // numbers int i = 42; json jn = i; auto f = jn.template get<double>(); // not recommended double f2 = jb; double f3; f3 = jb;  // etc. ```  note that `char` types are not automatically converted to json strings, but to integer numbers. a conversion to a string must be specified explicitly:  ```cpp char ch = 'a';                       // ascii value 65 json j_default = ch;                 // stores integer number 65 json j_string = std::string(1, ch);  // stores string 'a' ```  ### arbitrary types conversions  every type can be serialized in json, not just stl containers and scalar types. usually, you would do something along those lines:  ```cpp namespace ns {     // a simple struct to model a person     struct person {         std::string name;         std::string address;         int age;     }; }  ns::person p = {'ned flanders', '744 evergreen terrace', 60};  // convert to json: copy each value into the json object json j; j['name'] = p.name; j['address'] = p.address; j['age'] = p.age;  // ...  // convert from json: copy each value from the json object ns::person p {     j['name'].template get<std::string>(),     j['address'].template get<std::string>(),     j['age'].template get<int>() }; ```  it works, but that's quite a lot of boilerplate... fortunately, there's a better way:  ```cpp // create a person ns::person p {'ned flanders', '744 evergreen terrace', 60};  // conversion: person -> json json j = p;  std::cout << j << std::endl; // {'address':'744 evergreen terrace','age':60,'name':'ned flanders'}  // conversion: json -> person auto p2 = j.template get<ns::person>();  // that's it assert(p == p2); ```  #### basic usage  to make this work with one of your types, you only need to provide two functions:  ```cpp using json = nlohmann::json;  namespace ns {     void to_json(json& j, const person& p) {         j = json{{'name', p.name}, {'address', p.address}, {'age', p.age}};     }      void from_json(const json& j, person& p) {         j.at('name').get_to(p.name);         j.at('address').get_to(p.address);         j.at('age').get_to(p.age);     } } // namespace ns ```  that's all! when calling the `json` constructor with your type, your custom `to_json` method will be automatically called. likewise, when calling `template get<your_type>()` or `get_to(your_type&)`, the `from_json` method will be called.  some important things:  * those methods **must** be in your type's namespace (which can be the global namespace), or the library will not be able to locate them (in this example, they are in namespace `ns`, where `person` is defined). * those methods **must** be available (e.g., proper headers must be included) everywhere you use these conversions. look at [issue 1108](https://github.com/nlohmann/json/issues/1108) for errors that may occur otherwise. * when using `template get<your_type>()`, `your_type` **must** be [defaultconstructible](https://en.cppreference.com/w/cpp/named_req/defaultconstructible). (there is a way to bypass this requirement described later.) * in function `from_json`, use function [`at()`](https://json.nlohmann.me/api/basic_json/at/) to access the object values rather than `operator[]`. in case a key does not exist, `at` throws an exception that you can handle, whereas `operator[]` exhibits undefined behavior. * you do not need to add serializers or deserializers for stl types like `std::vector`: the library already implements these.  #### simplify your life with macros  if you just want to serialize/deserialize some structs, the `to_json`/`from_json` functions can be a lot of boilerplate.  there are two macros to make your life easier as long as you (1) want to use a json object as serialization and (2) want to use the member variable names as object keys in that object:  - `nlohmann_define_type_non_intrusive(name, member1, member2, ...)` is to be defined inside the namespace of the class/struct to create code for. - `nlohmann_define_type_intrusive(name, member1, member2, ...)` is to be defined inside the class/struct to create code for. this macro can also access private members.  in both macros, the first parameter is the name of the class/struct, and all remaining parameters name the members.  ##### examples  the `to_json`/`from_json` functions for the `person` struct above can be created with:  ```cpp namespace ns {     nlohmann_define_type_non_intrusive(person, name, address, age) } ```  here is an example with private members, where `nlohmann_define_type_intrusive` is needed:  ```cpp namespace ns {     class address {       private:         std::string street;         int housenumber;         int postcode;        public:         nlohmann_define_type_intrusive(address, street, housenumber, postcode)     }; } ```  #### how do i convert third-party types?  this requires a bit more advanced technique. but first, let's see how this conversion mechanism works:  the library uses **json serializers** to convert types to json. the default serializer for `nlohmann::json` is `nlohmann::adl_serializer` (adl means [argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl)).  it is implemented like this (simplified):  ```cpp template <typename t> struct adl_serializer {     static void to_json(json& j, const t& value) {         // calls the 'to_json' method in t's namespace     }      static void from_json(const json& j, t& value) {         // same thing, but with the 'from_json' method     } }; ```  this serializer works fine when you have control over the type's namespace. however, what about `boost::optional` or `std::filesystem::path` (c++17)? hijacking the `boost` namespace is pretty bad, and it's illegal to add something other than template specializations to `std`...  to solve this, you need to add a specialization of `adl_serializer` to the `nlohmann` namespace, here's an example:  ```cpp // partial specialization (full specialization works too) namespace nlohmann {     template <typename t>     struct adl_serializer<boost::optional<t>> {         static void to_json(json& j, const boost::optional<t>& opt) {             if (opt == boost::none) {                 j = nullptr;             } else {               j = *opt; // this will call adl_serializer<t>::to_json which will                         // find the free function to_json in t's namespace!             }         }          static void from_json(const json& j, boost::optional<t>& opt) {             if (j.is_null()) {                 opt = boost::none;             } else {                 opt = j.template get<t>(); // same as above, but with                                            // adl_serializer<t>::from_json             }         }     }; } ```  #### how can i use `get()` for non-default constructible/non-copyable types?  there is a way, if your type is [moveconstructible](https://en.cppreference.com/w/cpp/named_req/moveconstructible). you will need to specialize the `adl_serializer` as well, but with a special `from_json` overload:  ```cpp struct move_only_type {     move_only_type() = delete;     move_only_type(int ii): i(ii) {}     move_only_type(const move_only_type&) = delete;     move_only_type(move_only_type&&) = default;      int i; };  namespace nlohmann {     template <>     struct adl_serializer<move_only_type> {         // note: the return type is no longer 'void', and the method only takes         // one argument         static move_only_type from_json(const json& j) {             return {j.template get<int>()};         }          // here's the catch! you must provide a to_json method! otherwise, you         // will not be able to convert move_only_type to json, since you fully         // specialized adl_serializer on that type         static void to_json(json& j, move_only_type t) {             j = t.i;         }     }; } ```  #### can i write my own serializer? (advanced use)  yes. you might want to take a look at [`unit-udt.cpp`](https://github.com/nlohmann/json/blob/develop/tests/src/unit-udt.cpp) in the test suite, to see a few examples.  if you write your own serializer, you'll need to do a few things:  - use a different `basic_json` alias than `nlohmann::json` (the last template parameter of `basic_json` is the `jsonserializer`) - use your `basic_json` alias (or a template parameter) in all your `to_json`/`from_json` methods - use `nlohmann::to_json` and `nlohmann::from_json` when you need adl  here is an example, without simplifications, that only accepts types with a size <= 32, and uses adl.  ```cpp // you should use void as a second template argument // if you don't need compile-time checks on t template<typename t, typename sfinae = typename std::enable_if<sizeof(t) <= 32>::type> struct less_than_32_serializer {     template <typename basicjsontype>     static void to_json(basicjsontype& j, t value) {         // we want to use adl, and call the correct to_json overload         using nlohmann::to_json; // this method is called by adl_serializer,                                  // this is where the magic happens         to_json(j, value);     }      template <typename basicjsontype>     static void from_json(const basicjsontype& j, t& value) {         // same thing here         using nlohmann::from_json;         from_json(j, value);     } }; ```  be **very** careful when reimplementing your serializer, you can stack overflow if you don't pay attention:  ```cpp template <typename t, void> struct bad_serializer {     template <typename basicjsontype>     static void to_json(basicjsontype& j, const t& value) {       // this calls basicjsontype::json_serializer<t>::to_json(j, value);       // if basicjsontype::json_serializer == bad_serializer ... oops!       j = value;     }      template <typename basicjsontype>     static void to_json(const basicjsontype& j, t& value) {       // this calls basicjsontype::json_serializer<t>::from_json(j, value);       // if basicjsontype::json_serializer == bad_serializer ... oops!       value = j.template get<t>(); // oops!     } }; ```  ### specializing enum conversion  by default, enum values are serialized to json as integers. in some cases this could result in undesired behavior. if an enum is modified or re-ordered after data has been serialized to json, the later de-serialized json data may be undefined or a different enum value than was originally intended.  it is possible to more precisely specify how a given enum is mapped to and from json as shown below:  ```cpp // example enum type declaration enum taskstate {     ts_stopped,     ts_running,     ts_completed,     ts_invalid=-1, };  // map taskstate values to json as strings nlohmann_json_serialize_enum( taskstate, {     {ts_invalid, nullptr},     {ts_stopped, 'stopped'},     {ts_running, 'running'},     {ts_completed, 'completed'}, }) ```  the `nlohmann_json_serialize_enum()` macro declares a set of `to_json()` / `from_json()` functions for type `taskstate` while avoiding repetition and boilerplate serialization code.  **usage:**  ```cpp // enum to json as string json j = ts_stopped; assert(j == 'stopped');  // json string to enum json j3 = 'running'; assert(j3.template get<taskstate>() == ts_running);  // undefined json value to enum (where the first map entry above is the default) json jpi = 3.14; assert(jpi.template get<taskstate>() == ts_invalid ); ```  just as in [arbitrary type conversions](#arbitrary-types-conversions) above, - `nlohmann_json_serialize_enum()` must be declared in your enum type's namespace (which can be the global namespace), or the library will not be able to locate it, and it will default to integer serialization. - it must be available (e.g., proper headers must be included) everywhere you use the conversions.  other important points: - when using `template get<enum_type>()`, undefined json values will default to the first pair specified in your map. select this default pair carefully. - if an enum or json value is specified more than once in your map, the first matching occurrence from the top of the map will be returned when converting to or from json.  ### binary formats (bson, cbor, messagepack, ubjson, and bjdata)  though json is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance over a network. hence, the library supports [bson](https://bsonspec.org) (binary json), [cbor](https://cbor.io) (concise binary object representation), [messagepack](https://msgpack.org), [ubjson](https://ubjson.org) (universal binary json specification) and [bjdata](https://neurojson.org/bjdata) (binary jdata) to efficiently encode json values to byte vectors and to decode such vectors.  ```cpp // create a json value json j = r'({'compact': true, 'schema': 0})'_json;  // serialize to bson std::vector<std::uint8_t> v_bson = json::to_bson(j);  // 0x1b, 0x00, 0x00, 0x00, 0x08, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63, 0x74, 0x00, 0x01, 0x10, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // roundtrip json j_from_bson = json::from_bson(v_bson);  // serialize to cbor std::vector<std::uint8_t> v_cbor = json::to_cbor(j);  // 0xa2, 0x67, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63, 0x74, 0xf5, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x00  // roundtrip json j_from_cbor = json::from_cbor(v_cbor);  // serialize to messagepack std::vector<std::uint8_t> v_msgpack = json::to_msgpack(j);  // 0x82, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63, 0x74, 0xc3, 0xa6, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x00  // roundtrip json j_from_msgpack = json::from_msgpack(v_msgpack);  // serialize to ubjson std::vector<std::uint8_t> v_ubjson = json::to_ubjson(j);  // 0x7b, 0x69, 0x07, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63, 0x74, 0x54, 0x69, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x69, 0x00, 0x7d  // roundtrip json j_from_ubjson = json::from_ubjson(v_ubjson); ```  the library also supports binary types from bson, cbor (byte strings), and messagepack (bin, ext, fixext). they are stored by default as `std::vector<std::uint8_t>` to be processed outside the library.  ```cpp // cbor byte string with payload 0xcafe std::vector<std::uint8_t> v = {0x42, 0xca, 0xfe};  // read value json j = json::from_cbor(v);  // the json value has type binary j.is_binary(); // true  // get reference to stored binary value auto& binary = j.get_binary();  // the binary value has no subtype (cbor has no binary subtypes) binary.has_subtype(); // false  // access std::vector<std::uint8_t> member functions binary.size(); // 2 binary[0]; // 0xca binary[1]; // 0xfe  // set subtype to 0x10 binary.set_subtype(0x10);  // serialize to messagepack auto cbor = json::to_msgpack(j); // 0xd5 (fixext2), 0x10, 0xca, 0xfe ```   ## supported compilers  though it's 2023 already, the support for c++11 is still a bit sparse. currently, the following compilers are known to work:  - gcc 4.8 - 12.0 (and possibly later) - clang 3.4 - 15.0 (and possibly later) - apple clang 9.1 - 13.1 (and possibly later) - intel c++ compiler 17.0.2 (and possibly later) - nvidia cuda compiler 11.0.221 (and possibly later) - microsoft visual c++ 2015 / build tools 14.0.25123.0 (and possibly later) - microsoft visual c++ 2017 / build tools 15.5.180.51428 (and possibly later) - microsoft visual c++ 2019 / build tools 16.3.1+1def00d3d (and possibly later) - microsoft visual c++ 2022 / build tools 19.30.30709.0 (and possibly later)  i would be happy to learn about other compilers/versions.  please note:  - gcc 4.8 has a bug [57824](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57824)): multiline raw strings cannot be the arguments to macros. don't use multiline raw strings directly in macros with this compiler. - android defaults to using very old compilers and c++ libraries. to fix this, add the following to your `application.mk`. this will switch to the llvm c++ library, the clang compiler, and enable c++11 and other features disabled by default.      ```     app_stl := c++_shared     ndk_toolchain_version := clang3.6     app_cppflags += -frtti -fexceptions     ```      the code compiles successfully with [android ndk](https://developer.android.com/ndk/index.html?hl=ml), revision 9 - 11 (and possibly later) and [crystax's android ndk](https://www.crystax.net/en/android/ndk) version 10.  - for gcc running on mingw or android sdk, the error `'to_string' is not a member of 'std'` (or similarly, for `strtod` or `strtof`) may occur. note this is not an issue with the code,  but rather with the compiler itself. on android, see above to build with a newer environment.  for mingw, please refer to [this site](https://tehsausage.com/mingw-to-string) and [this discussion](https://github.com/nlohmann/json/issues/136) for information on how to fix this bug. for android ndk using `app_stl := gnustl_static`, please refer to [this discussion](https://github.com/nlohmann/json/issues/219).  - unsupported versions of gcc and clang are rejected by `#error` directives. this can be switched off by defining `json_skip_unsupported_compiler_check`. note that you can expect no support in this case.  the following compilers are currently used in continuous integration at [appveyor](https://ci.appveyor.com/project/nlohmann/json), [cirrus ci](https://cirrus-ci.com/github/nlohmann/json), and [github actions](https://github.com/nlohmann/json/actions):  | compiler                                                                                               | operating system   | ci provider    | |--------------------------------------------------------------------------------------------------------|--------------------|----------------| | apple clang 11.0.3 (clang-1103.0.32.62);  xcode 11.7                                                   | macos 11.7.1       | github actions | | apple clang 12.0.0 (clang-1200.0.32.29);  xcode 12.4                                                   | macos 11.7.1       | github actions | | apple clang 12.0.5 (clang-1205.0.22.11);  xcode 12.5.1                                                 | macos 11.7.1       | github actions | | apple clang 13.0.0 (clang-1300.0.29.3);   xcode 13.0                                                   | macos 11.7.1       | github actions | | apple clang 13.0.0 (clang-1300.0.29.3);   xcode 13.1                                                   | macos 12.6.1       | github actions | | apple clang 13.0.0 (clang-1300.0.29.30);  xcode 13.2.1                                                 | macos 12.6.1       | github actions | | apple clang 13.1.6 (clang-1316.0.21.2.3); xcode 13.3.1                                                 | macos 12.6.1       | github actions | | apple clang 13.1.6 (clang-1316.0.21.2.5); xcode 13.4.1                                                 | macos 12.6.1       | github actions | | apple clang 14.0.0 (clang-1400.0.29.102); xcode 14.0                                                   | macos 12.6.1       | github actions | | apple clang 14.0.0 (clang-1400.0.29.102); xcode 14.0.1                                                 | macos 12.6.1       | github actions | | apple clang 14.0.0 (clang-1400.0.29.202); xcode 14.1                                                   | macos 12.6.1       | github actions | | clang 3.5.2                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 3.6.2                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 3.7.1                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 3.8.1                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 3.9.1                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 4.0.1                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 5.0.2                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 6.0.1                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 7.0.1                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 8.0.0                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 9.0.0                                                                                            | ubuntu 20.04.3 lts | github actions | | clang 10.0.0                                                                                           | ubuntu 20.04.3 lts | github actions | | clang 10.0.0 with gnu-like command-line                                                                | windows-10.0.17763 | github actions | | clang 11.0.0 with gnu-like command-line                                                                | windows-10.0.17763 | github actions | | clang 11.0.0 with msvc-like command-line                                                               | windows-10.0.17763 | github actions | | clang 11.0.0                                                                                           | ubuntu 20.04.3 lts | github actions | | clang 12.0.0                                                                                           | ubuntu 20.04.3 lts | github actions | | clang 12.0.0 with gnu-like command-line                                                                | windows-10.0.17763 | github actions | | clang 13.0.0                                                                                           | ubuntu 20.04.3 lts | github actions | | clang 13.0.0 with gnu-like command-line                                                                | windows-10.0.17763 | github actions | | clang 14.0.0                                                                                           | ubuntu 20.04.3 lts | github actions | | clang 14.0.0 with gnu-like command-line                                        ","zigster64/dotenv.zig":"Load ENV vars from .env files on boot  # dotenv.zig load env vars from .env files on boot   --   on boot, calling `env.init(alloc, '.env')` will return an env that  includes values from the `.env` file  lines starting with `#` are treated as comments  all other lines will take the form   ``` env_var_name=value ```  lines that do not have a `=` sign will be skipped  ## install  ``` zig fetch --save git+https://github.com/zigster64/dotenv.zig#main ```  then add to your build.zig  ```zig     const dotenv = b.dependency('dotenv', .{ dependency options here );     exe.root_module.addimport('dotenv', dotenv.module('dotenv')); ```  ## 🤮 microlibray alert 🤮  this is a microlibrary, the code is trivial enough  consider just copypasting the file `dotenv.zig` into your project instead of adding yet another microdependency  its only about 20 lines of code  up to you  ## usage  ```zig const dotenv = @import('dotenv');  pub fn main() !void {     // create an allocator     var gpa = std.heap.generalpurposeallocator(.{}){};     const allocator = gpa.allocator();     defer gpa.deinit();      // init the dotenv object - this will read the .env file at runtime     var env = try dotenv.init(allocator, '.env');     defer env.deinit();      // gen 'env' vars     var database_host = env.get('database_host') orelse 'localhost';     var database_name = env.get('database_name') orelse 'zigzag-data';      ... do stuff      // change the value of the database_host     try env.put('database_host', 'postgres.local'); } ```  ## how it works  on boot, loads the `.env` file, and parses each line   if the line contains an '=' char, then it splits the line on that first '=' and then  adds key : value to the environment.  uses `std.process.envmap` - which is an in-memory clone of the initial env   ","hendriknielaender/ulid.zig":"Zig Universally Unique Lexicographically Sortable Identifier # ulid.zig [![zig](https://img.shields.io/badge/-zig-f7a41d?style=flat&logo=zig&logocolor=white)](https://ziglang.org/) ![github actions workflow status](https://img.shields.io/github/actions/workflow/status/hendriknielaender/ulid.zig/unit-test.yml) [![github release](https://img.shields.io/github/v/release/hendriknielaender/ulid.zig)](https://github.com/hendriknielaender/ulid.zig/releases) ![github code size in bytes](https://img.shields.io/github/languages/code-size/hendriknielaender/ulid.zig)   a **universally unique lexicographically sortable identifier (ulid)** implementation for zig, providing a robust and efficient way to generate unique identifiers that are both time-based and random.  ## why ulid?  uuid can be suboptimal for many uses-cases because:  - it isn't the most character efficient way of encoding 128 bits of randomness - uuid v1/v2 is impractical in many environments, as it requires access to a unique, stable mac address - uuid v3/v5 requires a unique seed and produces randomly distributed ids, which can cause fragmentation in many data structures - uuid v4 provides no other information than randomness which can cause fragmentation in many data structures  ## features  - 128-bit compatibility with uuid - 1.21e+24 unique ulids per millisecond - lexicographically sortable! - canonically encoded as a 26 character string, as opposed to the 36 character uuid - uses crockford's base32 for better efficiency and readability (5 bits per character) - case insensitive - no special characters (url safe) - monotonic sort order (correctly detects and handles the same millisecond)  ## test coverage - ulid generation: validates timestamp and randomness. - encoding: ensures ulids are correctly encoded into base32 strings. - decoding: confirms accurate decoding from base32 strings. - monotonicity: tests that ulids generated within the same millisecond are monotonically increasing. - overflow handling: checks proper error handling when randomness overflows. - edge cases: validates behavior with maximum ulid values and invalid inputs.  ## specification for detailed information on the ulid specification, refer to the [ulid specification](https://github.com/ulid/spec).  ## usage this library provides an implementation of ulid (universally unique lexicographically sortable identifier) generation and decoding in zig.  ### generating a ulid you can generate a new ulid as a 26-character crockford's base32 string:  ```zig const ulid = try ulid.generate(); std.debug.print('generated ulid: {s}╲n', .{ulid}); ``` this will output a unique, lexicographically sortable string.  ### decoding a ulid to decode a ulid string into its components (timestamp and randomness): ```zig const ulid_str = '01an4z07by79ka1307sr9x4mv3'; var decoded_ulid: ulid = undefined; try ulid.decode(ulid_str[0..], &decoded_ulid); std.debug.print('decoded ulid: timestamp={d}, randomness={d}╲n', .{decoded_ulid.timestamp, decoded_ulid.randomness}); ```  ### monotonic ulid generation to generate ulids with guaranteed monotonicity within the same millisecond, use the `ulidgenerator`: ```zig var generator = ulid.monotonic_factory(); const ulid = try generator.generate(null); // passing `null` uses the current timestamp. std.debug.print('generated monotonic ulid: {s}╲n', .{ulid}); ``` this will ensure that if multiple ulids are generated in the same millisecond, their randomness will be incremented to preserve order.  ### handling errors this library defines several error types for ulid encoding/decoding, such as:  - `invalid_length` – when the provided ulid string is not 26 characters long. - `invalid_character` – when the ulid string contains invalid base32 characters. - `overflow` – when the timestamp exceeds the maximum allowable value (48 bits). ","jdknezek/zobench":"Simple Zig benchmarking # zobench  zobench is a simple benchmark library for zig. it's inspired by [go's testing.b](https://golang.org/pkg/testing/#b).  ## example  ```zig fn benchmarkassign(b: *state) !void {     // expensive setup     b.resettimer();      var i: usize = 0;     while (i < b.n) : (i += 1) {         i = i;     } }  test 'runn' {     const result = try runn(benchmarkassign, 10);     try std.testing.expect(result.n == 10);      std.debug.print('╲n{} ops / {} ns = {d:.3} ns/op╲n', .{ result.n, result.ns, result.nsperop() }); }  test 'runns' {     const result = try runns(benchmarkassign, std.time.ns_per_s);     try std.testing.expect(result.ns >= std.time.ns_per_s);      std.debug.print('╲n{} ops / {} ns = {d:.3} ns/op╲n', .{ result.n, result.ns, result.nsperop() }); }  fn benchmarkalloc(b: *state) !void {     var allocator = b.allocator();      // expensive setup      b.resettimer();      var i: usize = 0;     while (i < b.n) : (i += 1) {         const p = try allocator.create(u64);         if (i % 2 == 0) {             allocator.destroy(p);         }     } }  test 'leak' {     const result = try runn(benchmarkalloc, 10);      std.debug.print('╲n{d:.3} allocs/op, {d:.3} bytes/op╲n', .{ result.allocsperop(), result.allocmemperop() });     if (result.mem > 0) {         std.debug.print('leaked {} bytes!╲n', .{result.mem});     } } ```  output:  ``` test [1/3] test.runn... 10 ops / 200 ns = 20.000 ns/op test [2/3] test.runns... 927815920 ops / 1154363300 ns = 1.244 ns/op test [3/3] test.alloc... 1.000 allocs/op, 8.000 bytes/op leaked 40 bytes! ``` ","Reokodoku/sap":"A simple argument parser library for zig # sap  sap is a simple argument parser library for zig that uses a tuple of flags to create a struct containing the value of the arguments.  ## how to add the library  1. run in the terminal: ```sh zig fetch --save git+https://github.com/reokodoku/sap ``` 2. add in your `build.zig`: ```zig const sap = b.dependency('sap', .{}); exe.root_module.addimport('sap', sap.module('sap')); ```  ## examples  minimal example: ```zig const sap = @import('sap');  var arg_parser = sap.parser(.{     sap.flag([]const u8, 'hello', 'h', 'world'), }).init(allocator); defer arg_parser.deinit();  const args = try arg_parser.parseargs();  std.debug.print('executable name: {s}╲n', .{args.executable_name});  var positionals_iter = args.positionals.iterator(); std.debug.print('positionals:╲n', .{}); while (positionals_iter.next()) |str|     std.debug.print('  {s}╲n', .{str});  std.debug.print('`hello`|`h` flag value: {s}╲n', .{args.hello}); ```  you can find more examples in the `examples/` folder.  for more information, see the source code or documentation (`zig build docs`).  ## features  * short arguments * long arguments * pass values after an equal (`--foo=bar`) or a space (`--foo bar`) * flags can be specified multiple times * flags that call a function * supported types:     * booleans     * strings     * ints (signed and unsigned)     * floats     * enums     * and all optional variants of the above (`?bool`, `?[]const u8`, ...)  ## zig version  sap targets the master branch of zig. in the `build.zig.zon` file, there is the `minimum_zig_version` field which specifies the latest version of zig in which sap compiles. when the zig master branch breaks the compilation, a commit will be merged to:  - fix the compilation errors - update the `minimum_zig_version` field with the new zig version  ","tiawl/glfw.zig":"@glfw packaged for @ziglang # glfw.zig  this is a fork of [hexops/glfw][1] which is itself a fork of [glfw/glfw][2].  ## why this forkception ?  the intention under this fork is the same as [hexops][13] had when they forked [glfw/glfw][2]: package it for [zig][3]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`.  however this repository has subtle differences for maintainability tasks: * no shell scripting, * a cron runs every day to check [glfw/glfw][2]. then it updates this repository if a new release is available, * no support for macos.  ## how to use it  the goal of this repository is not to provide a [zig][3] binding for [glfw/glfw][2]. there are at least as many legit ways as possible to make a binding as there are active accounts on github. so you are not going to find an answer for this question here. the point of this repository is to abstract the [glfw/glfw][2] compilation process with [zig][3] (which is not new comers friendly and not easy to maintain) to let you focus on your application. so you can use **glfw.zig**: - as raw (see glfw examples [here](https://github.com/tiawl/cimgui.zig/blob/trunk/examples)), - as a daily updated interface for your [zig][3] binding of [glfw/glfw][2] (see [here][14] for a private usage).  ## important note  the current usage of this repository is centered around [tiawl/cimgui.zig][3] compilation. so for your usage it could break because some files have been filtered in the process. if it happens, open an issue: this repository is open to potential usage evolution.  ## dependencies  the [zig][3] part of this package is relying on the latest [zig][3] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [glfw/glfw](https://github.com/tiawl/glfw.zig/blob/trunk/.references/glfw)  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/cimgui.zig][4]  this repository is automatically updated when a new release is available from these repositories: * [glfw/glfw][2] * [tiawl/toolbox][5] * [tiawl/vulkan.zig][6] * [tiawl/wayland.zig][7] * [tiawl/x11.zig][8] * [tiawl/spaceporn-action-bot][9] * [tiawl/spaceporn-action-ci][10] * [tiawl/spaceporn-action-cd-ping][11] * [tiawl/spaceporn-action-cd-pong][12]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/hexops/glfw [2]:https://github.com/glfw/glfw [3]:https://github.com/ziglang/zig [4]:https://github.com/tiawl/cimgui.zig [5]:https://github.com/tiawl/toolbox [6]:https://github.com/tiawl/vulkan.zig [7]:https://github.com/tiawl/wayland.zig [8]:https://github.com/tiawl/x11.zig [9]:https://github.com/tiawl/spaceporn-action-bot [10]:https://github.com/tiawl/spaceporn-action-ci [11]:https://github.com/tiawl/spaceporn-action-cd-ping [12]:https://github.com/tiawl/spaceporn-action-cd-pong [13]:https://github.com/hexops [14]:https://github.com/tiawl/spaceporn/blob/trunk/src/spaceporn/bindings/glfw/glfw.zig ","joachimschmidt557/zig-walkdir":"Provides functions for walking directories recursively # zig-walkdir  [![build status](https://travis-ci.org/joachimschmidt557/zig-walkdir.svg?branch=master)](https://travis-ci.org/joachimschmidt557/zig-walkdir)  a zig package providing functions for recursively traversing directories.  ## todo  - [x] breadth-first search - [x] depth-first search - [ ] tests - [ ] following symlinks - [ ] correct error handling ","allyourcodebase/cfitsio":"Zig build of CFITSIO library. # cfitsio  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## zig build of [cfitsio library](https://github.com/heasarc/cfitsio).  ### :rocket: usage  - add `cfitsio` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/allyourcodebase/cfitsio/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `cfitsio` dependency in `build.zig`.  ```zig const cfitsio_dep = b.dependency('cfitsio', .{     .target = target,     .optimize = optimize, }); const cfitsio_mod = cfitsio_dep.module('cfitsio'); <compile>.root_module.addimport('cfitsio', cfitsio_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/allyourcodebase/cfitsio/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/allyourcodebase/cfitsio/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/allyourcodebase/cfitsio.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/allyourcodebase/cfitsio/blob/main/license ","kassane/whisper.cpp":"Port of OpenAI's Whisper model in C/C++ (Uses zig build) # whisper.cpp  ![whisper.cpp](https://user-images.githubusercontent.com/1991296/235238348-05d0f6a4-da44-4900-a1de-d0707e75b763.jpeg)  [![actions status](https://github.com/ggerganov/whisper.cpp/workflows/ci/badge.svg)](https://github.com/ggerganov/whisper.cpp/actions) [![license: mit](https://img.shields.io/badge/license-mit-blue.svg)](https://opensource.org/licenses/mit) [![npm](https://img.shields.io/npm/v/whisper.cpp.svg)](https://www.npmjs.com/package/whisper.cpp/)  stable: [v1.5.4](https://github.com/ggerganov/whisper.cpp/releases/tag/v1.5.4) / [roadmap | f.a.q.](https://github.com/ggerganov/whisper.cpp/discussions/126)  high-performance inference of [openai's whisper](https://github.com/openai/whisper) automatic speech recognition (asr) model:  - plain c/c++ implementation without dependencies - apple silicon first-class citizen - optimized via arm neon, accelerate framework, metal and [core ml](https://github.com/ggerganov/whisper.cpp#core-ml-support) - avx intrinsics support for x86 architectures - vsx intrinsics support for power architectures - mixed f16 / f32 precision - [4-bit and 5-bit integer quantization support](https://github.com/ggerganov/whisper.cpp#quantization) - zero memory allocations at runtime - support for cpu-only inference - [efficient gpu support for nvidia](https://github.com/ggerganov/whisper.cpp#nvidia-gpu-support-via-cublas) - [partial opencl gpu support via clblast](https://github.com/ggerganov/whisper.cpp#opencl-gpu-support-via-clblast) - [openvino support](https://github.com/ggerganov/whisper.cpp#openvino-support) - [c-style api](https://github.com/ggerganov/whisper.cpp/blob/master/whisper.h)  supported platforms:  - [x] mac os (intel and arm) - [x] [ios](examples/whisper.objc) - [x] [android](examples/whisper.android) - [x] [java](bindings/java/readme.md) - [x] linux / [freebsd](https://github.com/ggerganov/whisper.cpp/issues/56#issuecomment-1350920264) - [x] [webassembly](examples/whisper.wasm) - [x] windows ([msvc](https://github.com/ggerganov/whisper.cpp/blob/master/.github/workflows/build.yml#l117-l144) and [mingw](https://github.com/ggerganov/whisper.cpp/issues/168)] - [x] [raspberry pi](https://github.com/ggerganov/whisper.cpp/discussions/166) - [x] [docker](https://github.com/ggerganov/whisper.cpp/pkgs/container/whisper.cpp)  the entire high-level implementation of the model is contained in [whisper.h](whisper.h) and [whisper.cpp](whisper.cpp). the rest of the code is part of the [ggml](https://github.com/ggerganov/ggml) machine learning library.  having such a lightweight implementation of the model allows to easily integrate it in different platforms and applications. as an example, here is a video of running the model on an iphone 13 device - fully offline, on-device: [whisper.objc](examples/whisper.objc)  https://user-images.githubusercontent.com/1991296/197385372-962a6dea-bca1-4d50-bf96-1d8c27b98c81.mp4  you can also easily make your own offline voice assistant application: [command](examples/command)  https://user-images.githubusercontent.com/1991296/204038393-2f846eae-c255-4099-a76d-5735c25c49da.mp4  on apple silicon, the inference runs fully on the gpu via metal:  https://github.com/ggerganov/whisper.cpp/assets/1991296/c82e8f86-60dc-49f2-b048-d2fdbd6b5225  or you can even run it straight in the browser: [talk.wasm](examples/talk.wasm)  ## implementation details  - the core tensor operations are implemented in c ([ggml.h](ggml.h) / [ggml.c](ggml.c)) - the transformer model and the high-level c-style api are implemented in c++ ([whisper.h](whisper.h) / [whisper.cpp](whisper.cpp)) - sample usage is demonstrated in [main.cpp](examples/main) - sample real-time audio transcription from the microphone is demonstrated in [stream.cpp](examples/stream) - various other examples are available in the [examples](examples) folder  the tensor operators are optimized heavily for apple silicon cpus. depending on the computation size, arm neon simd intrinsics or cblas accelerate framework routines are used. the latter are especially effective for bigger sizes since the accelerate framework utilizes the special-purpose amx coprocessor available in modern apple products.  ## quick start  first clone the repository.  then, download one of the whisper models converted in [ggml format](models). for example:  ```bash bash ./models/download-ggml-model.sh base.en ```  if you wish to convert the whisper models to ggml format yourself, instructions are in [models/readme.md](models/readme.md).  now build the [main](examples/main) example and transcribe an audio file like this:  ```bash # build the main example make  # transcribe an audio file ./main -f samples/jfk.wav ```  ---  for a quick demo, simply run `make base.en`:  ```java $ make base.en  cc  -i.              -o3 -std=c11   -pthread -dggml_use_accelerate   -c ggml.c -o ggml.o c++ -i. -i./examples -o3 -std=c++11 -pthread -c whisper.cpp -o whisper.o c++ -i. -i./examples -o3 -std=c++11 -pthread examples/main/main.cpp whisper.o ggml.o -o main  -framework accelerate ./main -h  usage: ./main [options] file0.wav file1.wav ...  options:   -h,        --help              [default] show this help message and exit   -t n,      --threads n         [4      ] number of threads to use during computation   -p n,      --processors n      [1      ] number of processors to use during computation   -ot n,     --offset-t n        [0      ] time offset in milliseconds   -on n,     --offset-n n        [0      ] segment index offset   -d  n,     --duration n        [0      ] duration of audio to process in milliseconds   -mc n,     --max-context n     [-1     ] maximum number of text context tokens to store   -ml n,     --max-len n         [0      ] maximum segment length in characters   -sow,      --split-on-word     [false  ] split on word rather than on token   -bo n,     --best-of n         [5      ] number of best candidates to keep   -bs n,     --beam-size n       [5      ] beam size for beam search   -wt n,     --word-thold n      [0.01   ] word timestamp probability threshold   -et n,     --entropy-thold n   [2.40   ] entropy threshold for decoder fail   -lpt n,    --logprob-thold n   [-1.00  ] log probability threshold for decoder fail   -debug,    --debug-mode        [false  ] enable debug mode (eg. dump log_mel)   -tr,       --translate         [false  ] translate from source language to english   -di,       --diarize           [false  ] stereo audio diarization   -tdrz,     --tinydiarize       [false  ] enable tinydiarize (requires a tdrz model)   -nf,       --no-fallback       [false  ] do not use temperature fallback while decoding   -otxt,     --output-txt        [false  ] output result in a text file   -ovtt,     --output-vtt        [false  ] output result in a vtt file   -osrt,     --output-srt        [false  ] output result in a srt file   -olrc,     --output-lrc        [false  ] output result in a lrc file   -owts,     --output-words      [false  ] output script for generating karaoke video   -fp,       --font-path         [/system/library/fonts/supplemental/courier new bold.ttf] path to a monospace font for karaoke video   -ocsv,     --output-csv        [false  ] output result in a csv file   -oj,       --output-json       [false  ] output result in a json file   -ojf,      --output-json-full  [false  ] include more information in the json file   -of fname, --output-file fname [       ] output file path (without file extension)   -ps,       --print-special     [false  ] print special tokens   -pc,       --print-colors      [false  ] print colors   -pp,       --print-progress    [false  ] print progress   -nt,       --no-timestamps     [false  ] do not print timestamps   -l lang,   --language lang     [en     ] spoken language ('auto' for auto-detect)   -dl,       --detect-language   [false  ] exit after automatically detecting language              --prompt prompt     [       ] initial prompt   -m fname,  --model fname       [models/ggml-base.en.bin] model path   -f fname,  --file fname        [       ] input wav file path   -oved d,   --ov-e-device dname [cpu    ] the openvino device used for encode inference   -ls,       --log-score         [false  ] log best decoder scores of tokens   -ng,       --no-gpu            [false  ] disable gpu   bash ./models/download-ggml-model.sh base.en downloading ggml model base.en ... ggml-base.en.bin               100%[========================>] 141.11m  6.34mb/s    in 24s done! model 'base.en' saved in 'models/ggml-base.en.bin' you can now use it like this:    $ ./main -m models/ggml-base.en.bin -f samples/jfk.wav   =============================================== running base.en on all samples in ./samples ... ===============================================  ---------------------------------------------- [+] running base.en on samples/jfk.wav ... (run 'ffplay samples/jfk.wav' to listen) ----------------------------------------------  whisper_init_from_file: loading model from 'models/ggml-base.en.bin' whisper_model_load: loading model whisper_model_load: n_vocab       = 51864 whisper_model_load: n_audio_ctx   = 1500 whisper_model_load: n_audio_state = 512 whisper_model_load: n_audio_head  = 8 whisper_model_load: n_audio_layer = 6 whisper_model_load: n_text_ctx    = 448 whisper_model_load: n_text_state  = 512 whisper_model_load: n_text_head   = 8 whisper_model_load: n_text_layer  = 6 whisper_model_load: n_mels        = 80 whisper_model_load: f16           = 1 whisper_model_load: type          = 2 whisper_model_load: mem required  =  215.00 mb (+    6.00 mb per decoder) whisper_model_load: kv self size  =    5.25 mb whisper_model_load: kv cross size =   17.58 mb whisper_model_load: adding 1607 extra tokens whisper_model_load: model ctx     =  140.60 mb whisper_model_load: model size    =  140.54 mb  system_info: n_threads = 4 / 10 | avx = 0 | avx2 = 0 | avx512 = 0 | fma = 0 | neon = 1 | arm_fma = 1 | f16c = 0 | fp16_va = 1 | wasm_simd = 0 | blas = 1 | sse3 = 0 | vsx = 0 |  main: processing 'samples/jfk.wav' (176000 samples, 11.0 sec), 4 threads, 1 processors, lang = en, task = transcribe, timestamps = 1 ...   [00:00:00.000 --> 00:00:11.000]   and so my fellow americans, ask not what your country can do for you, ask what you can do for your country.   whisper_print_timings:     fallbacks =   0 p /   0 h whisper_print_timings:     load time =   113.81 ms whisper_print_timings:      mel time =    15.40 ms whisper_print_timings:   sample time =    11.58 ms /    27 runs (    0.43 ms per run) whisper_print_timings:   encode time =   266.60 ms /     1 runs (  266.60 ms per run) whisper_print_timings:   decode time =    66.11 ms /    27 runs (    2.45 ms per run) whisper_print_timings:    total time =   476.31 ms ```  the command downloads the `base.en` model converted to custom `ggml` format and runs the inference on all `.wav` samples in the folder `samples`.  for detailed usage instructions, run: `./main -h`  note that the [main](examples/main) example currently runs only with 16-bit wav files, so make sure to convert your input before running the tool. for example, you can use `ffmpeg` like this:  ```java ffmpeg -i input.mp3 -ar 16000 -ac 1 -c:a pcm_s16le output.wav ```  ## more audio samples  if you want some extra audio samples to play with, simply run:  ``` make samples ```  this will download a few more audio files from wikipedia and convert them to 16-bit wav format via `ffmpeg`.  you can download and run the other models as follows:  ``` make tiny.en make tiny make base.en make base make small.en make small make medium.en make medium make large-v1 make large-v2 make large-v3 ```  ## memory usage  | model  | disk    | mem      | | ---    | ---     | ---      | | tiny   |  75 mib | ~273 mb | | base   | 142 mib | ~388 mb | | small  | 466 mib | ~852 mb | | medium | 1.5 gib | ~2.1 gb | | large  | 2.9 gib | ~3.9 gb |  ## quantization  `whisper.cpp` supports integer quantization of the whisper `ggml` models. quantized models require less memory and disk space and depending on the hardware can be processed more efficiently.  here are the steps for creating and using a quantized model:  ```bash # quantize a model with q5_0 method make quantize ./quantize models/ggml-base.en.bin models/ggml-base.en-q5_0.bin q5_0  # run the examples as usual, specifying the quantized model file ./main -m models/ggml-base.en-q5_0.bin ./samples/gb0.wav ```  ## core ml support  on apple silicon devices, the encoder inference can be executed on the apple neural engine (ane) via core ml. this can result in significant speed-up - more than x3 faster compared with cpu-only execution. here are the instructions for generating a core ml model and using it with `whisper.cpp`:  - install python dependencies needed for the creation of the core ml model:    ```bash   pip install ane_transformers   pip install openai-whisper   pip install coremltools   ```    - to ensure `coremltools` operates correctly, please confirm that [xcode](https://developer.apple.com/xcode/) is installed and execute `xcode-select --install` to install the command-line tools.   - python 3.10 is recommended.   - [optional] it is recommended to utilize a python version management system, such as [miniconda](https://docs.conda.io/en/latest/miniconda.html)  for this step:     - to create an environment, use: `conda create -n py310-whisper python=3.10 -y`     - to activate the environment, use: `conda activate py310-whisper`  - generate a core ml model. for example, to generate a `base.en` model, use:    ```bash   ./models/generate-coreml-model.sh base.en   ```    this will generate the folder `models/ggml-base.en-encoder.mlmodelc`  - build `whisper.cpp` with core ml support:    ```bash   # using makefile   make clean   whisper_coreml=1 make -j    # using cmake   cmake -b build -dwhisper_coreml=1   cmake --build build -j --config release   ```  - run the examples as usual. for example:    ```bash   ./main -m models/ggml-base.en.bin -f samples/jfk.wav    ...    whisper_init_state: loading core ml model from 'models/ggml-base.en-encoder.mlmodelc'   whisper_init_state: first run on a device may take a while ...   whisper_init_state: core ml model loaded    system_info: n_threads = 4 / 10 | avx = 0 | avx2 = 0 | avx512 = 0 | fma = 0 | neon = 1 | arm_fma = 1 | f16c = 0 | fp16_va = 1 | wasm_simd = 0 | blas = 1 | sse3 = 0 | vsx = 0 | coreml = 1 |    ...   ```    the first run on a device is slow, since the ane service compiles the core ml model to some device-specific format.   next runs are faster.  for more information about the core ml implementation please refer to pr [#566](https://github.com/ggerganov/whisper.cpp/pull/566).  ## openvino support  on platforms that support [openvino](https://github.com/openvinotoolkit/openvino), the encoder inference can be executed on openvino-supported devices including x86 cpus and intel gpus (integrated & discrete).  this can result in significant speedup in encoder performance. here are the instructions for generating the openvino model and using it with `whisper.cpp`:  - first, setup python virtual env. and install python dependencies. python 3.10 is recommended.    windows:   ```   cd models   python -m venv openvino_conv_env   openvino_conv_env╲scripts╲activate   python -m pip install --upgrade pip   pip install -r openvino-conversion-requirements.txt   ```    linux and macos:   ```   cd models   python3 -m venv openvino_conv_env   source openvino_conv_env/bin/activate   python -m pip install --upgrade pip   pip install -r openvino-conversion-requirements.txt   ```  - generate an openvino encoder model. for example, to generate a `base.en` model, use:    ```   python convert-whisper-to-openvino.py --model base.en   ```    this will produce ggml-base.en-encoder-openvino.xml/.bin ir model files. it's recommended to relocate these to the same folder as ggml models, as that   is the default location that the openvino extension will search at runtime.  - build `whisper.cpp` with openvino support:    download openvino package from [release page](https://github.com/openvinotoolkit/openvino/releases). the recommended version to use is [2023.0.0](https://github.com/openvinotoolkit/openvino/releases/tag/2023.0.0).    after downloading & extracting package onto your development system, set up required environment by sourcing setupvars script. for example:    linux:   ```bash   source /path/to/l_openvino_toolkit_ubuntu22_2023.0.0.10926.b4452d56304_x86_64/setupvars.sh   ```    windows (cmd):   ```   c:╲path╲to╲w_openvino_toolkit_windows_2023.0.0.10926.b4452d56304_x86_64╲setupvars.bat   ```    and then build the project using cmake:   ```bash   cmake -b build -dwhisper_openvino=1   cmake --build build -j --config release   ```  - run the examples as usual. for example:   ```bash   ./main -m models/ggml-base.en.bin -f samples/jfk.wav    ...    whisper_ctx_init_openvino_encoder: loading openvino model from 'models/ggml-base.en-encoder-openvino.xml'   whisper_ctx_init_openvino_encoder: first run on a device may take a while ...   whisper_openvino_init: path_model = models/ggml-base.en-encoder-openvino.xml, device = gpu, cache_dir = models/ggml-base.en-encoder-openvino-cache   whisper_ctx_init_openvino_encoder: openvino model loaded    system_info: n_threads = 4 / 8 | avx = 1 | avx2 = 1 | avx512 = 0 | fma = 1 | neon = 0 | arm_fma = 0 | f16c = 1 | fp16_va = 0 | wasm_simd = 0 | blas = 0 | sse3 = 1 | vsx = 0 | coreml = 0 | openvino = 1 |    ...   ```    the first time run on an openvino device is slow, since the openvino framework will compile the ir (intermediate representation) model to a device-specific 'blob'. this device-specific blob will get   cached for the next run.  for more information about the core ml implementation please refer to pr [#1037](https://github.com/ggerganov/whisper.cpp/pull/1037).  ## nvidia gpu support  with nvidia cards the processing of the models is done efficiently on the gpu via cublas and custom cuda kernels. first, make sure you have installed `cuda`: https://developer.nvidia.com/cuda-downloads  now build `whisper.cpp` with cublas support:  ``` make clean whisper_cublas=1 make -j ```  ## opencl gpu support via clblast  for cards and integrated gpus that support opencl, the encoder processing can be largely offloaded to the gpu through clblast. this is especially useful for users with amd apus or low end devices for up to ~2x speedup.  first, make sure you have installed `clblast` for your os or distribution: https://github.com/cnugteren/clblast  now build `whisper.cpp` with clblast support:  ``` makefile: cd whisper.cpp make clean whisper_clblast=1 make -j  cmake: cd whisper.cpp cmake -b build -dwhisper_clblast=on cmake --build build -j --config release ```   run all the examples as usual.  ## blas cpu support via openblas  encoder processing can be accelerated on the cpu via openblas. first, make sure you have installed `openblas`: https://www.openblas.net/  now build `whisper.cpp` with openblas support:  ``` make clean whisper_openblas=1 make -j ```  ## docker  ### prerequisites * docker must be installed and running on your system. * create a folder to store big models & intermediate files (ex. /whisper/models)  ### images we have two docker images available for this project:  1. `ghcr.io/ggerganov/whisper.cpp:main`: this image includes the main executable file as well as `curl` and `ffmpeg`. (platforms: `linux/amd64`, `linux/arm64`) 2. `ghcr.io/ggerganov/whisper.cpp:main-cuda`: same as `main` but compiled with cuda support. (platforms: `linux/amd64`)  ### usage  ```shell # download model and persist it in a local folder docker run -it --rm ╲   -v path/to/models:/models ╲   whisper.cpp:main './models/download-ggml-model.sh base /models' # transcribe an audio file docker run -it --rm ╲   -v path/to/models:/models ╲   -v path/to/audios:/audios ╲   whisper.cpp:main './main -m /models/ggml-base.bin -f /audios/jfk.wav' # transcribe an audio file in samples folder docker run -it --rm ╲   -v path/to/models:/models ╲   whisper.cpp:main './main -m /models/ggml-base.bin -f ./samples/jfk.wav' ```  ## limitations  - inference only  ## another example  here is another example of transcribing a [3:24 min speech](https://upload.wikimedia.org/wikipedia/commons/1/1f/george_w_bush_columbia_final.ogg) in about half a minute on a macbook m1 pro, using `medium.en` model:  <details>   <summary>expand to see the result</summary>  ```java $ ./main -m models/ggml-medium.en.bin -f samples/gb1.wav -t 8  whisper_init_from_file: loading model from 'models/ggml-medium.en.bin' whisper_model_load: loading model whisper_model_load: n_vocab       = 51864 whisper_model_load: n_audio_ctx   = 1500 whisper_model_load: n_audio_state = 1024 whisper_model_load: n_audio_head  = 16 whisper_model_load: n_audio_layer = 24 whisper_model_load: n_text_ctx    = 448 whisper_model_load: n_text_state  = 1024 whisper_model_load: n_text_head   = 16 whisper_model_load: n_text_layer  = 24 whisper_model_load: n_mels        = 80 whisper_model_load: f16           = 1 whisper_model_load: type          = 4 whisper_model_load: mem required  = 1720.00 mb (+   43.00 mb per decoder) whisper_model_load: kv self size  =   42.00 mb whisper_model_load: kv cross size =  140.62 mb whisper_model_load: adding 1607 extra tokens whisper_model_load: model ctx     = 1462.35 mb whisper_model_load: model size    = 1462.12 mb  system_info: n_threads = 8 / 10 | avx = 0 | avx2 = 0 | avx512 = 0 | fma = 0 | neon = 1 | arm_fma = 1 | f16c = 0 | fp16_va = 1 | wasm_simd = 0 | blas = 1 | sse3 = 0 | vsx = 0 |  main: processing 'samples/gb1.wav' (3179750 samples, 198.7 sec), 8 threads, 1 processors, lang = en, task = transcribe, timestamps = 1 ...   [00:00:00.000 --> 00:00:08.000]   my fellow americans, this day has brought terrible news and great sadness to our country. [00:00:08.000 --> 00:00:17.000]   at nine o'clock this morning, mission control in houston lost contact with our space shuttle columbia. [00:00:17.000 --> 00:00:23.000]   a short time later, debris was seen falling from the skies above texas. [00:00:23.000 --> 00:00:29.000]   the columbia's lost. there are no survivors. [00:00:29.000 --> 00:00:32.000]   on board was a crew of seven. [00:00:32.000 --> 00:00:39.000]   colonel rick husband, lieutenant colonel michael anderson, commander laurel clark, [00:00:39.000 --> 00:00:48.000]   captain david brown, commander william mccool, dr. kultna shavla, and ilan ramon, [00:00:48.000 --> 00:00:52.000]   a colonel in the israeli air force. [00:00:52.000 --> 00:00:58.000]   these men and women assumed great risk in the service to all humanity. [00:00:58.000 --> 00:01:03.000]   in an age when space flight has come to seem almost routine, [00:01:03.000 --> 00:01:07.000]   it is easy to overlook the dangers of travel by rocket [00:01:07.000 --> 00:01:12.000]   and the difficulties of navigating the fierce outer atmosphere of the earth. [00:01:12.000 --> 00:01:18.000]   these astronauts knew the dangers, and they faced them willingly, [00:01:18.000 --> 00:01:23.000]   knowing they had a high and noble purpose in life. [00:01:23.000 --> 00:01:31.000]   because of their courage and daring and idealism, we will miss them all the more. [00:01:31.000 --> 00:01:36.000]   all americans today are thinking as well of the families of these men and women [00:01:36.000 --> 00:01:40.000]   who have been given this sudden shock and grief. [00:01:40.000 --> 00:01:45.000]   you're not alone. our entire nation grieves with you, [00:01:45.000 --> 00:01:52.000]   and those you love will always have the respect and gratitude of this country. [00:01:52.000 --> 00:01:56.000]   the cause in which they died will continue. [00:01:56.000 --> 00:02:04.000]   mankind is led into the darkness beyond our world by the inspiration of discovery [00:02:04.000 --> 00:02:11.000]   and the longing to understand. our journey into space will go on. [00:02:11.000 --> 00:02:16.000]   in the skies today, we saw destruction and tragedy. [00:02:16.000 --> 00:02:22.000]   yet farther than we can see, there is comfort and hope. [00:02:22.000 --> 00:02:29.000]   in the words of the prophet isaiah, 'lift your eyes and look to the heavens [00:02:29.000 --> 00:02:35.000]   who created all these. he who brings out the starry hosts one by one [00:02:35.000 --> 00:02:39.000]   and calls them each by name.' [00:02:39.000 --> 00:02:46.000]   because of his great power and mighty strength, not one of them is missing. [00:02:46.000 --> 00:02:55.000]   the same creator who names the stars also knows the names of the seven souls we mourn today. [00:02:55.000 --> 00:03:01.000]   the crew of the shuttle columbia did not return safely to earth, [00:03:01.000 --> 00:03:05.000]   yet we can pray that all are safely home. [00:03:05.000 --> 00:03:13.000]   may god bless the grieving families, and may god continue to bless america. [00:03:13.000 --> 00:03:19.000]   [silence]   whisper_print_timings:     fallbacks =   1 p /   0 h whisper_print_timings:     load time =   569.03 ms whisper_print_timings:      mel time =   146.85 ms whisper_print_timings:   sample time =   238.66 ms /   553 runs (    0.43 ms per run) whisper_print_timings:   encode time = 18665.10 ms /     9 runs ( 2073.90 ms per run) whisper_print_timings:   decode time = 13090.93 ms /   549 runs (   23.85 ms per run) whisper_print_timings:    total time = 32733.52 ms ``` </details>  ## real-time audio input example  this is a naive example of performing real-time inference on audio from your microphone. the [stream](examples/stream) tool samples the audio every half a second and runs the transcription continuously. more info is available in [issue #10](https://github.com/ggerganov/whisper.cpp/issues/10).  ```java make stream ./stream -m ./models/ggml-base.en.bin -t 8 --step 500 --length 5000 ```  https://user-images.githubusercontent.com/1991296/194935793-76afede7-cfa8-48d8-a80f-28ba83be7d09.mp4  ## confidence color-coding  adding the `--print-colors` argument will print the transcribed text using an experimental color coding strategy to highlight words with high or low confidence:  ```java ./main -m models/ggml-base.en.bin -f samples/gb0.wav --print-colors ```  <img width='965' alt='image' src='https://user-images.githubusercontent.com/1991296/197356445-311c8643-9397-4e5e-b46e-0b4b4daa2530.png'>  ## controlling the length of the generated text segments (experimental)  for example, to limit the line length to a maximum of 16 characters, simply add `-ml 16`:  ```java ./main -m ./models/ggml-base.en.bin -f ./samples/jfk.wav -ml 16  whisper_model_load: loading model from './models/ggml-base.en.bin' ... system_info: n_threads = 4 / 10 | avx2 = 0 | avx512 = 0 | neon = 1 | fp16_va = 1 | wasm_simd = 0 | blas = 1 |  main: processing './samples/jfk.wav' (176000 samples, 11.0 sec), 4 threads, 1 processors, lang = en, task = transcribe, timestamps = 1 ...  [00:00:00.000 --> 00:00:00.850]   and so my [00:00:00.850 --> 00:00:01.590]   fellow [00:00:01.590 --> 00:00:04.140]   americans, ask [00:00:04.140 --> 00:00:05.660]   not what your [00:00:05.660 --> 00:00:06.840]   country can do [00:00:06.840 --> 00:00:08.430]   for you, ask [00:00:08.430 --> 00:00:09.440]   what you can do [00:00:09.440 --> 00:00:10.020]   for your [00:00:10.020 --> 00:00:11.000]   country. ```  ## word-level timestamp (experimental)  the `--max-len` argument can be used to obtain word-level timestamps. simply use `-ml 1`:  ```java ./main -m ./models/ggml-base.en.bin -f ./samples/jfk.wav -ml 1  whisper_model_load: loading model from './models/ggml-base.en.bin' ... system_info: n_threads = 4 / 10 | avx2 = 0 | avx512 = 0 | neon = 1 | fp16_va = 1 | wasm_simd = 0 | blas = 1 |  main: processing './samples/jfk.wav' (176000 samples, 11.0 sec), 4 threads, 1 processors, lang = en, task = transcribe, timestamps = 1 ...  [00:00:00.000 --> 00:00:00.320] [00:00:00.320 --> 00:00:00.370]   and [00:00:00.370 --> 00:00:00.690]   so [00:00:00.690 --> 00:00:00.850]   my [00:00:00.850 --> 00:00:01.590]   fellow [00:00:01.590 --> 00:00:02.850]   americans [00:00:02.850 --> 00:00:03.300]  , [00:00:03.300 --> 00:00:04.140]   ask [00:00:04.140 --> 00:00:04.990]   not [00:00:04.990 --> 00:00:05.410]   what [00:00:05.410 --> 00:00:05.660]   your [00:00:05.660 --> 00:00:06.260]   country [00:00:06.260 --> 00:00:06.600]   can [00:00:06.600 --> 00:00:06.840]   do [00:00:06.840 --> 00:00:07.010]   for [00:00:07.010 --> 00:00:08.170]   you [00:00:08.170 --> 00:00:08.190]  , [00:00:08.190 --> 00:00:08.430]   ask [00:00:08.430 --> 00:00:08.910]   what [00:00:08.910 --> 00:00:09.040]   you [00:00:09.040 --> 00:00:09.320]   can [00:00:09.320 --> 00:00:09.440]   do [00:00:09.440 --> 00:00:09.760]   for [00:00:09.760 --> 00:00:10.020]   your [00:00:10.020 --> 00:00:10.510]   country [00:00:10.510 --> 00:00:11.000]  . ```  ## speaker segmentation via tinydiarize (experimental)  more information about this approach is available here: https://github.com/ggerganov/whisper.cpp/pull/1058  sample usage:  ```py # download a tinydiarize compatible model ./models/download-ggml-model.sh small.en-tdrz  # run as usual, adding the '-tdrz' command-line argument ./main -f ./samples/a13.wav -m ./models/ggml-small.en-tdrz.bin -tdrz ... main: processing './samples/a13.wav' (480000 samples, 30.0 sec), 4 threads, 1 processors, lang = en, task = transcribe, tdrz = 1, timestamps = 1 ... ... [00:00:00.000 --> 00:00:03.800]   okay houston, we've had a problem here. [speaker_turn] [00:00:03.800 --> 00:00:06.200]   this is houston. say again please. [speaker_turn] [00:00:06.200 --> 00:00:08.260]   uh houston we've had a problem. [00:00:08.260 --> 00:00:11.320]   we've had a main beam up on a volt. [speaker_turn] [00:00:11.320 --> 00:00:13.820]   roger main beam interval. [speaker_turn] [00:00:13.820 --> 00:00:15.100]   uh uh [speaker_turn] [00:00:15.100 --> 00:00:18.020]   so okay stand, by thirteen we're looking at it. [speaker_turn] [00:00:18.020 --> 00:00:25.740]   okay uh right now uh houston the uh voltage is uh is looking good um. [00:00:27.620 --> 00:00:29.940]   and we had a a pretty large bank or so. ```  ## karaoke-style movie generation (experimental)  the [main](examples/main) example provides support for output of karaoke-style movies, where the currently pronounced word is highlighted. use the `-wts` argument and run the generated bash script. this requires to have `ffmpeg` installed.  here are a few *'typical'* examples:  ```java ./main -m ./models/ggml-base.en.bin -f ./samples/jfk.wav -owts source ./samples/jfk.wav.wts ffplay ./samples/jfk.wav.mp4 ```  https://user-images.githubusercontent.com/1991296/199337465-dbee4b5e-9aeb-48a3-b1c6-323ac4db5b2c.mp4  ---  ```java ./main -m ./models/ggml-base.en.bin -f ./samples/mm0.wav -owts source ./samples/mm0.wav.wts ffplay ./samples/mm0.wav.mp4 ```  https://user-images.githubusercontent.com/1991296/199337504-cc8fd233-0cb7-4920-95f9-4227de3570aa.mp4  ---  ```java ./main -m ./models/ggml-base.en.bin -f ./samples/gb0.wav -owts source ./samples/gb0.wav.wts ffplay ./samples/gb0.wav.mp4 ```  https://user-images.githubusercontent.com/1991296/199337538-b7b0c7a3-2753-4a88-a0cd-f28a317987ba.mp4  ---  ## video comparison of different models  use the [extra/bench-wts.sh](https://github.com/ggerganov/whisper.cpp/blob/master/extra/bench-wts.sh) script to generate a video in the following format:  ```java ./extra/bench-wts.sh samples/jfk.wav ffplay ./samples/jfk.wav.all.mp4 ```  https://user-images.githubusercontent.com/1991296/223206245-2d36d903-cf8e-4f09-8c3b-eb9f9c39d6fc.mp4  ---  ## benchmarks  in order to have an objective comparison of the performance of the inference across different system configurations, use the [bench](examples/bench) tool. the tool simply runs the encoder part of the model and prints how much time it took to execute it. the results are summarized in the following github issue:  [benchmark results](https://github.com/ggerganov/whisper.cpp/issues/89)  additionally a script to run whisper.cpp with different models and audio files is provided [bench.py](bench.py).  you can run it with the following command, by default it will run against any standard model in the models folder.  ```bash python3 extra/bench.py -f samples/jfk.wav -t 2,4,8 -p 1,2 ```  it is written in python with the intention of being easy to modify and extend for your benchmarking use case.  it outputs a csv file with the results of the benchmarking.   ## ggml format  the original models are converted to a custom binary format. this allows to pack everything needed into a single file:  - model parameters - mel filters - vocabulary - weights  you can download the converted models using the [models/download-ggml-model.sh](models/download-ggml-model.sh) script or manually from here:  - https://huggingface.co/ggerganov/whisper.cpp - https://ggml.ggerganov.com  for more details, see the conversion script [models/convert-pt-to-ggml.py](models/convert-pt-to-ggml.py) or the readme in [models](models).  ## [bindings](https://github.com/ggerganov/whisper.cpp/discussions/categories/bindings)  - [x] rust: [tazz4843/whisper-rs](https://github.com/tazz4843/whisper-rs) | [#310](https://github.com/ggerganov/whisper.cpp/discussions/310) - [x] javascript: [bindings/javascript](bindings/javascript) | [#309](https://github.com/ggerganov/whisper.cpp/discussions/309)   - react native (ios / android): [whisper.rn](https://github.com/mybigday/whisper.rn) - [x] go: [bindings/go](bindings/go) | [#312](https://github.com/ggerganov/whisper.cpp/discussions/312) - [x] java:   - [givimad/whisper-jni](https://github.com/givimad/whisper-jni) - [x] ruby: [bindings/ruby](bindings/ruby) | [#507](https://github.com/ggerganov/whisper.cpp/discussions/507) - [x] objective-c / swift: [ggerganov/whisper.spm](https://github.com/ggerganov/whisper.spm) | [#313](https://github.com/ggerganov/whisper.cpp/discussions/313)   - [exphat/swiftwhisper](https://github.com/exphat/swiftwhisper) - [x] .net: | [#422](https://github.com/ggerganov/whisper.cpp/discussions/422)   - [sandrohanea/whisper.net](https://github.com/sandrohanea/whisper.net)   - [nickdarvey/whisper](https://github.com/nickdarvey/whisper) - [x] python: | [#9](https://github.com/ggerganov/whisper.cpp/issues/9)   - [stlukey/whispercpp.py](https://github.com/stlukey/whispercpp.py) (cython)   - [aarnphm/whispercpp](https://github.com/aarnphm/whispercpp) (pybind11) - [x] r: [bnosac/audio.whisper](https://github.com/bnosac/audio.whisper) - [x] unity: [macoron/whisper.unity](https://github.com/macoron/whisper.unity)  ## examples  there are various examples of using the library for different projects in the [examples](examples) folder. some of the examples are even ported to run in the browser using webassembly. check them out!  | example | web | description | | ---     | --- | ---         | | [main](examples/main) | [whisper.wasm](examples/whisper.wasm) | tool for translating and transcribing audio using whisper | | [bench](examples/bench) | [bench.wasm](examples/bench.wasm) | benchmark the performance of whisper on your machine | | [stream](examples/stream) | [stream.wasm](examples/stream.wasm) | real-time transcription of raw microphone capture | | [command](examples/command) | [command.wasm](examples/command.wasm) | basic voice assistant example for receiving voice commands from the mic | | [wchess](examples/wchess) | [wchess.wasm](examples/wchess) | voice-controlled chess | | [talk](examples/talk) | [talk.wasm](examples/talk.wasm) | talk with a gpt-2 bot | | [talk-llama](examples/talk-llama) | | talk with a llama bot | | [whisper.objc](examples/whisper.objc) | | ios mobile application using whisper.cpp | | [whisper.swiftui](examples/whisper.swiftui) | | swiftui ios / macos application using whisper.cpp | | [whisper.android](examples/whisper.android) | | android mobile application using whisper.cpp | | [whisper.nvim](examples/whisper.nvim) | | speech-to-text plugin for neovim | | [generate-karaoke.sh](examples/generate-karaoke.sh) | | helper script to easily [generate a karaoke video](https://youtu.be/uj7hvta4blm) of raw audio capture | | [livestream.sh](examples/livestream.sh) | | [livestream audio transcription](https://github.com/ggerganov/whisper.cpp/issues/185) | | [yt-wsp.sh](examples/yt-wsp.sh) | | download + transcribe and/or translate any vod [(original)](https://gist.github.com/danirukun/96f763ec1a037cc92fe1a059b643b818) | | [server](examples/server) | | http transcription server with oai-like api |  ## [discussions](https://github.com/ggerganov/whisper.cpp/discussions)  if you have any kind of feedback about this project feel free to use the discussions section and open a new topic. you can use the [show and tell](https://github.com/ggerganov/whisper.cpp/discussions/categories/show-and-tell) category to share your own projects that use `whisper.cpp`. if you have a question, make sure to check the [frequently asked questions (#126)](https://github.com/ggerganov/whisper.cpp/discussions/126) discussion. ","jnordwick/zstats":"This repository has no description. 404: not found","johan0A/zig-linear-algebra":"This package is a simple linear algebra library writen entirely in Zig. zig-linear-algebra: a basic linear algebra library for zig ================================================  this package is a simple linear algebra library writen entirely in zig.  this library was written for my own use, and will be extended and optimized as i need it. it is suitable for operations on small matrices and vectors.  this library is not ready for use.  ## todo: (in this order~)  - [x] rework how precision of output types is handled for vectors - [x] rework how vectors handle integer types - [x] add doc comments for vector operations - [x] add more operations to vectors - [x] rework how precision of output types is handled for vectors again - [ ] decide how to handle undefined behavior (eg overflows) - [ ] add install guide - [ ] add usage guide - [ ] rework how precision of output types is handle for matrices - [ ] rework how matrices handle integer types - [ ] add even more operations to vectors - [ ] add more operations to matrices - [ ] compare performance to openblas  ","ikskuh/navmesh":"A navmesh implementation in zig 404: not found","kassane/fiber":"userland threads uses zig build boost.fiber  ===========      boost.fiber provides a framework for micro-/userland-threads (fibers) scheduled cooperatively. the api contains classes and functions to manage and synchronize fibers similar to boost.thread.    a fiber is able to store the current execution state, including all registers and cpu flags, the instruction pointer, and the stack pointer and later restore this state. the idea is to have multiple execution paths running on a single thread using a sort of cooperative scheduling (threads are preemptively scheduled) - the running fiber decides explicitly when it yields to allow another fiber to run (context switching).    a context switch between threads costs usually thousands of cpu cycles on x86 compared to a fiber switch with less than 100 cycles. a fiber can only run on a single thread at any point in time.    boost.fiber requires c++11!  ","bogwi/SortedMap":"Map for fast storing key-value pairs sorted by key # sortedmap in zig  ## description  sorted map is a fast key-value table, an advance version of [skiplist adt](https://en.wikipedia.org/wiki/skip_list) as proposed by w.pugh in 1989 for ordered mapping of keys to  values.  ## features  * takes any numeric key except the maximum possible value for the given type.  * takes any literal key of type `[]const u8` and of any length, but lexicographically smaller than `'ÿ'` ascii 255.  * values are arbitrary values. * works in `.set` or `.list` mode. the latter allows duplicate keys. * has forward and backward iteration. * has `min`, `max`, `median` key query. * supports queries by key or index, similar to python's list class, including reverse indexing. * basic operations like `get`, `remove` work on a range as well. * updating the values by giving the `start_idx` - `stop_idx` range is o(1) each update. yes, the whole map can be updated in o(n). * updating the values by giving the `start_key` - `stop_key` range is o(1) each update.  ## performance the benchmark is a set of standard stress routines to measure the throughput for the given task. the machine is an apple m1 with 32gb ram, optimization flag `releasefast`.  there are five tests in total, all of which are run on the random data with intermediate shuffling during the test stages:  **read heavy**╲ [read 98, insert 1,  remove 1,  update 0 ]╲ models caching of data in places such as web servers and disk page caches.  **exchange**╲ [read 10, insert 40, remove 40, update 10]╲ replicates a scenario where the map is used to exchange data.  **exchange heavy**╲ [read 1, insert 98, remove 98, update 1]╲ this test is an inverse of *rh* test. hard for any map.  **rapid grow**╲ [read 5,  insert 80, remove 5,  update 10]╲ a scenario where the map is used to collect large amounts of data in a short burst.  **clone**╲ clone the map. that is, rebuild the map anew yet from the sorted data.  ### `u64`, arbitrary feed ```                sortedmap u64 benchmark|               10_000_000 ops:each test|  |name         |tp mops:sec|    rt :sec|  ===================================== |rh           |      51.47|   0.194274| arena size: 13804, cache len: 131  |ex           |      23.25|   0.430069| arena size: 13804, cache len: 121  |exh          |      20.20|   0.494928| arena size: 13804, cache len: 135  |rg           |       0.53|  18.996072| arena size: 595966060, cache len: 5  |clone        |       5.86|   1.279128| ```  ### `[8]const u8`, arbitrary literal, arbitrary feed ```                sortedmap str benchmark|               10_000_000 ops:each test|  |name         |tp mops:sec|    rt :sec|  ===================================== |rh           |      25.49|   0.392336| arena size: 13564, cache len: 133  |ex           |      17.02|   0.587408| arena size: 13564, cache len: 123  |exh          |      14.49|   0.690115| arena size: 13564, cache len: 137  |rg           |       0.37|  26.855707| arena size: 894236804, cache len: 5  |clone        |       3.12|   2.400613| ```  ## how to run the benchmark ``` zig build bench ``` by default it runs 100_000 rounds each test on the `u64` type.  give it a larger number to stress the map more. ``` zig build bench -- 1_000_000 ``` prepend with `-str` to test on the arbitrary `[8]u8` word. ``` zig build bench -- 1_000_000 -str ```  ## how to use it copy `sorted_map.zig` and `cache.zig` into your project, or make a fork and work from there. or you can import it as a dependency.  declare in your file: ```zig const sortedmap = @import('sorted_map.zig').sortedmap; ```  initiate for numeric keys: ```zig const map = sortedmap(u64, your_value_type, .list).init(your_allocator); defer map.deinit();  ```  initiate for string literal keys: ```zig const map = sortedmap([]const u8, your_value_type, .set).init(your_allocator); defer map.deinit(); ```   ## zig version ``` 0.12.0-dev.1830+779b8e259 ```              ","ahmdhusam/concurrent-channel":"A thread-safe communication channel for concurrent programming in Zig. 404: not found","Syndica/zstd.zig":"Zig binding of Z Standard # zstd.zig  zig binding of z standard based on _`v1.5.2`_  ## how to import   in your `build.zig`: ```zig pub fn build(b: *std.build) void {     // ...      const zstd_dep = b.dependency('zstd', opts);     const zstd_mod = zstd_dep.module('zstd');     const zstd_c_lib = zstd_dep.artifact('zstd');      const exec = ...      // link it     exec.addmodule('zstd', zstd_mod);     exec.linklibrary(zstd_c_lib);      // ... } ```  ## usage  ```zig const zstdreader = @import('zstd').reader; ...  pub fn main() {     const path = ...      const file = try std.fs.cwd().openfile(path, .{});     defer file.close();      const file_stat = try file.stat();     const file_size: u64 = @intcast(file_stat.size);     var memory = try std.os.mmap(         null,         file_size,         std.os.prot.read,         std.os.map.private,         file.handle,         0,     );     var decompressed_stream = try zstdreader.init(memory);     var reader = decompressed_stream.reader();      ... } ``` ","bcrist/tempora":"Simple Zig Dates/Times/Timezones 404: not found","r4gus/zigenity":"Like zenity but in Zig # zigenity  like [zenity](https://gitlab.gnome.org/gnome/zenity) but in [zig](https://ziglang.org/) and only for linux.  ![question dialog](static/example01.png)  ## dialog types  | type | supported | |:----:|:---------:| | calendar | | | entry | | | error | | | info | | | file-selection | ✅ | | list | | | notification | | | progress | | | question | ✅ | | warning | | | scale | | | text-info | | | color-selection | | | password | ✅ | | forms | |  ## dependency  * `gtk+-3.0`  ## getting started  to build this application you need [zig 0.11.0](https://ziglang.org/download/). after installing zig run the following commands to build the application:  ``` git clone https://github.com/r4gus/zigenity.git cd zigenity zig build -doptimize=releasesmall ```  run `zigenity --help` for a list of options.  this application uses the same return codes and options as [zenity](https://gitlab.gnome.org/gnome/zenity), including: * `0` - ok button was pressed * `1` - cancel button was pressed * `5` - timeout (this is only returned when using the `--timeout` option) * `255` - some other error (e.g., no dialog type has been selected) ","kassane/outcome":"Provides very lightweight outcome<T> and result<T> (non-Boost edition) (uses zig build-system) 404: not found","tensorush/zig-backoff":"Zig implementation of exponential backoff algorithm. # zig-backoff  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ### zig implementation of [exponential backoff algorithm](https://en.wikipedia.org/wiki/exponential_backoff).  ### :rocket: usage  - add `backoff` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-backoff/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `backoff` dependency in `build.zig`.  ```zig const backoff_dep = b.dependency('backoff', .{     .target = target,     .optimize = optimize, }); const backoff_mod = backoff_dep.module('backoff'); <compile>.root_module.addimport('backoff', backoff_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-backoff/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-backoff/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/tensorush/zig-backoff.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-backoff/blob/main/license ","squeek502/zig-unidecode":"Very approximate UTF-8 to ASCII transliterator (a Zig implementation of the Text::Unidecode Perl module) # zig-unidecode  a [zig](https://ziglang.org/) implementation of the [text::unidecode perl module](https://metacpan.org/pod/text::unidecode) to convert utf-8 text into a (very) approximate ascii-only transliteration. that is, this is 'meant to be a transliterator of last resort.'  for a more detailed description including motivation, caveats, etc, see:  https://metacpan.org/pod/text::unidecode  ## examples  | utf-8  | transliterated ascii | | ------------- | ------------- | | `'ÿéáh'`  | `'yeah'`  | | `'北亰'`  | `'bei jing '` | | `'Славься'`  | `'slav'sia'` | | `'[██  ] 50%'`  | `'[##  ] 50%'` |  ## some things worth noting  - the returned output will only contain ascii characters (`0x00`-`0x7f`). - any ascii characters in the input will be unconverted in the output. - utf-8 codepoints may be transliterated to a variable number of ascii   characters (including 0). - utf-8 codepoints > `0x7f` will never be transliterated to include any   ascii control characters except `╲n`. - unknown utf-8 codepoints may be transliterated to `[?]`.  ## the different functions provided  ### `unidecodealloc`  takes an allocator in order to handle any input size safely. this should be used for most use-cases.  ### `unidecodebuf`  takes a `dest` slice that must be large enough to handle the transliterated ascii. because the output size can vary greatly depending on the input, this is unsafe unless it can be known ahead-of-time that the transliterated output will fit (i.e. comptime).  ### `unidecodestringliteral`  a way to transliterate a utf-8 string literal into ascii at compile time. ","nektro/zig-detect-license":"Given an input text guess which SPDX license it most likely is an instance of # zig-detect-license  given an input text guess which spdx license it most likely is an instance of  ## built with - https://github.com/ziglang/zig master - https://github.com/nektro/zigmod package manager  - https://github.com/nektro/zig-licenses-text - https://github.com/nektro/zig-leven - https://github.com/nektro/zig-fs-check  ## install ``` zigmod aq add 1/nektro/detect-license ```  ## usage - `pub fn detect(alloc: *std.mem.allocator, license_src: []const u8) ![]const u8`     - given an input string, will return the spdx licence identifier for the closest guess to which one it might be  - `pub fn detectindir(alloc: *std.mem.allocator, dir: std.fs.dir) !?[]const u8`     - given a directory, will search for a `license` file and return the guess for which one it is. will return `null` if the license file can not be found. if this returns null when you do indeed have a license file, please help expand the search examples by submitting a bug report.  ## license mit ","Ratakor/skip":"zig and C99 implementation of skip lists  skip ==== a c99 and zig implementation of [skip lists](https://wikipedia.org/wiki/skip_list)  usage ----- define `skip_doubly` to use doubly skip lists instead of singly skip lists. change `skipkey` and `skipval` types in skip.h according to your key/val types, include skip.c and skip.h to your project, that's it. ","nektro/zig-bencode":"Bencode parser for Zig. # zig-bencode ![loc](https://sloc.xyz/github/nektro/zig-bencode)  bencode parser for zig.  uses the [zigmod](https://github.com/nektro/zigmod) package manager.  https://en.wikipedia.org/wiki/bencode  https://www.bittorrent.org/beps/bep_0003.html#bencoding  ## usage add the following to the bottom of your `zig.mod` ```yml dependencies:   - src: git https://github.com/nektro/zig-bencode ```  in your code ```zig const bencode = @import('bencode');  pub fn main() !void {     var gpa = std.heap.generalpurposeallocator(.{}){};     const alloc = &gpa.allocator;      const file = @embedfile('./some/path/to.torrent');     var buf = std.io.fixedbufferstream(file);     const r = buf.reader();     const ben = try bencode.parse(r, alloc);      // do something with `ben`... } ```  ## license mit ","DISTREAT/zig-argtic":"Zig argument parser # zig-argtic  a library for parsing command-line options, arguments, and sub-commands.  _build using zig version: `0.12.0`_  ## how does it compare to the posix and gnu conventions?  - an option requires a long name (gnu compatible; eg. `--long-option`) - an option may have a single char name and start with one hyphen (similar to posix) - an option may have a value (gnu compliant)   - ...directly following as the next index inside the argument vector (eg. `-o file.txt`)   - but may not follow directly after the option name (incompatible gnu/incompatible posix; eg. `-ofile.txt`) - options may be grouped in any order (posix compliant; eg. `-o -v` -> `-ov`) - options may appear multiple times (posix) - options precede required arguments (posix) - options may be supplied in any order (gnu) - options may be separated into option name and value through the use of an equal sign (gnu complicant; eg. `--name=value`)  [source: posix conventions](http://www.iitk.ac.in/esc101/05aug/tutorial/essential/attributes/_posix.html)  [source: gnu conventions/additions](https://www.gnu.org/software/libc/manual/html_node/argument-syntax.html)  ## example  ```zig // simple example - reduced to a minimum const specification = argtic.argumentspecification{     .name = 'exe',     .positionals = &[_]argtic.positional{         .{ .name = 'value' },     }, };  const argument_vector = try std.process.argsalloc(allocator); defer std.process.argsfree(allocator, argument_vector);  const arguments = try argtic.argumentprocessor.parse(allocator, specification, argument_vector[1..]); defer arguments.deinit();  std.log.info('{s}', .{arguments.getargument('value').?}); ```  for more thorough examples, visit `examples/` and `src/tests.zig`.  [required arguments](https://github.com/distreat/zig-argtic/blob/master/examples/positionals.zig)  [optional arguments](https://github.com/distreat/zig-argtic/blob/master/examples/optionals.zig)  [optional positionals](https://github.com/distreat/zig-argtic/blob/master/examples/extra_positionals.zig)  [subcommands](https://github.com/distreat/zig-argtic/blob/master/examples/subcommands.zig)  ## documentation  the documentation is created in the directory `docs/` when running `zig build`.  [documentation](https://distreat.github.io/zig-argtic/)  ## appendix  this project was likely one of the most challenging projects i have written, especially because i struggle with parsers in general. nonetheless, i did realize this project in the end and am more or less content, although not happy.  there is a lot of missing work, but i assume it's usable to the point where i could use it in future projects. to put it in perspective, this is probably already the 10th iteration i have written, and i finally got a decent structure down that i assume to be scalable and maintainable.  anyway, don't underestimate the project of writing a cli argument parser that supports subcommands, flags (with multiple value syntax), compound flags, and positional arguments. this project tested my limits again and agian and even made me consider using a peg or regular expression parser - also - it's not like i started programming yesterday. notably, the api took me some time to figure out, which is funny considering it's simplicity.  every single stage of this project tested me and my idealistic bed-of-rose-loving ass. considering all i've just said, i'd recommend writing an argument parser once in your life - it just makes you feel cured of all previous projects (or sad about your life choices) - because i hated it, especially in the final half-assed stages.  now that i succeeded (more or less), you may consider this my magnum opus of yak shaving. ","bcrist/Zig-SX":"S-Expression [de]serialization in Zig 404: not found","zigcc/zig-todo-web-app":"A Single-page TODO app in Zig! 404: not found","joachimschmidt557/vpkz":"Zig library and command-line application for working with Valve VPK files # vpkz  a zig library and cli application for handling valve vpk files  works with zig 0.13.0.  - [x] reading vpk headers - [x] extracting complete archives - [ ] selectively reading/extracting files - [ ] creating/updating vpk files ","RohanVashisht1234/zorsig":"This repository has no description. # zorsig: a better morse library for zig programming language  features: - minimum version of zig: 0.13.0 - memory safe - no allocators used - high performance library  ## how to use? ```zig const std = @import('std'); const zorsig = @import('zorsig'); const print = std.debug.print;  pub fn main() void {     const res1 = zorsig.char_to_morse('a');     print('{s}╲n', .{res1});      const res2 = zorsig.morse_to_char('.-');     print('{c}╲n', .{res2});      // no allocator     var res3 = zorsig.morse_to_string('.... . .-.. .-.. --- --..-- / .-- --- .-. .-.. -.. -.-.--');      while (res3.next()) |next_element| {         print('{c}', .{next_element});     }     print('╲n', .{});     var res4 = zorsig.string_to_morse('hello, world!');      while (res4.next()) |next_element| {         print('{s} ', .{next_element});     } } ``` ### output:  <img width='1055' alt='screenshot 2024-11-13 at 3 26 46 pm' src='https://github.com/user-attachments/assets/13efa6c4-c073-47ed-bfe1-05cb10fbfc9f'>  ## get started: **run the following command in your terminal:**  ```sh zig fetch --save 'https://github.com/rohanvashisht1234/zorsig/archive/refs/tags/v0.0.1.tar.gz' ```  **add the following to your build.zig (just above the line `b.installartifact(exe);`): ** ```zig const zorsig = b.dependency('zorsig', .{     .target = target,     .optimize = optimize, });  exe.root_module.addimport('zorsig', zorsig.module('zorsig')); ``` ## that's it, now use the zorsig. ","zigster64/jwt.zig":"A JWT library for zig <h1 align='center'>     zig jwt </h1>  <div align='center'>     a <a href='https://jwt.io/'>jwt</a> library for zig </div>  ---  this is a hard fork of github.com/softprops/zig-jwt  differences are :  - allows you to decode a jwt that you dont have the secret for - fixes breaking changes from the latest 0.14 type name changes  ---  ## 📼 installing  create a new exec project with `zig init`. copy an example from the examples directory into your into `src/main.zig`  create a `build.zig.zon` file to declare a dependency  > .zon short for 'zig object notation' files are essentially zig structs. `build.zig.zon` is zigs native package manager convention for where to declare dependencies  starting in zig 0.12.0, you can use and should prefer  ```sh zig fetch --save https://github.com/zigster64/jwt.zig/archive/refs/tags/v1.0.0.tar.gz ```  otherwise, to manually add it, do so as follows  ```diff .{     .name = 'my-app',     .version = '0.1.0',     .dependencies = .{ +       // 👇 declare dep properties +        .jwt = .{ +            // 👇 uri to download +            .url = 'https://github.com/zigster64/jwt.zig/archive/refs/tags/v1.0.0.tar.gz', +            // 👇 hash verification +            .hash = '...', +        },     }, } ```  > the hash below may vary. you can also depend any tag with `https://github.com/zigster64/jwt.zig/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/zigster64/jwt.zig/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference dep from build.zig.zon +    const jwt = b.dependency('jwt', .{ +        .target = target, +        .optimize = optimize, +    }).module('jwt');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the module to executable +    exe.root_mode.addimport('jwt', jwt);      b.installartifact(exe); } ```  ## examples  see examples directory  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)   ╲- softprops 2024 ","voidstar240/zig-wayland-xdg_decoration-client":"XDG Decoration protocol extension for zig-wayland-client # wayland xdg decoration client this is the xdg decoration protocol extension for the [`zig-wayland-client`](https://github.com/voidstar240/zig-wayland-client) library. ","RetroDev256/instinct":"This repository has no description. # instinct  an ultra simple set of distinct integer types.  ### use cases: - you don't want to mix up array index types - you want safety checks on an integer that must have a range - you want the above, but with a value that represents null  ### types: ```zig pub fn optionalrangedint(     comptime t: type,     comptime type_id: u32,     comptime range: range(t),     comptime null_value: t, ) type { ... }  pub fn optionalint(     comptime t: type,     comptime type_id: u32,     comptime null_value: t, ) type { ... }  pub fn rangedint(     comptime t: type,     comptime type_id: u32,     comptime range: range(t), ) type { ... }  pub fn int(     comptime t: type,     comptime type_id: u32, ) type { ... } ```  ### methods: each type provides the following methods: - `init` creates a new distinct type - `set` changes the value of the distinct type - `val` fetches the value of the distinct type - `cast` converts the distinct type to another distinct type limitation: you can't directly cast from an optional to non-optional type","sorairolake/sysexits-zig":"The system exit codes as defined by <sysexits.h> for Zig <!-- spdx-filecopyrighttext: 2023 shun sakai  spdx-license-identifier: apache-2.0 or mit -->  # sysexits-zig  [![ci][ci-badge]][ci-url]  **sysexits-zig** is a library that provides the system exit code constants as defined by [`<sysexits.h>`].  this library is a port of [sysexits-rs].  ## usage  add this package to your `build.zig.zon`:  ```sh zig fetch --save git+https://github.com/sorairolake/sysexits-zig.git ```  add the following to your `build.zig`:  ```zig const sysexits = b.dependency('sysexits', .{}); exe.root_module.addimport('sysexits', sysexits.module('sysexits')); ```  ### example  ```zig const std = @import('std');  const sysexits = @import('sysexits');  pub fn main() !u8 {     const bytes = [_]u8{ 0xf0, 0x9f, 0x92, 0x96 };     if (std.unicode.utf8validateslice(&bytes)) {         try std.io.getstdout().writer().print('{s}╲n', .{bytes});         return @intfromenum(sysexits.exitcode.ok);     } else {         try std.io.getstderr().writer().print('error: invalid utf-8 sequence╲n', .{});         return @intfromenum(sysexits.exitcode.data_err);     } } ```  ### documentation  to build the documentation:  ```sh zig build doc ```  the result is generated in `zig-out/docs`.  if you want to preview this, run a http server locally. for example:  ```sh python -m http.server -d zig-out/docs ```  then open `http://localhost:8000/` in your browser.  ## zig version  this library is compatible with zig version 0.13.0.  ## source code  the upstream repository is available at <https://github.com/sorairolake/sysexits-zig.git>.  the source code is also available at:  - <https://gitlab.com/sorairolake/sysexits-zig.git> - <https://codeberg.org/sorairolake/sysexits-zig.git>  ## changelog  please see [changelog.adoc].  ## contributing  please see [contributing.adoc].  ## license  copyright &copy; 2023&ndash;2024 shun sakai (see [authors.adoc])  this library is distributed under the terms of either the _apache license 2.0_ or the _mit license_.  this project is compliant with version 3.2 of the [_reuse specification_]. see copyright notices of individual files for more details on copyright and licensing information.  [ci-badge]: https://img.shields.io/github/actions/workflow/status/sorairolake/sysexits-zig/ci.yaml?branch=develop&style=for-the-badge&logo=github&label=ci [ci-url]: https://github.com/sorairolake/sysexits-zig/actions?query=branch%3adevelop+workflow%3aci++ [`<sysexits.h>`]: https://man.openbsd.org/sysexits [sysexits-rs]: https://crates.io/crates/sysexits [changelog.adoc]: changelog.adoc [contributing.adoc]: contributing.adoc [authors.adoc]: authors.adoc [_reuse specification_]: https://reuse.software/spec/ ","interpunct/clap-zig-bindings":"manually written idiomatic zig bindings for CLAP audio API # [clap-zig-bindings]  **this is currently a work in progress**  zig bindings for the [clap] audio api. currently covers 100% of the api as of clap version `1.2.2`. this library does not cover draft extensions.  this is a full hand-written translation. everything is done to make the most of zig's type system.  this is not a plugin framework!  ## including as a dependency  use the `zig fetch` command, ie:  ```sh zig fetch --save git+https://git.sr.ht/~interpunct/clap-zig-bindings ```  then add the following to your `build.zig`:  ```zig const clap_bindings = b.dependency('clap-bindings', .{}) exe.root_module.addimport('clap-bindings', clap_bindings.module('clap-bindings')); ```  this library currently targets zig version `0.13.0`.  ## issue tracker  browse tickets at <https://todo.sr.ht/~interpunct/clap-zig-bindings>.  if you are having issues and there is not already an open ticket for them at the page above please send an email with what your problems are to [my public inbox], and i will make a ticket for them. (this does not require a sourcehut account)  ## contributing  patches are done by email on [my public inbox]. this is funcitonality built in to git. if this workflow is new to you please refer to the [sourcehut docs]. i promise that it is quick and easy to learn and set up.  ## license  `clap-zig-bindings` is distributed under lgplv3, see the license file.  [clap-zig-bindings]: https://sr.ht/~interpunct/clap-zig-bindings/ [clap]: https://cleveraudio.org [my public inbox]: mailto:~interpunct/public-inbox@lists.sr.ht [sourcehut docs]: https://man.sr.ht/git.sr.ht/send-email.md  ","bcrist/Zig-ConsoleHelper":"Console Helpers for command line applications 404: not found","bcrist/dizzy":"Zig Comptime Dependency Injection # dizzy ### function parameter dependency injection for zig  see test.zig for example usage. ","bcrist/zkittle":"A little Zig template engine 404: not found","srjilarious/zargunaught":"Zig argument parsing library, based on my C++ argunaught library 404: not found","tensorush/zig-exhaustigen":"Zig port of exhaustigen library for exhaustive testing. # zig-exhaustigen  [![ci][ci-shd]][ci-url] [![cd][cd-shd]][cd-url] [![dc][dc-shd]][dc-url] [![lc][lc-shd]][lc-url]  ## zig port of [exhaustigen](https://github.com/graydon/exhaustigen-rs) exhaustive testing library.  ### :rocket: usage  - add `exhaustigen` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-exhaustigen/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `exhaustigen` dependency in `build.zig`.  ```zig const exhaustigen_dep = b.dependency('exhaustigen', .{     .target = target,     .optimize = optimize, }); const exhaustigen_mod = exhaustigen_dep.module('gen'); <compile>.root_module.addimport('gen', exhaustigen_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-exhaustigen/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-exhaustigen/blob/main/.github/workflows/ci.yaml [cd-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-exhaustigen/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/tensorush/zig-exhaustigen/blob/main/.github/workflows/cd.yaml [dc-shd]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=doc&labelcolor=black [dc-url]: https://tensorush.github.io/zig-exhaustigen [lc-shd]: https://img.shields.io/github/license/tensorush/zig-exhaustigen.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-exhaustigen/blob/main/license ","tensorush/zig-quickphf":"Zig port of quickphf library for static hash map generation. # zig-quickphf  [![ci][ci-shd]][ci-url] [![cd][cd-shd]][cd-url] [![dc][dc-shd]][dc-url] [![lc][lc-shd]][lc-url]  ## zig port of [quickphf library](https://github.com/dtrifuno/quickphf) for static hash map generation.  ### :rocket: usage  - add `quickphf` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-quickphf/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `quickphf` dependency in `build.zig`.  ```zig const quickphf_dep = b.dependency('quickphf', .{     .target = target,     .optimize = optimize, }); const quickphf_mod = quickphf_dep.module('quickphf'); <compile>.root_module.addimport('quickphf', quickphf_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-quickphf/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-quickphf/blob/main/.github/workflows/ci.yaml [cd-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-quickphf/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/tensorush/zig-quickphf/blob/main/.github/workflows/cd.yaml [dc-shd]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=docs&labelcolor=black [dc-url]: https://tensorush.github.io/zig-quickphf [lc-shd]: https://img.shields.io/github/license/tensorush/zig-quickphf.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-quickphf/blob/main/license ","thechampagne/sfdir-zig":"Zig binding for Single-file dir a directory listing functions. # sfdir-zig  [![](https://img.shields.io/github/v/tag/thechampagne/sfdir-zig?label=version)](https://github.com/thechampagne/sfdir-zig/releases/latest) [![](https://img.shields.io/github/license/thechampagne/sfdir-zig)](https://github.com/thechampagne/sfdir-zig/blob/main/license)  zig binding for **single-file dir** a directory listing functions.  ### references  - [sfdir](https://github.com/mattiasgustavsson/libs/blob/main/dir.h)  ### license  this repo is released under the [apache license 2.0](https://github.com/thechampagne/sfdir-zig/blob/main/license). ","EsportToys/ClipPad":"A barebones plaintext scratch pad. 404: not found","nektro/zig-errno":"This repository has no description. 404: not found","andrewrk/libebur128":"libebur128 with the build system replaced by zig this is a fork of [libebur128](https://github.com/jiixyj/libebur128), packaged for zig. unnecessary files have been deleted, and the build system has been replaced with `build.zig`.  original readme follows:  ============================================================================   libebur128 ==========  libebur128 is a library that implements the ebu r 128 standard for loudness normalisation.  all source code is licensed under the mit license. see copying file for details.  see also [loudness-scanner tool](https://github.com/jiixyj/loudness-scanner).  news ----  v1.2.6 released:  * fix dynamic linking on windows.  v1.2.5 released:  * remove `build_static_libs` build option. instead the cmake-supported    `build_shared_libs` option is now honored as expected.  * various code cleanups, warning fixes and documentation improvements  * fix issue related to filter state indexing with high channel enums (#77)  * introduce limits for number of channels and maximum supported samplerate to    avoid integer overflows  * fix error return code of `ebur128_set_channel`. the actual behavior is now    aligned to the documentation (#90).  v1.2.4 released:  * fix broken `ebur128_loudness_global_multiple()` function. since v1.1.0 it    calculated the relative threshold just from the last state given to it,    resulting in wrong values.  * more tests  * fix some minor build issues  * fix uninitialized memory in `ebur128_init()`, possibly resulting in wrong    values  v1.2.3 released:  * fix uninitialized memory access during true peak scanning (bug #72)  v1.2.2 released (v1.2.1 was mistagged):  * fix a null pointer dereference when doing true peak scanning of 192khz data  v1.2.0 released:   * new functions for real time loudness/peak monitoring:    * `ebur128_loudness_window()`    * `ebur128_set_max_window()`    * `ebur128_set_max_history()`    * `ebur128_prev_sample_peak()`    * `ebur128_prev_true_peak()`  * new fir resampler for true peak calculation, removing speex dependency  * add true peak conformance tests  * bug fixes  v1.1.0 released:   * add `ebur128_relative_threshold()`  * add channel definitions from itu r-rec-bs 1770-4 to channel enum  * fix some minor build issues  v1.0.3 released:   * fix build with recent speexdsp  * correct license file name  * cmake option to disable static library  * minimal-example.c: do not hard code program name in usage  features --------  * portable ansi c code * implements m, s and i modes * implements loudness range measurement (ebu - tech 3342) * true peak scanning * supports all samplerates by recalculation of the filter coefficients  installation ------------  in the root folder, type:      mkdir build     cd build     cmake ..     make  if you want the git version, run simply:      git clone git://github.com/jiixyj/libebur128.git  usage -----  library usage should be pretty straightforward. all exported symbols are documented in the ebur128.h header file. for a usage example, see minimal-example.c in the tests folder.  on some operating systems, static libraries should be compiled as position independent code. you can enable that by turning on `with_static_pic`. ","jkoop/zig-extras":"An assortment of random utility functions that aren't in std and don't need to be their own pacakge. # zig-extras  an assortment of random utility functions that aren't in std and don't deserve their own package.  ## license mit ","travisstaloch/fixed-point":"A fixed point arithmetic package in zig # fixed-point ","sea-grass/goku":"A Static Site Generator written in Zig. # goku  goku is a static site generator written in zig.  ## introduction  a static site generator (ssg) is typically run on some input source to produce a folder of html files, suitable for hosting on any http server. goku aims to be a ssg that can operate on a variety of input sources to generate static sites of up to hundreds of thousands of pages.  ## notice  > [!note]   > goku is in its early stages. the roadmap for features is prioritized on an as-needed basis. if you want to use goku but it's lacking a key feature you need, feel free to check out the [contributing](#contributing) section of the readme.  ## requirements  - officially supported zig: `0.14.0-dev.1710+8ee52f99c` (you can get it from the [zig releases page](https://ziglang.org/download/))  ## installation  use zig to build the application binary. with a shell open in this project's directory:  ``` zig build -doptimize=releasesafe ```  the goku binary will be available at `zig-out/bin/goku`.  ## usage  see [the docs](./site/pages/docs/site.md) on how to scaffold your first goku site.  once you've set up your site, you can use goku to build it:  ``` goku site -o build ```  in the above example, goku will scan `site/pages` recursively for all `.md` files, parse their yaml frontmatter for a `slug`, and then place the built sites into the `build` folder according to each page's `slug`. it will provide a build summary with the time elapsed and the source and destination directories.  once you've built the site, you can try previewing it on your local machine using your preferred file server. for example, if you have `python3` on your system, you can try:  ``` sh -c 'cd build; python3 -m http.server' ```  ## further work  in its current form, goku is very basic. there is no support for theming, asset management, etc. if there's a feature you'd like to see, please open a github issue.  ## contributing  contributions are welcome, but i do request that if there's no open github issue regarding your ideal change that you open one first! it's likely that i'm already working on the feature, so following this process helps to ensure that we're not spending double the time.  ## bug reports  if you find a bug in the software, please report it using the github issue tracker for this project's repository.  ","nektro/zig-zlib":"This repository has no description. # zig-zlib zlib wrapper for zig.  https://www.zlib.net/  zlib version: 1.2.11  ## license mit ","kassane/zig-bearssl":"A BearSSL binding for Zig # zig-bearssl a [bearssl](https://bearssl.org/) binding for zig, providing primitive (and probably unsafe, i'm no ssl expert) bindings for ssl and tls connections to generic zig code. ","DISTREAT/projavu":"A program for on-disk storing and managing of project ideas. # projavu  a program for on-disk storing and managing of project ideas.  _build using zig version: `0.10.1`_  ![screenshot](docs/screenshot.png)  ## features  - display ideas similar to [taskwarrior](https://taskwarrior.org/) - filter ideas to only show relevant entries - categorize projects based on development progress - assign tags to projects - editor-focused workflow  ## backend  - all noted ideas are stored on-disk via a hash-calculated path - a csv table is used to reference ideas, store tags, and progress - on-disk content is only deleted when not referenced anymore and the garbage collector is manually run - the underlying library is undergoing decent integration-testing.  ## binaries  binaries and checksums are provided with every release.  [releases](https://github.com/distreat/projavu/releases)  ## documentation  this repository contains both a cli and library interface.  the documentation for the library is created in the directory `docs/` when running `zig build`.  [documentation](https://distreat.github.io/projavu/)  ","bcrist/Zig-S-Records":"Motorola S-Record library in Zig 404: not found","tensorush/zig-quickdiv":"Zig port of quickdiv library for optimized repeated division. # zig-quickdiv  [![ci][ci-shd]][ci-url] [![cd][cd-shd]][cd-url] [![dc][dc-shd]][dc-url] [![lc][lc-shd]][lc-url]  ## zig port of [quickdiv library](https://github.com/dtrifuno/quickdiv) for optimized repeated division.  ### :rocket: usage  - add `quickdiv` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-quickdiv/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `quickdiv` dependency in `build.zig`.  ```zig const quickdiv_dep = b.dependency('quickdiv', .{     .target = target,     .optimize = optimize, }); const quickdiv_mod = quickdiv_dep.module('quickdiv'); <compile>.root_module.addimport('quickdiv', quickdiv_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-quickdiv/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-quickdiv/blob/main/.github/workflows/ci.yaml [cd-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-quickdiv/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/tensorush/zig-quickdiv/blob/main/.github/workflows/cd.yaml [dc-shd]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=docs&labelcolor=black [dc-url]: https://tensorush.github.io/zig-quickdiv [lc-shd]: https://img.shields.io/github/license/tensorush/zig-quickdiv.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-quickdiv/blob/main/license ","bcrist/zig-percent-encoding":"Percent (URL) Encoding and Decoding for Zig 404: not found","tensorush/zig-cookie":"Zig port of cookie library for HTTP cookie storage. # zig-cookie  [![ci][ci-shd]][ci-url] [![cd][cd-shd]][cd-url] [![dc][dc-shd]][dc-url] [![cc][cc-shd]][cc-url] [![lc][lc-shd]][lc-url]  ## zig port of [cookie library](https://github.com/rwf2/cookie-rs) for http cookie storage.  ### :rocket: usage  - add `cookie` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-cookie/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `cookie` dependency in `build.zig`.  ```zig const cookie_dep = b.dependency('cookie', .{     .target = target,     .optimize = optimize, }); const cookie_mod = cookie_dep.module('cookie'); <compile>.root_module.addimport('cookie', cookie_mod); ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-cookie/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-cookie/blob/main/.github/workflows/ci.yaml [cd-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-cookie/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/tensorush/zig-cookie/blob/main/.github/workflows/cd.yaml [dc-shd]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=docs&labelcolor=black [dc-url]: https://tensorush.github.io/zig-cookie [cc-shd]: https://img.shields.io/codecov/c/github/tensorush/zig-cookie?style=for-the-badge&labelcolor=black [cc-url]: https://app.codecov.io/gh/tensorush/zig-cookie [lc-shd]: https://img.shields.io/github/license/tensorush/zig-cookie.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-cookie/blob/main/license ","tensorush/githunt":"Hacker News feed of top Git links. # githunt  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## hacker news feed of top git links.  ### :rocket: usage  ```sh git clone https://github.com/tensorush/githunt.git cd githunt/ zig build exe ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/githunt/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/githunt/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/tensorush/githunt.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/githunt/blob/main/license ","ziglana/zig-zip":"🦕 zig.zip - immutable zig package registry 404: not found","kassane/duckdb":"DuckDB is an in-process SQL OLAP Database Management System <div align='center'>   <img src='https://duckdb.org/images/duckdb_logo_dl.png' height='50'> </div> <p>&nbsp;</p>     <p align='center'>   <a href='https://github.com/duckdb/duckdb/actions'>     <img src='https://github.com/duckdb/duckdb/actions/workflows/main.yml/badge.svg?branch=main' alt='github actions badge'>   </a>   <a href='https://app.codecov.io/gh/duckdb/duckdb'>     <img src='https://codecov.io/gh/duckdb/duckdb/branch/main/graph/badge.svg?token=faxjcffghn' alt='codecov'/>   </a>   <a href='https://discord.gg/tcvwpjfnzx'>     <img src='https://shields.io/discord/909674491309850675' alt='discord' />   </a>   <a href='https://github.com/duckdb/duckdb/releases/'>     <img src='https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logocolor=white' alt='latest release'>   </a> </p>  ## duckdb duckdb is a high-performance analytical database system. it is designed to be fast, reliable and easy to use. duckdb provides a rich sql dialect, with support far beyond basic sql. duckdb supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. for more information on the goals of duckdb, please refer to [the why duckdb page on our website](https://duckdb.org/why_duckdb).  ## installation if you want to install and use duckdb, please see [our website](https://www.duckdb.org) for installation and usage instructions.  ## data import for csv files and parquet files, data import is as simple as referencing the file in the from clause:  ```sql select * from 'myfile.csv'; select * from 'myfile.parquet'; ```  refer to our [data import](https://duckdb.org/docs/data/overview) section for more information.  ## sql reference the [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and sql constructs available in duckdb.  ## development  for development, duckdb requires [cmake](https://cmake.org), python3 and a `c++11` compliant compiler. run `make` in the root directory to compile the sources. for development, use `make debug` to build a non-optimized debug version. you should run `make unit` and `make allunit` to verify that your version works properly after making changes. to test performance, you can run `build_benchmark=1 build_tpch=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. the detail of benchmarks is in our [benchmark guide](benchmark/readme.md).  please also refer to our [contribution guide](contributing.md). ","jkoop/zig-time":"zig-time but with Zig packaging # zig-time  this is a fork of [zig-time](https://github.com/nektro/zig-time) that's uses zig's native packaging instead of [zigmod](https://github.com/nektro/zigmod).  ## usage  add this repository to your `build.zig.zon`, eg: ```zon // build.zig.zon .{     .name = 'awesome-project',     .version = '0.1.0',     .minimum_zig_version = '0.12.0',     .paths = .{ '' },     .dependencies = .{         .zig_time = .{             .url = 'git+https://github.com/protonull/zig-time#<commit hash>',             .hash = '<hash>' // comment this out zig will automatically tell you what has to use.         },     }, } ```  after that, add the dependency to your build script, eg:  ```zig // build.zig const std = @import('std');  pub fn build(     b: *std.build ) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const exe = b.addexecutable(.{         .name = 'awesome-project',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });      // zig-time dependency goes here     exe.root_module.addimport('zig-time', b.dependency('zig_time', .{}).module('time'));          b.installartifact(exe); } ```  you may notice there's `zig-time`, `zig_time`, and `time`.  - `zig-time` is what you'd use as the import, like so: `const time = @import('zig-time')` - `zig_time` is the key to match in `build.zig.zon`, which doesn't like dashes. - `time` is the name of the exported module from zig-time, the library itself. ","Ang3lERR404/zig-utilities":"Utilities for zig, in a smol, convenient file # utils.zig a smol utility library before skill issues were found :d  # ***in the entire standard library for zig*** =~= > w h y╲ > a r e╲ > y o u╲ > l i k e╲ > t h i s","kassane/ffi-flang-zig":"FFI flang-new runtime with Zig # ffi-flang-zig  ffi between fortran runtime and zig  [llvm/flang v18.1.7](https://github.com/llvm/llvm-project/tree/llvmorg-18.1.7/flang) files are included in this repository.  inspired by [sourceryinstitute/iso_fortran_binding](https://github.com/sourceryinstitute/iso_fortran_binding). however, for llvm-based only!  ## requires  - [zig](https://ziglang.org/download) v0.13.0 or master - [flang-new](https://github.com/llvm/llvm-project/tree/llvmorg-18.1.7/flang)   ## how to use  build docker and run image:  ```bash $ docker build -t flang-zig -f .devcontainer/dockerfile $ docker run -it --rm -v $(pwd):/app -w /app flang-zig bash ```  ### build help  ```bash project-specific options:   -doptimize=[enum]            prioritize performance, safety, or binary size                                  supported values:                                    debug                                    releasesafe                                    releasefast                                    releasesmall   -dtarget=[string]            the cpu architecture, os, and abi to build for   -dcpu=[string]               target cpu features to add or subtract   -ddynamic-linker=[string]    path to interpreter on the target system   -dshared=[bool]              build as shared library [default: false]   -damalgamation=[bool]        build as amalgamation [default: false]   -denable-tests=[bool]        build tests [default: false] ```","bcrist/Zig-fmtHelper":"Some std.fmt helpers for Zig programs 404: not found","bcrist/Zig-LC4k":"Generate ispMach4000 CPLD bitstreams directly from Zig code 404: not found","tiawl/toolbox":"A toolkit to package & maintain C APIs for @ziglang # toolbox  a toolkit to package & maintain c apis for [zig][2]  ## important note  this package was originally thought for the [tiawl/spaceporn][1] dependencies chain. it is actively used in it. but it is also possible to use it in other projects. however maybe some features are always binded to its original conception guideline. for this reason, this repository is open to breaking proposals. so if you are using it for your own needs, expect breaking (but also documented) changes for each release.  if you want to see how to use it you can check repositories list into the [cicd reminder section](https://github.com/tiawl/toolbox/tree/trunk#cicd-reminder).  ## dependencies  the [zig][2] part of this package is relying on the latest [zig][2] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  ## cicd reminder  these repositories are automatically updated when a new release is available: * [tiawl/vulkan.zig][3] * [tiawl/wayland.zig][4] * [tiawl/x11.zig][5] * [tiawl/glfw.zig][6] * [tiawl/cimgui.zig][7] * [tiawl/spirv.zig][8] * [tiawl/glslang.zig][9] * [tiawl/shaderc.zig][10] * [tiawl/oniguruma.zig][15] * [tiawl/libjq.zig][14]  this repository is automatically updated when a new release is available from these repositories: * [tiawl/spaceporn-action-ci][11] * [tiawl/spaceporn-action-cd-ping][12] * [tiawl/spaceporn-action-cd-pong][13]  ## documentation  a minimal documentation is available [here](https://github.com/tiawl/toolbox/blob/trunk/doc.md)  ## license  this repository is dedicated to the public domain. see the license file for more details.  [1]:https://github.com/tiawl/spaceporn [2]:https://github.com/ziglang/zig [3]:https://github.com/tiawl/vulkan.zig [4]:https://github.com/tiawl/wayland.zig [5]:https://github.com/tiawl/x11.zig [6]:https://github.com/tiawl/glfw.zig [7]:https://github.com/tiawl/cimgui.zig [8]:https://github.com/tiawl/spirv.zig [9]:https://github.com/tiawl/glslang.zig [10]:https://github.com/tiawl/shaderc.zig [11]:https://github.com/tiawl/spaceporn-action-ci [12]:https://github.com/tiawl/spaceporn-action-cd-ping [13]:https://github.com/tiawl/spaceporn-action-cd-pong [14]:https://github.com/tiawl/libjq.zig [15]:https://github.com/tiawl/oniguruma.zig ","sea-grass/zig-present":"A command-line tool for running interactive TUI presentations. # zig-present  `zig-present` is a command-line tool for creating interactive tui presentations.  <div style='max-width: 100%; margin: 0 auto; width: 800px;'>  ![demo video of running the zig-present software in a terminal session](./doc/demo.gif)  </div>  ## example  presentations are expressed in a simple text format. here's an example presentation:  ```txt !zig-present # coffee brewing  how to brew coffee with a french press  /next_slide  # what you'll need:  - french press - ground coffee beans - boiling water  /next_slide  # steps  1. add ground coffee beans to the french press 2. add 1 cup of boiling water to the french press, per 7g of coffee beans 3. cover the french press with the lid 4. wait 8 minutes 5. push the plunger down slowly 6. pour and enjoy ```  ## requirements  - officially supported zig: `zig 0.13.0-dev.351+64ef45eb0` (you can get it from the [zig releases page](https://ziglang.org/download/))  ## installation  use zig to build the application binary. with a shell open in this project's directory:  ``` zig build -doptimize=releasesafe ```  the binary will be available at `zig-out/bin/zig-present`.  ## usage  see the [example](#example) for a sample presentation file or the [presentation](#presentation) section for info on the available presentation commands. store this in a file with the .txt extension, like `presentation.txt`. then, you can start the presentation like this:  ``` $ zig-present presentation.txt ```  ## presentation  every zig-present file must start with the line `!zig-present`.  lines starting with a `/` denote a command. all other lines are interpreted as text to print (empty lines and whitespace are preserved).  the most important command is `/next_slide`, which effectively creates a new slide within the presentation. see [commands](#commands) for all of the commands.  ## commands  a presentation file can contain pre-defined commands. see the following table for a glossary:  | command | description | example usage | |----|---|---| | `/next_slide` | adds a pause in the presentation, waiting for the user to press enter. then, will clear the screen and continue the presentation. you may optionally provide a prompt to be displayed beside the cursor. | `/next_slide go to next slide` | | `/docker` | run the docker command, for example to provide the user with an interactive shell. | `/docker run -it busybox sh` | | `/stdout` | run the shell command and print the result. | `/stdout date` | | `/pause` | adds a pause in the presentation, waiting for the user to press enter. does not clear the screen when the user hits enter. you may optionally provide a prompt to be displayed beside the cursor. | `/pause hit enter when you know the answer.` |   ","allyourcodebase/catch2":"Catch 2 ported to the zig build system # `build.zig` for catch2  provides a package to be used by the zig package manager for c++ programs.  ## status  | refname   | catch2 version | zig `0.12.x` | zig `0.13.x` | zig `0.14.0-dev` | |:----------|:---------------|:------------:|:------------:|:----------------:| | `3.7.1+1` | `v3.7.1`       | ✅           | ✅           | ✅               |  ## use  add the dependency in your `build.zig.zon` by running the following command: ```bash zig fetch --save git+https://github.com/allyourcodebase/catch2#3.7.1+1 ```  then, in your `build.zig`: ```zig const catch2_dep = b.dependency('catch2', { .target = target, .optimize = optimize }); const catch2_lib = catch2_dep.artifact('catch2'); const catch2_main = catch2_dep.artifact('catch2withmain'); // wherever needed: exe.linklibrary(catch2_lib); exe.linklibrary(catch2_main); ```  a complete usage demonstration is provided in the [example](example) directory ","kassane/benchmark":"A microbenchmark support library (uses zig build) # benchmark  [![build-and-test](https://github.com/google/benchmark/workflows/build-and-test/badge.svg)](https://github.com/google/benchmark/actions?query=workflow%3abuild-and-test) [![bazel](https://github.com/google/benchmark/actions/workflows/bazel.yml/badge.svg)](https://github.com/google/benchmark/actions/workflows/bazel.yml) [![pylint](https://github.com/google/benchmark/workflows/pylint/badge.svg)](https://github.com/google/benchmark/actions?query=workflow%3apylint) [![test-bindings](https://github.com/google/benchmark/workflows/test-bindings/badge.svg)](https://github.com/google/benchmark/actions?query=workflow%3atest-bindings) [![coverage status](https://coveralls.io/repos/google/benchmark/badge.svg)](https://coveralls.io/r/google/benchmark)  [![discord](https://discordapp.com/api/guilds/1125694995928719494/widget.png?style=shield)](https://discord.gg/cz7ux7wkc2)  a library to benchmark code snippets, similar to unit tests. example:  ```c++ #include <benchmark/benchmark.h>  static void bm_somefunction(benchmark::state& state) {   // perform setup here   for (auto _ : state) {     // this code gets timed     somefunction();   } } // register the function as a benchmark benchmark(bm_somefunction); // run the benchmark benchmark_main(); ```  ## getting started  to get started, see [requirements](#requirements) and [installation](#installation). see [usage](#usage) for a full example and the [user guide](docs/user_guide.md) for a more comprehensive feature overview.  it may also help to read the [google test documentation](https://github.com/google/googletest/blob/main/docs/primer.md) as some of the structural aspects of the apis are similar.  ## resources  [discussion group](https://groups.google.com/d/forum/benchmark-discuss)  irc channels: * [libera](https://libera.chat) #benchmark  [additional tooling documentation](docs/tools.md)  [assembly testing documentation](docs/assemblytests.md)  [building and installing python bindings](docs/python_bindings.md)  ## requirements  the library can be used with c++03. however, it requires c++11 to build, including compiler and standard library support.  the following minimum versions are required to build the library:  * gcc 4.8 * clang 3.4 * visual studio 14 2015 * intel 2015 update 1  see [platform-specific build instructions](docs/platform_specific_build_instructions.md).  ## installation  this describes the installation process using cmake. as pre-requisites, you'll need git and cmake installed.  _see [dependencies.md](docs/dependencies.md) for more details regarding supported versions of build tools._  ```bash # check out the library. $ git clone https://github.com/google/benchmark.git # go to the library root directory $ cd benchmark # make a build directory to place the build output. $ cmake -e make_directory 'build' # generate build system files with cmake, and download any dependencies. $ cmake -e chdir 'build' cmake -dbenchmark_download_dependencies=on -dcmake_build_type=release ../ # or, starting with cmake 3.13, use a simpler form: # cmake -dcmake_build_type=release -s . -b 'build' # build the library. $ cmake --build 'build' --config release ``` this builds the `benchmark` and `benchmark_main` libraries and tests. on a unix system, the build directory should now look something like this:  ``` /benchmark   /build     /src       /libbenchmark.a       /libbenchmark_main.a     /test       ... ```  next, you can run the tests to check the build.  ```bash $ cmake -e chdir 'build' ctest --build-config release ```  if you want to install the library globally, also run:  ``` sudo cmake --build 'build' --config release --target install ```  note that google benchmark requires google test to build and run the tests. this dependency can be provided two ways:  * checkout the google test sources into `benchmark/googletest`. * otherwise, if `-dbenchmark_download_dependencies=on` is specified during   configuration as above, the library will automatically download and build   any required dependencies.  if you do not wish to build and run the tests, add `-dbenchmark_enable_gtest_tests=off` to `cmake_args`.  ### debug vs release  by default, benchmark builds as a debug library. you will see a warning in the output when this is the case. to build it as a release library instead, add `-dcmake_build_type=release` when generating the build system files, as shown above. the use of `--config release` in build commands is needed to properly support multi-configuration tools (like visual studio for example) and can be skipped for other build systems (like makefile).  to enable link-time optimisation, also add `-dbenchmark_enable_lto=true` when generating the build system files.  if you are using gcc, you might need to set `gcc_ar` and `gcc_ranlib` cmake cache variables, if autodetection fails.  if you are using clang, you may need to set `llvmar_executable`, `llvmnm_executable` and `llvmranlib_executable` cmake cache variables.  to enable sanitizer checks (eg., `asan` and `tsan`), add: ```  -dcmake_c_flags='-g -o2 -fno-omit-frame-pointer -fsanitize=address -fsanitize=thread -fno-sanitize-recover=all'  -dcmake_cxx_flags='-g -o2 -fno-omit-frame-pointer -fsanitize=address -fsanitize=thread -fno-sanitize-recover=all '   ```  ### stable and experimental library versions  the main branch contains the latest stable version of the benchmarking library; the api of which can be considered largely stable, with source breaking changes being made only upon the release of a new major version.  newer, experimental, features are implemented and tested on the [`v2` branch](https://github.com/google/benchmark/tree/v2). users who wish to use, test, and provide feedback on the new features are encouraged to try this branch. however, this branch provides no stability guarantees and reserves the right to change and break the api at any time.  ## usage  ### basic usage  define a function that executes the code to measure, register it as a benchmark function using the `benchmark` macro, and ensure an appropriate `main` function is available:  ```c++ #include <benchmark/benchmark.h>  static void bm_stringcreation(benchmark::state& state) {   for (auto _ : state)     std::string empty_string; } // register the function as a benchmark benchmark(bm_stringcreation);  // define another benchmark static void bm_stringcopy(benchmark::state& state) {   std::string x = 'hello';   for (auto _ : state)     std::string copy(x); } benchmark(bm_stringcopy);  benchmark_main(); ```  to run the benchmark, compile and link against the `benchmark` library (libbenchmark.a/.so). if you followed the build steps above, this library will  be under the build directory you created.  ```bash # example on linux after running the build steps above. assumes the # `benchmark` and `build` directories are under the current directory. $ g++ mybenchmark.cc -std=c++11 -isystem benchmark/include ╲   -lbenchmark/build/src -lbenchmark -lpthread -o mybenchmark ```  alternatively, link against the `benchmark_main` library and remove `benchmark_main();` above to get the same behavior.  the compiled executable will run all benchmarks by default. pass the `--help` flag for option information or see the [user guide](docs/user_guide.md).  ### usage with cmake  if using cmake, it is recommended to link against the project-provided `benchmark::benchmark` and `benchmark::benchmark_main` targets using `target_link_libraries`. it is possible to use ```find_package``` to import an installed version of the library. ```cmake find_package(benchmark required) ``` alternatively, ```add_subdirectory``` will incorporate the library directly in to one's cmake project. ```cmake add_subdirectory(benchmark) ``` either way, link to the library as follows. ```cmake target_link_libraries(mytarget benchmark::benchmark) ``` ","Lumi-Engine/lumi":"The main Lumi engine repo <p align=center>     <img src='https://codeberg.org/lumi-engine/lumi-design/raw/branch/main/2023/lumi_codeberg_banner.svg' /> </p>  lumi engine is a 2d game engine which aims to provide a performant, flexible and easy game development environment. ","kassane/tlsf":"Two-Level Segregated Fit memory allocator implementation. # tlsf two-level segregated fit memory allocator implementation. written by matthew conte (matt@baisoku.org). released under the bsd license.  features --------   * o(1) cost for malloc, free, realloc, memalign   * extremely low overhead per allocation (4 bytes)   * low overhead per tlsf management of pools (~3kb)   * low fragmentation   * compiles to only a few kb of code and data   * support for adding and removing memory pool regions on the fly  caveats -------   * currently, assumes architecture can make 4-byte aligned accesses   * not designed to be thread safe; the user must provide this  notes ----- this code was based on the tlsf 1.4 spec and documentation found at:    http://www.gii.upv.es/tlsf/main/docs  it also leverages the tlsf 2.0 improvement to shrink the per-block overhead from 8 to 4 bytes.  history ------- 2016/04/10 - v3.1   * code moved to github   * tlsfbits.h rolled into tlsf.c   * license changed to bsd  2014/02/08 - v3.0   * this version is based on improvements from 3dinteractive gmbh   * interface changed to allow more than one memory pool   * separated pool handling from control structure (adding, removing, debugging)   * control structure and pools can still be constructed in the same memory block   * memory blocks for control structure and pools are checked for alignment   * added functions to retrieve control structure size, alignment size, min and max block size, overhead of pool structure, and overhead of a single allocation   * minimal pool size is tlsf_block_size_min() + tlsf_pool_overhead()   * pool must be empty when it is removed, in order to allow o(1) removal  2011/10/20 - v2.0   * 64-bit support   * more compiler intrinsics for ffs/fls   * ffs/fls verification during tlsf creation in debug builds  2008/04/04 - v1.9   * add tlsf_heap_check, a heap integrity check   * support a predefined tlsf_assert macro   * fix realloc case where block should shrink; if adjacent block is in use, execution would go down the slow path  2007/02/08 - v1.8   * fix for unnecessary reallocation in tlsf_realloc  2007/02/03 - v1.7   * tlsf_heap_walk takes a callback   * tlsf_realloc now returns null on failure   * tlsf_memalign optimization for 4-byte alignment   * usage of size_t where appropriate  2006/11/21 - v1.6   * ffs/fls broken out into tlsfbits.h   * tlsf_overhead queries per-pool overhead  2006/11/07 - v1.5   * smart realloc implementation   * smart memalign implementation  2006/10/11 - v1.4   * add some ffs/fls implementations   * minor code footprint reduction  2006/09/14 - v1.3   * profiling indicates heavy use of blocks of size 1-128, so implement small block handling   * reduce pool overhead by about 1kb   * reduce minimum block size from 32 to 12 bytes   * realloc bug fix  2006/09/09 - v1.2   * add tlsf_block_size   * static assertion mechanism for invariants   * minor bugfixes   2006/09/01 - v1.1   * add tlsf_realloc   * add tlsf_walk_heap  2006/08/25 - v1.0   * first release ","tensorush/zig-mementohash":"Zig implementation of MementoHash consistent hashing algorithm. # zig-mementohash  [![ci][ci-shield]][ci-url] [![cd][cd-shield]][cd-url] [![dc][dc-shield]][dc-url] [![lc][lc-shield]][lc-url]  ## zig implementation of [mementohash consistent hashing algorithm](https://arxiv.org/abs/2306.09783).  ### :rocket: usage  - add `mementohash` dependency to `build.zig.zon`.  ```sh zig fetch --save https://github.com/tensorush/zig-mementohash/archive/<git_tag_or_commit_hash>.tar.gz ```  - use `mementohash` dependency in `build.zig`.  ```zig const mementohash_dep = b.dependency('mementohash', .{     .target = target,     .optimize = optimize, }); const mementohash_mod = mementohash_dep.module('mementohash'); <compile>.root_module.addimport('mementohash', mementohash_mod); ```  ### :bar_chart: benchmarks  - speed: the time the algorithm needs to find the node the given key belongs to.      ```sh     $ zig build bench -- -s     elapsed time: 151.215ms     ```  - balance: the ability of the algorithm to spread the keys evenly across the cluster nodes.      ```sh     $ zig build bench -- -b     load balance: 7.84     ```  - monotonicity: the ability of the algorithm to move the minimum amount of resources when the cluster scales.      ```sh     $ zig build bench -- -m     number of misplaced keys after removal: 0.00%     number of misplaced keys after restoring: 0.00%     ```  <!-- markdown links -->  [ci-shield]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-mementohash/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/zig-mementohash/blob/main/.github/workflows/ci.yaml [cd-shield]: https://img.shields.io/github/actions/workflow/status/tensorush/zig-mementohash/cd.yaml?branch=main&style=for-the-badge&logo=github&label=cd&labelcolor=black [cd-url]: https://github.com/tensorush/zig-mementohash/blob/main/.github/workflows/cd.yaml [dc-shield]: https://img.shields.io/badge/click-f6a516?style=for-the-badge&logo=zig&logocolor=f6a516&label=docs&labelcolor=black [dc-url]: https://tensorush.github.io/zig-mementohash [lc-shield]: https://img.shields.io/github/license/tensorush/zig-mementohash.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/zig-mementohash/blob/main/license ","travisstaloch/combinato":"Parser combinators in zig 404: not found","nektro/zig-fs-check":"Various utilities for testing certain conditions in the local files # zig-fs-check  various utilities for testing certain conditions in the local files  ## built with - zig master     - https://github.com/ziglang/zig - zigmod package manager     - https://github.com/nektro/zigmod  ## install ``` zigmod aq add 1/nektro/fs-check ```  ## usage - `pub fn doesfileexist(dir: std.fs.dir, fpath: []const u8) !bool` - `pub fn doesdirexist(dir: std.fs.dir, fpath: []const u8) !bool`  ## license mit ","nickelca/x-client":"X11 client library for Zig inspired by @marler8997's zigx at https://github.com/marler8997/zigx/ ","allyourcodebase/json-c":"json-c ported to the zig build system # `build.zig` for json-c  provides a package to be used by the zig package manager for c programs.  ## status  for now the hard-coded config assumes linux.  | refname | json-c version         | zig `0.12.x` | zig `0.13.x` | zig `0.14.0-dev` | |---------|------------------------|--------------|--------------|------------------| | `0.17`  | `json-c-0.17-20230812` | ✅           | ✅           | ✅               | | `0.18`  | `json-c-0.18-20240915` | ✅           | ✅           | ✅               |   ## use  add the dependency in your `build.zig.zon` by running the following command: ```bash zig fetch --save git+https://github.com/allyourcodebase/json-c#0.18 ```  then, in your `build.zig`: ```zig const jsonc = b.dependency('json-c', { .target = target, .optimize = optimize }); const libjsonc = jsonc.artifact('json-c'); // wherever needed: exe.linklibrary(libjsonc); ``` ","Orolia2s/json-c":"json-c ported to the zig build system # `build.zig` for json-c  provides a package to be used by the zig package manager for c programs.  ## use  add the dependency in your `build.zig.zon` by running the following command: ```bash zig fetch --save git+https://github.com/orolia2s/json-c#0.17 ```  then, in your `build.zig`: ```zig const jsonc = b.dependency('json-c', { .target = target, .optimize = optimize }); const libjsonc = jsonc.artifact('json-c'); // wherever needed: exe.linklibrary(libjsonc); ``` ","Durobot/export_ppm":"A couple of functions to export data as a PPM/PGM image file from your Zig code # export_ppm  just a couple of functions in zig that export image data, rgb/rgba/grayscale/grayscale+alpha (but alpha channel is ignored), 8 or 16 bits per channel, as ppm/pgm files. not enough code to be called a library.  ppm and pgm are very simple graphic file formats, but they are widespread enough for popular editors, like [gimp](https://www.gimp.org/), [krita](https://krita.org) or [adobe photoshop](https://www.adobe.com/creativecloud/file-types/image/raster/ppm-file.html) to be able to open them. meaning you can quickly dump whatever you want from your zig programs as a ppm/pgm file and open it in an editor.  see https://en.wikipedia.org/wiki/netpbm?useskin=vector, https://netpbm.sourceforge.net/doc/ppm.html.  check out the tests in  `export_ppm.zig` for examples of use.  **test_data_src** folder contains png images i used as test data, ignore them or use them however you want. i release them in public domain.  **export_ppm.zig** is licensed under [the mit license](https://en.wikipedia.org/w/index.php?title=mit_license&useskin=vector).  just drop `export_ppm.zig` into your project and add `const eppm = @import('export_ppm.zig');`, or use the zig package manager:  1. in your project's `build.zig.zon`, in `.dependencies`, add     ```zig    .export_ppm =    .{        .url = 'https://github.com/durobot/export_ppm/archive/<git commit hash, 40 hex digits>.tar.gz',        .hash = '<zig package hash, 68 hex digits>' // use arbitrary hash, get correct hash from the error     }    ```  2. in your project's `build.zig`, in `pub fn build`, before `b.installartifact(exe);`, add     ```zig    const eppm = b.dependency('export_ppm',    .{        .target = target,        .optimize = optimize,    });    exe.root_module.addimport('export_ppm', eppm.module('export_ppm'));    ```  3. add `const eppm = @import('export_ppm');`in your source file(s).  4. build your project with `zig build`, as you normally do.","bcrist/Zig-ROM-Compress":"Simple compression scheme for sparse ROM data 404: not found","jinzhongjia/zTroy":"a zig library # ztroy  a versatile libary.  the goal of this library is to create a general library of basic functional functions  > now, this library is developing!  ## feature  `.ini` parse  ## install  zig version: `0.12.0` or higher!  1. add to `build.zig.zon`  ```sh # it is recommended to replace the following branch with commit id zig fetch --save https://github.com/jinzhongjia/ztroy/archive/main.tar.gz # of course, you can also use git+https to fetch this package! ```  2. config `build.zig`  add this:  ```zig // to standardize development, maybe you should use `lazydependency()` instead of `dependency()` // more info to see: https://ziglang.org/download/0.12.0/release-notes.html#toc-lazy-dependencies const ztroy = b.dependency('ztroy', .{     .target = target,     .optimize = optimize, });  // add module exe.root_module.addimport('tory', ztroy.module('troy')); ```  ## document  waiting to be added!","softprops/uri-template":"a zig uri template (rfc6570) implementation <h1 align='center'>     zig uri template </h1>  <div align='center'>     zig library for <a href='https://datatracker.ietf.org/doc/html/rfc6570'>uri templating</a> </div>  ---  [![main](https://github.com/softprops/uri-template/actions/workflows/ci.yml/badge.svg)](https://github.com/softprops/uri-template/actions/workflows/ci.yml) ![license info](https://img.shields.io/github/license/softprops/uri-template) ![release](https://img.shields.io/github/v/release/softprops/uri-template) [![zig support](https://img.shields.io/badge/zig-0.13.0-black?logo=zig)](https://ziglang.org/documentation/0.13.0/)   ## examples  see examples directory  ## 📼 installing  create a new exec project with `zig init` then update `build.zig.zon` by running.  ```sh zig fetch --save https://github.com/softprops/uri-template/archive/refs/tags/v0.1.1.tar.gz ```  > you can also depend any tag with `https://github.com/softprops/uri-template/archive/refs/tags/v{version}.tar.gz` or current main with `https://github.com/softprops/uri-template/archive/refs/heads/main/main.tar.gz`. to resolve a hash omit it and let zig tell you the expected value.  add the following in your `build.zig` file  ```diff const std = @import('std');  pub fn build(b: *std.build) void {     const target = b.standardtargetoptions(.{});      const optimize = b.standardoptimizeoption(.{});     // 👇 de-reference dep from build.zig.zon +    const uritemplate = b.dependency('uritemplate', .{ +        .target = target, +        .optimize = optimize, +    }).module('uritemplate');     var exe = b.addexecutable(.{         .name = 'your-exe',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });     // 👇 add the module to executable +    exe.root_mode.addimport('uritemplate', uritemplate);      b.installartifact(exe); } ```  ## 🥹 for budding ziglings  does this look interesting but you're new to zig and feel left out? no problem, zig is young so most us of our new are as well. here are some resources to help get you up to speed on zig  - [the official zig website](https://ziglang.org/) - [zig's one-page language documentation](https://ziglang.org/documentation/0.13.0/) - [ziglearn](https://ziglearn.org/) - [ziglings exercises](https://github.com/ratfactor/ziglings)   ╲- softprops 2024 ","kALLEBALIK/poopie":"A benchmarking library. # performance optimizer observation platform inside executable ![bench im](/assets/bm.png?raw=true) ### usage ```zig     var poopie: poopie = .{         .config = .{             .store_result = true,             .compare_mode = .slowest,         },     };      var sampler = try poopie.createsampler(allocator, .{ .warmups = 100, .samples = 1000 });     defer sampler.deinit();      sampler.start();     while (sampler.sample()) : (sampler.store()) {         //         // some code to test         //     }     _ = try poopie.collect(allocator, &sampler, .{ .name = 'mybench' }); ``` you can overwrite poopie settings in each collection if you want ```zig _ = try poopie.collect(allocator, &sampler, .{ .name = 'mybench', .compare_mode = .fastest }); ``` or compare against a specific file ```zig _ = try poopie.collect(allocator, &sampler, .{     .name = 'mybench',     .compare_mode = .file,     .compare_file = 'mybench_10_100070223.1_1726867407409043.json', }); ```      stores benchmarks in .benchmark folder if ``store_result == true`` (false by default).  #### prev work this shitty library is just crappy code slapped on top of andrew's (and contributors) awesome [poop](https://github.com/andrewrk/poop) code. ","thechampagne/cnbt-zig":"Zig binding for cNBT an NBT file parser and manipulator library. # cnbt-zig  [![](https://img.shields.io/github/v/tag/thechampagne/cnbt-zig?label=version)](https://github.com/thechampagne/cnbt-zig/releases/latest) [![](https://img.shields.io/github/license/thechampagne/cnbt-zig)](https://github.com/thechampagne/cnbt-zig/blob/main/license)  zig binding for **cnbt** an nbt file parser and manipulator library.  ### references  - [cnbt](https://github.com/chmod222/cnbt)  ### license  this repo is released under the [apache license 2.0](https://github.com/thechampagne/cnbt-zig/blob/main/license). ","kassane/vswhom-zig":"Pure zig-FFI to Jon Blow's VS discovery script # vswhom-zig  pure zig-ffi to jon blow's vs discovery script, based on: [vswhom-sys.rs](https://github.com/nabijaczleweli/vswhom-sys.rs)  need: [zig 0.11 or higher](https://ziglang.org/download) ","dasimmet/zig-libxml2":"libxml2 built using Zig build system # libxml2 built with zig  this repository contains zig code for building libxml2 using zig. this allows other projects that use the zig build system to easily consume this library, cross-compile it, etc.  **why?** using the zig build system makes it much easier to cross-compile a library, even if you aren't using the zig programming language. see [maintain it with zig](https://kristoff.it/blog/maintain-it-with-zig/) for some more information.  this library currently hardcodes the libxml2 version (latest as of writing this but unlikely to remain that way for long). in the future, i'd like to allow users to pass in a custom libxml2 directory, and it'd be really cool to setup some sort of github action to check for new versions and try to pull it in. maybe one day.  ## usage  while we all eagerly await the [zig package manager](https://github.com/ziglang/zig/issues/943), the recommended way to use this is via git submodules or just embedding this into your repository.  ```zig const libxml2 = @import('path/to/libxml2.zig');  pub fn build(b: *std.build) !void {     // ...      const lib = try libxml2.create(b, target, mode, .{         // these are the minimal options to not depend on any other libraries.         // if you ave these libraries, just set these to true.         .iconv = false,         .lzma = false,         .zlib = false,     });      const exe = b.addexecutable('my-program', 'src/main.zig');     lib.link(exe); } ```  this package does not provide any zig-native apis to access the underlying c library. this is by design, the focus of this repository is only to enable building the underlying library using the zig build system. therefore, to use the library, import the headers and use the c api:  ```zig const c = @cimport({     @cinclude('libxml/xmlreader.h'); });  // ... do stuff with `c` ```  ### other dependencies  some features require other libraries. in the example above, we disabled those features. for example, if you set `.zlib = true`, then zlib must be available.  in this scenario, you can find and use a zlib build such as [zig-zlib](https://github.com/mattnite/zig-zlib) as normal. when that library is also added to the project, it adds its include paths and linking information to the build, so libxml2 can be built with zlib support. ","bcrist/Zig-Intel-Hex":"Intel Hex format library in Zig 404: not found","kassane/cobalt":"Coroutines for C++20 & asio (uses zig build for testing) 404: not found","4zv4l/zig_colored_logger":"Simple colored logger for the std.log.LogFn # zig_colored_logger simple colored logger for the std.log.logfn  ## usage  to add the project in your `build.zig.zon`:  `zig fetch --save git+https://github.com/4zv4l/zig_colored_logger`  then and this in `build.zig`:  ```rs const colored_logger = b.dependency('colored_logger', .{ .project_name = exe.name }); exe.root_module.addimport('colored_logger', colored_logger.module('colored_logger')); ```  > this library depends on chameleon https://github.com/tr1ckydev/chameleon  ## how it looks like <img width='625' alt='image' src='https://github.com/user-attachments/assets/b74ac911-fead-46f5-a4ee-1b2eb3890918'> ","dgv/s3db.zig":"Zig wrapper of https://github.com/jrhy/s3db # s3db.zig [![zig version](https://img.shields.io/badge/0.13.0-orange?style=flat&logo=zig&label=zig&color=%23eba742)](https://ziglang.org/download/) [![reference zig](https://img.shields.io/badge/deps%20-1-orange?color=%23eba742)](https://github.com/dgv/s3db.zig/blob/main/build.zig.zon) [![build](https://github.com/dgv/s3db.zig/actions/workflows/build.yml/badge.svg)](https://github.com/dgv/s3db.zig/actions/workflows/build.yml) [![license: mit](https://img.shields.io/badge/license-mit-yellow.svg)](https://opensource.org/licenses/mit)  zig wrapper lib/sample for sqlite/go extension that stores tables in an s3-compatible object store  ## usage ```zig var db = try s3db.init(.{     .mode = s3db.db.mode{ .memory = {} },     .open_flags = .{ .write = true }, }); defer db.deinit();  try db.exec('create virtual table user using s3db (columns='id integer primary key, age integer, name text')', .{}, .{}); ...  ``` ","dgv/clipboard":"multiplatform clipboard for zig # clipboard [![zig version](https://img.shields.io/badge/0.13.0-orange?style=flat&logo=zig&label=zig&color=%23eba742)](https://ziglang.org/download/) [![reference zig](https://img.shields.io/badge/zigdoc%20-pages-orange?color=%23eba742)](https://dgv.dev.br/clipboard/) [![reference zig](https://img.shields.io/badge/deps%20-0-orange?color=%23eba742)](https://github.com/dgv/clipboard/blob/main/build.zig.zon) [![0 dependencies!](https://0dependencies.dev/0dependencies.svg)](https://0dependencies.dev) [![build](https://github.com/dgv/clipboard/actions/workflows/build.yml/badge.svg)](https://github.com/dgv/clipboard/actions/workflows/build.yml) [![license: mit](https://img.shields.io/badge/license-mit-yellow.svg)](https://opensource.org/licenses/mit)  provide copying and pasting text (utf-8) to the clipboard for zig.  ### platform support - macos - linux, unix (requires 'xclip' or 'xsel' command to be installed) - windows  ### usage #### install ``` zig fetch --save https://github.com/dgv/clipboard/archive/refs/heads/main.zip ``` #### import (build.zig) ```zig ... exe.root_module.addimport('clipboard', b.dependency('clipboard', .{}).module('clipboard')); b.installartifact(exe); ```  #### sample ```zig const clipboard = @import('clipboard'); const std = @import('std');  pub fn main() !void {     try clipboard.write('zig ⚡');     std.debug.print('{s}╲n', .{clipboard.read() catch ''}); } ``` ","kassane/libvlcpp":"C++ bindings for libVLC # libvlcpp  [![join the chat at https://discord.gg/3h3k3jf](https://img.shields.io/discord/716939396464508958?label=discord)](https://discord.gg/3h3k3jf)  [libvlcpp](https://code.videolan.org/videolan/libvlcpp) is a header-only, c++ bindings for the libvlc crossplatform multimedia api. it is an official binding over the videolan libvlc library and can be used on many platforms.  ## documentation  since libvlcpp is a close wrapper over libvlc, your documentation needs will be best served by either checking the libvlcpp source code, or the [libvlc documentation](https://www.videolan.org/developers/vlc/doc/doxygen/html/group__libvlc.html).  ## issues  libvlcpp tickets are located on our [gitlab](https://code.videolan.org/videolan/libvlcpp/-/issues).  ## contribution  contribution are always welcome!  feel free to open a merge request on our [gitlab](https://code.videolan.org/videolan/libvlcpp/-/merge_requests).  ## examples  for usage examples, head over to the examples folder where you will find several code samples, such as [helloworld](examples/helloworld/main.cpp) and more.  ## used by  libvlcpp is being used and tested extensively in various projects, such as the videolan [medialibrary](https://code.videolan.org/videolan/medialibrary), the previous [vlc for uwp](https://code.videolan.org/videolan/vlc-winrt) app and more.","kassane/Catch2":"A modern, C++-native, test framework for unit-tests, TDD and BDD - using C++14, C++17 and later (C++11 support is in v2.x branch, and C++03 on the Catch1.x branch) - uses zig build-system <a id='top'></a> ![catch2 logo](data/artwork/catch2-logo-small-with-background.png)  [![github releases](https://img.shields.io/github/release/catchorg/catch2.svg)](https://github.com/catchorg/catch2/releases) [![linux build status](https://github.com/catchorg/catch2/actions/workflows/linux-simple-builds.yml/badge.svg)](https://github.com/catchorg/catch2/actions/workflows/linux-simple-builds.yml) [![linux build status](https://github.com/catchorg/catch2/actions/workflows/linux-other-builds.yml/badge.svg)](https://github.com/catchorg/catch2/actions/workflows/linux-other-builds.yml) [![macos build status](https://github.com/catchorg/catch2/actions/workflows/mac-builds.yml/badge.svg)](https://github.com/catchorg/catch2/actions/workflows/mac-builds.yml) [![build status](https://ci.appveyor.com/api/projects/status/github/catchorg/catch2?svg=true&branch=devel)](https://ci.appveyor.com/project/catchorg/catch2) [![code coverage](https://codecov.io/gh/catchorg/catch2/branch/devel/graph/badge.svg)](https://codecov.io/gh/catchorg/catch2) [![try online](https://img.shields.io/badge/try-online-blue.svg)](https://godbolt.org/z/edoy15q9g) [![join the chat in discord: https://discord.gg/4cws9zd](https://img.shields.io/badge/discord-chat!-brightgreen.svg)](https://discord.gg/4cws9zd)   ## what is catch2?  catch2 is mainly a unit testing framework for c++, but it also provides basic micro-benchmarking features, and simple bdd macros.  catch2's main advantage is that using it is both simple and natural. test names do not have to be valid identifiers, assertions look like normal c++ boolean expressions, and sections provide a nice and local way to share set-up and tear-down code in tests.  **example unit test** ```cpp #include <catch2/catch_test_macros.hpp>  #include <cstdint>  uint32_t factorial( uint32_t number ) {     return number <= 1 ? number : factorial(number-1) * number; }  test_case( 'factorials are computed', '[factorial]' ) {     require( factorial( 1) == 1 );     require( factorial( 2) == 2 );     require( factorial( 3) == 6 );     require( factorial(10) == 3'628'800 ); } ```  **example microbenchmark** ```cpp #include <catch2/catch_test_macros.hpp> #include <catch2/benchmark/catch_benchmark.hpp>  #include <cstdint>  uint64_t fibonacci(uint64_t number) {     return number < 2 ? number : fibonacci(number - 1) + fibonacci(number - 2); }  test_case('benchmark fibonacci', '[!benchmark]') {     require(fibonacci(5) == 5);      require(fibonacci(20) == 6'765);     benchmark('fibonacci 20') {         return fibonacci(20);     };      require(fibonacci(25) == 75'025);     benchmark('fibonacci 25') {         return fibonacci(25);     }; } ```  _note that benchmarks are not run by default, so you need to run it explicitly with the `[!benchmark]` tag._   ## catch2 v3 has been released!  you are on the `devel` branch, where the v3 version is being developed. v3 brings a bunch of significant changes, the big one being that catch2 is no longer a single-header library. catch2 now behaves as a normal library, with multiple headers and separately compiled implementation.  the documentation is slowly being updated to take these changes into account, but this work is currently still ongoing.  for migrating from the v2 releases to v3, you should look at [our documentation](docs/migrate-v2-to-v3.md#top). it provides a simple guidelines on getting started, and collects most common migration problems.  for the previous major version of catch2 [look into the `v2.x` branch here on github](https://github.com/catchorg/catch2/tree/v2.x).   ## how to use it this documentation comprises these three parts:  * [why do we need yet another c++ test framework?](docs/why-catch.md#top) * [tutorial](docs/tutorial.md#top) - getting started * [reference section](docs/readme.md#top) - all the details   ## more * issues and bugs can be raised on the [issue tracker on github](https://github.com/catchorg/catch2/issues) * for discussion or questions please use [our discord](https://discord.gg/4cws9zd) * see who else is using catch2 in [open source software](docs/opensource-users.md#top) or [commercially](docs/commercial-users.md#top). ","ikavalio/zig-netip":"A simple IP address library for zig # zig-netip  this is mostly an educational project to implement a library similar to go's [netip](https://pkg.go.dev/net/netip)  using zig idioms and comptime features.   the library targets the latest stable release which is currently `0.13`.  # definitions  * `ip4addr`, `ip6addr`, `ip6addrscoped` (and an `addr` union) address types that're small value types. they can be converted to `std.net.ip4address` or  `std.net.ip6address`. all types have a bunch of comptime  friendly methods, e.g. `parse`, `get`, `toarray`, and  flexible-ish `format` specifiers. * `ip4prefix`, `ip6prefix` (and a `prefix` union) address types that're built on top of  `ip4addr` and `ip6addr` abstractions.  # examples  check [the netip tests](../main/src/netip.zig) for more.  ```zig test 'addr example' {     // ipv4 create     const v4_addr1 = comptime try ip4addr.parse('192.0.2.1');     const v4_addr2 = try addr.parse('192.0.2.1');     const v4_addr3 = ip4addr.fromarray(u8, [_]u8{ 192, 0, 2, 2 });     const v4_addr4 = ip4addr.fromarray(u16, [_]u16{ 0xc000, 0x0202 });     const v4_addr5 = addr.init4(ip4addr.init(0xc0000203));     const v4_addr6 = ip4addr.fromnetaddress(try std.net.ip4address.parse('192.0.2.3', 1));      // ipv6 create     const v6_addr1 = comptime try ip6addr.parse('2001:db8::1');     const v6_addr2 = try addr.parse('2001:db8::1');     const v6_addr3 = ip6addr.fromarray(u8, [_]u8{ 0x20, 0x1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2 });     const v6_addr4 = ip6addr.fromarray(u16, [_]u16{ 0x2001, 0xdb8, 0, 0, 0, 0, 0, 0x2 });     const v6_addr5 = addr.init6(ip6addr.init(0x2001_0db8_0000_0000_0000_0000_0000_0003));     const v6_addr6 = ip6addr.fromnetaddress(try std.net.ip6address.parse('2001:db8::3', 1));      // ipv6 scoped     const v6_scoped1 = comptime try ip6addrscoped.parse('2001:db8::1%eth2');     const v6_scoped2 = try addr.parse('2001:db8::2%4');      // handle parsing errors     try testing.expect(ip4addr.parse('-=_=-') == ip4addr.parseerror.invalidcharacter);     try testing.expect(addr.parse('0.-=_=-') == addr.parseerror.invalidcharacter);     try testing.expect(ip6addr.parse('-=_=-') == ip6addr.parseerror.invalidcharacter);     try testing.expect(addr.parse('::-=_=-') == addr.parseerror.invalidcharacter);      // copy     const v4_addr7 = v4_addr5;     const v6_addr8 = v6_addr3;      _ = .{v4_addr7, v4_addr4, v4_addr6, v6_scoped1, v6_scoped2, v6_addr4, v6_addr6};      // compare via values     try testing.expectequal(math.order.eq, order(v4_addr1, v4_addr2.v4));     try testing.expectequal(math.order.lt, order(v6_addr1, v6_addr8));     try testing.expectequal(math.order.gt, order(v6_addr8, v6_addr1));     try testing.expectequal(math.order.gt, order(v6_addr2, v4_addr2)); // cross af comparison      // print     try testing.expectfmt('192.0.2.1', '{}', .{v4_addr1});     try testing.expectfmt('c0.00.02.02', '{x}', .{v4_addr3});     try testing.expectfmt('11000000.0.10.11', '{b}', .{v4_addr5});     try testing.expectfmt('2001:db8::1', '{}', .{v6_addr1});     try testing.expectfmt('2001:db8:0:0:0:0:0:2', '{xe}', .{v6_addr3});     try testing.expectfmt('2001:0db8::0003', '{x}', .{v6_addr5});     try testing.expectfmt('2001:0db8:0000:0000:0000:0000:0000:0001', '{xe}', .{v6_addr2}); }  test 'prefix example' {     // create a ipv6 prefix     const v6_prefix1 = try ip6prefix.init(try ip6addr.parse('2001:db8:85a3::1'), 48);     const v6_prefix2 = try prefix.parse('2001:db8:85a3::/48');      // create a prefix     const v4_prefix1 = try ip4prefix.init(try ip4addr.parse('192.0.2.1'), 24);     const v4_prefix2 = try prefix.parse('192.0.2.1/24');      // compare mask bits     try testing.expectequal(v6_prefix1.maskbits(), v6_prefix2.v6.maskbits());     try testing.expectequal(v4_prefix1.maskbits(), v4_prefix2.v4.maskbits());      // handle parsing errors     try testing.expecterror(prefix.parseerror.overflow, prefix.parse('2001:db8::/256'));     try testing.expecterror(prefix.parseerror.overflow, prefix.parse('1.1.1.1/33'));      // print     try testing.expectfmt('2001:db8:85a3::1/48', '{}', .{v6_prefix1});     try testing.expectfmt('2001:0db8:85a3::0001/48', '{x}', .{v6_prefix1});     try testing.expectfmt('2001:db8:85a3::-2001:db8:85a3:ffff:ffff:ffff:ffff:ffff', '{r}', .{v6_prefix1});     try testing.expectfmt('192.0.2.0/24', '{}', .{v4_prefix1.canonical()});     try testing.expectfmt('192.0.2.0-192.0.2.255', '{r}', .{v4_prefix1});      // contains address     try testing.expect(v6_prefix2.containsaddr(try addr.parse('2001:db8:85a3:cafe::efac')));     try testing.expect(v4_prefix2.containsaddr(try addr.parse('192.0.2.42')));      // inclusion and overlap test     try testing.expectequal(prefixinclusion.sub, v6_prefix1.testinclusion(try ip6prefix.parse('2001:db8::/32')));     try testing.expect(v6_prefix2.overlaps(try prefix.parse('2001:db8::/32')));     try testing.expectequal(prefixinclusion.sub, v4_prefix1.testinclusion(try ip4prefix.parse('192.0.2.0/16')));     try testing.expect(v4_prefix2.overlaps(try prefix.parse('192.0.2.0/16'))); } ``` ","4zv4l/zbencode":"zig bencode library # zbencode zig bencode library  # example of usage  ```zig const std = @import('std'); const bencode = @import('bencode'); const fs = std.fs; const print = std.debug.print; const sizefmt = std.fmt.fmtintsizebin; const hexfmt = std.fmt.fmtslicehexlower;  pub fn main() !void {     // setup + args     const allocator = std.heap.page_allocator;     const args = try std.process.argsalloc(allocator);     defer std.process.argsfree(allocator, args);     if (args.len != 2) {         print('usage: {s} [file.torrent]╲n', .{args[0]});         return;     }      // decoding     const data = try fs.cwd().readfilealloc(allocator, args[1], std.math.maxint(usize));     var bdata = try bencode.parse(allocator, data);     defer bdata.deinit();     allocator.free(data);      // show info from torrent file     const root = bdata.root.dictionnary;     const infos = root.get('info').?.dictionnary;      print('name    : {}╲n', .{infos.get('name').?});     print('length  : {}╲n', .{sizefmt(@intcast(infos.get('length').?.integer))});     print('tracker : {}╲n', .{root.get('announce').?});     print('creator : {}╲n', .{root.get('created by').?});     print('created : {}╲n', .{root.get('creation date').?}); } ```  ``` $ btest debian-12.6.0-amd64-netinst.iso.torrent name    : debian-12.6.0-amd64-netinst.iso length  : 631mib tracker : http://bttracker.debian.org:6969/announce creator : mktorrent 1.1 created : 1719662085 ``` ","kassane/intrusive":"Boost.org intrusive module (uses zig build) boost.intrusive ==========  boost.intrusive, part of collection of the [boost c++ libraries](http://github.com/boostorg), is a library presenting intrusive containers to the world of c++. intrusive containers are special containers that offer better performance and exception safety guarantees than non-intrusive containers (like stl containers). the performance benefits of intrusive containers makes them ideal as a building block to efficiently construct complex data structures like multi-index containers or to design high performance code like memory allocation algorithms.  while intrusive containers were and are widely used in c, they became more and more forgotten in c++ due to the presence of the standard containers which don't support intrusive techniques.boost.intrusive wants to push intrusive containers usage encapsulating the implementation in stl-like interfaces. hence anyone familiar with standard containers can easily use boost.intrusive.  ### license  distributed under the [boost software license, version 1.0](http://www.boost.org/license_1_0.txt).  ### properties  * c++03 * header-only  ### build status  branch          | travis | appveyor | coverity scan | codecov.io | deps | docs | tests | :-------------: | ------ | -------- | ------------- | ---------- | ---- | ---- | ----- | [`master`](https://github.com/boostorg/intrusive/tree/master) | [![build status](https://travis-ci.org/boostorg/intrusive.svg?branch=master)](https://travis-ci.org/boostorg/intrusive) | [![build status](https://ci.appveyor.com/api/projects/status/9ckrveolxsonxfnb/branch/master?svg=true)](https://ci.appveyor.com/project/jeking3/intrusive-0k1xg/branch/master) | [![coverity scan build status](https://scan.coverity.com/projects/16048/badge.svg)](https://scan.coverity.com/projects/boostorg-intrusive) | [![codecov](https://codecov.io/gh/boostorg/intrusive/branch/master/graph/badge.svg)](https://codecov.io/gh/boostorg/intrusive/branch/master)| [![deps](https://img.shields.io/badge/deps-master-brightgreen.svg)](https://pdimov.github.io/boostdep-report/master/intrusive.html) | [![documentation](https://img.shields.io/badge/docs-master-brightgreen.svg)](http://www.boost.org/doc/libs/master/doc/html/intrusive.html) | [![enter the matrix](https://img.shields.io/badge/matrix-master-brightgreen.svg)](http://www.boost.org/development/tests/master/developer/intrusive.html) [`develop`](https://github.com/boostorg/intrusive/tree/develop) | [![build status](https://travis-ci.org/boostorg/intrusive.svg?branch=develop)](https://travis-ci.org/boostorg/intrusive) | [![build status](https://ci.appveyor.com/api/projects/status/9ckrveolxsonxfnb/branch/develop?svg=true)](https://ci.appveyor.com/project/jeking3/intrusive-0k1xg/branch/develop) | [![coverity scan build status](https://scan.coverity.com/projects/16048/badge.svg)](https://scan.coverity.com/projects/boostorg-intrusive) | [![codecov](https://codecov.io/gh/boostorg/intrusive/branch/develop/graph/badge.svg)](https://codecov.io/gh/boostorg/intrusive/branch/develop) | [![deps](https://img.shields.io/badge/deps-develop-brightgreen.svg)](https://pdimov.github.io/boostdep-report/develop/intrusive.html) | [![documentation](https://img.shields.io/badge/docs-develop-brightgreen.svg)](http://www.boost.org/doc/libs/develop/doc/html/intrusive.html) | [![enter the matrix](https://img.shields.io/badge/matrix-develop-brightgreen.svg)](http://www.boost.org/development/tests/develop/developer/intrusive.html)  ### directories  | name        | purpose                        | | ----------- | ------------------------------ | | `doc`       | documentation                  | | `example`   | examples                       | | `include`   | headers                        | | `proj`      | ide projects                   | | `test`      | unit tests                     |  ### more information  * [ask questions](http://stackoverflow.com/questions/ask?tags=c%2b%2b,boost,boost-intrusive) * [report bugs](https://github.com/boostorg/intrusive/issues): be sure to mention boost version, platform and compiler you're using. a small compilable code sample to reproduce the problem is always good as well. * submit your patches as pull requests against **develop** branch. note that by submitting patches you agree to license your modifications under the [boost software license, version 1.0](http://www.boost.org/license_1_0.txt). * discussions about the library are held on the [boost developers mailing list](http://www.boost.org/community/groups.html#main). be sure to read the [discussion policy](http://www.boost.org/community/policy.html) before posting and add the `[intrusive]` tag at the beginning of the subject line.  ","kassane/zig-scudo":"Scudo Allocator for Zig # scudo-zig  scudo allocator for zig  ## requires  - [zig](https://ziglang.org/download) v0.13.0 or master   ## how to use  ```bash # create a project $ mkdir project_name $ cd project_name $ zig init  # get zig-scudo (add on zon file - overwrited) zig fetch --save=scudo git+https://github.com/kassane/zig-scudo ```  in `build.zig`, add: ```zig // pkg name (same in zon file) const scudo_dep = b.dependency('scudo',.{.target = target, .optimize = optimize }); const scudo_module = scudo_dep.module('scudoallocator'); // get lib + zig bindings  // my project (executable) exe.root_module.addimport('scudoallocator', scudo_module); ```  ## references  - [llvm-doc: scudo allocator](https://llvm.org/docs/scudohardenedallocator.html) - [scudo hardened allocator — unofficial internals](https://www.l3harris.com/newsroom/editorial/2023/10/scudo-hardened-allocator-unofficial-internals-documentation) authored by [rodrigo rubira](https://github.com/rrbranco) - [high level overview of scudo](https://expertmiami.blogspot.com/2019/05/high-level-overview-of-scudo.html) by kostya - [what is the scudo hardened allocator?](https://expertmiami.blogspot.com/2019/05/what-is-scudo-hardened-allocator_10.html) by kostya - [google/rust-scudo](https://github.com/google/rust-scudo)","kassane/unordered":"Boost.org unordered module (uses zig build) # boost.unordered  [![branch](https://img.shields.io/badge/branch-master-brightgreen.svg)](https://github.com/boostorg/unordered/tree/master) [![ci](https://github.com/boostorg/unordered/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/boostorg/unordered/actions/workflows/ci.yml) [![drone status](https://img.shields.io/drone/build/boostorg/unordered/master?server=https%3a%2f%2fdrone.cpp.al&logo=drone&logocolor=%23cccccc&label=ci)](https://drone.cpp.al/boostorg/unordered) [![build status](https://img.shields.io/appveyor/build/cppalliance/unordered/master?logo=appveyor&label=ci)](https://ci.appveyor.com/project/cppalliance/unordered/branch/master)  [![codecov](https://codecov.io/gh/boostorg/unordered/branch/master/graph/badge.svg)](https://codecov.io/gh/boostorg/unordered/branch/master)  [![deps](https://img.shields.io/badge/deps-master-brightgreen.svg)](https://pdimov.github.io/boostdep-report/master/unordered.html)  [![documentation](https://img.shields.io/badge/docs-master-brightgreen.svg)](https://www.boost.org/doc/libs/master/libs/unordered/doc/html/unordered.html)  [![enter the matrix](https://img.shields.io/badge/matrix-master-brightgreen.svg)](http://www.boost.org/development/tests/master/developer/unordered.html)<br/> [![branch](https://img.shields.io/badge/branch-develop-brightgreen.svg)](https://github.com/boostorg/unordered/tree/develop) [![ci](https://github.com/boostorg/unordered/actions/workflows/ci.yml/badge.svg?branch=develop)](https://github.com/boostorg/unordered/actions/workflows/ci.yml) [![drone status](https://img.shields.io/drone/build/boostorg/unordered/develop?server=https%3a%2f%2fdrone.cpp.al&logo=drone&logocolor=%23cccccc&label=ci)](https://drone.cpp.al/boostorg/unordered) [![build status](https://img.shields.io/appveyor/build/cppalliance/unordered/master?logo=appveyor&label=ci)](https://ci.appveyor.com/project/cppalliance/unordered/branch/develop) [![codecov](https://codecov.io/gh/boostorg/unordered/branch/develop/graph/badge.svg)](https://codecov.io/gh/boostorg/unordered/branch/develop) [![deps](https://img.shields.io/badge/deps-develop-brightgreen.svg)](https://pdimov.github.io/boostdep-report/develop/unordered.html) [![documentation](https://img.shields.io/badge/docs-develop-brightgreen.svg)](https://www.boost.org/doc/libs/develop/libs/unordered/doc/html/unordered.html) [![enter the matrix](https://img.shields.io/badge/matrix-develop-brightgreen.svg)](http://www.boost.org/development/tests/develop/developer/unordered.html)<br/> [![bsl 1.0](https://img.shields.io/badge/license-bsl_1.0-blue.svg)](https://www.boost.org/users/license.html) <img alt='c++11 required' src='https://img.shields.io/badge/standard-c%2b%2b11-blue.svg'> <img alt='header-only library' src='https://img.shields.io/badge/build-header--only-blue.svg'>  boost.unordered offers a catalog of hash containers with different standards compliance levels, performances and intented usage scenarios:  **`boost::unordered_set` `boost::unordered_map` `boost::unordered_multiset` `boost::unordered_multimap`**  <ul>fully conformant implementations of <code>std::unordered_[multi](set|map)</code>, but faster and up to the latest revisions of the standard even if you're working in an older version of c++ (heterogeneous lookup, <code>try_emplace</code>, <code>contains</code>, etc.)</ul>  **`boost::unordered_flat_set` `boost::unordered_flat_map`**  <ul>the fastest of the lot. based on open addressing, these containers slightly deviate from the standard in exchange for top performance.</ul>  **`boost::unordered_node_set` `boost::unordered_node_map`**  <ul>variations of <code>boost::unordered_flat_(set|map)</code> providing pointer stability.</ul>  **`boost::concurrent_flat_set` `boost::concurrent_flat_map`**  <ul>high performance for multithreaded scenarios. introducing a new non-standard, iterator-free api.</ul>  ## learn about boost.unordered  * [online documentation](https://boost.org/libs/unordered) * [some benchmarks](https://github.com/boostorg/boost_unordered_benchmarks) * technical articles on boost.unordered internal design:   * [advancing the state of the art for `std::unordered_map` implementations](https://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html)   * [inside `boost::unordered_flat_map`](https://bannalia.blogspot.com/2022/11/inside-boostunorderedflatmap.html)   * [inside `boost::concurrent_flat_map`](https://bannalia.blogspot.com/2023/07/inside-boostconcurrentflatmap.html)   * [bulk visitation in `boost::concurrent_flat_map`](https://bannalia.blogspot.com/2023/10/bulk-visitation-in-boostconcurrentflatm.html)  ## get the library  boost.unordered can be installed in a number of ways:  * [download boost](https://www.boost.org/users/download/) and you're ready to go (this is a header-only library requiring no building). * using conan 2: in case you don't have it yet, add an entry for boost in your `conanfile.txt` (the example requires at least boost 1.83): ``` [requires] boost/[>=1.83.0] ``` <ul>if you're not using any compiled boost library, the following will skip building altogether:</ul>  ``` [options] boost:header_only=true ``` * using vcpkg: execute the command ``` vcpkg install boost-unordered ``` * using cmake: [boost cmake support infrastructure](https://github.com/boostorg/cmake) allows you to use cmake directly to download, build and consume all of boost or some specific libraries.  ## support  * join the **#boost-unordered** discussion group at [cpplang.slack.com](https://cpplang.slack.com/) ([ask for an invite](https://cppalliance.org/slack/) if you’re not a member of this workspace yet) * ask in the [boost users mailing list](https://lists.boost.org/mailman/listinfo.cgi/boost-users) (add the `[unordered]` tag at the beginning of the subject line) * [file an issue](https://github.com/boostorg/unordered/issues)  ## contribute  * [pull requests](https://github.com/boostorg/unordered/pulls) against **develop** branch are most welcome. note that by submitting patches you agree to license your modifications under the [boost software license, version 1.0](http://www.boost.org/license_1_0.txt). ","kassane/context":"`boost.context` library using zig build boost.context =============  boost.context is a foundational library that provides a sort of cooperative multitasking on a single thread. by providing an abstraction of the current execution state in the current thread, including the stack (with  local variables) and stack pointer, all registers and cpu flags, and the instruction pointer, a execution_context  instance represents a specific point in the application's execution path. this is useful for building  higher-level abstractions, like coroutines, cooperative threads (userland threads) or an equivalent to  c# keyword yield in c++.  a fiber provides the means to suspend the current execution path and to transfer execution control,  thereby permitting another fiber to run on the current thread. this state full transfer mechanism  enables a fiber to suspend execution from within nested functions and, later, to resume from where it  was suspended. while the execution path represented by a fiber only runs on a single thread, it can be  migrated to another thread at any given time.  a context switch between threads requires system calls (involving the os kernel), which can cost more than  thousand cpu cycles on x86 cpus. by contrast, transferring control among fibers requires only fewer than  hundred cpu cycles because it does not involve system calls as it is done within a single thread.  boost.context requires c++11!  ","RetroDev256/jitter_rng":"This repository has no description. # say hello to easy-peasy true random!  this library exposes a std.random interface and jitter() function - both will use cpu timing jitter to generate random numbers.  we make the following assumptions: - your system has a cpu that supports high resolution timers - your system runs other processes at the same time as this one - your system has a non-deterministic cpu scheduler - your cpu is not some esoteric architecture  while all of these assumptions must be held to ensure current theory, in many cases not all of them are necessary to gain true randomness.  these assumptions mean that the cpu's internal timer is not tied to the current execution of the program. external variables such as cpu heat, the cpu frequency, the cpu scheduler, and even cache misses will further add entropy to the timings of when instructions occur.  we harvest this entropy simply by sampling the high resolution cpu timer.  ``` ramen:[retrodev]:~/repos/zig/jitter_rng$ zig build run -doptimize=releasefast | rng_test stdin rng_test using practrand version 0.95 rng = rng_stdin, seed = unknown test set = core, folding = standard(unknown format)  rng=rng_stdin, seed=unknown length= 2 megabytes (2^21 bytes), time= 2.1 seconds   no anomalies in 111 test result(s)  rng=rng_stdin, seed=unknown length= 4 megabytes (2^22 bytes), time= 6.2 seconds   no anomalies in 127 test result(s)  rng=rng_stdin, seed=unknown length= 8 megabytes (2^23 bytes), time= 12.5 seconds   no anomalies in 139 test result(s)  rng=rng_stdin, seed=unknown length= 16 megabytes (2^24 bytes), time= 24.4 seconds   no anomalies in 153 test result(s)  rng=rng_stdin, seed=unknown length= 32 megabytes (2^25 bytes), time= 43.6 seconds   no anomalies in 169 test result(s)  rng=rng_stdin, seed=unknown length= 64 megabytes (2^26 bytes), time= 82.5 seconds   no anomalies in 182 test result(s)  rng=rng_stdin, seed=unknown length= 128 megabytes (2^27 bytes), time= 160 seconds   no anomalies in 199 test result(s)  rng=rng_stdin, seed=unknown length= 256 megabytes (2^28 bytes), time= 313 seconds   no anomalies in 217 test result(s)  rng=rng_stdin, seed=unknown length= 512 megabytes (2^29 bytes), time= 547 seconds   no anomalies in 232 test result(s)  ... and so on ... ```  ### disclaimer:  please use battle-tested software, i provide no guaruntees whatsoever. in the case that your computer doesn't support this high resolution timer, the rng may simply return 0 at all times. beware. ","dasimmet/zig-meta-allyourcode":"This repository has no description. # meta-allyourcode  lazy dependencies for zig build. this repository is for writing `build.zig` configurations for other c/c++ projects  ## cmake  using the zig build system, this repository bootstraps `cmake` `3.30.1` without any system cmake or the usual shellscript method. it takes a while and is only tested on x64 linux, but can be used to build your c/c++ dependency libraries.  the package also has a custom `cmakestep` that will configure and build and install a cmake project, and providdes a `.install(b, name)` function to get the artifacts: ``` zig fetch --save https://github.com/dasimmet/zig-meta-allyourcode/archive/refs/heads/master.tar.gz ``` build.zig (from [example](./example/build.zig)): ``` pub fn build() void {   const meta_import = b.lazyimport(@this(), 'meta_allyourcode');    if (meta_import) |meta_allyourcode| {}   const cmakestep = meta_allyourcode.addcmakestep(b, .{     .target = b.standardtargetoptions(.{}),     .name = 'cmake',     .source_dir = b.path(''),       .defines = &.{           .{ 'cmake_build_type', if (optimize == .debug) 'debug' else 'release' },       },   });   cmakestep.addcmakedefine();   const install_step = cmakestep.install(b, '');   b.getinstallstep().dependon(&install_step.step); } ```  ## integrated builds  - cmake (including custom build step?)   - ✅ stage1 linux   - ✅ running bootstrap `cmake` to reconfigure itself with `cc=zig cc`   - ✅ use zig built `make` to rebuild `cmake`   - 🏃‍♂️ stage1 windows   - 🏃‍♂️ stage1 macos   - 🏃‍♂️test building other cmake projects   - try to link cmake fully static   - test other architectures - libgit2 ✅   - build for wasm32-wasi - wabt   - ✅ compile libwabt and wasm2wat   - ✅ add build.zig include code  ","bcrist/shittip":"Another shitty HTTP server # shittip ### a shitty http server  ","tensorush/loog":"Server log analyzer. # loog  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## [server log](https://en.wikipedia.org/wiki/common_log_format) analyzer.  ### :rocket: usage  ```sh git clone https://github.com/tensorush/loog.git cd loog/ zig build exe -- -h ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/loog/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/loog/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/tensorush/loog.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/loog/blob/main/license ","tensorush/sandblast":"Rust codebase sandblasting tool. # sandblast  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## rust codebase sandblasting tool.  ### :rocket: usage  ```sh git clone https://github.com/tensorush/sandblast.git cd sandblast/ zig build exe -- -h ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/sandblast/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black [ci-url]: https://github.com/tensorush/sandblast/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/tensorush/sandblast.svg?style=for-the-badge&labelcolor=black [lc-url]: https://github.com/tensorush/sandblast/blob/main/license ","tensorush/dobby":"[WIP] ELF debugger. # dobby  [![ci][ci-shd]][ci-url] [![lc][lc-shd]][lc-url]  ## elf debugger.  ### :rocket: usage  ```sh git clone https://github.com/tensorush/dobby.git cd dobby/ zig build exe -- -h ```  <!-- markdown links -->  [ci-shd]: https://img.shields.io/github/actions/workflow/status/tensorush/dobby/ci.yaml?branch=main&style=for-the-badge&logo=github&label=ci&labelcolor=black&killcache=true [ci-url]: https://github.com/tensorush/dobby/blob/main/.github/workflows/ci.yaml [lc-shd]: https://img.shields.io/github/license/tensorush/dobby.svg?style=for-the-badge&labelcolor=black&killcache=true [lc-url]: https://github.com/tensorush/dobby/blob/main/license ","quentin-k/zig-hc256":"Hc256 Cipher in zig # zig hc256  an implementation of the hc-256 cipher in zig.  ## license  apache 2.0  ## usage  1. initialize the cipher with a key and iv 2. use the `apply_stream` method on a slice of `u8`s to encrypt/decrypt the data  the test vectors file (`/tests/test-vectors.zig`) shows examples on how to use the library.","nektro/zig-ci-detect":"Detect what kind of CI environment the program is running in # zig-ci-detect  detect what kind of ci environment the program is in  adapted from https://github.com/npm/ci-detect  ## usage > `pub fn detect() ?ci`  the main function of this package. if it detects that the program is running in one of the registered environments, it will return an enum value of the type `ci` with the tag in accordance with the system.  > `ci`  an enum of all the detectable ci/cd systems.  ## license mit ","kassane/libsigcplusplus":"libsigc++ implements a typesafe callback system for standard C++. (uses zig build) # libsigc++ typesafe callback framework for c++  # introduction  libsigc++ (a.k.a. libsigcplusplus) implements a typesafe callback system for standard c++. it allows you to define signals and to connect those signals to any callback function, either global or a member function, regardless of whether it is static or virtual.  libsigc++ is used by gtkmm to wrap the gtk signal system. it does not depend on gtk or gtkmm.  sigc++-2.0 and sigc++-3.0 are different parallel-installable abis. this file describes sigc++-3.0.  ## license  distribution of library and components is under the lgpl as listed in the file copying. examples and tests are public domain.  ## compatibility  compatible compilers must support c++17, such as the decltype(auto) specifier (from c++14) and std::invoke().  # general information  web site  - https://libsigcplusplus.github.io/libsigcplusplus/  download location  - https://download.gnome.org/sources/libsigc++/  - https://github.com/libsigcplusplus/libsigcplusplus/releases/  reference documentation  - https://libsigcplusplus.github.io/libsigcplusplus/reference/html/  tarballs contain reference documentation. in tarballs generated with meson, see the untracked/docs/docs/reference/html directory.  discussion on gnome's discourse forum  - https://discourse.gnome.org/tag/cplusplus  - https://discourse.gnome.org/c/platform  git repository  - https://github.com/libsigcplusplus/libsigcplusplus  bugs can be reported to  - https://github.com/libsigcplusplus/libsigcplusplus/issues  patches can be submitted to  - https://github.com/libsigcplusplus/libsigcplusplus/pulls  # building  whenever possible, you should use the official binary packages approved by the supplier of your operating system, such as your linux distribution. for instance, ubuntu linux, debian linux and fedora linux have official libsigc++ packages.  ## building from a release tarball  building from a release tarball is easier than building from git.  it's easiest to build with meson, if the tarball was made with meson, and to build with autotools, if the tarball was made with autotools. then you don't have to use maintainer-mode.  how do you know how the tarball was made? if it was made with meson, it contains files in untracked/build_scripts/, untracked/docs/ and possibly other subdirectories of untracked/.  ### building from a tarball with meson  don't call the builddir 'build'. there is a directory called 'build' with files used by autotools.  for instance: ```sh # if the tarball was made with autotools, and you want to rebuild the reference # documentation, you must enable maintainer-mode: $ meson setup --prefix=/some_directory --libdir=lib -dmaintainer-mode=true your_builddir .  # if the tarball was made with meson, or you don't want to rebuild the docs: $ meson setup --prefix=/some_directory --libdir=lib your_builddir .  # then: $ cd your_builddir $ ninja $ ninja install # you can run the tests like so: $ ninja test ```  ### building from a tarball with autotools  for instance: ```sh # if the tarball was made with autotools: $ ./configure --prefix=/some_directory  # if the tarball was made with meson, you must enable maintainer-mode: $ ./autogen.sh --prefix=/some_directory  # then: $ make $ make install # you can build the examples and tests, and run the tests, like so: $ make check ```  ## building from git  building from git can be difficult so you should prefer building from a release tarball unless you need to work on the libsigc++ code itself.  jhbuild can be a good help. see the [jhbuild repo](https://gitlab.gnome.org/gnome/jhbuild), the [jhbuild wiki](https://wiki.gnome.org/projects/jhbuild) and the [jhbuild manual](https://gnome.pages.gitlab.gnome.org/jhbuild).  ### building from git with meson  you must have meson properly installed (meson, ninja, etc) and you will also need [mm-common](https://gitlab.gnome.org/gnome/mm-common/) version 1.0.0 or higher.  maintainer-mode is enabled by default when you build from a git clone.  don't call the builddir 'build'. there is a directory called 'build' with files used by autotools.  ```sh $ meson setup --prefix=/some_directory --libdir=lib your_builddir . $ cd your_builddir $ ninja $ ninja install # you can run the tests like so: $ ninja test # you can create a tarball like so: $ ninja dist ```  ### building from git with autotools  you must have autotools properly installed (autoconf, automake, etc) and you will also need [mm-common](https://gitlab.gnome.org/gnome/mm-common/).  ```sh $ ./autogen.sh --prefix=/some_directory $ make $ make install # you can build the examples and tests, and run the tests, like so: $ make check # you can create a tarball like so: $ make distcheck # or $ make dist ```  ### building from git with cmake  the cmake build is not used very often by the libsigc++ developers, but it should work, and we would welcome improvements.  for instance:  ```sh $ mkdir libsigcplusplus_build $ cd libsigcplusplus_build $ cmake path/to/libsigcplusplus $ make ```  ## building with microsoft visual c++  see [msvc-builds.md](msvc_nmake/msvc-builds.md) ","allyourcodebase/rabbitmq-c":"RabbitMQ C client (zig build) # rabbitmq c amqp client library  ![build status](https://github.com/alanxz/rabbitmq-c/actions/workflows/ci.yml/badge.svg)  [![coverage status](https://coveralls.io/repos/github/alanxz/rabbitmq-c/badge.svg?branch=master)](https://coveralls.io/github/alanxz/rabbitmq-c?branch=master)  [![fuzzing status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/rabbitmq-c.svg)](https://oss-fuzz-build-logs.storage.googleapis.com/index.html#rabbitmq-c)  [![openssf best practices](https://www.bestpractices.dev/projects/7001/badge)](https://www.bestpractices.dev/projects/7001)  ## introduction  this is a c-language amqp client library for use with v2.0+ of the [rabbitmq](http://www.rabbitmq.com/) broker.   - <http://github.com/alanxz/rabbitmq-c>  announcements regarding the library are periodically made on the rabbitmq-c-users and cross-posted to rabbitmq-users.   - <https://groups.google.com/forum/#!forum/rabbitmq-c-users>  - <https://groups.google.com/forum/#!forum/rabbitmq-users>  ## latest stable version  the latest stable release of rabbitmq-c can be found at:   - <https://github.com/alanxz/rabbitmq-c/releases/latest>  ## documentation  api documentation for v0.8.0+ can viewed from:  <http://alanxz.github.io/rabbitmq-c/docs/0.8.0/>  ## getting started  ### building and installing  #### prereqs: - [cmake v3.22 or better](http://www.cmake.org/) - a c compiler (gcc 4.4+, clang, and msvc are test. other compilers may also   work) - *optionally* [openssl](http://www.openssl.org/) v1.1.1+ to enable support for   connecting to rabbitmq over ssl/tls - *optionally* [popt](http://freecode.com/projects/popt) to build some handy   command-line tools. - *optionally* [xmlto](https://fedorahosted.org/xmlto/) to build man pages for   the handy command-line tools - *optionally* [doxygen](http://www.stack.nl/~dimitri/doxygen/) to build   developer api documentation.  after downloading and extracting the source from a tarball to a directory ([see above](#latest-stable-version)), the commands to build rabbitmq-c on most systems are:      mkdir build && cd build     cmake ..     cmake --build . [--config release]  the --config release flag should be used in multi-configuration generators e.g., visual studio or xcode.  it is also possible to point the cmake gui tool at the cmakelists.txt in the root of the source tree and generate build projects or ide workspace  installing the library and optionally specifying a prefix can be done with:      cmake -dcmake_install_prefix=/usr/local ..     cmake --build . [--config release] --target install  more information on cmake can be found on its faq (http://www.cmake.org/wiki/cmake_faq)  other interesting flags that can be passed to cmake:  * `build_examples=on/off` toggles building the examples. off by default. * `build_shared_libs=on/off` toggles building rabbitmq-c as a shared library.    on by default. * `build_static_libs=on/off` toggles building rabbitmq-c as a static library.    on by default. * `build_testing=on/off` toggles building test code. on by default. * `build_tools=on/off` toggles building the command line tools. by default    this is on if the build system can find the popt header and library. * `build_tools_docs=on/off` toggles building the man pages for the command line    tools. by default this is on if build_tools is on and the build system can    find the xmlto utility. * `enable_ssl_support=on/off` toggles building rabbitmq-c with ssl support. by    default this is on if the openssl headers and library can be found. * `build_api_docs=on/off` - toggles building the doxygen api documentation, by    default this is off * `run_system_tests=on/off` toggles building the system tests (i.e. tests requiring     an accessible rabbitmq server instance on localhost), by default this is off  ## building rabbitmq - using vcpkg  you can download and install rabbitmq using the [vcpkg](https://github.com/microsoft/vcpkg)  dependency manager:      git clone https://github.com/microsoft/vcpkg.git     cd vcpkg     ./bootstrap-vcpkg.sh     ./vcpkg integrate install     ./vcpkg install librabbitmq  the rabbitmq port in vcpkg is kept up to date by microsoft team members and  community contributors. if the version is out of date,  please [create an issue or pull request](https://github.com/microsoft/vcpkg) on the vcpkg repository.  ## running the examples  arrange for a rabbitmq or other amqp server to be running on `localhost` at tcp port number 5672.  in one terminal, run      ./examples/amqp_listen localhost 5672 amq.direct test  in another terminal,      ./examples/amqp_sendstring localhost 5672 amq.direct test 'hello world'  you should see output similar to the following in the listener's terminal window:      delivery 1, exchange amq.direct routingkey test     content-type: text/plain     ----     00000000: 68 65 6c 6c 6f 20 77 6f : 72 6c 64                 hello world     0000000b:  ## writing applications using `librabbitmq`  please see the `examples` directory for short examples of the use of the `librabbitmq` library.  ### threading  you cannot share a socket, an `amqp_connection_state_t`, or a channel between threads using `librabbitmq`. the `librabbitmq` library is built with event-driven, single-threaded applications in mind, and does not yet cater to any of the requirements of `pthread`ed applications.  your applications instead should open an amqp connection (and an associated socket, of course) per thread. if your program needs to access an amqp connection or any of its channels from more than one thread, it is entirely responsible for designing and implementing an appropriate locking scheme. it will generally be much simpler to have a connection exclusive to each thread that needs amqp service.  ### license & copyright  portions created by alan antonuk are copyright (c) 2012-2021 alan antonuk. all rights reserved.  portions created by vmware are copyright (c) 2007-2012 vmware, inc. all rights reserved.  portions created by tony garnock-jones are copyright (c) 2009-2010 vmware, inc. and tony garnock-jones. all rights reserved.  permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'software'), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:  the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.  the software is provided 'as is', without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.","Protonull/zig-time":"zig-time but with Zig packaging # zig-time  this is a fork of [zig-time](https://github.com/nektro/zig-time) that's uses zig's native packaging instead of [zigmod](https://github.com/nektro/zigmod).  ## usage  add this repository to your `build.zig.zon`, eg: ```zon // build.zig.zon .{     .name = 'awesome-project',     .version = '0.1.0',     .minimum_zig_version = '0.12.0',     .paths = .{ '' },     .dependencies = .{         .zig_time = .{             .url = 'git+https://github.com/protonull/zig-time#<commit hash>',             .hash = '<hash>' // comment this out zig will automatically tell you what has to use.         },     }, } ```  after that, add the dependency to your build script, eg:  ```zig // build.zig const std = @import('std');  pub fn build(     b: *std.build ) void {     const target = b.standardtargetoptions(.{});     const optimize = b.standardoptimizeoption(.{});      const exe = b.addexecutable(.{         .name = 'awesome-project',         .root_source_file = .{ .path = 'src/main.zig' },         .target = target,         .optimize = optimize,     });      // zig-time dependency goes here     exe.root_module.addimport('zig-time', b.dependency('zig_time', .{}).module('time'));          b.installartifact(exe); } ```  you may notice there's `zig-time`, `zig_time`, and `time`.  - `zig-time` is what you'd use as the import, like so: `const time = @import('zig-time')` - `zig_time` is the key to match in `build.zig.zon`, which doesn't like dashes. - `time` is the name of the exported module from zig-time, the library itself. ","ajkachnic/fasthttpparser":"A moderately fast HTTP 1.1 parser written in Zig. # fasthttpparser  *note: this is unstable and the api is likely to change; use at your own risk*  a http 1.1 parser written in zig. currently competes with [`httparse`](https://https://github.com/seanmonstar/httparse) and is beaten by [`picohttpparser`](https://github.com/h20/picohttpparser)  ## benchmarks  | parser         | one-long | one-short  | smaller    | bigger     | |----------------|----------|------------|------------|------------| | fasthttpparser | 1.08gb/s | 987.54mb/s | 986.80mb/s | 984.49mb/s | | picohttpparser | 3.04gb/s | 2.99gb/s   | 3.06gb/s   | 3.06gb/s   |  you can run these yourself with `zig build bench`. i'll eventually extend the benchmark suite to include httparse, but i don't feel like dealing with rust-zig interop (test harness is written in zig) at the moment.  ## installation  since the parser ships as a single file (`fasthttpparser.zig`), you can just drop that into your project.  then, you could add it to your `build.zig` file as a package, or just import it directly. ","andy5995/zigpokerhands":"A program that uses zigdeck to evaluate five cards to determine if it matches a poker hand [![linux ci](https://github.com/andy5995/zigpokerhands/actions/workflows/linux.yml/badge.svg)](https://github.com/andy5995/zigpokerhands/actions/workflows/linux.yml)  # zigpokerhands  a program that uses [zigdeck](https://github.com/andy5995/zigdeck) to evaluate five cards to determine if it matches a poker hand  ## output examples  ``` evaluating 1000000 hands...                                     pair: 421692                                 twopair: 47047                            threeofakind: 20578                                straight: 4090                                   flush: 2514                               fullhouse: 1450                             fourofakind: 244                           straightflush: 18                              royalflush: 1 ```  ``` evaluating 1000000 hands...                                     pair: 421887                                 twopair: 47001                            threeofakind: 20558                                straight: 4168                                   flush: 2511                               fullhouse: 1378                             fourofakind: 225                           straightflush: 21                              royalflush: 0  ```  ``` evaluating 1000000 hands...                                     pair: 420623                                 twopair: 47240                            threeofakind: 20832                                straight: 4136                                   flush: 2587                               fullhouse: 1391                             fourofakind: 252                           straightflush: 19                              royalflush: 2  ``` ","kassane/observable_unique_ptr":"Unique-ownership smart pointers with observable lifetime. (uses zig build) # observable_unique_ptr, observable_sealed_ptr, observer_ptr  ![build status](https://github.com/cschreib/observable_unique_ptr/actions/workflows/cmake.yml/badge.svg) ![docs build status](https://github.com/cschreib/observable_unique_ptr/actions/workflows/doc.yml/badge.svg) [![codecov](https://codecov.io/gh/cschreib/observable_unique_ptr/branch/main/graph/badge.svg?token=8c11d2u94d)](https://codecov.io/gh/cschreib/observable_unique_ptr)  built and tested on:  - linux (gcc/clang)  - windows (msvc 32/64)  - macos (clang)  - webassembly (emscripten)  **table of content:** <!-- markdowntoc autolink='true' -->  - [introduction](#introduction) - [usage](#usage) - [enable_observer_from_this](#enable_observer_from_this) - [policies](#policies) - [limitations](#limitations) - [thread safety](#thread-safety) - [comparison spreadsheet](#comparison-spreadsheet) - [speed benchmarks](#speed-benchmarks) - [alternative implementation](#alternative-implementation)  <!-- /markdowntoc -->   ## introduction  this is a small header-only library, providing the unique-ownership smart pointers `observable_unique_ptr` and `observable_sealed_ptr` that can be observed with non-owning pointers `observer_ptr`. this is a mixture of `std::unique_ptr` and `std::shared_ptr`: it borrows the unique-ownership semantic of `std::unique_ptr` (movable, non-copiable), but allows creating `observer_ptr` to monitor the lifetime of the pointed object (like `std::weak_ptr` for `std::shared_ptr`).  the only difference between `observable_unique_ptr` and `observable_sealed_ptr` is that the former can release ownership, while the latter cannot. disallowing release of ownership enables allocation optimizations. therefore, the recommendation is to use `observable_sealed_ptr` unless release of ownership is required.  these pointers are useful for cases where the shared-ownership of `std::shared_ptr` is not desirable, e.g., when lifetime must be carefully controlled and not be allowed to extend, yet non-owning/weak/observer references to the object may exist after the object has been deleted.  note: because of the unique ownership model, observer pointers cannot extend the lifetime of the pointed object, hence this library provides less safety compared to `std::shared_ptr`/`std::weak_ptr`. see the [thread safety](#thread-safety) section. this is also true of `std::unique_ptr`, and is a fundamental limitation of unique ownership. if this is an issue, simply use `std::shared_ptr`/`std::weak_ptr`.   ## usage  this is a header-only library requiring a c++17-compliant compiler. you have multiple ways to set it up:  - just include this repository as a submodule in your own git repository and use cmake `add_subdirectory` (or use cmake `fetchcontent`), then link with `target_link_libraries(<your-target> public oup::oup)`.  - download the header and include it in your own sources.  from there, include the single header `<oup/observable_unique_ptr.hpp>`, and directly use the smart pointer in your own code:  ```c++ #include <oup/observable_unique_ptr.hpp>  #include <string> #include <iostream> #include <cassert>  int main() {     // non-owning pointer that will outlive the object     oup::observer_ptr<std::string> obs_ptr;      {         // sealed (unique) pointer that owns the object         auto owner_ptr = oup::make_observable_sealed<std::string>('hello');          // a sealed pointer cannot be copied but it can be moved         // auto tmp_copied = owner_ptr; // error!         // auto tmp_moved = std::move(owner_ptr); // ok          // make the observer pointer point to the object         obs_ptr = owner_ptr;          // the observer pointer is now valid         assert(!obs_ptr.expired());          // it can be used like a regular raw pointer         assert(obs_ptr != nullptr);         std::cout << *obs_ptr << std::endl;          // an observer pointer can be copied and moved         // auto tmp_copied = obs_ptr; // ok         // auto tmp_moved = std::move(obs_ptr); // ok     }      // the sealed pointer has gone out of scope, the object is deleted,     // the observer pointer is now null.     assert(obs_ptr.expired());     assert(obs_ptr == nullptr);      return 0; } ```   ## enable_observer_from_this  as with `std::shared_ptr`/`std::weak_ptr`, if you need to obtain an observer pointer to an object when you only have `this` (i.e., from a member function), you can inherit from `oup::enable_observer_from_this_unique<t>` or `oup::enable_observer_from_this_sealed<t>` (depending on the type of the owner pointer) to gain access to the `observer_from_this()` member function. contrary to `std::enable_shared_from_this<t>`, this function is `noexcept` and is able to return a valid observer pointer at all times, even if the object is being constructed or is not owned by a unique or sealed pointer. also contrary to `std::enable_shared_from_this<t>`, this feature naturally supports multiple inheritance.  to achieve this, the price to pay is that `oup::enable_observer_from_this_unique<t>` uses virtual inheritance, while `oup::enable_observer_from_this_sealed<t>` requires `t`'s constructor to take a control block as input (thereby preventing `t` from being default-constructible, copiable, or movable). if needed, these trade-offs can be controlled by policies, see below.   ## policies  similarly to `std::string` and `std::basic_string`, this library provides both 'convenience' types (`oup::observable_unique_ptr<t,deleter>`, `oup::observable_sealed_ptr<t>`, `oup::observer_ptr<t>`, `oup::enable_observable_from_this_unique<t>`, `oup::enable_observable_from_this_sealed<t>`) and 'generic' types (`oup::basic_observable_ptr<t,deleter,policy>`, `oup::basic_observer_ptr<t,obspolicy>`, `oup::basic_enable_observable_from_this<t,policy>`).  if the trade-offs chosen to defined the 'convenience' types are not appropriate for your use cases, they can be fine-tuned using the generic classes and providing your own choice of policies. please refer to the documentation for more information on policies. in particular, policies will control most of the api and behavior of the `enable_observable_from_this` feature, as well as allowing you to tune the size of the reference counting object (speed/memory trade-off).   ## limitations  the following limitations are features that were not implemented simply because of lack of motivation.   - this library is not thread-safe, contrary to `std::shared_ptr`. see the [thread safety](#thread-safety) section for more info.  - this library does not support pointers to arrays, but `std::unique_ptr` and `std::shared_ptr` both do.  - this library does not support custom allocators, but `std::shared_ptr` does.   ## thread safety  this library uses reference counting to handle observable and observer pointers. the current implementation does not use any synchronization mechanism (mutex, lock, etc.) to wrap operations on the reference counter. therefore, it is unsafe to have an observable pointer on one thread being observed by observer pointers on another thread.  the above could be fixed in the future by adding a configurable policy to enable or disable synchronization. however, the unique ownership model still imposes fundamental limitations on thread safety: an observer pointer cannot extend the lifetime of the observed object (like `std::weak_ptr::lock()` would do). the only guarantee that could be offered is the following: if `expired()` returns true, the observed pointer is guaranteed to remain `nullptr` forever, with no race condition. if `expired()` returns false, the pointer could still expire on the next instant, which can lead to race conditions. to completely avoid race conditions, you will need to add explicit synchronization around your object.  finally, because this library uses no global state (beyond the standard allocator, which is thread-safe), it is perfectly fine to use it in a threaded application, provided that all observer pointers for a given object live on the same thread as the object itself.   ## comparison spreadsheet  in this comparison spreadsheet, the raw pointer `t*` is assumed to never be owning, and used only to observe an existing object (which may or may not have been deleted). unless otherwise specified, the stack and heap sizes were measured with gcc 9.4.0 and libstdc++-9.  labels:  - raw: `t*`  - unique: `std::unique_ptr<t>`  - weak: `std::weak_ptr<t>`  - shared: `std::shared_ptr<t>`  - observer: `oup::observer_ptr<t>`  - obs_unique: `oup::observable_unique_ptr<t>`  - obs_sealed: `oup::observable_sealed_ptr<t>`  | pointer                  | raw  | weak   | observer | unique | shared | obs_unique | obs_sealed | |--------------------------|------|--------|----------|--------|--------|------------|------------| | owning                   | no   | no     | no       | yes    | yes    | yes        | yes        | | releasable               | n/a  | n/a    | n/a      | yes    | no     | yes        | no         | | observable deletion      | no   | yes    | yes      | yes    | yes    | yes        | yes        | | thread-safe              | no   | yes    | no       | no     | yes    | no         | no         | | atomic                   | yes  | no(1)  | no       | no     | no(1)  | no         | no         | | support arrays           | yes  | yes    | no       | yes    | yes    | no         | no         | | support custom allocator | n/a  | yes    | no       | yes    | yes    | no         | no         | | support custom deleter   | n/a  | n/a    | n/a      | yes    | yes(2) | yes        | no         | | max number of observers  | inf. | ?(3)   | 2^31 - 1 | 1      | ?(3)   | 1          | 1          | | number of heap alloc.    | 0    | 0      | 0        | 1      | 1/2(4) | 2          | 1          | | size in bytes (64 bit)   |      |        |          |        |        |            |            | |  - stack (per instance)  | 8    | 16     | 16       | 8      | 16     | 16         | 16         | |  - heap (shared)         | 0    | 0      | 0        | 0      | 24(5)  | 4          | 4(6)       | |  - total                 | 8    | 16     | 16       | 8      | 40     | 20         | 20         | | size in bytes (32 bit)   |      |        |          |        |        |            |            | |  - stack (per instance)  | 4    | 8      | 8        | 4      | 8      | 8          | 8          | |  - heap (shared)         | 0    | 0      | 0        | 0      | 16     | 4          | 4          | |  - total                 | 4    | 8      | 8        | 4      | 24     | 12         | 12         |  notes:   - (1) yes if using `std::atomic<std::shared_ptr<t>>` and `std::atomic<std::weak_ptr<t>>`.  - (2) not if using `std::make_shared()`.  - (3) not defined by the c++ standard. in practice, libstdc++ stores its reference count on an `_atomic_word`, which for a common 64bit linux platform is a 4 byte signed integer, hence the limit will be 2^31 - 1. microsoft's stl uses `_atomic_counter_t`, which for a 64bit windows platform is 4 bytes unsigned integer, hence the limit will be 2^32 - 1.  - (4) 2 by default, or 1 if using `std::make_shared()`.  - (5) when using `std::make_shared()`, this can get as low as 16 bytes, or larger than 24 bytes, depending on the size and alignment requirements of the object type. this behavior is shared by libstdc++ and ms-stl.  - (6) can get larger than 4 depending on the alignment requirements of the object type.   ## speed benchmarks  labels are the same as in the comparison spreadsheet. the speed benchmarks were compiled with all optimizations turned on (except lto). speed is measured relative to `std::unique_ptr<t>` used as owner pointer, and `t*` used as observer pointer, which should be the fastest possible implementation (but obviously the one with least safety).  you can run the benchmarks yourself, they are located in `tests/speed_benchmark.cpp`. the benchmark executable runs tests for three object types: `int`, `float`, `std::string`, and `std::array<int,65'536>`, to simulate objects of various allocation cost. the timings below are the median values measured across all object types, which should be most relevant to highlight the overhead from the pointer itself (and erases flukes from the benchmarking framework). in real life scenarios, the actual measured overhead will be substantially lower, as actual business logic is likely to dominate the time budget.  detail of the benchmarks:  - create owner empty: default-construct an owner pointer (to nullptr).  - create owner: construct an owner pointer by taking ownership of an existing object.  - create owner factory: construct an owner pointer using `std::make_*` or `oup::make_*` factory functions.  - dereference owner: get a reference to the underlying owned object from an owner pointer.  - create observer empty: default-construct an observer pointer (to nullptr).  - create observer: construct an observer pointer from an owner pointer.  - create observer copy: construct a new observer pointer from another observer pointer.  - dereference observer: get a reference to the underlying object from an observer pointer.  the benchmarks were last ran for oup v0.7.1.  *compiler: gcc 9.4.0, std: libstdc++-9, os: linux 5.15.0, cpu: ryzen 5 2600:*  | pointer               | raw/unique | weak/shared | observer/obs_unique | observer/obs_sealed | | ---                   | ---        | ---         | ---                 | ---                 | | create owner empty    | 1          | 1.1         | 1.1                 | 1.2                 | | create owner          | 1          | 2.1         | 1.7                 | n/a                 | | create owner factory  | 1          | 1.3         | 1.7                 | 1.1                 | | dereference owner     | 1          | 1.0         | 1.0                 | 1.1                 | | create observer empty | 1          | 1.1         | 1.2                 | 1.2                 | | create observer       | 1          | 1.6         | 1.6                 | 1.6                 | | create observer copy  | 1          | 1.7         | 1.6                 | 1.6                 | | dereference observer  | 1          | 3.5         | 1.0                 | 1.0                 |  *compiler: msvc 16.11.3, std: ms-stl, os: windows 10.0.19043, cpu: i7-7800x:*  | pointer               | raw/unique | weak/shared | observer/obs_unique | observer/obs_sealed | | ---                   | ---        | ---         | ---                 | ---                 | | create owner empty    | 1          | 1.4         | 1.8                 | 1.5                 | | create owner          | 1          | 2.2         | 2.9                 | n/a                 | | create owner factory  | 1          | 1.2         | 2.2                 | 0.9                 | | dereference owner     | 1          | 0.7         | 1.3                 | 1.0                 | | create observer empty | 1          | 1.6         | 1.0                 | 0.8                 | | create observer       | 1          | 5.3         | 1.6                 | 1.6                 | | create observer copy  | 1          | 5.3         | 1.4                 | 1.5                 | | dereference observer  | 1          | 9.4         | 1.4                 | 0.8                 |  *compiler: emscripten 2.0.34, std: libc++, os: node.js 14.15.5 + linux kernel 5.1.0, cpu: ryzen 5 2600:*  | pointer               | raw/unique | weak/shared | observer/obs_unique | observer/obs_sealed | | ---                   | ---        | ---         | ---                 | ---                 | | create owner empty    | 1          | 6.9         | 1.1                 | 1.0                 | | create owner          | 1          | 1.8         | 1.6                 | n/a                 | | create owner factory  | 1          | 1.2         | 1.7                 | 1.0                 | | dereference owner     | 1          | 1.0         | 1.0                 | 1.0                 | | create observer empty | 1          | 11.4        | 1.6                 | 1.6                 | | create observer       | 1          | 14.8        | 2.3                 | 2.3                 | | create observer copy  | 1          | 14.9        | 2.3                 | 2.5                 | | dereference observer  | 1          | 38.7        | 1.0                 | 1.0                 |   ## alternative implementation  an alternative implementation of an 'observable unique pointer' can be found [here](https://www.codeproject.com/articles/1011134/smart-observers-to-use-with-unique-ptr). it does not compile out of the box with gcc unfortunately and lacks certain features (their `make_observable` always performs two allocations). have a look to check if this better suits your needs. ","liyu1981/translate_c_extract":"a simple tool to clean zig translate-c result with annotation. # translate-c-extract  a simple tool to clean `zig translate-c` result with annotation.  ## see it by example  example `hello.h`  ```c #ifndef __hello_h__ #define __hello_h__  #include <stddef.h> #include <stdint.h>   // translate-c provide-begin: /#define╲s(?<tk>╲s+)╲s.+/ #define const_a 'a' #define const_one 1 // translate-c provide-end: /#define╲s(?<tk>╲s+)╲s.+/  // translate-c provide: regexmatchresult typedef struct {     size_t start;     size_t len; } loc;  // translate-c provide: get_last_error_message void get_last_error_message(loc* loc); // translate-c provide: my_create_a_hello_string int my_create_a_hello_string(char** buf);  #endif ```  if `zig build run -- tests/hello.h`, will produce  ```zig // generated by: ` zig-cache/o/b211bd45d7e3d2d5cee3d2849990c1b8/translate_c_extract tests/hello.h ` // timestamp: 1706073955549678  pub extern fn get_last_error_message(loc: [*c]loc) void;  pub extern fn my_create_a_hello_string(buf: [*c][*c]u8) c_int;  pub const const_a = 'a';  pub const const_one = @as(c_int, 1); ```  ## annotation syntax  if use '// translate-c provide: <name>', the <name> then will be looked up in `zig translate-c` result for filtering.  if use `// translate-c provide-begin:`, then follow a `pcre2` regex, and must with a name group called `tk`. the matched names will be searched in `zig translate-c` result for filtering. the `// translate-c provide-end` part must match previous regex.  ## and  mit license :) ","voidstar240/zig-wayland-xdg_shell-client":"XDG Shell protocol extension for zig-wayland-client # wayland xdg shell client this is the xdg shell protocol extension for the [`zig-wayland-client`](https://github.com/voidstar240/zig-wayland-client) library. ","nitrogenez/resfs":"File system abstraction layer for Zig games and apps # resfs  **res**ource **f**ile **s**ystem, or resfs is a file system abstraction layer made specifically for games and applications in zig. it includes file type detection, resource lookup, etc.   to use it, just add it to your dependency tree in `build.zig.zon`.  todo: better readme. ","BratishkaErik/zig-ebuilder":"Generate Zig ebuilds for Gentoo-based distros using 'zig-build.eclass'. https://github.com/gentoo/gentoo/pull/37283 404: not found","xfitgd/xfit":"vulkan based cross platform game engine # xfit : zig 게임 엔진 프로젝트  자세한 설명은 wiki 탭을 참고하세요.  ## using libraries  - [opus](https://github.com/xiph/opus) - [opusfile](https://github.com/xiph/opusfile) - [libogg, libvorbis](https://xiph.org/downloads/) - [freetype](https://freetype.org/) - [libwebp](https://chromium.googlesource.com/webm/libwebp) - [miniaudio](https://github.com/mackron/miniaudio) - [zig-datetime](https://github.com/frmdstryr/zig-datetime) - [lua](https://github.com/lua/lua) - [ini](https://github.com/ziglibs/ini), [zigini](https://github.com/kawaii-ash/zigini) - [s2s](https://github.com/ziglibs/s2s) - [zig-yaml](https://github.com/kubkon/zig-yaml) - [zig-xml](https://github.com/ianprime0509/zig-xml) ","fogti/esvc2":"esvc, but flattened # event sourcing version control  see the esvc v1 repo for an intro...  ## related literature  * [partially commutative inverse monoids](https://www.eti.uni-siegen.de/ti/veroeffentlichungen/06-mfcs-inv.pdf) ","kassane/range-v3":"Range library for C++14/17/20, basis for C++20's std::ranges (uses zig build-system) range-v3 ========  range library for c++14/17/20. this code was the basis of [a formal proposal](https://ericniebler.github.io/std/wg21/d4128.html) to add range support to the c++ standard library. that proposal evolved through a technical specification, and finally into [p0896r4 'the one ranges proposal'](https://wg21.link/p0896r4) which was merged into the c++20 working drafts in november 2018.  about: ------  ranges are an extension of the standard template library that makes its iterators and algorithms more powerful by making them _composable_. unlike other range-like solutions which seek to do away with iterators, in range-v3 ranges are an abstraction layer _on top_ of iterators.  range-v3 is built on three pillars: views, actions, and algorithms. the algorithms are the same as those with which you are already familiar in the stl, except that in range-v3 all the algorithms have overloads that take ranges in addition to the overloads that take iterators. views are composable adaptations of ranges where the adaptation happens lazily as the view is iterated. and an action is an eager application of an algorithm to a container that mutates the container in-place and returns it for further processing.  views and actions use the pipe syntax (e.g., `rng | adapt1 | adapt2 | ...`) so your code is terse and readable from left to right.  documentation: --------------  check out the (woefully incomplete) documentation [here](https://ericniebler.github.io/range-v3/).  other resources (mind the dates, the library probably has changed since then):  - usage:   - talk: [cppcon 2015: eric niebler 'ranges for the standard library'](https://www.youtube.com/watch?v=mfuxnmfacie), 2015.   - [a slice of python in c++](http://ericniebler.com/2014/12/07/a-slice-of-python-in-c/), 07.12.2014.   - actions (back then called [container algorithms](http://ericniebler.com/2014/11/23/container-algorithms/)), 23.11.2014.   - [range comprehensions](http://ericniebler.com/2014/04/27/range-comprehensions/), 27.04.2014.   - [input iterators vs input ranges](http://ericniebler.com/2013/11/07/input-iterators-vs-input-ranges/), 07.11.2013.  - design / implementation:   - rationale behind range-v3: [n4128: ranges for the standard library revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html), 2014.   - ranges ts: [n4560: c++ extensions for ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf), 2015.   - implementation of customization points in range-v3:     - [n4381: suggested design for customization points](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html), 2015.     - [p0386: inline variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r0.pdf), 2016.     - [customization point design in c++11 and beyond](http://ericniebler.com/2014/10/21/customization-point-design-in-c11-and-beyond/), 2014.   - proxy iterators in range-v3:     - [d0022: proxy iterators for the ranges extensions](https://ericniebler.github.io/std/wg21/d0022.html).     - [to be or not to be (an iterator)](http://ericniebler.com/2015/01/28/to-be-or-not-to-be-an-iterator/), 2015.     - [iterators++: part1](http://ericniebler.com/2015/02/03/iterators-plus-plus-part-1/), 2015.     - [iterators++: part2](http://ericniebler.com/2015/02/13/iterators-plus-plus-part-2/), 2015.     - [iterators++: part3](http://ericniebler.com/2015/03/03/iterators-plus-plus-part-3/), 2015.   - metaprogramming utilities:     - see the [meta documentation](https://ericniebler.github.io/meta/index.html), the library has changed significantly since the [2014 blog post](http://ericniebler.com/2014/11/13/tiny-metaprogramming-library/).   - concept emulation layer: [concept checking in c++11](http://ericniebler.com/2013/11/23/concept-checking-in-c11/), 2013.   - [c++now 2014: eric niebler 'c++11 library design'](https://www.youtube.com/watch?v=zgof4nrqllo), 2014.  license: --------  most of the source code in this project are mine, and those are under the boost software license. parts are taken from alex stepanov's elements of programming, howard hinnant's libc++, and from the sgi stl. please see the attached license file and the credits file for the licensing and acknowledgments.  supported compilers -------------------  the code is known to work on the following compilers:  - clang 5.0 (or later) - gcc 6.5 (or later) - clang/llvm 6 (or later) on windows (older versions may work - we haven't tested.) - visual studio 2019 (or later) on windows, with some caveats due to range-v3's strict conformance requirements:   - range-v3 needs `/permissive-` and either `/std:c++latest`, `/std:c++20`,  or `/std:c++17`  **development status:** this code is fairly stable, well-tested, and suitable for casual use, although currently lacking documentation. _in general_, no promise is made about support or long-term stability. this code *will* evolve without regard to backwards compatibility.  a notable exception is anything found within the `ranges::cpp20` namespace. those components will change rarely or (preferably) never at all.  **build status** - on github actions: [![github actions status](https://github.com/ericniebler/range-v3/workflows/range-v3%20ci/badge.svg?branch=master)](https://github.com/ericniebler/range-v3/actions)  building range-v3 - using vcpkg -------------------------------  you can download and install range-v3 using the [vcpkg](https://github.com/microsoft/vcpkg) dependency manager: ```sh git clone https://github.com/microsoft/vcpkg.git cd vcpkg ./bootstrap-vcpkg.sh ./vcpkg integrate install ./vcpkg install range-v3 ``` the range-v3 port in vcpkg is kept up to date by microsoft team members and community contributors. if the version is out of date, please [create an issue or pull request](https://github.com/microsoft/vcpkg) on the vcpkg repository.  building range-v3 - using conan -------------------------------  you can download and install range-v3 using the [conan](https://github.com/conan-io/conan) dependency manager.  setup your cmakelists.txt (see [conan documentation](https://docs.conan.io/en/latest/integrations/build_system.html) on how to use msbuild, meson and others): ```cmake project(myproject cxx)  add_executable(${project_name} main.cpp)  include(${cmake_binary_dir}/conanbuildinfo.cmake) # include conan-generated file conan_basic_setup(targets) # introduce conan-generated targets  target_link_libraries(${project_name} conan_pkg::range-v3) ``` create `conanfile.txt` in your source dir: ```sh [requires] range-v3/0.12.0  [generators] cmake ``` install and run `conan`, then build your project as always: ```sh pip install conan mkdir build cd build conan install ../ --build=missing cmake ../ cmake --build . ```  building range-v3 - using `build2` ----------------------------------  you can use [`build2`](https://build2.org), a dependency manager and build-system combined, to use `range-v3` (or work on it):  currently this package is available in these package repositories:  - **https://cppget.org/range-v3/** for released and published versions.  - [**the git repository with the sources of the `build2` package of `range-v3`**](https://github.com/build2-packaging/range-v3.git) for unreleased or custom revisions of `range-v3`, or for working on it with `build2`.  ### usage:   - `build2` package name: `range-v3`  - library target name : `lib{range-v3}`  - [detailed use cases and instructions in this document](https://github.com/build2-packaging/range-v3/blob/master/notes-build2.md).  for example, to make your `build2` project depend on `range-v3`:   - add one of the repositories to your configurations, or in your `repositories.manifest`, if not already there; for example:     ```     :     role: prerequisite     location: https://pkg.cppget.org/1/alpha # v0.11.0 is there.     ```   - add this package as a dependency to your `manifest` file (example for `v0.11.x`):     ```     depends: range-v3 ~0.11.0     ```   - import the target and use it as a prerequisite to your own target using `range-v3` in the appropriate `buildfile`:     ```py     import range_v3 = range-v3%lib{range-v3}      lib{mylib} : cxx{**} ... $range_v3     ```  then just build your project as usual (with `b` or `bdep update`), `build2` will figure out the rest.  for `build2` newcomers or to get more details and use cases, you can read [this document](https://github.com/build2-packaging/range-v3/blob/master/notes-build2.md) and the [`build2` toolchain introduction](https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml).   say thanks! -----------  i do this work because i love it and because i love c++ and want it to be as excellent as i know it can be. if you like my work and are looking for a way to say thank you, you can leave a supportive comment on [my blog](http://ericniebler.com). or you could leave me some kudos on my open hub range-v3 contribution page. just click the **give kudos** button [here](https://www.openhub.net/p/range-v3/contributors/3053743222308608). ","zon-dev/mime":"Support MIME (HTTP Media Types) types parse in Zig. # mime support mime (http media types) types parse in zig.   ### usage: ```zig var mime = mime.parse(std.heap.page_allocator, 'text/plain; charset=utf-8; foo=bar'); try std.testing.expect(mime != null); try std.testing.expect(std.mem.eql(u8, mime.?.essence, 'text/plain; charset=utf-8; foo=bar')); try std.testing.expect(std.mem.eql(u8, mime.?.basetype, 'text')); try std.testing.expect(std.mem.eql(u8, mime.?.subtype, 'plain'));  const charset = mime.?.getparam('charset'); try testing.expectequalstrings('utf-8', charset.?);  const foo = mime.?.getparam('foo'); try testing.expectequalstrings('bar', foo.?);  const bar = mime.?.getparam('bar'); try testing.expect(bar == null); ``` ","kassane/cpu_features":"A cross platform C99 library to get cpu features at runtime. # cpu_features  a cross-platform c library to retrieve cpu features (such as available instructions) at runtime.  # github-ci status  [comment]: <> (the following lines are generated by 'scripts/generate_badges.d' that you can run online https://run.dlang.io/)  |  | linux | freebsd | macos | windows | | :-- | --: | --: | --: | --: | | amd64 | [![cmake][i1a0]][l1a0]<br/>[![bazel][i1a1]][l1a1] | [![cmake][i2a0]][l2a0]<br/>![bazel][d1] | [![cmake][i3a0]][l3a0]<br/>[![bazel][i3a1]][l3a1] | [![cmake][i4a0]][l4a0]<br/>![bazel][d1] | | aarch64 | [![cmake][i1b0]][l1b0]<br/>[![bazel][i1b1]][l1b1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | | arm | [![cmake][i1c0]][l1c0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | | mips | [![cmake][i1d0]][l1d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | | power | [![cmake][i1e0]][l1e0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | | riscv | [![cmake][i1f0]][l1f0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | | loongarch | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | | s390x | [![cmake][i1h0]][l1h0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] | ![cmake][d0]<br/>![bazel][d1] |  [d0]: https://img.shields.io/badge/n%2fa-lightgrey?&logo=cmake [d1]: https://img.shields.io/badge/n%2fa-lightgrey?&logo=data:image/svg%2bxml;base64,phn2zybyb2xlpsjpbwciihzpzxdcb3g9ijagmcayncayncigeg1sbnm9imh0dha6ly93d3cudzmub3jnlziwmdavc3znij48cgf0acbkpsjnniaumtzsns43odygns43odzmniaxms43mziumje0iduuotq2idyglje2mxpnmca2ljixnfyxmmw1ljc4nia1ljc4nlyxmkwwidyumje0ek0xocaumtzsns43odygns43odzmmtggmteunzmybc01ljc4ni01ljc4nkwxocaumtyxek0ynca2ljixnfyxmmwtns43odygns43odzwmtjmmjqgni4ymtr6tteyidyumtzsns43odygns43odzmmtigmtcunzmybc01ljc4ni01ljc4nkwxmia2lje2mxpnmteuodqgmtgumdu0djuunzg1bc01ljc4ni01ljc4nxytns43odzsns43odugns43odz6tteylje2ide4lja1ngw1ljc4ni01ljc4nny1ljc4nmwtns43odugns43odv2ltuunzg1eiigc3ryb2tlpsj0cmfuc3bhcmvudcigzmlsbd0id2hpdguilz48l3n2zz4= [i1a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_linux_cmake.yml?branch=main&event=push&label=&logo=cmake [i1a1]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_linux_bazel.yml?branch=main&event=push&label=&logo=data:image/svg%2bxml;base64,phn2zybyb2xlpsjpbwciihzpzxdcb3g9ijagmcayncayncigeg1sbnm9imh0dha6ly93d3cudzmub3jnlziwmdavc3znij48cgf0acbkpsjnniaumtzsns43odygns43odzmniaxms43mziumje0iduuotq2idyglje2mxpnmca2ljixnfyxmmw1ljc4nia1ljc4nlyxmkwwidyumje0ek0xocaumtzsns43odygns43odzmmtggmteunzmybc01ljc4ni01ljc4nkwxocaumtyxek0ynca2ljixnfyxmmwtns43odygns43odzwmtjmmjqgni4ymtr6tteyidyumtzsns43odygns43odzmmtigmtcunzmybc01ljc4ni01ljc4nkwxmia2lje2mxpnmteuodqgmtgumdu0djuunzg1bc01ljc4ni01ljc4nxytns43odzsns43odugns43odz6tteylje2ide4lja1ngw1ljc4ni01ljc4nny1ljc4nmwtns43odugns43odv2ltuunzg1eiigc3ryb2tlpsj0cmfuc3bhcmvudcigzmlsbd0id2hpdguilz48l3n2zz4= [i1b0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/aarch64_linux_cmake.yml?branch=main&event=push&label=&logo=cmake [i1b1]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/aarch64_linux_bazel.yml?branch=main&event=push&label=&logo=data:image/svg%2bxml;base64,phn2zybyb2xlpsjpbwciihzpzxdcb3g9ijagmcayncayncigeg1sbnm9imh0dha6ly93d3cudzmub3jnlziwmdavc3znij48cgf0acbkpsjnniaumtzsns43odygns43odzmniaxms43mziumje0iduuotq2idyglje2mxpnmca2ljixnfyxmmw1ljc4nia1ljc4nlyxmkwwidyumje0ek0xocaumtzsns43odygns43odzmmtggmteunzmybc01ljc4ni01ljc4nkwxocaumtyxek0ynca2ljixnfyxmmwtns43odygns43odzwmtjmmjqgni4ymtr6tteyidyumtzsns43odygns43odzmmtigmtcunzmybc01ljc4ni01ljc4nkwxmia2lje2mxpnmteuodqgmtgumdu0djuunzg1bc01ljc4ni01ljc4nxytns43odzsns43odugns43odz6tteylje2ide4lja1ngw1ljc4ni01ljc4nny1ljc4nmwtns43odugns43odv2ltuunzg1eiigc3ryb2tlpsj0cmfuc3bhcmvudcigzmlsbd0id2hpdguilz48l3n2zz4= [i1c0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/arm_linux_cmake.yml?branch=main&event=push&label=&logo=cmake [i1d0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/mips_linux_cmake.yml?branch=main&event=push&label=&logo=cmake [i1e0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/power_linux_cmake.yml?branch=main&event=push&label=&logo=cmake [i1f0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/riscv_linux_cmake.yml?branch=main&event=push&label=&logo=cmake [i1h0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/s390x_linux_cmake.yml?branch=main&event=push&label=&logo=cmake [i2a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_freebsd_cmake.yml?branch=main&event=push&label=&logo=cmake [i3a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_macos_cmake.yml?branch=main&event=push&label=&logo=cmake [i3a1]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_macos_bazel.yml?branch=main&event=push&label=&logo=data:image/svg%2bxml;base64,phn2zybyb2xlpsjpbwciihzpzxdcb3g9ijagmcayncayncigeg1sbnm9imh0dha6ly93d3cudzmub3jnlziwmdavc3znij48cgf0acbkpsjnniaumtzsns43odygns43odzmniaxms43mziumje0iduuotq2idyglje2mxpnmca2ljixnfyxmmw1ljc4nia1ljc4nlyxmkwwidyumje0ek0xocaumtzsns43odygns43odzmmtggmteunzmybc01ljc4ni01ljc4nkwxocaumtyxek0ynca2ljixnfyxmmwtns43odygns43odzwmtjmmjqgni4ymtr6tteyidyumtzsns43odygns43odzmmtigmtcunzmybc01ljc4ni01ljc4nkwxmia2lje2mxpnmteuodqgmtgumdu0djuunzg1bc01ljc4ni01ljc4nxytns43odzsns43odugns43odz6tteylje2ide4lja1ngw1ljc4ni01ljc4nny1ljc4nmwtns43odugns43odv2ltuunzg1eiigc3ryb2tlpsj0cmfuc3bhcmvudcigzmlsbd0id2hpdguilz48l3n2zz4= [i4a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_windows_cmake.yml?branch=main&event=push&label=&logo=cmake [l1a0]: https://github.com/google/cpu_features/actions/workflows/amd64_linux_cmake.yml [l1a1]: https://github.com/google/cpu_features/actions/workflows/amd64_linux_bazel.yml [l1b0]: https://github.com/google/cpu_features/actions/workflows/aarch64_linux_cmake.yml [l1b1]: https://github.com/google/cpu_features/actions/workflows/aarch64_linux_bazel.yml [l1c0]: https://github.com/google/cpu_features/actions/workflows/arm_linux_cmake.yml [l1d0]: https://github.com/google/cpu_features/actions/workflows/mips_linux_cmake.yml [l1e0]: https://github.com/google/cpu_features/actions/workflows/power_linux_cmake.yml [l1f0]: https://github.com/google/cpu_features/actions/workflows/riscv_linux_cmake.yml [l1h0]: https://github.com/google/cpu_features/actions/workflows/s390x_linux_cmake.yml [l2a0]: https://github.com/google/cpu_features/actions/workflows/amd64_freebsd_cmake.yml [l3a0]: https://github.com/google/cpu_features/actions/workflows/amd64_macos_cmake.yml [l3a1]: https://github.com/google/cpu_features/actions/workflows/amd64_macos_bazel.yml [l4a0]: https://github.com/google/cpu_features/actions/workflows/amd64_windows_cmake.yml  ## table of contents  - [design rationale](#rationale) - [code samples](#codesample) - [running sample code](#usagesample) - [what's supported](#support) - [android ndk's drop in replacement](#ndk) - [license](#license) - [build with cmake](#cmake) - [community bindings](#bindings)  <a name='rationale'></a> ## design rationale  -   **simple to use.** see the snippets below for examples. -   **extensible.** easy to add missing features or architectures. -   **compatible with old compilers** and available on many architectures so it     can be used widely. to ensure that cpu_features works on as many platforms     as possible, we implemented it in a highly portable version of c: c99. -   **sandbox-compatible.** the library uses a variety of strategies to cope     with sandboxed environments or when `cpuid` is unavailable. this is useful     when running integration tests in hermetic environments. -   **thread safe, no memory allocation, and raises no exceptions.**     cpu_features is suitable for implementing fundamental libc functions like     `malloc`, `memcpy`, and `memcmp`. -   **unit tested.**  <a name='codesample'></a> ## code samples  **note:** for c++ code, the library functions are defined in the `cpu_features` namespace.  ### checking features at runtime  here's a simple example that executes a codepath if the cpu supports both the aes and the sse4.2 instruction sets:  ```c #include 'cpuinfo_x86.h'  // for c++, add `using namespace cpu_features;` static const x86features features = getx86info().features;  void compute(void) {   if (features.aes && features.sse4_2) {     // run optimized code.   } else {     // run standard code.   } } ```  ### caching for faster evaluation of complex checks  if you wish, you can read all the features at once into a global variable, and then query for the specific features you care about. below, we store all the arm features and then check whether aes and neon are supported.  ```c #include <stdbool.h> #include 'cpuinfo_arm.h'  // for c++, add `using namespace cpu_features;` static const armfeatures features = getarminfo().features; static const bool has_aes_and_neon = features.aes && features.neon;  // use has_aes_and_neon. ```  this is a good approach to take if you're checking for combinations of features when using a compiler that is slow to extract individual bits from bit-packed structures.  ### checking compile time flags  the following code determines whether the compiler was told to use the avx instruction set (e.g., `g++ -mavx`) and sets `has_avx` accordingly.  ```c #include <stdbool.h> #include 'cpuinfo_x86.h'  // for c++, add `using namespace cpu_features;` static const x86features features = getx86info().features; static const bool has_avx = cpu_features_compiled_x86_avx || features.avx;  // use has_avx. ```  `cpu_features_compiled_x86_avx` is set to 1 if the compiler was instructed to use avx and 0 otherwise, combining compile time and runtime knowledge.  ### rejecting poor hardware implementations based on microarchitecture  on x86, the first incarnation of a feature in a microarchitecture might not be the most efficient (e.g. avx on sandy bridge). we provide a function to retrieve the underlying microarchitecture so you can decide whether to use it.  below, `has_fast_avx` is set to 1 if the cpu supports the avx instruction set&mdash;but only if it's not sandy bridge.  ```c #include <stdbool.h> #include 'cpuinfo_x86.h'  // for c++, add `using namespace cpu_features;` static const x86info info = getx86info(); static const x86microarchitecture uarch = getx86microarchitecture(&info); static const bool has_fast_avx = info.features.avx && uarch != intel_snb;  // use has_fast_avx. ```  this feature is currently available only for x86 microarchitectures.  <a name='usagesample'></a> ### running sample code  building `cpu_features` (check [quickstart](#quickstart) below) brings a small executable to test the library.  ```shell  % ./build/list_cpu_features arch            : x86 brand           :        intel(r) xeon(r) cpu e5-1650 0 @ 3.20ghz family          :   6 (0x06) model           :  45 (0x2d) stepping        :   7 (0x07) uarch           : intel_snb flags           : aes,avx,cx16,smx,sse4_1,sse4_2,ssse3 ```  ```shell % ./build/list_cpu_features --json {'arch':'x86','brand':'       intel(r) xeon(r) cpu e5-1650 0 @ 3.20ghz','family':6,'model':45,'stepping':7,'uarch':'intel_snb','flags':['aes','avx','cx16','smx','sse4_1','sse4_2','ssse3']} ```  <a name='support'></a> ## what's supported  |         | x86³ | aarch64 | arm     | mips⁴   | power   | riscv   | loongarch | s390x   | |---------|:----:|:-------:|:-------:|:-------:|:-------:|:-------:|:---------:|:-------:| | linux   | yes² | yes¹    | yes¹    | yes¹    | yes¹    | yes¹    | yes¹      | yes¹    | | freebsd | yes² | not yet | not yet | not yet | not yet | n/a     | not yet   | not yet | | macos   | yes² | yes⁵    | n/a     | n/a     | n/a     | n/a     | n/a       | n/a     | | windows | yes² | not yet | not yet | n/a     | n/a     | n/a     | n/a       | n/a     | | android | yes² | yes¹    | yes¹    | yes¹    | n/a     | n/a     | n/a       | n/a     | | ios     | n/a  | not yet | not yet | n/a     | n/a     | n/a     | n/a       | n/a     |  1.  **features revealed from linux.** we gather data from several sources     depending on availability:     +   from glibc's         [getauxval](https://www.gnu.org/software/libc/manual/html_node/auxiliary-vector.html)     +   by parsing `/proc/self/auxv`     +   by parsing `/proc/cpuinfo` 2.  **features revealed from cpu.** features are retrieved by using the `cpuid`     instruction. 3.  **microarchitecture detection.** on x86 some features are not always     implemented efficiently in hardware (e.g. avx on sandybridge). exposing the     microarchitecture allows the client to reject particular microarchitectures. 4.  all flavors of mips are supported, little and big endian as well as 32/64     bits. 5.  **features revealed from sysctl.** features are retrieved by the `sysctl`     instruction.  <a name='ndk'></a> ## android ndk's drop in replacement  [cpu_features](https://github.com/google/cpu_features) is now officially supporting android and offers a drop in replacement of for the ndk's [cpu-features.h](https://android.googlesource.com/platform/ndk/+/main/sources/android/cpufeatures/cpu-features.h) , see [ndk_compat](ndk_compat) folder for details.  <a name='license'></a> ## license  the cpu_features library is licensed under the terms of the apache license. see [license](license) for more information.  <a name='cmake'></a> ## build with cmake  please check the [cmake build instructions](cmake/readme.md).  <a name='quickstart'></a> ### quickstart  - run `list_cpu_features`   ```sh   cmake -s. -bbuild -dbuild_testing=off -dcmake_build_type=release   cmake --build build --config release -j   ./build/list_cpu_features --json   ```    _note_: use `--target all_build` on the second line for `visual studio` and `xcode`.  - run tests   ```sh   cmake -s. -bbuild -dbuild_testing=on -dcmake_build_type=debug   cmake --build build --config debug -j   cmake --build build --config debug --target test   ```    _note_: use `--target run_tests` on the last line for `visual studio` and `--target run_test` for `xcode`.   - install `cpu_features`   ```sh   cmake --build build --config release --target install -v   ```    _note_: use `--target install` for `visual studio`.    _note_: when using `makefile` or `xcode` generator, you can use   [`destdir`](https://www.gnu.org/software/make/manual/html_node/destdir.html)   to install on a local repository.<br>   e.g.   ```sh   cmake --build build --config release --target install -v -- destdir=install   ```  <a name='bindings'></a> ## community bindings  links provided here are not affiliated with google but are kindly provided by the oss community.   - .net    - https://github.com/toor1245/cpu_features.net  - python    - https://github.com/narasimha1997/py_cpu  - java    - https://github.com/aecsocket/cpu-features-java   _send pr to showcase your wrapper here_ ","kassane/fmt":"A modern formatting library (uses zig build-system) <img src='https://user-images.githubusercontent.com/576385/156254208-f5b743a9-88cf-439d-b0c0-923d53e8d551.png' alt='{fmt}' width='25%'/>  [![image](https://github.com/fmtlib/fmt/workflows/linux/badge.svg)](https://github.com/fmtlib/fmt/actions?query=workflow%3alinux) [![image](https://github.com/fmtlib/fmt/workflows/macos/badge.svg)](https://github.com/fmtlib/fmt/actions?query=workflow%3amacos) [![image](https://github.com/fmtlib/fmt/workflows/windows/badge.svg)](https://github.com/fmtlib/fmt/actions?query=workflow%3awindows) [![fmt is continuously fuzzed at oss-fuzz](https://oss-fuzz-build-logs.storage.googleapis.com/badges/fmt.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?╲%0acolspec=id%20type%20component%20status%20proj%20reported%20owner%20╲%0asummary&q=proj%3dfmt&can=1) [![ask questions at stackoverflow with the tag fmt](https://img.shields.io/badge/stackoverflow-fmt-blue.svg)](https://stackoverflow.com/questions/tagged/fmt) [![image](https://api.securityscorecards.dev/projects/github.com/fmtlib/fmt/badge)](https://securityscorecards.dev/viewer/?uri=github.com/fmtlib/fmt)  **{fmt}** is an open-source formatting library providing a fast and safe alternative to c stdio and c++ iostreams.  if you like this project, please consider donating to one of the funds that help victims of the war in ukraine: <https://www.stopputin.net/>.  [documentation](https://fmt.dev)  [cheat sheets](https://hackingcpp.com/cpp/libs/fmt.html)  q&a: ask questions on [stackoverflow with the tag fmt](https://stackoverflow.com/questions/tagged/fmt).  try {fmt} in [compiler explorer](https://godbolt.org/z/8mx1ew73v).  # features  - simple [format api](https://fmt.dev/latest/api/) with positional   arguments for localization - implementation of [c++20   std::format](https://en.cppreference.com/w/cpp/utility/format) and   [c++23 std::print](https://en.cppreference.com/w/cpp/io/print) - [format string syntax](https://fmt.dev/latest/syntax/) similar   to python╲'s   [format](https://docs.python.org/3/library/stdtypes.html#str.format) - fast ieee 754 floating-point formatter with correct rounding,   shortness and round-trip guarantees using the   [dragonbox](https://github.com/jk-jeon/dragonbox) algorithm - portable unicode support - safe [printf   implementation](https://fmt.dev/latest/api/#printf-formatting)   including the posix extension for positional arguments - extensibility: [support for user-defined   types](https://fmt.dev/latest/api/#formatting-user-defined-types) - high performance: faster than common standard library   implementations of `(s)printf`, iostreams, `to_string` and   `to_chars`, see [speed tests](#speed-tests) and [converting a   hundred million integers to strings per   second](http://www.zverovich.net/2020/06/13/fast-int-to-string-revisited.html) - small code size both in terms of source code with the minimum   configuration consisting of just three files, `core.h`, `format.h`   and `format-inl.h`, and compiled code; see [compile time and code   bloat](#compile-time-and-code-bloat) - reliability: the library has an extensive set of   [tests](https://github.com/fmtlib/fmt/tree/master/test) and is   [continuously fuzzed](https://bugs.chromium.org/p/oss-fuzz/issues/list?colspec=id%20type%20component%20status%20proj%20reported%20owner%20summary&q=proj%3dfmt&can=1) - safety: the library is fully type-safe, errors in format strings can   be reported at compile time, automatic memory management prevents   buffer overflow errors - ease of use: small self-contained code base, no external   dependencies, permissive mit   [license](https://github.com/fmtlib/fmt/blob/master/license) - [portability](https://fmt.dev/latest/#portability) with   consistent output across platforms and support for older compilers - clean warning-free codebase even on high warning levels such as   `-wall -wextra -pedantic` - locale independence by default - optional header-only configuration enabled with the   `fmt_header_only` macro  see the [documentation](https://fmt.dev) for more details.  # examples  **print to stdout** ([run](https://godbolt.org/z/tevcjh))  ``` c++ #include <fmt/core.h>  int main() {   fmt::print('hello, world!╲n'); } ```  **format a string** ([run](https://godbolt.org/z/ok8h33))  ``` c++ std::string s = fmt::format('the answer is {}.', 42); // s == 'the answer is 42.' ```  **format a string using positional arguments** ([run](https://godbolt.org/z/yn7txe))  ``` c++ std::string s = fmt::format('i'd rather be {1} than {0}.', 'right', 'happy'); // s == 'i'd rather be happy than right.' ```  **print dates and times** ([run](https://godbolt.org/z/c31exdy3w))  ``` c++ #include <fmt/chrono.h>  int main() {   auto now = std::chrono::system_clock::now();   fmt::print('date and time: {}╲n', now);   fmt::print('time: {:%h:%m}╲n', now); } ```  output:      date and time: 2023-12-26 19:10:31.557195597     time: 19:10  **print a container** ([run](https://godbolt.org/z/mxm1yqje7))  ``` c++ #include <vector> #include <fmt/ranges.h>  int main() {   std::vector<int> v = {1, 2, 3};   fmt::print('{}╲n', v); } ```  output:      [1, 2, 3]  **check a format string at compile time**  ``` c++ std::string s = fmt::format('{:d}', 'i am not a number'); ```  this gives a compile-time error in c++20 because `d` is an invalid format specifier for a string.  **write a file from a single thread**  ``` c++ #include <fmt/os.h>  int main() {   auto out = fmt::output_file('guide.txt');   out.print('don't {}', 'panic'); } ```  this can be [5 to 9 times faster than fprintf](http://www.zverovich.net/2020/08/04/optimal-file-buffer-size.html).  **print with colors and text styles**  ``` c++ #include <fmt/color.h>  int main() {   fmt::print(fg(fmt::color::crimson) | fmt::emphasis::bold,              'hello, {}!╲n', 'world');   fmt::print(fg(fmt::color::floral_white) | bg(fmt::color::slate_gray) |              fmt::emphasis::underline, 'olá, {}!╲n', 'mundo');   fmt::print(fg(fmt::color::steel_blue) | fmt::emphasis::italic,              '你好{}！╲n', '世界'); } ```  output on a modern terminal with unicode support:  ![image](https://github.com/fmtlib/fmt/assets/%0a576385/2a93c904-d6fa-4aa6-b453-2618e1c327d7)  # benchmarks  ## speed tests  | library           | method        | run time, s | |-------------------|---------------|-------------| | libc              | printf        |   0.91      | | libc++            | std::ostream  |   2.49      | | {fmt} 9.1         | fmt::print    |   0.74      | | boost format 1.80 | boost::format |   6.26      | | folly format      | folly::format |   1.87      |  {fmt} is the fastest of the benchmarked methods, ╲~20% faster than `printf`.  the above results were generated by building `tinyformat_test.cpp` on macos 12.6.1 with `clang++ -o3 -dndebug -dspeed_test -dhave_format`, and taking the best of three runs. in the test, the format string `'%0.10f:%04d:%+g:%s:%p:%c:%%╲n'` or equivalent is filled 2,000,000 times with output sent to `/dev/null`; for further details refer to the [source](https://github.com/fmtlib/format-benchmark/blob/master/src/tinyformat-test.cc).  {fmt} is up to 20-30x faster than `std::ostringstream` and `sprintf` on ieee754 `float` and `double` formatting ([dtoa-benchmark](https://github.com/fmtlib/dtoa-benchmark)) and faster than [double-conversion](https://github.com/google/double-conversion) and [ryu](https://github.com/ulfjack/ryu):  [![image](https://user-images.githubusercontent.com/576385/95684665-11719600-0ba8-11eb-8e5b-972ff4e49428.png)](https://fmt.dev/unknown_mac64_clang12.0.html)  ## compile time and code bloat  the script [bloat-test.py][test] from [format-benchmark][bench] tests compile time and code bloat for nontrivial projects. it generates 100 translation units and uses `printf()` or its alternative five times in each to simulate a medium-sized project. the resulting executable size and compile time (apple clang version 15.0.0 (clang-1500.1.0.2.5), macos sonoma, best of three) is shown in the following tables.  [test]: https://github.com/fmtlib/format-benchmark/blob/master/bloat-test.py [bench]: https://github.com/fmtlib/format-benchmark  **optimized build (-o3)**  | method        | compile time, s | executable size, kib | stripped size, kib | |---------------|-----------------|----------------------|--------------------| | printf        |             1.6 |                   54 |                 50 | | iostreams     |            25.9 |                   98 |                 84 | | fmt 83652df   |             4.8 |                   54 |                 50 | | tinyformat    |            29.1 |                  161 |                136 | | boost format  |            55.0 |                  530 |                317 |  {fmt} is fast to compile and is comparable to `printf` in terms of per-call binary size (within a rounding error on this system).  **non-optimized build**  | method        | compile time, s | executable size, kib | stripped size, kib | |---------------|-----------------|----------------------|--------------------| | printf        |             1.4 |                   54 |                 50 | | iostreams     |            23.4 |                   92 |                 68 | | {fmt} 83652df |             4.4 |                   89 |                 85 | | tinyformat    |            24.5 |                  204 |                161 | | boost format  |            36.4 |                  831 |                462 |  `libc`, `lib(std)c++`, and `libfmt` are all linked as shared libraries to compare formatting function overhead only. boost format is a header-only library so it doesn╲'t provide any linkage options.  ## running the tests  please refer to [building the library](https://fmt.dev/latest/get-started/#building-from-source) for instructions on how to build the library and run the unit tests.  benchmarks reside in a separate repository, [format-benchmarks](https://github.com/fmtlib/format-benchmark), so to run the benchmarks you first need to clone this repository and generate makefiles with cmake:      $ git clone --recursive https://github.com/fmtlib/format-benchmark.git     $ cd format-benchmark     $ cmake .  then you can run the speed test:      $ make speed-test  or the bloat test:      $ make bloat-test  # migrating code  [clang-tidy](https://clang.llvm.org/extra/clang-tidy/) v18 provides the [modernize-use-std-print](https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-std-print.html) check that is capable of converting occurrences of `printf` and `fprintf` to `fmt::print` if configured to do so. (by default it converts to `std::print`.)  # notable projects using this library  - [0 a.d.](https://play0ad.com/): a free, open-source, cross-platform   real-time strategy game - [ampl/mp](https://github.com/ampl/mp): an open-source library for   mathematical programming - [apple's foundationdb](https://github.com/apple/foundationdb): an open-source,   distributed, transactional key-value store - [aseprite](https://github.com/aseprite/aseprite): animated sprite   editor & pixel art tool - [aviobook](https://www.aviobook.aero/en): a comprehensive aircraft   operations suite - [blizzard battle.net](https://battle.net/): an online gaming   platform - [celestia](https://celestia.space/): real-time 3d visualization of   space - [ceph](https://ceph.com/): a scalable distributed storage system - [ccache](https://ccache.dev/): a compiler cache - [clickhouse](https://github.com/clickhouse/clickhouse): an   analytical database management system - [contour](https://github.com/contour-terminal/contour/): a modern   terminal emulator - [cuauv](https://cuauv.org/): cornell university╲'s autonomous   underwater vehicle - [drake](https://drake.mit.edu/): a planning, control, and analysis   toolbox for nonlinear dynamical systems (mit) - [envoy](https://github.com/envoyproxy/envoy): c++ l7 proxy and   communication bus (lyft) - [fivem](https://fivem.net/): a modification framework for gta v - [fmtlog](https://github.com/mengrao/fmtlog): a performant   fmtlib-style logging library with latency in nanoseconds - [folly](https://github.com/facebook/folly): facebook open-source   library - [gemrb](https://gemrb.org/): a portable open-source implementation   of bioware's infinity engine - [grand mountain   adventure](https://store.steampowered.com/app/1247360/grand_mountain_adventure/):   a beautiful open-world ski & snowboarding game - [harpywar/pvpgn](https://github.com/pvpgn/pvpgn-server): player vs   player gaming network with tweaks - [kbengine](https://github.com/kbengine/kbengine): an open-source   mmog server engine - [keypirinha](https://keypirinha.com/): a semantic launcher for   windows - [kodi](https://kodi.tv/) (formerly xbmc): home theater software - [knuth](https://kth.cash/): high-performance bitcoin full-node - [libunicode](https://github.com/contour-terminal/libunicode/): a   modern c++17 unicode library - [mariadb](https://mariadb.org/): relational database management   system - [microsoft verona](https://github.com/microsoft/verona): research   programming language for concurrent ownership - [mongodb](https://mongodb.com/): distributed document database - [mongodb smasher](https://github.com/duckie/mongo_smasher): a small   tool to generate randomized datasets - [openspace](https://openspaceproject.com/): an open-source   astrovisualization framework - [penultima online (pol)](https://www.polserver.com/): an mmo server,   compatible with most ultima online clients - [pytorch](https://github.com/pytorch/pytorch): an open-source   machine learning library - [quasardb](https://www.quasardb.net/): a distributed,   high-performance, associative database - [quill](https://github.com/odygrd/quill): asynchronous low-latency   logging library - [qkw](https://github.com/ravijanjam/qkw): generalizing aliasing to   simplify navigation, and execute complex multi-line terminal   command sequences - [redis-cerberus](https://github.com/hunantv/redis-cerberus): a redis   cluster proxy - [redpanda](https://vectorized.io/redpanda): a 10x faster kafka®   replacement for mission-critical systems written in c++ - [rpclib](http://rpclib.net/): a modern c++ msgpack-rpc server and   client library - [salesforce analytics   cloud](https://www.salesforce.com/analytics-cloud/overview/):   business intelligence software - [scylla](https://www.scylladb.com/): a cassandra-compatible nosql   data store that can handle 1 million transactions per second on a   single server - [seastar](http://www.seastar-project.org/): an advanced, open-source   c++ framework for high-performance server applications on modern   hardware - [spdlog](https://github.com/gabime/spdlog): super fast c++ logging   library - [stellar](https://www.stellar.org/): financial platform - [touch surgery](https://www.touchsurgery.com/): surgery simulator - [trinitycore](https://github.com/trinitycore/trinitycore):   open-source mmorpg framework - [🐙 userver framework](https://userver.tech/): open-source   asynchronous framework with a rich set of abstractions and database   drivers - [windows terminal](https://github.com/microsoft/terminal): the new   windows terminal  [more╲...](https://github.com/search?q=fmtlib&type=code)  if you are aware of other projects using this library, please let me know by [email](mailto:victor.zverovich@gmail.com) or by submitting an [issue](https://github.com/fmtlib/fmt/issues).  # motivation  so why yet another formatting library?  there are plenty of methods for doing this task, from standard ones like the printf family of function and iostreams to boost format and fastformat libraries. the reason for creating a new library is that every existing solution that i found either had serious issues or didn╲'t provide all the features i needed.  ## printf  the good thing about `printf` is that it is pretty fast and readily available being a part of the c standard library. the main drawback is that it doesn╲'t support user-defined types. `printf` also has safety issues although they are somewhat mitigated with [╲_╲_attribute╲_╲_ ((format (printf, ╲...))](https://gcc.gnu.org/onlinedocs/gcc/function-attributes.html) in gcc. there is a posix extension that adds positional arguments required for [i18n](https://en.wikipedia.org/wiki/internationalization_and_localization) to `printf` but it is not a part of c99 and may not be available on some platforms.  ## iostreams  the main issue with iostreams is best illustrated with an example:  ``` c++ std::cout << std::setprecision(2) << std::fixed << 1.23456 << '╲n'; ```  which is a lot of typing compared to printf:  ``` c++ printf('%.2f╲n', 1.23456); ```  matthew wilson, the author of fastformat, called this ╲'chevron hell╲'. iostreams don╲'t support positional arguments by design.  the good part is that iostreams support user-defined types and are safe although error handling is awkward.  ## boost format  this is a very powerful library that supports both `printf`-like format strings and positional arguments. its main drawback is performance. according to various benchmarks, it is much slower than other methods considered here. boost format also has excessive build times and severe code bloat issues (see [benchmarks](#benchmarks)).  ## fastformat  this is an interesting library that is fast, safe and has positional arguments. however, it has significant limitations, citing its author:  > three features that have no hope of being accommodated within the > current design are: > > - leading zeros (or any other non-space padding) > - octal/hexadecimal encoding > - runtime width/alignment specification  it is also quite big and has a heavy dependency, on stlsoft, which might be too restrictive for use in some projects.  ## boost spirit.karma  this is not a formatting library but i decided to include it here for completeness. as iostreams, it suffers from the problem of mixing verbatim text with arguments. the library is pretty fast, but slower on integer formatting than `fmt::format_to` with format string compilation on karma╲'s own benchmark, see [converting a hundred million integers to strings per second](http://www.zverovich.net/2020/06/13/fast-int-to-string-revisited.html).  # license  {fmt} is distributed under the mit [license](https://github.com/fmtlib/fmt/blob/master/license).  # documentation license  the [format string syntax](https://fmt.dev/latest/syntax/) section in the documentation is based on the one from python [string module documentation](https://docs.python.org/3/library/string.html#module-string). for this reason, the documentation is distributed under the python software foundation license available in [doc/python-license.txt](https://raw.github.com/fmtlib/fmt/master/doc/python-license.txt). it only applies if you distribute the documentation of {fmt}.  # maintainers  the {fmt} library is maintained by victor zverovich ([vitaut](https://github.com/vitaut)) with contributions from many other people. see [contributors](https://github.com/fmtlib/fmt/graphs/contributors) and [releases](https://github.com/fmtlib/fmt/releases) for some of the names. let us know if your contribution is not listed or mentioned incorrectly and we╲'ll make it right.  # security policy  to report a security issue, please disclose it at [security advisory](https://github.com/fmtlib/fmt/security/advisories/new).  this project is maintained by a team of volunteers on a reasonable-effort basis. as such, please give us at least *90* days to work on a fix before public exposure. ","tiawl/libjq.zig":"@jqlang C API packaged for @ziglang # libjq.zig  this is a fork of [jqlang/jq][1] to package the libjq c api for [zig][2]  ## why this fork ?  the intention under this fork is to package [jqlang/jq][1] for [zig][2]. so: * unnecessary files have been deleted, * the build system has been replaced with `build.zig`, * a cron runs every day to check [jqlang/jq][1]. then it updates this repository if a new release is available.  ## how to use it  the goal of this repository is not to provide a [zig][2] binding for [jqlang/jq][1]. there are at least as many legit ways as possible to make a binding as there are active accounts on github. so you are not going to find an answer for this question here. the point of this repository is to abstract the [jqlang/jq][1] compilation process with [zig][2] (which is not new comers friendly and not easy to maintain) to let you focus on your application. so you can use **libjq.zig**: - as raw (see the [examples directory](https://github.com/tiawl/libjq.zig/blob/trunk/examples)), - as a daily updated interface for your [zig][2] binding of [jqlang/jq][1] (an available exemple is coming soon).  ## dependencies  the [zig][2] part of this package is relying on the latest [zig][2] release (0.13.0) and will only be updated for the next one (so for the 0.14.0).  here the repositories' version used by this fork: * [jqlang/jq](https://github.com/tiawl/libjq.zig/blob/trunk/.references/jq)  ## cicd reminder  these repositories are automatically updated when a new release is available: * (coming soon)  this repository is automatically updated when a new release is available from these repositories: * [jqlang/jq][1] * [tiawl/toolbox][3] * [tiawl/oniguruma.zig][9] * [tiawl/spaceporn-action-env][8] * [tiawl/spaceporn-action-bot][4] * [tiawl/spaceporn-action-ci][5] (todo) * [tiawl/spaceporn-action-cd-ping][6] (todo) * [tiawl/spaceporn-action-cd-pong][7]  ## `zig build` options  these additional options have been implemented for maintainability tasks: ```   -dfetch   update .references folder and build.zig.zon then stop execution   -dupdate  update binding ```  ## license  this repository is not subject to a unique license:  the parts of this repository originated from this repository are dedicated to the public domain. see the license file for more details.  **for other parts, it is subject to the license restrictions their respective owners choosed. by design, the public domain code is incompatible with the license notion. in this case, the license prevails. so if you have any doubt about a file property, open an issue.**  [1]:https://github.com/jqlang/jq [2]:https://github.com/ziglang/zig [3]:https://github.com/tiawl/toolbox [4]:https://github.com/tiawl/spaceporn-action-bot [5]:https://github.com/tiawl/spaceporn-action-ci [6]:https://github.com/tiawl/spaceporn-action-cd-ping [7]:https://github.com/tiawl/spaceporn-action-cd-pong [8]:https://github.com/tiawl/spaceporn-action-env [9]:https://github.com/tiawl/oniguruma.zig "}